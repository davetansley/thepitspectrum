# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;===========================================================================
  6   8000              ; Persistent watchpoint.
  7   8000              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
  8   8000              ; If you do so the program will hit a breakpoint when it tries to
  9   8000              ; write to the first byte of the 3rd line.
 10   8000              ; When program breaks in the fill_memory sub routine please hover over hl
 11   8000              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 12   8000              ;===========================================================================
 13   8000
 14   8000              ; WPMEMx 0x5840, 1, w
 15   8000
 16   8000
 17   8000              ;===========================================================================
 18   8000              ; main routine - the code execution starts here.
 19   8000              ; Sets up the new interrupt routine, the memory
 20   8000              ; banks and jumps to the start loop.
 21   8000              ;===========================================================================
 22   8000              main:
 23   8000 21 54 B9         ld hl,font
 24   8003 22 36 5C         ld (23606),hl
 25   8006 CD 9F B0         call options_show
 26   8009                  ; Show the red pre-title screen
 27   8009 CD 47 AC         call titlescreen_preshow
 28   800C
 29   800C                  ; Draw the title screen
 30   800C              main_titlescreen:
 31   800C CD 53 AC         call titlescreen_show
 32   800F CD 3A C6         call player_init_gamestart
 33   8012
 34   8012              main_lifestart:
 35   8012
 36   8012 CD 60 C6         call player_init_lifestart
 37   8015 CD 6F C5         call game_setcurrentrocks   ; set the current rocks based on the level
 38   8018                  ;ld a,12
 39   8018                  ;ld (game_difficulty),a
 40   8018 CD AF C5         call game_setdifficulty     ; set the current difficulty
 41   801B
 42   801B CD E0 AD         call lifescreen_draw        ; show the lives remaining screen
 43   801E
 44   801E CD C9 80         call init_start
 45   8021 CD FE A8         call screen_draw
 46   8024 CD 4D A8         call buffer_allbuffertoscreen
 47   8027
 48   8027 CD 90 CF         call missiles_init
 49   802A CD 61 C8         call ship_land              ; land the ship
 50   802D CD 83 C9         call tank_init
 51   8030 CD 57 CF         call diamonds_init
 52   8033 CD 48 D1         call thepit_init
 53   8036 CD E4 D1         call monster_init
 54   8039 CD 34 D3         call robots_init
 55   803C CD E7 D6         call bullet_init
 56   803F
 57   803F              mloop:
 58   803F                  ;halt
 59   803F CD 86 80         call main_loop_processing
 60   8042
 61   8042                  ;
 62   8042                  ; Check if the player died
 63   8042                  ;
 64   8042 21 FE C5         ld hl,player+10
 65   8045 7E               ld a,(hl)                   ; check if the player died this frame
 66   8046 FE 01            cp 1
 67   8048 C2 72 80         jp nz,mloop0
 68   804B CD F1 C6         call player_died        ; do end of life housekeeping
 69   804E 06 28            ld b,40
 70   8050 CD 64 81         call utilities_pauseforframes
 71   8053
 72   8053 21 FD C5         ld hl,player+9        ; check lives remaining
 73   8056 7E               ld a,(hl)
 74   8057 FE 00            cp 0
 75   8059 C2 6C 80         jp nz,mloop1         ; haven't finished, so keep going
 76   805C
 77   805C 3A 04 C5         ld a,(game_numberplayers) ; get the number of players
 78   805F FE 01            cp 1
 79   8061 CA BA 80         jp z,main_gameover   ; if just one player, then this is game over
 80   8064
 81   8064 3A 05 C5         ld a,(game_currentplayer) ; get the current player
 82   8067 FE 02            cp 2                    ; if we're here, we have no lives, and if the current player is 2, then we're done
 83   8069 CA BA 80         jp z,main_gameover            ; if it's  two game over
 84   806C
 85   806C              mloop1:
 86   806C CD 53 C5         call game_changeplayer ; change player if needed
 87   806F C3 12 80         jp main_lifestart    ; otherwise, start a new life
 88   8072              mloop0:
 89   8072                  ;
 90   8072                  ; Check if the player completed the level
 91   8072                  ;
 92   8072 21 01 C6         ld hl,player+13
 93   8075 7E               ld a,(hl)
 94   8076 FE 01            cp 1
 95   8078 C2 3F 80         jp nz,mloop
 96   807B CD 2B C8         call player_checkforexit
 97   807E FE 01            cp 1                        ; look at return, if 1, level has been completed
 98   8080 CA C0 80         jp z,main_endlevel          ; jump to level transition screen
 99   8083 C3 3F 80         jp mloop                ; start the loop again
100   8086
101   8086
102   8086              main_loop_processing:
103   8086
104   8086 CD 0C A8         call buffer_buffertoscreen  ; copy buffer to screen
105   8089 CD 71 A7         call buffer_clearlist       ; zero the updated lines list
106   808C CD 04 C6         call player_getlocation     ; figure out where the player is
107   808F CD 35 C7         call player_drawplayer      ; delete player
108   8092 CD F8 BF         call control_input          ; check input
109   8095 CD 35 C7         call player_drawplayer      ; draw player
110   8098 CD B2 C9         call tank_process           ; prcoess the tank
111   809B CD 4C C8         call ship_process           ; proces the ship
112   809E CD D2 CB         call rocks_processrocks     ; process falling rocks
113   80A1 CD 54 D1         call thepit_process         ; process the pit trap
114   80A4 CD B8 CF         call missiles_process       ; process missiles
115   80A7 CD 01 D2         call monster_process        ; process monster
116   80AA CD BD D3         call robots_process         ; process robots
117   80AD CD 2E D7         call bullet_process         ; process the bullet
118   80B0 CD 36 CF         call diamonds_twinkle       ; make the diamonds twinkle
119   80B3 CD 45 CD         call scores_printscore      ; update the score on screen
120   80B6 CD 8F C5         call game_incrementframe    ; increment the game frame
121   80B9
122   80B9 C9               ret
123   80BA
124   80BA              main_gameover:
125   80BA CD 43 AE         call gameover_draw          ; show the game over screen
126   80BD C3 0C 80         jp main_titlescreen         ; go back to title
127   80C0
128   80C0              main_endlevel:
129   80C0 CD BF C6         call player_recordcurrentstate
130   80C3 CD 91 AF         call endlevel_draw          ; show the end level screen
131   80C6 C3 12 80         jp main_lifestart           ; start a new life
132   80C9
133   80C9
134   80C9              ;===========================================================================
135   80C9              ; Include modules
136   80C9              ;===========================================================================
137   80C9                  include "init.asm"
# file opened: init.asm
  1+  80C9              ;
  2+  80C9              ; Set up at start up
  3+  80C9              ;
  4+  80C9              init_start:
  5+  80C9              ; We want a black screen.
  6+  80C9
  7+  80C9 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  80CB                                      ; bright (64).
  9+  80CB CD 49 81         call utilities_clearscreen
 10+  80CE 32 8D 5C         ld (23693),a        ; set our screen colours.
 11+  80D1 AF               xor a               ; quick way to load accumulator with zero.
 12+  80D2 CD 9B 22         call 8859           ; set permanent border colours.
 13+  80D5
 14+  80D5 21 E3 A8         ld hl,screen_offset ; reset some temp variables
 15+  80D8 36 00            ld (hl),0
 16+  80DA 21 E4 A8         ld hl,screen_tmp
 17+  80DD 36 00            ld (hl),0
 18+  80DF 21 18 A7         ld hl,buffer_tmp
 19+  80E2 36 00            ld (hl),0
 20+  80E4 23               inc hl
 21+  80E5 36 00            ld (hl),0
 22+  80E7
 23+  80E7 CD A2 C5         call game_resetcurrentframe ; reset current frame
 24+  80EA
 25+  80EA C9               ret
 26+  80EB
 27+  80EB              ;
 28+  80EB              ;   Start coord
 29+  80EB              ;   vert c, horiz b
 30+  80EB              init_coord:
 31+  80EB 18 30            defb 24,48
 32+  80ED
 33+  80ED              ;
 34+  80ED              ; Number of lives to start
 35+  80ED              ;
 36+  80ED              init_lives:
 37+  80ED 03               defb 3
 38+  80EE
 39+  80EE              ;
 40+  80EE              ; Score to start
 41+  80EE              ;
 42+  80EE              init_score:
 43+  80EE 30 30 30 30      defb '000000'
 43+  80F2 30 30
# file closed: init.asm
138   80F4                  include "utilities.asm"
# file opened: utilities.asm
  1+  80F4              ; ##########################################################################
  2+  80F4              ; Print a character
  3+  80F4              ; Inputs:
  4+  80F4              ; b - x coord
  5+  80F4              ; c - y coord
  6+  80F4              ; d - character
  7+  80F4              ; e - colour
  8+  80F4              ; ##########################################################################
  9+  80F4              utilities_print_char:
 10+  80F4 7B               ld a,e
 11+  80F5 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  80F8 3E 16            ld a,22
 13+  80FA D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  80FB 78               ld a,b              ; Gets the X co-ordinate
 15+  80FC 3D               dec a
 16+  80FD D7               rst 16
 17+  80FE 79               ld a,c              ; and the Y co-ordinate
 18+  80FF D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  8100 7A               ld a,d              ; ASCII code for udg.
 20+  8101 D7               rst 16              ; draw block.
 21+  8102 C9               ret
 22+  8103
 23+  8103
 24+  8103              ;Inputs:
 25+  8103              ;     DE and A are factors
 26+  8103              ;Outputs:
 27+  8103              ;     A is not changed
 28+  8103              ;     B is 0
 29+  8103              ;     C is not changed
 30+  8103              ;     DE is not changed
 31+  8103              ;     HL is the product
 32+  8103              ;Time:
 33+  8103              ;     342+6x
 34+  8103              ;
 35+  8103              utilities_multiply:
 36+  8103 06 08            ld b,8          ;7           7
 37+  8105 21 00 00         ld hl,0         ;10         10
 38+  8108 29               add hl,hl     ;11*8       88
 39+  8109 07               rlca          ;4*8        32
 40+  810A 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  810C 19                   add hl,de   ;--         --
 42+  810D 10 F9            djnz $-5      ;13*7+8     99
 43+  810F C9               ret             ;10         10
 44+  8110
 45+  8110              utilities_waitforkey:
 46+  8110 21 08 5C         ld hl,23560         ; LAST K system variable.
 47+  8113 36 00            ld (hl),0           ; put null value there.
 48+  8115              utilities_waitforkey0:
 49+  8115 7E               ld a,(hl)           ; new value of LAST K.
 50+  8116 FE 00            cp 0                ; is it still zero?
 51+  8118 20 0A            jr nz,utilities_waitforkey1           ; yes, so no key pressed.
 52+  811A 01 1F 00         ld bc,31                        ; Kempston joystick port.
 53+  811D ED 78            in a,(c)                        ; read input.
 54+  811F E6 10            and 16
 55+  8121 CA 15 81         jp z,utilities_waitforkey0
 56+  8124              utilities_waitforkey1:
 57+  8124 C9               ret                 ; key was pressed.
 58+  8125
 59+  8125              ;
 60+  8125              ; Waits number of frames for keypress. If got, returns 1, if not 0
 61+  8125              ; Inputs:
 62+  8125              ; a - number of frames to waits
 63+  8125              ; Ouputs:
 64+  8125              ; e - 0 not pressed, 1 pressed
 65+  8125              utilities_waitforkey_forframes:
 66+  8125 21 08 5C         ld hl,23560         ; LAST K system variable.
 67+  8128 36 00            ld (hl),0           ; put null value there.
 68+  812A 47               ld b,a              ; number of frames to wait
 69+  812B              utilities_waitforkey_forframes0:
 70+  812B 7E               ld a,(hl)           ; new value of LAST K.
 71+  812C FE 00            cp 0                ; is it still zero?
 72+  812E 28 03            jr z,utilities_waitforkey_forframes1           ; yes, so no key pressed.
 73+  8130 1E 01            ld e,1              ; set the pressed flag
 74+  8132 C9               ret                 ; key was pressed.
 75+  8133              utilities_waitforkey_forframes1:
 76+  8133 C5               push bc
 77+  8134 01 1F 00         ld bc,31                        ; Kempston joystick port.
 78+  8137 ED 78            in a,(c)                        ; read input.
 79+  8139 C1               pop bc
 80+  813A E6 10            and 16
 81+  813C CA 42 81         jp z,utilities_waitforkey_forframes2
 82+  813F 1E 01            ld e,1              ; set the pressed flag
 83+  8141 C9               ret                 ; key was pressed.
 84+  8142              utilities_waitforkey_forframes2:
 85+  8142 76               halt                ; wait for frame
 86+  8143 76               halt                ; wait for frame
 87+  8144 10 E5            djnz utilities_waitforkey_forframes0 ; loop again
 88+  8146 1E 00            ld e,0              ; nothing pressed in time
 89+  8148 C9               ret
 90+  8149
 91+  8149              ;
 92+  8149              ; Clears the screen
 93+  8149              ; Inputs:
 94+  8149              ; a - attribute colour
 95+  8149              utilities_clearscreen:
 96+  8149 76               halt
 97+  814A 21 00 58         ld hl,22528         ; attr
 98+  814D 11 01 58         ld de,22529         ; attr+1
 99+  8150 01 FF 02         ld bc,767
100+  8153 77               ld (hl),a
101+  8154 ED B0            ldir
102+  8156
103+  8156 21 00 40         ld hl, 16384        ;pixels
104+  8159 11 01 40         ld de, 16385        ;pixels + 1
105+  815C 01 FF 17         ld bc, 6143         ;pixels area length - 1
106+  815F 36 00            ld (hl), 0          ;set first byte to '0'
107+  8161 ED B0            ldir                ;copy bytes
108+  8163
109+  8163 C9               ret
110+  8164
111+  8164              ;
112+  8164              ; Wait for a number of frames
113+  8164              ; Inputs:
114+  8164              ; b - number of frames
115+  8164              utilities_pauseforframes:
116+  8164 76               halt
117+  8165 10 FD            djnz utilities_pauseforframes
118+  8167 C9               ret
119+  8168
120+  8168              utilities_readkey:
121+  8168 21 88 81         LD HL,utilties_keymap              ; Point HL at the keyboard list
122+  816B 16 08            LD D,8                                  ; This is the number of ports (rows) to check
123+  816D 0E FE            LD C,$FE                            ; C is always FEh for reading keyboard ports
124+  816F              utilities_readkey_0:
125+  816F 46               LD B,(HL)                               ; Get the keyboard port address from table
126+  8170 23               INC HL                                  ; Increment to list of keys
127+  8171 ED 78            IN A,(C)                                ; Read the row of keys in
128+  8173 E6 1F            AND $1F                                     ; We are only interested in the first five bits
129+  8175 1E 05            LD E,5                                  ; This is the number of keys in the row
130+  8177              utilities_readkey_1:
131+  8177 CB 3F            SRL A                                   ; Shift A right; bit 0 sets carry bit
132+  8179 30 0B            JR NC,utilities_readkey_2   ; If the bit is 0, we've found our key
133+  817B 23               INC HL                                  ; Go to next table address
134+  817C 1D               DEC E                                   ; Decrement key loop counter
135+  817D 20 F8            JR NZ,utilities_readkey_1   ; Loop around until this row finished
136+  817F 15               DEC D                                   ; Decrement row loop counter
137+  8180 20 ED            JR NZ,utilities_readkey_0   ; Loop around until we are done
138+  8182 A7               AND A                                   ; Clear A (no key found)
139+  8183 C3 68 81         jp utilities_readkey
140+  8186              utilities_readkey_2:
141+  8186 7E               LD A,(HL)                               ; We've found a key at this point; fetch the character code!
142+  8187 C9               RET
143+  8188
144+  8188              utilties_keymap:
145+  8188 FE 23 5A 58      defb $FE,"#","Z","X","C","V"
145+  818C 43 56
146+  818E FD 41 53 44      defb $FD,"A","S","D","F","G"
146+  8192 46 47
147+  8194 FB 51 57 45      defb $FB,"Q","W","E","R","T"
147+  8198 52 54
148+  819A F7 31 32 33      defb $F7,"1","2","3","4","5"
148+  819E 34 35
149+  81A0 EF 30 39 38      defb $EF,"0","9","8","7","6"
149+  81A4 37 36
150+  81A6 DF 50 4F 49      defb $DF,"P","O","I","U","Y"
150+  81AA 55 59
151+  81AC BF 23 4C 4B      defb $BF,"#","L","K","J","H"
151+  81B0 4A 48
152+  81B2 7F 20 23 4D      defb $7F," ","#","M","N","B"
152+  81B6 4E 42
153+  81B8
154+  81B8
155+  81B8              ;
156+  81B8              ; Generates a randomish number in the range 0 to e
157+  81B8              ; Inputs:
158+  81B8              ; e - upper value
159+  81B8              ; Outputs:
160+  81B8              ; a - random number
161+  81B8              utilities_randomupper
162+  81B8 3A 03 C5         ld a,(game_framenumber)
163+  81BB 6F               ld l,a
164+  81BC 26 00            ld h,0
165+  81BE 16 00            ld d,0
166+  81C0 42 4B            ld bc,de
167+  81C2              utilities_randomupper0:
168+  81C2 B7               or a
169+  81C3 ED 42            sbc hl,bc
170+  81C5 F2 C2 81         jp p,utilities_randomupper0
171+  81C8 09               add hl,bc
172+  81C9 01 00 00         ld bc,0
173+  81CC 09               add hl,bc
174+  81CD 7D               ld a,l
175+  81CE C9               ret
176+  81CF
# file closed: utilities.asm
139   81CF                  include "strings.asm"
# file opened: strings.asm
  1+  81CF              string_score1:
  2+  81CF 04 00 53 43      defb 4,0,'SCORE1',255
  2+  81D3 4F 52 45 31
  2+  81D7 FF
  3+  81D8              string_scorenumbers1:
  4+  81D8 04 01 30 30      defb 4,1,'000000',255
  4+  81DC 30 30 30 30
  4+  81E0 FF
  5+  81E1              string_company:
  6+  81E1 0C 00 43 45      defb 12,0,'CENTURI',255
  6+  81E5 4E 54 55 52
  6+  81E9 49 FF
  7+  81EB              string_player1:
  8+  81EB 0C 01 50 4C      defb 12,1,'PLAYER 1',255
  8+  81EF 41 59 45 52
  8+  81F3 20 31 FF
  9+  81F6              string_player2:
 10+  81F6 0C 01 50 4C      defb 12,1,'PLAYER 2',255
 10+  81FA 41 59 45 52
 10+  81FE 20 32 FF
 11+  8201              string_score2:
 12+  8201 16 00 53 43      defb 22,0,'SCORE2',255
 12+  8205 4F 52 45 32
 12+  8209 FF
 13+  820A              string_scorenumbers2:
 14+  820A 16 01 30 30      defb 22,1,'000000',255
 14+  820E 30 30 30 30
 14+  8212 FF
 15+  8213              string_titlescreen_copyright:
 16+  8213 06 15 7F 31      defb 6,21, 127,'1982  CENTURI INC',255
 16+  8217 39 38 32 20
 16+  821B 20 43 45 4E
 16+  821F 54 55 52 49
 16+  8223 20 49 4E 43
 16+  8227 FF
 17+  8228
 18+  8228
 19+  8228              string_alttitlescreen_1:
 20+  8228 0C 00 43 52      defb 12,0,'CREDITS 1',255
 20+  822C 45 44 49 54
 20+  8230 53 20 31 FF
 21+  8234              string_alttitlescreen_2:
 22+  8234 00 02 20 20      defb 0,2,'           THE OBJECT',254
 22+  8238 20 20 20 20
 22+  823C 20 20 20 20
 22+  8240 20 54 48 45
 22+  8244 20 4F 42 4A
 22+  8248 45 43 54 FE
 23+  824C 00 03 20 20      defb 0,3,'          OF THIS GAME',254
 23+  8250 20 20 20 20
 23+  8254 20 20 20 20
 23+  8258 4F 46 20 54
 23+  825C 48 49 53 20
 23+  8260 47 41 4D 45
 23+  8264 FE
 24+  8265 00 04 20 20      defb 0,4,'         IS TO DIG DOWN',254
 24+  8269 20 20 20 20
 24+  826D 20 20 20 49
 24+  8271 53 20 54 4F
 24+  8275 20 44 49 47
 24+  8279 20 44 4F 57
 24+  827D 4E FE
 25+  827F 00 05 20 20      defb 0,5,'        TO THE BOTTOM PIT',254
 25+  8283 20 20 20 20
 25+  8287 20 20 54 4F
 25+  828B 20 54 48 45
 25+  828F 20 42 4F 54
 25+  8293 54 4F 4D 20
 25+  8297 50 49 54 FE
 26+  829B 00 06 20 20      defb 0,6,'               AND',254
 26+  829F 20 20 20 20
 26+  82A3 20 20 20 20
 26+  82A7 20 20 20 20
 26+  82AB 20 41 4E 44
 26+  82AF FE
 27+  82B0 00 07 20 20      defb 0,7,'        COLLECT AT LEAST',254
 27+  82B4 20 20 20 20
 27+  82B8 20 20 43 4F
 27+  82BC 4C 4C 45 43
 27+  82C0 54 20 41 54
 27+  82C4 20 4C 45 41
 27+  82C8 53 54 FE
 28+  82CB 00 08 20 20      defb 0,8,'         ONE LARGE JEWEL',254
 28+  82CF 20 20 20 20
 28+  82D3 20 20 20 4F
 28+  82D7 4E 45 20 4C
 28+  82DB 41 52 47 45
 28+  82DF 20 4A 45 57
 28+  82E3 45 4C FE
 29+  82E6 00 09 20 20      defb 0,9,'              THEN',254
 29+  82EA 20 20 20 20
 29+  82EE 20 20 20 20
 29+  82F2 20 20 20 20
 29+  82F6 54 48 45 4E
 29+  82FA FE
 30+  82FB 00 0A 20 20      defb 0,10,'         RETURN TO SHIP',254
 30+  82FF 20 20 20 20
 30+  8303 20 20 20 52
 30+  8307 45 54 55 52
 30+  830B 4E 20 54 4F
 30+  830F 20 53 48 49
 30+  8313 50 FE
 31+  8315 00 0B 20 20      defb 0,11,'         THRU UPPER PIT',255
 31+  8319 20 20 20 20
 31+  831D 20 20 20 54
 31+  8321 48 52 55 20
 31+  8325 55 50 50 45
 31+  8329 52 20 50 49
 31+  832D 54 FF
 32+  832F              string_alttitlescreen_3:
 33+  832F 00 0D 20 20      defb 0,13,'    SINGLE BONUS  5000 POINTS',254
 33+  8333 20 20 53 49
 33+  8337 4E 47 4C 45
 33+  833B 20 42 4F 4E
 33+  833F 55 53 20 20
 33+  8343 35 30 30 30
 33+  8347 20 50 4F 49
 33+  834B 4E 54 53 FE
 34+  834F 00 0E 20 20      defb 0,14,'      COLLECT 1 LARGE JEWEL',254
 34+  8353 20 20 20 20
 34+  8357 43 4F 4C 4C
 34+  835B 45 43 54 20
 34+  835F 31 20 4C 41
 34+  8363 52 47 45 20
 34+  8367 4A 45 57 45
 34+  836B 4C FE
 35+  836D 00 0F 20 20      defb 0,15,'       AND RETURN TO SHIP',254
 35+  8371 20 20 20 20
 35+  8375 20 41 4E 44
 35+  8379 20 52 45 54
 35+  837D 55 52 4E 20
 35+  8381 54 4F 20 53
 35+  8385 48 49 50 FE
 36+  8389 00 11 20 20      defb 0,17,'    DOUBLE BONUS  10000 POINTS',254
 36+  838D 20 20 44 4F
 36+  8391 55 42 4C 45
 36+  8395 20 42 4F 4E
 36+  8399 55 53 20 20
 36+  839D 31 30 30 30
 36+  83A1 30 20 50 4F
 36+  83A5 49 4E 54 53
 36+  83A9 FE
 37+  83AA 00 12 20 20      defb 0,18,'    COLLECT ALL 3 LARGE JEWELS',254
 37+  83AE 20 20 43 4F
 37+  83B2 4C 4C 45 43
 37+  83B6 54 20 41 4C
 37+  83BA 4C 20 33 20
 37+  83BE 4C 41 52 47
 37+  83C2 45 20 4A 45
 37+  83C6 57 45 4C 53
 37+  83CA FE
 38+  83CB 00 13 20 20      defb 0,19,'       OR   ALL 4 SMALL JEWELS',254
 38+  83CF 20 20 20 20
 38+  83D3 20 4F 52 20
 38+  83D7 20 20 41 4C
 38+  83DB 4C 20 34 20
 38+  83DF 53 4D 41 4C
 38+  83E3 4C 20 4A 45
 38+  83E7 57 45 4C 53
 38+  83EB FE
 39+  83EC 00 15 20 20      defb 0,21,'    TRIPLE BONUS  15000 POINTS',254
 39+  83F0 20 20 54 52
 39+  83F4 49 50 4C 45
 39+  83F8 20 42 4F 4E
 39+  83FC 55 53 20 20
 39+  8400 31 35 30 30
 39+  8404 30 20 50 4F
 39+  8408 49 4E 54 53
 39+  840C FE
 40+  840D 00 16 20 20      defb 0,22,'       COLLECT ALL 7 JEWELS',255
 40+  8411 20 20 20 20
 40+  8415 20 43 4F 4C
 40+  8419 4C 45 43 54
 40+  841D 20 41 4C 4C
 40+  8421 20 37 20 4A
 40+  8425 45 57 45 4C
 40+  8429 53 FF
 41+  842B
 42+  842B              string_lifescreen_player:
 43+  842B 0B 00 20 50      defb 11,0,' PLAYER 1 ',255
 43+  842F 4C 41 59 45
 43+  8433 52 20 31 20
 43+  8437 FF
 44+  8438              string_lifescreen_lives:
 45+  8438 0B 03 30 20      defb 11,3,48,' MEN LEFT',255
 45+  843C 4D 45 4E 20
 45+  8440 4C 45 46 54
 45+  8444 FF
 46+  8445              string_lifescreen_lastman:
 47+  8445 0C 03 4C 41      defb 12,3,'LAST MAN',255
 47+  8449 53 54 20 4D
 47+  844D 41 4E FF
 48+  8450
 49+  8450              string_gameoverscreen_gameover:
 50+  8450 0B 06 47 41      defb 11,6,'GAME OVER',255
 50+  8454 4D 45 20 4F
 50+  8458 56 45 52 FF
 51+  845C              string_gameoverscreen_copyright:
 52+  845C 07 12 7F 31      defb 7,18,127,'1982 CENTURI INC',255
 52+  8460 39 38 32 20
 52+  8464 43 45 4E 54
 52+  8468 55 52 49 20
 52+  846C 49 4E 43 FF
 53+  8470              string_gameoverscreen_bestscores:
 54+  8470 07 16 42 45      defb 7,22,'BEST SCORES TODAY',255
 54+  8474 53 54 20 53
 54+  8478 43 4F 52 45
 54+  847C 53 20 54 4F
 54+  8480 44 41 59 FF
 55+  8484              string_gameover_credits:
 56+  8484 0C 01 43 52      defb 12,1,'CREDITS 0',255
 56+  8488 45 44 49 54
 56+  848C 53 20 30 FF
 57+  8490
 58+  8490              string_highscore_congratulations:
 59+  8490 08 05 43 4F      defb 8,5,'CONGRATULATIONS',255
 59+  8494 4E 47 52 41
 59+  8498 54 55 4C 41
 59+  849C 54 49 4F 4E
 59+  84A0 53 FF
 60+  84A2              string_highscore_player1:
 61+  84A2 0C 07 50 4C      defb 12,7,'PLAYER 1',255
 61+  84A6 41 59 45 52
 61+  84AA 20 31 FF
 62+  84AD              string_highscore_player2:
 63+  84AD 0C 07 50 4C      defb 12,7,'PLAYER 2',255
 63+  84B1 41 59 45 52
 63+  84B5 20 32 FF
 64+  84B8              string_highscore_youhaveearned:
 65+  84B8 08 0A 59 4F      defb 8,10,'YOU HAVE EARNED',255
 65+  84BC 55 20 48 41
 65+  84C0 56 45 20 45
 65+  84C4 41 52 4E 45
 65+  84C8 44 FF
 66+  84CA              string_highscore_place1:
 67+  84CA 06 0C 54 48      defb 6,12,'THE GREATEST SCORE',255
 67+  84CE 45 20 47 52
 67+  84D2 45 41 54 45
 67+  84D6 53 54 20 53
 67+  84DA 43 4F 52 45
 67+  84DE FF
 68+  84DF              string_highscore_place2:
 69+  84DF 06 0C 54 48      defb 6,12,'THE 2ND BEST SCORE',255
 69+  84E3 45 20 32 4E
 69+  84E7 44 20 42 45
 69+  84EB 53 54 20 53
 69+  84EF 43 4F 52 45
 69+  84F3 FF
 70+  84F4              string_highscore_place3:
 71+  84F4 06 0C 54 48      defb 6,12,'THE 3RD BEST SCORE',255
 71+  84F8 45 20 33 52
 71+  84FC 44 20 42 45
 71+  8500 53 54 20 53
 71+  8504 43 4F 52 45
 71+  8508 FF
 72+  8509              string_highscore_pleaseenter
 73+  8509 03 0F 52 45      defb 3,15,'RECORD YOUR INITIALS BELOW',255
 73+  850D 43 4F 52 44
 73+  8511 20 59 4F 55
 73+  8515 52 20 49 4E
 73+  8519 49 54 49 41
 73+  851D 4C 53 20 42
 73+  8521 45 4C 4F 57
 73+  8525 FF
 74+  8526
 75+  8526              string_endlevel_youhaveearned:
 76+  8526 08 0B 59 4F      defb 8,11,'YOU HAVE EARNED',255
 76+  852A 55 20 48 41
 76+  852E 56 45 20 45
 76+  8532 41 52 4E 45
 76+  8536 44 FF
 77+  8538              string_endlevel_bonus1:
 78+  8538 09 0D 53 49      defb 9,13,'SINGLE BONUS',255
 78+  853C 4E 47 4C 45
 78+  8540 20 42 4F 4E
 78+  8544 55 53 FF
 79+  8547              string_endlevel_bonus2:
 80+  8547 09 0D 44 4F      defb 9,13,'DOUBLE BONUS',255
 80+  854B 55 42 4C 45
 80+  854F 20 42 4F 4E
 80+  8553 55 53 FF
 81+  8556              string_endlevel_bonus3:
 82+  8556 09 0D 54 52      defb 9,13,'TRIPLE BONUS',255
 82+  855A 49 50 4C 45
 82+  855E 20 42 4F 4E
 82+  8562 55 53 FF
 83+  8565              string_endlevel_points1:
 84+  8565 0A 0F 35 30      defb 10,15,'5000 POINTS',255
 84+  8569 30 30 20 50
 84+  856D 4F 49 4E 54
 84+  8571 53 FF
 85+  8573              string_endlevel_points2:
 86+  8573 09 0F 31 30      defb 9,15,'10000 POINTS',255
 86+  8577 30 30 30 20
 86+  857B 50 4F 49 4E
 86+  857F 54 53 FF
 87+  8582              string_endlevel_points3:
 88+  8582 09 0F 31 35      defb 9,15,'15000 POINTS',255
 88+  8586 30 30 30 20
 88+  858A 50 4F 49 4E
 88+  858E 54 53 FF
 89+  8591              string_endlevel_anothergo:
 90+  8591 08 12 48 41      defb 8,18,'HAVE ANOTHER GO',255
 90+  8595 56 45 20 41
 90+  8599 4E 4F 54 48
 90+  859D 45 52 20 47
 90+  85A1 4F FF
 91+  85A3
 92+  85A3              string_zonk:
 93+  85A3 00 00 5A 4F      defb 0,0,'ZONK!!',255
 93+  85A7 4E 4B 21 21
 93+  85AB FF
 94+  85AC
 95+  85AC
 96+  85AC              string_options_title:
 97+  85AC 0D 03 54 48      defb 13,3,'THE PIT',255
 97+  85B0 45 20 50 49
 97+  85B4 54 FF
 98+  85B6              string_options_1player:
 99+  85B6 09 06 31 2E      defb 9,6,'1. ONE PLAYER',255
 99+  85BA 20 4F 4E 45
 99+  85BE 20 50 4C 41
 99+  85C2 59 45 52 FF
100+  85C6              string_options_2player:
101+  85C6 09 07 32 2E      defb 9,7,'2. TWO PLAYER',255
101+  85CA 20 54 57 4F
101+  85CE 20 50 4C 41
101+  85D2 59 45 52 FF
102+  85D6              string_options_keyboard:
103+  85D6 09 08 33 2E      defb 9,8,'3. KEYS (QAOPSp)',255
103+  85DA 20 4B 45 59
103+  85DE 53 20 28 51
103+  85E2 41 4F 50 53
103+  85E6 70 29 FF
104+  85E9              string_options_joystick:
105+  85E9 09 09 34 2E      defb 9,9,'4. KEMPSTON',255
105+  85ED 20 4B 45 4D
105+  85F1 50 53 54 4F
105+  85F5 4E FF
106+  85F7              string_options_start:
107+  85F7 09 0A 35 2E      defb 9,10,'5. START',255
107+  85FB 20 53 54 41
107+  85FF 52 54 FF
108+  8602              string_options_vanity:
109+  8602 08 16 53 70      defb 8,22,'Spectrum Conversion',254
109+  8606 65 63 74 72
109+  860A 75 6D 20 43
109+  860E 6F 6E 76 65
109+  8612 72 73 69 6F
109+  8616 6E FE
110+  8618 07 17 62 79      defb 7,23,'by Dave Tansley, 2020',255
110+  861C 20 44 61 76
110+  8620 65 20 54 61
110+  8624 6E 73 6C 65
110+  8628 79 2C 20 32
110+  862C 30 32 30 FF
111+  8630
112+  8630              ;
113+  8630              ; Prints specified string
114+  8630              ; Inputs:
115+  8630              ; de: pointer to string
116+  8630              ; bc: length of string
117+  8630              ;
118+  8630              ; Print String Data
119+  8630              ; First two bytes of string contain X and Y char position, then the string
120+  8630              ; Individual strings are terminated with 0xFE
121+  8630              ; End of data is terminated with 0xFF
122+  8630              ; HL: Address of string
123+  8630              ;
124+  8630 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
125+  8631 23                                   INC HL                          ; Increase HL to the next memory location
126+  8632 56                                   LD D,(HL)                       ; Fetch the Y coordinate
127+  8633 23                                   INC HL                          ; Increase HL to the next memory location
128+  8634 CD 47 86                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
129+  8637 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
130+  8638 23                                   INC HL                          ; Increase HL to the next character
131+  8639 FE FE                                CP 0xFE                         ; Compare with 0xFE
132+  863B 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
133+  863D D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
134+  863E E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
135+  863F CD 57 86                             CALL Print_Char                 ; Print the character
136+  8642 E1                                   POP HL                          ; Retrieve HL back off the stack
137+  8643 1C                                   INC E                           ; Go to the next screen address
138+  8644 18 F1                                JR string_print_0               ; Loop back to print next character
139+  8646 C9                                   RET
140+  8647
141+  8647              ; Get screen address
142+  8647              ; D = Y character position
143+  8647              ; E = X character position
144+  8647              ; Returns address in DE
145+  8647              ;
146+  8647 7A           string_getcharaddress:       LD A,D
147+  8648 E6 07                                AND %00000111
148+  864A 1F                                   RRA
149+  864B 1F                                   RRA
150+  864C 1F                                   RRA
151+  864D 1F                                   RRA
152+  864E B3                                   OR E
153+  864F 5F                                   LD E,A
154+  8650 7A                                   LD A,D
155+  8651 E6 18                                AND %00011000
156+  8653 F6 40                                OR %01000000
157+  8655 57                                   LD D,A
158+  8656 C9                                   RET                             ; Returns screen address in DE
159+  8657
160+  8657              ; Print a single character out
161+  8657              ; A:  Character to print
162+  8657              ; DE: Screen address to print character at
163+  8657              ;
164+  8657 2A 36 5C     Print_Char:             LD HL,(23606)                    ; Address of character set table in ROM
165+  865A 06 00                                LD B,0                          ; Set BC to A
166+  865C 4F                                   LD C,A
167+  865D E6 FF                                AND 0xFF                        ; Clear the carry bit
168+  865F CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
169+  8661 CB 10                                RL B
170+  8663 CB 11                                RL C
171+  8665 CB 10                                RL B
172+  8667 CB 11                                RL C
173+  8669 CB 10                                RL B
174+  866B 09                                   ADD HL,BC                       ; Get the character address in HL
175+  866C 0E 08                                LD C,8                          ; Loop counter
176+  866E D5                                   PUSH DE
177+  866F 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
178+  8670 12                                   LD (DE),A                       ; Stick A onto the screen
179+  8671 14                                   INC D                           ; Goto next line on screen
180+  8672 23                                   INC HL                           ; Goto next byte of character
181+  8673 0D                                   DEC C                           ; Decrease the loop counter
182+  8674 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
183+  8676 D1                                   POP DE
184+  8677 C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
140   8678                  include "screen\buffer.asm"
# file opened: screen/buffer.asm
  1+  8678              buffer_buffer:
  2+  8678 00 00 00...      defs 7424                   ; area reserved for screen
  3+  A378
  4+  A378              buffer_attr_buffer:
  5+  A378 00 00 00...      defs 928                    ; attrs buffer area
  6+  A718
  7+  A718              buffer_tmp:
  8+  A718 00 00            defb 0,0                    ; temp area
  9+  A71A
 10+  A71A              ;
 11+  A71A              ; If this is set to one, three lines will be refreshed for the screen coord redraw
 12+  A71A              ; This is used when digging to make sure that the above dug block gets redrawn
 13+  A71A              ;
 14+  A71A              buffer_threelinerefresh:
 15+  A71A 00               defb 0
 16+  A71B
 17+  A71B              ;
 18+  A71B              ; This list stores lines to be updated by the buffer.
 19+  A71B              ; This is done by half line. Lines are encded with.
 20+  A71B              ; 00hlllll
 21+  A71B              ; Where h is the half of the screen (0 or 1), lllll is the line number
 22+  A71B              buffer_updatedlines:
 23+  A71B FF FF FF...      defs 21,255
 24+  A730
 25+  A730              buffer_updateall:
 26+  A730 00               defb 0
 27+  A731
 28+  A731              ;
 29+  A731              ; Stores a line number in the update list
 30+  A731              ; Inputs:
 31+  A731              ; a - row number
 32+  A731              buffer_marklineforupdate:
 33+  A731 FE 15            cp 21
 34+  A733 D0               ret nc                          ; dont store lines that we shouldn't draw
 35+  A734 5F               ld e,a                          ; store in e
 36+  A735 ED 4B 3F AC      ld bc,(origcoords)              ; this should hold the coords of what was drawn
 37+  A739 79               ld a,c                          ; get the horiz coord
 38+  A73A FE 0F            cp 15
 39+  A73C CA 53 A7         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 40+  A73F FE 10            cp 16                           ; if this is 15 or less, the first half of screen
 41+  A741 CA 53 A7         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 42+  A744 DA 4F A7         jp c,buffer_marklineforupdate4  ; if first half, nothing to do
 43+  A747 78               ld a,b                          ; get the vertical
 44+  A748 3E 20            ld a,32                         ; set the 6th bit by adding 32
 45+  A74A 83               add a,e
 46+  A74B 5F               ld e,a                          ; store this value
 47+  A74C C3 5A A7         jp buffer_marklineforupdate2
 48+  A74F              buffer_marklineforupdate4:
 49+  A74F 78               ld a,b
 50+  A750 C3 5A A7         jp buffer_marklineforupdate2    ; just get the vertical
 51+  A753              buffer_marklineforupdate3:          ; special case for 15,16 - need to render both halves, since might be between
 52+  A753 CD 5E A7         call buffer_storelineforupdate  ; call store update for e
 53+  A756 3E 20            ld a,32
 54+  A758 83               add a,e
 55+  A759 5F               ld e,a
 56+  A75A              buffer_marklineforupdate2:
 57+  A75A CD 5E A7         call buffer_storelineforupdate  ; call store update for e
 58+  A75D C9               ret
 59+  A75E
 60+  A75E
 61+  A75E              ;
 62+  A75E              ; Stores the calculated line and half if needed
 63+  A75E              ; Inputs:
 64+  A75E              ; e - half/row
 65+  A75E              ;
 66+  A75E              buffer_storelineforupdate:
 67+  A75E 06 15            ld b,21
 68+  A760 21 1B A7         ld hl,buffer_updatedlines
 69+  A763              buffer_storelineforupdate0:
 70+  A763 7E               ld a,(hl)                       ; get the line stored in updated lines
 71+  A764 BB               cp e                            ; is this the same as the row number passed in?
 72+  A765 C8               ret z                           ; if so, don't need to do anything
 73+  A766 FE FF            cp 255                          ; is this 255, ie the end of the buffer
 74+  A768 C2 6D A7         jp nz,buffer_storelineforupdate1 ; if not, move to next
 75+  A76B 73               ld (hl),e
 76+  A76C C9               ret
 77+  A76D              buffer_storelineforupdate1:
 78+  A76D 23               inc hl
 79+  A76E 10 F3            djnz buffer_storelineforupdate0
 80+  A770 C9               ret
 81+  A771
 82+  A771              ;
 83+  A771              ; Zeroes the updated lines list
 84+  A771              ;
 85+  A771              buffer_clearlist:
 86+  A771 06 15            ld b,21
 87+  A773 21 1B A7         ld hl,buffer_updatedlines
 88+  A776              buffer_clearlist0:
 89+  A776 36 FF            ld (hl),255
 90+  A778 23               inc hl
 91+  A779 10 FB            djnz buffer_clearlist0
 92+  A77B C9               ret
 93+  A77C
 94+  A77C              ;
 95+  A77C              ; Which half are we displaying? 0 left 1 right
 96+  A77C              ;
 97+  A77C              buffer_bufferhalf:
 98+  A77C 00               defb 0
 99+  A77D
100+  A77D              ;
101+  A77D              ; Copies the buffer to the screen. Use stack.
102+  A77D              ; Inputs:
103+  A77D              ; hl - half/line number to display - 0 is first half, 0 is first line
104+  A77D              ;
105+  A77D              buffer_bufferlinetoscreen:
106+  A77D 7C               ld a,h
107+  A77E 32 7C A7         ld (buffer_bufferhalf),a        ; store the half
108+  A781 7D               ld a,l
109+  A782 4F               ld c,a                          ; store a
110+  A783 ED 5B E3 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows, want it *256
111+  A787 83               add a,e                       ; add the row number
112+  A788 11 00 01         ld de,256
113+  A78B CD 03 81         call utilities_multiply
114+  A78E 54 5D            ld de,hl
115+  A790 21 78 86         ld hl,buffer_buffer
116+  A793 19               add hl,de                   ; add the offset
117+  A794 79               ld a,c                      ; get original row back
118+  A795 ED 73 08 A8      ld (buffer_bufferlinetoscreen3+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
119+  A799 D9               exx
120+  A79A 0E 00            ld c,0                      ; zero horizontal
121+  A79C 47               ld b,a                      ; load the row number into vertical coord
122+  A79D 04               inc b
123+  A79E 04               inc b                       ; move forward 2 to allow for scores
124+  A79F CD DB A9         call screen_getcelladdress  ; get the memory into de
125+  A7A2 21 10 00         ld hl,16                    ; offset by 16 chars to get to the centre, since populating stack from right
126+  A7A5 19               add hl,de
127+  A7A6 3A 7C A7         ld a,(buffer_bufferhalf)    ; get the half
128+  A7A9 FE 01            cp 1
129+  A7AB CA D8 A7         jp z,buffer_bufferlinetoscreen4
130+  A7AE              buffer_bufferlinetoscreen0:     ; PROCESS THE LEFT HALF
131+  A7AE D9               exx                         ; hl is now buffer
132+  A7AF 23               inc hl
133+  A7B0 23               inc hl                      ; move hl forward 2 to skip first two blocks
134+  A7B1 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
135+  A7B2 F1               pop af
136+  A7B3 C1               pop bc
137+  A7B4 D1               pop de
138+  A7B5 DD E1            pop ix
139+  A7B7 D9               exx                         ; hl is now screen
140+  A7B8 08               ex af,af'
141+  A7B9 F1               pop af
142+  A7BA C1               pop bc
143+  A7BB D1               pop de
144+  A7BC F9               ld sp,hl                    ; sp pointing at screen
145+  A7BD D5               push de
146+  A7BE C5               push bc
147+  A7BF F5               push af
148+  A7C0 08               ex af,af'
149+  A7C1 D9               exx                         ; hl is now buffer
150+  A7C2 DD E5            push ix
151+  A7C4 D5               push de
152+  A7C5 C5               push bc
153+  A7C6 F5               push af
154+  A7C7 11 1E 00         ld de,30                    ; add thirty to get to next line
155+  A7CA 19               add hl,de
156+  A7CB F9               ld sp,hl                    ; sp pointing at buffer
157+  A7CC D9               exx                         ; hl is now screen
158+  A7CD 08               ex af,af'
159+  A7CE 24               inc h
160+  A7CF 7C               ld a,h
161+  A7D0 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
162+  A7D2 C2 AE A7         jp nz,buffer_bufferlinetoscreen0 ; next line in cell
163+  A7D5              buffer_bufferlinetoscreen1:
164+  A7D5 C3 07 A8         jp buffer_bufferlinetoscreen3
165+  A7D8              buffer_bufferlinetoscreen4:     ; PROCESS THE RIGHT HALF
166+  A7D8 D9               exx                         ; hl is buffer
167+  A7D9 11 10 00         ld de,16
168+  A7DC 19               add hl,de                   ; move halfway across
169+  A7DD D9               exx                         ; hl is screen
170+  A7DE 11 0E 00         ld de,14
171+  A7E1 19               add hl,de
172+  A7E2              buffer_bufferlinetoscreen2:
173+  A7E2 D9               exx                         ; hl is now buffer
174+  A7E3 F9               ld sp,hl                    ; do first fourteen for right hand side, sp pointing at buffer
175+  A7E4 F1               pop af
176+  A7E5 C1               pop bc
177+  A7E6 D1               pop de
178+  A7E7 DD E1            pop ix
179+  A7E9 D9               exx                         ; hl is now screen
180+  A7EA 08               ex af,af'
181+  A7EB F1               pop af
182+  A7EC C1               pop bc
183+  A7ED D1               pop de
184+  A7EE F9               ld sp,hl                    ; sp pointing at screen
185+  A7EF D5               push de
186+  A7F0 C5               push bc
187+  A7F1 F5               push af
188+  A7F2 08               ex af,af'
189+  A7F3 D9               exx                         ; hl is now buffer
190+  A7F4 DD E5            push ix
191+  A7F6 D5               push de
192+  A7F7 C5               push bc
193+  A7F8 F5               push af
194+  A7F9 11 20 00         ld de,32                    ; add thirty two to get to next line
195+  A7FC 19               add hl,de
196+  A7FD F9               ld sp,hl                    ; sp pointing at buffer
197+  A7FE D9               exx                         ; hl is now screen
198+  A7FF 08               ex af,af'
199+  A800 24               inc h
200+  A801 7C               ld a,h
201+  A802 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
202+  A804 C2 E2 A7         jp nz,buffer_bufferlinetoscreen2 ; next line in cell
203+  A807              buffer_bufferlinetoscreen3:
204+  A807 31 00 00         ld sp,0
205+  A80A D9               exx
206+  A80B C9               ret
207+  A80C
208+  A80C              ;
209+  A80C              ; Copies the buffer to the screen for updated lines. Use stack.
210+  A80C              ; Inputs: none
211+  A80C              ;
212+  A80C              buffer_buffertoscreen:
213+  A80C 3A 30 A7         ld a,(buffer_updateall)      ; get the all update flag
214+  A80F FE 00            cp 0
215+  A811 CA 1D A8         jp z,buffer_buffertoscreen2  ; if not set, draw only updated
216+  A814 CD 4D A8         call buffer_allbuffertoscreen ; otherwise, draw whole screen
217+  A817 21 30 A7         ld hl,buffer_updateall
218+  A81A 36 00            ld (hl),0                    ; reset flag
219+  A81C C9               ret
220+  A81D              buffer_buffertoscreen2:
221+  A81D 06 15            ld b,21
222+  A81F FD 21 1B A7      ld iy,buffer_updatedlines    ; the location of the updated lines
223+  A823              buffer_buffertoscreen0:
224+  A823 FD 7E 00         ld a,(iy)
225+  A826 FE FF            cp 255
226+  A828 CA 4C A8         jp z,buffer_buffertoscreen1                       ; if this is 255, then we're at the end of the updated list
227+  A82B 6F               ld l,a
228+  A82C 26 00            ld h,0
229+  A82E E6 20            and 32                      ; and with 32 to see if 6th bit is set
230+  A830 FE 20            cp 32                       ; if so, second half of screen
231+  A832 C2 3D A8         jp nz,buffer_buffertoscreen3
232+  A835 26 01            ld h,1                      ; store half in h
233+  A837 FD 7E 00         ld a,(iy)
234+  A83A D6 20            sub 32                      ; remove 32
235+  A83C 6F               ld l,a                      ; stor in line number
236+  A83D              buffer_buffertoscreen3:
237+  A83D C5               push bc
238+  A83E FD E5            push iy
239+  A840 F3               di
240+  A841 CD 7D A7         call buffer_bufferlinetoscreen      ; hl has h=half (0 or 1), l=line
241+  A844 FB               ei
242+  A845 FD E1            pop iy
243+  A847 C1               pop bc
244+  A848 FD 23            inc iy
245+  A84A 10 D7            djnz buffer_buffertoscreen0
246+  A84C              buffer_buffertoscreen1:
247+  A84C                  ;call buffer_buffertoattrsfast
248+  A84C C9               ret
249+  A84D
250+  A84D              ;
251+  A84D              ; Copies the buffer to the screen. Use stack.
252+  A84D              ; Inputs: none
253+  A84D              ;
254+  A84D              buffer_allbuffertoscreen:
255+  A84D 06 15            ld b,21
256+  A84F 3E 00            ld a,0
257+  A851              buffer_allbuffertoscreen0:
258+  A851 C5               push bc
259+  A852 F5               push af
260+  A853 F3               di
261+  A854 26 00            ld h,0
262+  A856 6F               ld l,a
263+  A857 CD 7D A7         call buffer_bufferlinetoscreen
264+  A85A FB               ei
265+  A85B F1               pop af
266+  A85C F5               push af
267+  A85D F3               di
268+  A85E 26 01            ld h,1
269+  A860 6F               ld l,a
270+  A861 CD 7D A7         call buffer_bufferlinetoscreen
271+  A864 FB               ei
272+  A865 F1               pop af
273+  A866 C1               pop bc
274+  A867 3C               inc a
275+  A868 10 E7            djnz buffer_allbuffertoscreen0
276+  A86A F3               di
277+  A86B CD 70 A8         call buffer_buffertoattrsfast
278+  A86E FB               ei
279+  A86F C9               ret
280+  A870
281+  A870              ;
282+  A870              ; Copies the attrs buffer to screen with the stack
283+  A870              ;
284+  A870              buffer_buffertoattrsfast:
285+  A870 ED 73 DF A8      ld (buffer_buffertoattrsfast1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
286+  A874 3A E3 A8         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
287+  A877 11 20 00         ld de,32
288+  A87A CD 03 81         call utilities_multiply
289+  A87D 54 5D            ld de,hl
290+  A87F 21 78 A3         ld hl,buffer_attr_buffer
291+  A882 19               add hl,de                       ; add the offset, start of attr buffer now in hl
292+  A883 D9               exx
293+  A884 21 50 58         ld hl,22528+80                  ; start of attr memory + 2 lines for score + 16 to start at right side
294+  A887 FD 21 18 A7      ld iy,buffer_tmp
295+  A88B FD 36 00 15      ld (iy),21              ; number of times to loop
296+  A88F              buffer_buffertoattrsfast0:
297+  A88F D9               exx                         ; hl is now buffer
298+  A890 23               inc hl
299+  A891 23               inc hl                      ; move hl forward 2 to skip first two blocks
300+  A892 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
301+  A893 F1               pop af
302+  A894 C1               pop bc
303+  A895 D1               pop de
304+  A896 DD E1            pop ix
305+  A898 D9               exx                         ; hl is now screen
306+  A899 08               ex af,af'
307+  A89A F1               pop af
308+  A89B C1               pop bc
309+  A89C D1               pop de
310+  A89D F9               ld sp,hl                    ; sp pointing at screen
311+  A89E D5               push de
312+  A89F C5               push bc
313+  A8A0 F5               push af
314+  A8A1 08               ex af,af'
315+  A8A2 D9               exx                         ; hl is now buffer
316+  A8A3 DD E5            push ix
317+  A8A5 D5               push de
318+  A8A6 C5               push bc
319+  A8A7 F5               push af
320+  A8A8 1E 0E            ld e,14                    ; do another fourteen for right hand side
321+  A8AA 16 00            ld d,0
322+  A8AC 19               add hl,de
323+  A8AD F9               ld sp,hl                    ; sp pointing at buffer
324+  A8AE F1               pop af
325+  A8AF C1               pop bc
326+  A8B0 D1               pop de
327+  A8B1 DD E1            pop ix
328+  A8B3 D9               exx                         ; hl is now screen
329+  A8B4 08               ex af,af'
330+  A8B5 1E 0E            ld e,14
331+  A8B7 16 00            ld d,0
332+  A8B9 19               add hl,de
333+  A8BA F1               pop af
334+  A8BB C1               pop bc
335+  A8BC D1               pop de
336+  A8BD F9               ld sp,hl                    ; sp pointing at screen
337+  A8BE D5               push de
338+  A8BF C5               push bc
339+  A8C0 F5               push af
340+  A8C1 08               ex af,af'
341+  A8C2 D9               exx                         ; hl is now buffer
342+  A8C3 DD E5            push ix
343+  A8C5 D5               push de
344+  A8C6 C5               push bc
345+  A8C7 F5               push af
346+  A8C8 1E 10            ld e,16
347+  A8CA 16 00            ld d,0
348+  A8CC 19               add hl,de
349+  A8CD D9               exx                         ; hl is now screen
350+  A8CE 11 12 00         ld de,18
351+  A8D1 19               add hl,de
352+  A8D2 FD 7E 00         ld a,(iy)
353+  A8D5 3D               dec a
354+  A8D6 FE 00            cp 0
355+  A8D8 FD 77 00         ld (iy),a
356+  A8DB C2 8F A8         jp nz,buffer_buffertoattrsfast0 ; do another row
357+  A8DE              buffer_buffertoattrsfast1:
358+  A8DE 31 00 00         ld sp,0
359+  A8E1 D9               exx
360+  A8E2 C9               ret
# file closed: screen/buffer.asm
141   A8E3                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  A8E3              screen_offset:
  2+  A8E3 00               defb 0                      ; offset from top of screen in lines
  3+  A8E4
  4+  A8E4              screen_tmp:
  5+  A8E4 00 00            defb 0,0                      ; temporary memory
  6+  A8E6
  7+  A8E6              screen_setscorecolours:
  8+  A8E6 21 F4 B8         ld hl,score_colours
  9+  A8E9 11 00 58         ld de,22528                     ; attrs here
 10+  A8EC 01 40 00         ld bc,64
 11+  A8EF ED B0            ldir
 12+  A8F1 C9               ret
 13+  A8F2
 14+  A8F2              screen_sethighscorecolours:
 15+  A8F2 21 34 B9         ld hl,high_score_colours
 16+  A8F5 11 E0 5A         ld de,22528+736                 ; attrs here
 17+  A8F8 01 20 00         ld bc,32
 18+  A8FB ED B0            ldir
 19+  A8FD C9               ret
 20+  A8FE
 21+  A8FE              ; Draw the screen
 22+  A8FE              ; Inputs:
 23+  A8FE              ; none
 24+  A8FE              ; Notes:
 25+  A8FE              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
 26+  A8FE              screen_draw:
 27+  A8FE                  ;call clear_screen
 28+  A8FE 0E 00            ld c,0                      ; horiz
 29+  A900 06 00            ld b,0                      ; vert, 0 at top
 30+  A902 DD 21 CF B2      ld ix,level_layout               ; point ix at level data
 31+  A906 FD 21 78 A3      ld iy,buffer_attr_buffer    ; point iy at attr data
 32+  A90A              screen_draw0:
 33+  A90A DD 7E 00         ld a,(ix)                   ; load the block number
 34+  A90D C5               push bc                     ; store bc, contains loop count
 35+  A90E CD C9 AA         call screen_getattr         ; get the memory location for this cell's attr into hl
 36+  A911 7E               ld a,(hl)                   ; get the attr value at the address
 37+  A912 FD 77 00         ld (iy),a                   ; load the attr into memory
 38+  A915 DD 7E 00         ld a,(ix)                   ; load the block number
 39+  A918 CD 90 AA         call screen_getblock        ; get the block data into hl
 40+  A91B CD 6D AA         call screen_showchar        ; show this character here
 41+  A91E C1               pop bc                      ; get the loop counter back
 42+  A91F DD 23            inc ix                      ; increment level location
 43+  A921 FD 23            inc iy                      ; increment attr location
 44+  A923 0C               inc c                       ; increment horiz
 45+  A924 79               ld a,c
 46+  A925 FE 20            cp 32                       ; check if horiz has reach edge of screen
 47+  A927 C2 0A A9         jp nz,screen_draw0          ; if not, loop
 48+  A92A 0E 00            ld c,0                      ; if so, reset horiz
 49+  A92C 04               inc b                       ; increment vertical
 50+  A92D 78               ld a,b
 51+  A92E FE 1D            cp 29                       ; check if at bottom
 52+  A930 C2 0A A9         jp nz,screen_draw0          ; if not, loop
 53+  A933 21 E4 A8         ld hl, screen_tmp
 54+  A936 36 09            ld (hl),9                   ; load the block number into memory
 55+  A938 DD 2A 09 C5      ld ix,(game_current_rocks)  ; current rock memory
 56+  A93C CD AB A9         call screen_initobjects     ; draw rocks
 57+  A93F 21 E4 A8         ld hl, screen_tmp
 58+  A942 36 0C            ld (hl),12                  ; load the block number into memory
 59+  A944 DD 21 56 B8      ld ix,level_missiles       ; missile memory
 60+  A948 CD AB A9         call screen_initobjects     ; draw missiles
 61+  A94B 21 E4 A8         ld hl, screen_tmp
 62+  A94E 36 08            ld (hl),08                  ; load the block number into memory
 63+  A950 DD 21 CF B8      ld ix,level_diamonds       ; diamond memory
 64+  A954 CD AB A9         call screen_initobjects     ; draw diamonds
 65+  A957 21 E4 A8         ld hl, screen_tmp
 66+  A95A 36 0E            ld (hl),14                  ; load the block number into memory
 67+  A95C DD 21 DF B8      ld ix,level_gems           ; gems memory
 68+  A960 CD AB A9         call screen_initobjects     ; draw gems
 69+  A963 CD 6A A9         call screen_setuptext       ; draws text on the screen
 70+  A966 CD 85 CD         call scores_printscores     ; print the current scores
 71+  A969 C9               ret
 72+  A96A
 73+  A96A              ;
 74+  A96A              ; Sets up text on the screen
 75+  A96A              ;
 76+  A96A              screen_setuptext:
 77+  A96A CD E1 CD         call scores_showtable
 78+  A96D CD F2 A8         call screen_sethighscorecolours
 79+  A970 21 CF 81         ld hl, string_score1
 80+  A973 CD 30 86         call string_print
 81+  A976 21 D8 81         ld hl, string_scorenumbers1
 82+  A979 CD 30 86         call string_print
 83+  A97C 21 E1 81         ld hl, string_company
 84+  A97F CD 30 86         call string_print
 85+  A982 21 01 82         ld hl, string_score2
 86+  A985 CD 30 86         call string_print
 87+  A988 21 0A 82         ld hl, string_scorenumbers2
 88+  A98B CD 30 86         call string_print
 89+  A98E 3A 05 C5         ld a,(game_currentplayer)
 90+  A991 FE 01            cp 1
 91+  A993 C2 9C A9         jp nz,screen_setuptext0
 92+  A996 21 EB 81         ld hl, string_player1
 93+  A999 C3 9F A9         jp screen_setuptext1
 94+  A99C              screen_setuptext0:
 95+  A99C 21 F6 81         ld hl, string_player2
 96+  A99F              screen_setuptext1:
 97+  A99F CD 30 86         call string_print
 98+  A9A2 CD E6 A8         call screen_setscorecolours
 99+  A9A5 C9               ret
100+  A9A6
101+  A9A6              ;
102+  A9A6              ; Sets a line of colours
103+  A9A6              ; Inputs:
104+  A9A6              ; a - colour to set
105+  A9A6              ; b - number to set
106+  A9A6              ; de - start memory location
107+  A9A6              ;
108+  A9A6              screen_setcolours:
109+  A9A6 12               ld (de),a
110+  A9A7 13               inc de
111+  A9A8 10 FC            djnz screen_setcolours
112+  A9AA C9               ret
113+  A9AB
114+  A9AB              ;
115+  A9AB              ; Draw initial object positions
116+  A9AB              ; Inputs:
117+  A9AB              ; ix - memory location of objects
118+  A9AB              ; a - graphic
119+  A9AB              screen_initobjects:
120+  A9AB DD 4E 00         ld c,(ix)                   ; get the horiz coord
121+  A9AE 79               ld a,c
122+  A9AF FE FF            cp 255
123+  A9B1 CA DA A9         jp z,screen_initobjects2
124+  A9B4 DD 23            inc ix                      ; move to next
125+  A9B6 DD 46 00         ld b,(ix)                   ; get the vert coord
126+  A9B9 DD 23            inc ix
127+  A9BB CD EC A9         call screen_getcellattradress ; get the memory address of b,c attr into de
128+  A9BE D5               push de
129+  A9BF 3A E4 A8         ld a,(screen_tmp)                  ; get the block number back
130+  A9C2 CD C9 AA         call screen_getattr         ; get the memory location for this cell's attr into hl
131+  A9C5 D1               pop de
132+  A9C6 7E               ld a,(hl)                   ; get the attr value at the address
133+  A9C7 12               ld (de),a                   ; load the attr into memory
134+  A9C8 3A E4 A8         ld a,(screen_tmp)                  ; get the block number back
135+  A9CB CD 90 AA         call screen_getblock        ; get the block data into hl
136+  A9CE CD 6D AA         call screen_showchar        ; show this character here
137+  A9D1
138+  A9D1              screen_initobjects1:
139+  A9D1 DD 23            inc ix                      ; move past state
140+  A9D3 DD 23            inc ix
141+  A9D5 DD 23            inc ix                      ; move past mem
142+  A9D7 C3 AB A9         jp screen_initobjects
143+  A9DA              screen_initobjects2:
144+  A9DA C9               ret
145+  A9DB
146+  A9DB
147+  A9DB              ;
148+  A9DB              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
149+  A9DB              ; Inputs:
150+  A9DB              ; bc: coords
151+  A9DB              ; Outputs:
152+  A9DB              ; de: memory location
153+  A9DB              ;
154+  A9DB              screen_getcelladdress:
155+  A9DB 78               ld a,b      ; vertical position.
156+  A9DC E6 18            and 24      ; which segment, 0, 1 or 2?
157+  A9DE C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
158+  A9E0 57               ld d,a      ; this is our high byte.
159+  A9E1 78               ld a,b      ; what was that vertical position again?
160+  A9E2 E6 07            and 7       ; which row within segment?
161+  A9E4 0F               rrca        ; multiply row by 32.
162+  A9E5 0F               rrca
163+  A9E6 0F               rrca
164+  A9E7 5F               ld e,a      ; low byte.
165+  A9E8 79               ld a,c      ; add on y coordinate.
166+  A9E9 83               add a,e     ; mix with low byte.
167+  A9EA 5F               ld e,a      ; address of screen position in de.
168+  A9EB C9               ret
169+  A9EC
170+  A9EC              ;
171+  A9EC              ; Calculate buffer address of attribute for character at (b, c).
172+  A9EC              ; Inputs:
173+  A9EC              ; bc: coords
174+  A9EC              ; Outputs:
175+  A9EC              ; de: memory location
176+  A9EC              ;
177+  A9EC              screen_getcellattradress:
178+  A9EC 11 78 A3         ld de,buffer_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
179+  A9EF 69               ld l,c      ; x position.
180+  A9F0 26 00            ld h,0      ; 0 h
181+  A9F2 19               add hl,de
182+  A9F3 54 5D            ld de,hl    ; horiz done
183+  A9F5 78               ld a,b      ; do vert
184+  A9F6 D5               push de
185+  A9F7 C5               push bc
186+  A9F8 11 20 00         ld de,32
187+  A9FB CD 03 81         call utilities_multiply
188+  A9FE C1               pop bc
189+  A9FF D1               pop de
190+  AA00 19               add hl,de
191+  AA01 54 5D            ld de,hl    ; vert done
192+  AA03 C9               ret
193+  AA04
194+  AA04              ;
195+  AA04              ; Calculate buffer address offset of attribute for character at (b, c).
196+  AA04              ; Inputs:
197+  AA04              ; bc: coords
198+  AA04              ; Outputs:
199+  AA04              ; de: memory location
200+  AA04              ;
201+  AA04              screen_getcellattroffset:
202+  AA04 69               ld l,c      ; x position.
203+  AA05 26 00            ld h,0      ; 0 h
204+  AA07 54 5D            ld de,hl    ; horiz done
205+  AA09 78               ld a,b      ; do vert
206+  AA0A D5               push de
207+  AA0B C5               push bc
208+  AA0C 11 20 00         ld de,32
209+  AA0F CD 03 81         call utilities_multiply
210+  AA12 C1               pop bc
211+  AA13 D1               pop de
212+  AA14 19               add hl,de
213+  AA15 54 5D            ld de,hl    ; vert done
214+  AA17 C9               ret
215+  AA18
216+  AA18              ;
217+  AA18              ; Calculate buffer address of attribute for character at (b, c).
218+  AA18              ; Inputs:
219+  AA18              ; bc: coords
220+  AA18              ; Outputs:
221+  AA18              ; de: memory location
222+  AA18              ;
223+  AA18              screen_getscreenattradress:
224+  AA18 11 00 58         ld de,22528 ; memory is at base + horiz (c) + vert*32 (b)
225+  AA1B 69               ld l,c      ; x position.
226+  AA1C 26 00            ld h,0      ; 0 h
227+  AA1E 19               add hl,de
228+  AA1F 54 5D            ld de,hl    ; horiz done
229+  AA21 78               ld a,b      ; do vert
230+  AA22 D5               push de
231+  AA23 C5               push bc
232+  AA24 11 20 00         ld de,32
233+  AA27 CD 03 81         call utilities_multiply
234+  AA2A C1               pop bc
235+  AA2B D1               pop de
236+  AA2C 19               add hl,de
237+  AA2D 54 5D            ld de,hl    ; vert done
238+  AA2F C9               ret
239+  AA30
240+  AA30              ;
241+  AA30              ; Gets the attr memory location for a screen coord
242+  AA30              ; Will overwrite bc
243+  AA30              ; Inputs:
244+  AA30              ; bc - screen coords
245+  AA30              ; Outputs:
246+  AA30              ; de - memory location
247+  AA30              ; bc - character coords
248+  AA30              ;
249+  AA30              screen_getattraddressfromscreencoords:
250+  AA30 78               ld a,b                          ; get the player block coords of current block
251+  AA31 E6 F8            and 248                         ; find closest multiple of eight
252+  AA33 0F               rrca
253+  AA34 0F               rrca
254+  AA35 0F               rrca                ; divide by 8
255+  AA36 47               ld b,a
256+  AA37 79               ld a,c
257+  AA38 48               ld c,b                         ; swap b and c
258+  AA39 E6 F8            and 248
259+  AA3B 0F               rrca
260+  AA3C 0F               rrca
261+  AA3D 0F               rrca                ; divide by 8
262+  AA3E 47               ld b,a
263+  AA3F CD EC A9         call screen_getcellattradress   ; work out memory location of current block attributes, memory in de
264+  AA42 C9               ret
265+  AA43
266+  AA43
267+  AA43              ; Gets the nearest cell coords for a screen coord
268+  AA43              ; Will overwrite bc
269+  AA43              ; Inputs:
270+  AA43              ; bc - screen coords
271+  AA43              ; Outputs:
272+  AA43              ; bc - character coords
273+  AA43              ;
274+  AA43              screen_getcharcoordsfromscreencoords:
275+  AA43 78               ld a,b                          ; get the player block coords of current block
276+  AA44 E6 F8            and 248                         ; find closest multiple of eight
277+  AA46 0F               rrca
278+  AA47 0F               rrca
279+  AA48 0F               rrca                ; divide by 8
280+  AA49 47               ld b,a
281+  AA4A 79               ld a,c
282+  AA4B 48               ld c,b                         ; swap b and c
283+  AA4C E6 F8            and 248
284+  AA4E 0F               rrca
285+  AA4F 0F               rrca
286+  AA50 0F               rrca                ; divide by 8
287+  AA51 47               ld b,a
288+  AA52 C9               ret
289+  AA53
290+  AA53              ; Gets the screen coords for a cell coord
291+  AA53              ; Will overwrite bc
292+  AA53              ; Inputs:
293+  AA53              ; bc - char coords
294+  AA53              ; Outputs:
295+  AA53              ; bc - screen coords
296+  AA53              ;
297+  AA53              screen_getscreencoordsfromcharcoords:
298+  AA53 78               ld a,b                          ; get the player block coords of current block
299+  AA54 07               rlca
300+  AA55 07               rlca
301+  AA56 07               rlca                ; multiply by 8
302+  AA57 47               ld b,a
303+  AA58 79               ld a,c
304+  AA59 48               ld c,b                         ; swap b and c
305+  AA5A 07               rlca
306+  AA5B 07               rlca
307+  AA5C 07               rlca                ; divide by 8
308+  AA5D 47               ld b,a
309+  AA5E C9               ret
310+  AA5F
311+  AA5F              ;
312+  AA5F              ; Get buffer address for a character at b,c - b vert
313+  AA5F              ; Buffer memory is stored as sequential block
314+  AA5F              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
315+  AA5F              ; Inputs:
316+  AA5F              ; bc - coords
317+  AA5F              ; Outputs:
318+  AA5F              ; de - memory location of first byte
319+  AA5F              screen_getbufferaddress:
320+  AA5F 21 78 86         ld hl, buffer_buffer    ; first get screen buffer start
321+  AA62 50               ld d,b                  ; then work out vertical offset
322+  AA63 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
323+  AA65 19               add hl,de               ; add to base
324+  AA66 59               ld e,c                  ; then add horizontal offset (c)
325+  AA67 16 00            ld d,0
326+  AA69 19               add hl,de               ; add to base
327+  AA6A 54 5D            ld de,hl
328+  AA6C C9               ret
329+  AA6D
330+  AA6D              ;
331+  AA6D              ; Display character hl at (b, c) to buffer.
332+  AA6D              ; Stored sequentially
333+  AA6D              ; Inputs:
334+  AA6D              ; hl: block address
335+  AA6D              ; bc: coords
336+  AA6D              ;
337+  AA6D              screen_showchar:
338+  AA6D ED 43 3F AC      ld (origcoords),bc   ; store char coords
339+  AA71 3E 00            ld a,0
340+  AA73 E5               push hl
341+  AA74 CD 5F AA         call screen_getbufferaddress ; get the current screen buffer pointer
342+  AA77 E1               pop hl
343+  AA78 06 08            ld b,8              ; number of pixels high.
344+  AA7A              screen_showchar0:
345+  AA7A 7E               ld a,(hl)           ; source graphic.
346+  AA7B 12               ld (de),a           ; transfer to screen.
347+  AA7C 23               inc hl              ; next piece of data.
348+  AA7D E5               push hl             ; store hl
349+  AA7E 62 6B            ld hl,de            ; put de in hl
350+  AA80 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
351+  AA82 16 00            ld d,0
352+  AA84 19               add hl,de              ; add de to hl
353+  AA85 54 5D            ld de,hl            ; load back to de
354+  AA87 E1               pop hl              ; restore hl
355+  AA88
356+  AA88 10 F0            djnz screen_showchar0 ; repeat
357+  AA8A 2E 01            ld l,1
358+  AA8C CD F0 AB         call sprites_marklinesforupdatechar
359+  AA8F
360+  AA8F C9               ret
361+  AA90
362+  AA90
363+  AA90              ;
364+  AA90              ; Get cell graphic.
365+  AA90              ; Inputs:
366+  AA90              ; a: block
367+  AA90              ; Outputs:
368+  AA90              ; hl: memory
369+  AA90              ;
370+  AA90              screen_getblock:
371+  AA90 07               rlca                        ; multiply block number by eight.
372+  AA91 07               rlca
373+  AA92 07               rlca
374+  AA93 5F               ld e,a                      ; displacement to graphic address.
375+  AA94 16 00            ld d,0                      ; no high byte.
376+  AA96 21 54 BD         ld hl,sprites               ; address of character blocks.
377+  AA99 19               add hl,de                   ; point to block.
378+  AA9A C9               ret
379+  AA9B
380+  AA9B              ;
381+  AA9B              ; Set a the attr of a coord
382+  AA9B              ; Inputs:
383+  AA9B              ; bc - char coords
384+  AA9B              ; a - attr
385+  AA9B              ;
386+  AA9B              screen_setattr:
387+  AA9B DD E5            push ix
388+  AA9D C5               push bc
389+  AA9E 08               ex af, af'
390+  AA9F CD 04 AA         call screen_getcellattroffset   ; get offset into de
391+  AAA2 21 78 A3         ld hl,buffer_attr_buffer
392+  AAA5 19               add hl,de                       ; get the memory location
393+  AAA6 08               ex af, af'                      ; get attr back
394+  AAA7 77               ld (hl),a                         ; set the attr
395+  AAA8 08               ex af, af'                      ; get attr back
396+  AAA9 ED 5B E3 A8      ld de,(screen_offset)           ; get the offset
397+  AAAD 78               ld a,b                          ; get the vertical
398+  AAAE 93               sub e                           ; subtract the offset
399+  AAAF DA C5 AA         jp c,screen_setattr0            ; if less than zero, don't update the attr on screen
400+  AAB2 FE 15            cp 21
401+  AAB4 D2 C5 AA         jp nc,screen_setattr0           ; if more than 21, don't update the attr on screen
402+  AAB7 47               ld b,a                          ; put the coord back in b
403+  AAB8 CD 18 AA         call screen_getscreenattradress ; screen attr address in de
404+  AABB 21 40 00         ld hl,64                        ; attr memory + two rows for scores
405+  AABE 19               add hl,de
406+  AABF 08               ex af, af'                      ; get attr back
407+  AAC0 77               ld (hl),a
408+  AAC1 C1               pop bc
409+  AAC2 DD E1            pop ix
410+  AAC4 C9               ret
411+  AAC5              screen_setattr0:
412+  AAC5 C1               pop bc
413+  AAC6 DD E1            pop ix
414+  AAC8 C9               ret
415+  AAC9
416+  AAC9              ;
417+  AAC9              ; Get cell attribute.
418+  AAC9              ; Inputs:
419+  AAC9              ; a: block
420+  AAC9              ; Outputs:
421+  AAC9              ; hl: memory
422+  AAC9              ;
423+  AAC9              screen_getattr:
424+  AAC9 5F               ld e,a                      ; displacement to attribute address.
425+  AACA 16 00            ld d,0                      ; no high byte.
426+  AACC 21 34 BE         ld hl,sprite_attrs          ; address of block attributes.
427+  AACF 19               add hl,de                   ; point to attribute.
428+  AAD0 C9               ret
429+  AAD1
430+  AAD1              ;
431+  AAD1              ; Checks whether a character block has anything in it
432+  AAD1              ; Inputs:
433+  AAD1              ; bc - char coords
434+  AAD1              ; Outputs:
435+  AAD1              ; a - 1, empty
436+  AAD1              screen_ischarempty:
437+  AAD1 CD 5F AA         call screen_getbufferaddress ; get the current screen buffer pointer
438+  AAD4 06 08            ld b,8                      ; check 8 rows
439+  AAD6              screen_ischarempty2:
440+  AAD6 1A               ld a,(de)                   ; check line
441+  AAD7 FE 00            cp 0
442+  AAD9 C2 E7 AA         jp nz,screen_ischarempty1   ; if not zero, jump out with false
443+  AADC 21 20 00         ld hl,32
444+  AADF 19               add hl,de
445+  AAE0 54 5D            ld de,hl                    ; move to next row
446+  AAE2 10 F2            djnz screen_ischarempty2
447+  AAE4              screen_ischarempty0:
448+  AAE4 3E 01            ld a,1
449+  AAE6 C9               ret
450+  AAE7              screen_ischarempty1:
451+  AAE7 3E 00            ld a,0
452+  AAE9 C9               ret
453+  AAEA
454+  AAEA              ;
455+  AAEA              ; Copies a block from one place to another directly underneath, leaves the original empty
456+  AAEA              ; Inputs:
457+  AAEA              ; bc - coords of block to copy from
458+  AAEA              screen_copyblockdown
459+  AAEA CD 5F AA         call screen_getbufferaddress ; get the current screen buffer pointer for source
460+  AAED 06 08            ld b,8                      ; copy 8 rows
461+  AAEF              screen_copyblock0:
462+  AAEF 1A               ld a,(de)                    ; get what we're copying
463+  AAF0 08               ex af,af'
464+  AAF1 3E 00            ld a,0
465+  AAF3 12               ld (de),a                    ; replace with empty
466+  AAF4 08               ex af,af'
467+  AAF5 14               inc d                        ; add 256 to get to the next row
468+  AAF6 12               ld (de),a                    ; copy to the next row
469+  AAF7 15               dec d
470+  AAF8 21 20 00         ld hl,32
471+  AAFB 19               add hl,de                       ; return back to source, next row down
472+  AAFC 54 5D            ld de,hl
473+  AAFE 10 EF            djnz screen_copyblock0
474+  AB00 C9               ret
475+  AB01
476+  AB01              ;
477+  AB01              ; Returns the first byte of a character. Useful for figuring out what's there
478+  AB01              ; Inputs:
479+  AB01              ; bc - coords
480+  AB01              ; Outputs:
481+  AB01              ; a - first byte
482+  AB01              ;
483+  AB01              screen_getcharfirstbyte:
484+  AB01 CD 5F AA         call screen_getbufferaddress ; get the current screen buffer pointer for source
485+  AB04 1A               ld a,(de)
486+  AB05 C9               ret
487+  AB06
# file closed: screen/screen.asm
142   AB06                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  AB06              ;
  2+  AB06              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  AB06              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  AB06              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  AB06              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  AB06              ; routine takes care of all the shifting itself. This means that sprite
  7+  AB06              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  AB06              ; space they would require in pre-shifted form.
  9+  AB06              ; Inputs:
 10+  AB06              ; hl - sprite data
 11+  AB06              ; bc - screen coords
 12+  AB06              ;
 13+  AB06              sprites_drawsprite7:
 14+  AB06 EE 07            xor 7               ; complement last 3 bits.
 15+  AB08 3C               inc a               ; add one for luck!
 16+  AB09              sprites_drawsprite3:
 17+  AB09 CB 11            rl c                ; ...into middle byte...
 18+  AB0B CB 12            rl d                ; ...and finally into left character cell.
 19+  AB0D 3D               dec a               ; count shifts we've done.
 20+  AB0E 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  AB10                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  AB10 79               ld a,c              ; left edge of image is currently in e.
 23+  AB11 4A               ld c,d              ; put right edge there instead.
 24+  AB12 57               ld d,a              ; and the left edge back into c.
 25+  AB13 18 29            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  AB15              sprites_drawsprite:
 27+  AB15 ED 43 3F AC      ld (origcoords),bc  ; store coords
 28+  AB19 ED 43 41 AC      ld (dispx),bc       ; store coords in dispx for now.
 29+  AB1D E5               push hl
 30+  AB1E CD 1D AC         call sprites_scadd  ; calculate screen address.
 31+  AB21 E1               pop hl
 32+  AB22 3E 08            ld a,8              ; height of sprite in pixels.
 33+  AB24              sprites_drawsprite1:
 34+  AB24 08               ex af,af'           ; store loop counter.
 35+  AB25 D5               push de             ; store screen address.
 36+  AB26 4E               ld c,(hl)           ; first sprite graphic.
 37+  AB27 23               inc hl              ; increment poiinter to sprite data.
 38+  AB28 22 43 AC         ld (sprtmp),hl      ; store it for later.
 39+  AB2B 16 00            ld d,0              ; blank right byte for now.
 40+  AB2D 78               ld a,b              ; b holds y position.
 41+  AB2E E6 07            and 7               ; how are we straddling character cells?
 42+  AB30 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 43+  AB32 FE 05            cp 5                ; 5 or more right shifts needed?
 44+  AB34 30 D0            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 45+  AB36 A7               and a               ; oops, carry flag is set so clear it.
 46+  AB37              sprites_drawsprite2:
 47+  AB37 CB 19            rr c                ; rotate left byte right...
 48+  AB39 CB 1A            rr d                ; ...into right byte.
 49+  AB3B 3D               dec a               ; one less shift to do.
 50+  AB3C 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 51+  AB3E              sprites_drawsprite0:
 52+  AB3E E1               pop hl              ; pop screen address from stack.
 53+  AB3F 7E               ld a,(hl)           ; what's there already.
 54+  AB40 A9               xor c               ; merge in image data.
 55+  AB41 77               ld (hl),a           ; place onto screen.
 56+  AB42 23               inc hl
 57+  AB43 7E               ld a,(hl)           ; what's already there.
 58+  AB44 AA               xor d               ; right edge of sprite image data.
 59+  AB45 77               ld (hl),a           ; plonk it on screen.
 60+  AB46 3A 41 AC         ld a,(dispx)        ; vertical coordinate.
 61+  AB49 3C               inc a               ; next line down.
 62+  AB4A 32 41 AC         ld (dispx),a        ; store new position.
 63+  AB4D 2B               dec hl
 64+  AB4E 11 20 00         ld de,32            ; add 32 to get to the next row
 65+  AB51 19               add hl,de           ; add 32
 66+  AB52              sprites_drawsprite6:
 67+  AB52 EB               ex de,hl            ; screen address in de.
 68+  AB53 2A 43 AC         ld hl,(sprtmp)      ; restore graphic address.
 69+  AB56 08               ex af,af'           ; restore loop counter.
 70+  AB57 3D               dec a               ; decrement it.
 71+  AB58 C2 24 AB         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 72+  AB5B 2E 02            ld l,2
 73+  AB5D CD CC AB         call sprites_marklinesforupdatescreen
 74+  AB60 C9               ret                 ; job done.
 75+  AB61
 76+  AB61              ; Inputs:
 77+  AB61              ; hl - sprite data
 78+  AB61              ; bc - screen coords
 79+  AB61              ;
 80+  AB61              sprites_draw2by2sprite7
 81+  AB61 EE 07            xor 7               ; complement last 3 bits.
 82+  AB63 3C               inc a               ; add one for luck!
 83+  AB64              sprites_draw2by2sprite3
 84+  AB64 CB 12            rl d                ; rotate left...
 85+  AB66 CB 11            rl c                ; ...into middle byte...
 86+  AB68 CB 13            rl e                ; ...and finally into left character cell.
 87+  AB6A 3D               dec a               ; count shifts we've done.
 88+  AB6B 20 F7            jr nz,sprites_draw2by2sprite3 ; return until all shifts complete.
 89+  AB6D                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 90+  AB6D 7B               ld a,e              ; left edge of image is currently in e.
 91+  AB6E 5A               ld e,d              ; put right edge there instead.
 92+  AB6F 51               ld d,c              ; middle bit goes in d.
 93+  AB70 4F               ld c,a              ; and the left edge back into c.
 94+  AB71 18 31            jr sprites_draw2by2sprite0 ; we've done the switch so transfer to screen.
 95+  AB73              sprites_draw2by2sprite
 96+  AB73 ED 43 3F AC      ld (origcoords),bc  ; store coords
 97+  AB77 ED 43 41 AC      ld (dispx),bc       ; store coords in dispx for now.
 98+  AB7B 79               ld a,c
 99+  AB7C 32 45 AC         ld (sprtmp0),a         ; store vertical.
100+  AB7F E5               push hl
101+  AB80 CD 1D AC         call sprites_scadd          ; calculate screen address.
102+  AB83 E1               pop hl
103+  AB84 3E 10            ld a,16             ; height of sprite in pixels.
104+  AB86              sprites_draw2by2sprite1
105+  AB86 08               ex af,af'           ; store loop counter.
106+  AB87 D5               push de             ; store screen address.
107+  AB88 4E               ld c,(hl)           ; first sprite graphic.
108+  AB89 23               inc hl              ; increment poiinter to sprite data.
109+  AB8A 56               ld d,(hl)           ; next bit of sprite image.
110+  AB8B 23               inc hl              ; point to next row of sprite data.
111+  AB8C 22 43 AC         ld (sprtmp),hl        ; store in tmp0 for later.
112+  AB8F 1E 00            ld e,0              ; blank right byte for now.
113+  AB91 78               ld a,b              ; b holds y position.
114+  AB92 E6 07            and 7               ; how are we straddling character cells?
115+  AB94 28 0E            jr z,sprites_draw2by2sprite0 ; we're not straddling them, don't bother shifting.
116+  AB96 FE 05            cp 5                ; 5 or more right shifts needed?
117+  AB98 30 C7            jr nc,sprites_draw2by2sprite7 ; yes, shift from left as it's quicker.
118+  AB9A A7               and a               ; oops, carry flag is set so clear it.
119+  AB9B              sprites_draw2by2sprite2
120+  AB9B CB 19            rr c                ; rotate left byte right...
121+  AB9D CB 1A            rr d                ; ...through middle byte...
122+  AB9F CB 1B            rr e                ; ...into right byte.
123+  ABA1 3D               dec a               ; one less shift to do.
124+  ABA2 20 F7            jr nz,sprites_draw2by2sprite2 ; return until all shifts complete.
125+  ABA4              sprites_draw2by2sprite0
126+  ABA4 E1               pop hl              ; pop screen address from stack.
127+  ABA5 7E               ld a,(hl)           ; what's there already.
128+  ABA6 A9               xor c               ; merge in image data.
129+  ABA7 77               ld (hl),a           ; place onto screen.
130+  ABA8 23               inc hl               ; next character cell to right please.
131+  ABA9 7E               ld a,(hl)           ; what's there already.
132+  ABAA AA               xor d               ; merge with middle bit of image.
133+  ABAB 77               ld (hl),a           ; put back onto screen.
134+  ABAC 23               inc hl              ; next bit of screen area.
135+  ABAD 7E               ld a,(hl)           ; what's already there.
136+  ABAE AB               xor e               ; right edge of sprite image data.
137+  ABAF 77               ld (hl),a           ; plonk it on screen.
138+  ABB0 3A 45 AC         ld a,(sprtmp0)         ; temporary vertical coordinate.
139+  ABB3 3C               inc a               ; next line down.
140+  ABB4 32 45 AC         ld (sprtmp0),a         ; store new position.
141+  ABB7 2B               dec hl
142+  ABB8 2B               dec hl
143+  ABB9 11 20 00         ld de,32            ; add 32 to get to the next row
144+  ABBC 19               add hl,de           ; add 32
145+  ABBD              sprites_draw2by2sprite6
146+  ABBD EB               ex de,hl            ; screen address in de.
147+  ABBE 2A 43 AC         ld hl,(sprtmp)        ; restore graphic address.
148+  ABC1 08               ex af,af'           ; restore loop counter.
149+  ABC2 3D               dec a               ; decrement it.
150+  ABC3 C2 86 AB         jp nz,sprites_draw2by2sprite1 ; not reached bottom of sprite yet to repeat.
151+  ABC6 2E 03            ld l,3
152+  ABC8 CD CC AB         call sprites_marklinesforupdatescreen
153+  ABCB C9               ret                 ; job done.
154+  ABCC
155+  ABCC              ;
156+  ABCC              ; Marks lines for update with screen coords
157+  ABCC              ; Inputs:
158+  ABCC              ; l - number to update
159+  ABCC              ;
160+  ABCC              sprites_marklinesforupdatescreen:
161+  ABCC F5               push af
162+  ABCD ED 4B 3F AC      ld bc,(origcoords)
163+  ABD1 CD 43 AA         call screen_getcharcoordsfromscreencoords
164+  ABD4 ED 43 3F AC      ld (origcoords),bc
165+  ABD8 3A 1A A7         ld a,(buffer_threelinerefresh)              ; check the three line update flag
166+  ABDB FE 01            cp 1
167+  ABDD C2 EB AB         jp nz,sprites_marklinesforupdatescreen0
168+  ABE0 2C               inc l                                       ; increase number to 3
169+  ABE1 05               dec b
170+  ABE2 ED 43 3F AC      ld (origcoords),bc                           ; decrease vertical coord
171+  ABE6 3E 00            ld a,0
172+  ABE8 32 1A A7         ld (buffer_threelinerefresh),a              ; reset the flag
173+  ABEB              sprites_marklinesforupdatescreen0:
174+  ABEB CD FA AB         call sprites_marklinesforupdate
175+  ABEE F1               pop af
176+  ABEF C9               ret
177+  ABF0
178+  ABF0              ;
179+  ABF0              ; Marks lines for update with char coords
180+  ABF0              ; Inputs:
181+  ABF0              ; l - number to update
182+  ABF0              ;
183+  ABF0              sprites_marklinesforupdatechar:
184+  ABF0 F5               push af
185+  ABF1 ED 43 3F AC      ld (origcoords),bc
186+  ABF5 CD FA AB         call sprites_marklinesforupdate
187+  ABF8 F1               pop af
188+  ABF9 C9               ret
189+  ABFA
190+  ABFA              ;
191+  ABFA              ; Marks lines for update
192+  ABFA              ; Inputs:
193+  ABFA              ; l - number to update
194+  ABFA              ;
195+  ABFA              sprites_marklinesforupdate:
196+  ABFA ED 4B 3F AC      ld bc,(origcoords)
197+  ABFE ED 5B E3 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows
198+  AC02 78               ld a,b
199+  AC03 93               sub e
200+  AC04 47               ld b,a
201+  AC05 7D               ld a,l                          ; get loop counter
202+  AC06              sprites_marklinesforupdate0:
203+  AC06 C5               push bc
204+  AC07 08               ex af,af'                     ; store loop counter
205+  AC08 78               ld a,b
206+  AC09 CD 31 A7         call buffer_marklineforupdate ; mark this line for update
207+  AC0C ED 4B 3F AC      ld bc,(origcoords)            ; move the coords for the next line
208+  AC10 04               inc b
209+  AC11 ED 43 3F AC      ld (origcoords),bc
210+  AC15 C1               pop bc
211+  AC16 04               inc b
212+  AC17 08               ex af,af'                     ; restore loop counter
213+  AC18 3D               dec a
214+  AC19 C2 06 AC         jp nz,sprites_marklinesforupdate0
215+  AC1C C9               ret
216+  AC1D
217+  AC1D              ;
218+  AC1D              ; This routine returns a buffer address for (c, b) in de (c vert).
219+  AC1D              ; For example: 0,0 will be at memory offset 0
220+  AC1D              ; 1,0 (1 down) will be at memory offset 1
221+  AC1D              ; 0,7 will be at memory offset 0
222+  AC1D              ; 9,1 will be at memory offset 8+1
223+  AC1D              ; 8,0 will be at memory offset 256
224+  AC1D              ; 9,0 will be at memory offset 257
225+  AC1D              ; Outputs:
226+  AC1D              ; de - coords
227+  AC1D              ;
228+  AC1D              sprites_scadd:
229+  AC1D 79               ld a,c               ; calculate vertical offset
230+  AC1E E6 F8            and 248             ;  to get nearest multiple of 8
231+  AC20 0F               rrca
232+  AC21 0F               rrca
233+  AC22 0F               rrca                ; divide by 8
234+  AC23 67               ld h,a
235+  AC24 78               ld a,b               ; calculate horizontal offset
236+  AC25 E6 F8            and 248             ;  to get nearest multiple of 8
237+  AC27 0F               rrca
238+  AC28 0F               rrca
239+  AC29 0F               rrca                ; divide by 8
240+  AC2A 6F               ld l,a
241+  AC2B C5               push bc             ; store the screen coords
242+  AC2C 44 4D            ld bc,hl            ; load bc with the character coords
243+  AC2E CD 5F AA         call screen_getbufferaddress
244+  AC31 C1               pop bc              ; get back screen coords, de is now memory of character
245+  AC32 79               ld a,c              ; now add the vertical within the cell
246+  AC33 E6 07            and 7
247+  AC35 0F               rrca                ; multiply by 32.
248+  AC36 0F               rrca
249+  AC37 0F               rrca
250+  AC38 6F               ld l,a
251+  AC39 26 00            ld h,0
252+  AC3B 19               add hl,de
253+  AC3C 54 5D            ld de,hl
254+  AC3E C9               ret
255+  AC3F
256+  AC3F 00 00        origcoords   defb 0,0           ; general-use coordinates.
257+  AC41
258+  AC41 00           dispx   defb 0           ; general-use coordinates.
259+  AC42 00           dispy   defb 0
260+  AC43 00 00        sprtmp  defb 0,0           ; sprite temporary address.
261+  AC45 00 00        sprtmp0  defb 0,0           ; sprite temporary address.
262+  AC47
# file closed: screen/sprites.asm
143   AC47                  include "screen\titlescreen.asm"
# file opened: screen/titlescreen.asm
  1+  AC47              titlescreen_preshow:
  2+  AC47 CD F8 AC         call titlescreen_preinit
  3+  AC4A CD 62 B1         call sound_gamestart
  4+  AC4D 06 3C            ld b,60
  5+  AC4F CD 64 81         call utilities_pauseforframes         ; pause for a second
  6+  AC52 C9               ret
  7+  AC53
  8+  AC53              ;
  9+  AC53              ; Draws the title screen
 10+  AC53              ;
 11+  AC53              titlescreen_show:
 12+  AC53 CD E5 AC         call titlescreen_init
 13+  AC56 CD 8E AC         call titlescreen_drawtitle
 14+  AC59 3A 08 C5         ld a,(game_control)
 15+  AC5C FE 00            cp 0
 16+  AC5E CA 66 AC         jp z,titlescreen_show1
 17+  AC61 06 32            ld b,50
 18+  AC63 CD 64 81         call utilities_pauseforframes         ; pause for a second
 19+  AC66              titlescreen_show1:
 20+  AC66 3E FA            ld a,250                              ; wait for 200 frames
 21+  AC68 CD 25 81         call utilities_waitforkey_forframes   ; wait for keypress
 22+  AC6B 7B               ld a,e
 23+  AC6C FE 01            cp 1                                  ; was anything pressed?
 24+  AC6E C8               ret z                                 ; end titlescreen if so
 25+  AC6F
 26+  AC6F CD 05 AD         call titlescreen_alt_init             ; otherwise, draw alt screen
 27+  AC72 CD AA AC         call titlescreen_alt_drawtitle
 28+  AC75 3A 08 C5         ld a,(game_control)
 29+  AC78 FE 00            cp 0
 30+  AC7A CA 82 AC         jp z,titlescreen_show0
 31+  AC7D 06 32            ld b,50
 32+  AC7F CD 64 81         call utilities_pauseforframes         ; pause for a second if joystick
 33+  AC82              titlescreen_show0:
 34+  AC82 3E FA            ld a,250                              ; wait for 200 frames
 35+  AC84 CD 25 81         call utilities_waitforkey_forframes   ; wait for keypress
 36+  AC87 7B               ld a,e
 37+  AC88 FE 01            cp 1                                  ; was anything pressed?
 38+  AC8A C2 53 AC         jp nz,titlescreen_show               ; start again if not
 39+  AC8D C9               ret
 40+  AC8E
 41+  AC8E              ;
 42+  AC8E              ; Draws the iconic logo
 43+  AC8E              ;
 44+  AC8E              titlescreen_drawtitle:
 45+  AC8E 06 67            ld b,103              ; number of points
 46+  AC90 DD 21 12 AD      ld ix,titlescreen_logo_data
 47+  AC94              titlescreen_drawtitle0:
 48+  AC94 C5               push bc
 49+  AC95 DD 4E 00         ld c,(ix)                   ; got horiz
 50+  AC98 DD 23            inc ix
 51+  AC9A DD 46 00         ld b,(ix)                   ; got vert
 52+  AC9D DD 23            inc ix
 53+  AC9F CD 18 AA         call screen_getscreenattradress ; memory in de
 54+  ACA2 13               inc de                      ; slide one to the right, since I'm too lazy to change the data
 55+  ACA3 3E 13            ld a,19
 56+  ACA5 12               ld (de),a
 57+  ACA6 C1               pop bc
 58+  ACA7 10 EB            djnz titlescreen_drawtitle0 ; loop if we're not at the end
 59+  ACA9 C9               ret
 60+  ACAA
 61+  ACAA              ;
 62+  ACAA              ; Draws the alternate title screen
 63+  ACAA              ;
 64+  ACAA              titlescreen_alt_drawtitle:
 65+  ACAA 21 28 82         ld hl,string_alttitlescreen_1
 66+  ACAD CD 30 86         call string_print
 67+  ACB0 21 34 82         ld hl,string_alttitlescreen_2
 68+  ACB3 CD 30 86         call string_print
 69+  ACB6 21 2F 83         ld hl,string_alttitlescreen_3
 70+  ACB9 CD 30 86         call string_print
 71+  ACBC 06 20            ld b,32
 72+  ACBE 3E 43            ld a,67
 73+  ACC0 11 00 58         ld de,22528                         ; top row attrs here
 74+  ACC3 CD A6 A9         call screen_setcolours
 75+  ACC6 06 20            ld b,32
 76+  ACC8 3E 46            ld a,70
 77+  ACCA 11 A0 59         ld de,22528+416                     ; 13th row attrs here
 78+  ACCD CD A6 A9         call screen_setcolours
 79+  ACD0 06 20            ld b,32
 80+  ACD2 3E 43            ld a,67
 81+  ACD4 11 20 5A         ld de,22528+544                         ; 17th row attrs here
 82+  ACD7 CD A6 A9         call screen_setcolours
 83+  ACDA 06 20            ld b,32
 84+  ACDC 3E 42            ld a,66
 85+  ACDE 11 A0 5A         ld de,22528+672                         ; 21st row attrs here
 86+  ACE1 CD A6 A9         call screen_setcolours
 87+  ACE4 C9               ret
 88+  ACE5
 89+  ACE5              ;
 90+  ACE5              ; Initialises the screen
 91+  ACE5              ;
 92+  ACE5              titlescreen_init:
 93+  ACE5              ; We want a black screen.
 94+  ACE5 3E 0B            ld a,11             ; magenta ink (7) on blue paper (0),
 95+  ACE7                                      ; bright (64).
 96+  ACE7 CD 49 81         call utilities_clearscreen
 97+  ACEA 32 8D 5C         ld (23693),a        ; set our screen colours.
 98+  ACED 3E 01            ld a,1              ; 2 is the code for red.
 99+  ACEF D3 FE            out (254),a         ; write to port 254.
100+  ACF1
101+  ACF1 21 13 82         ld hl,string_titlescreen_copyright
102+  ACF4 CD 30 86         call string_print
103+  ACF7
104+  ACF7 C9               ret
105+  ACF8
106+  ACF8              ;
107+  ACF8              ; Initialises the pre-screen
108+  ACF8              ;
109+  ACF8              titlescreen_preinit:
110+  ACF8              ; We want a red screen.
111+  ACF8 3E 10            ld a,16             ; magenta ink (7) on blue paper (0),
112+  ACFA                                      ; bright (64).
113+  ACFA CD 49 81         call utilities_clearscreen
114+  ACFD 32 8D 5C         ld (23693),a        ; set our screen colours.
115+  AD00 3E 02            ld a,2              ; 2 is the code for red.
116+  AD02 D3 FE            out (254),a         ; write to port 254.
117+  AD04 C9               ret
118+  AD05
119+  AD05              ;
120+  AD05              ; Initialises the screen
121+  AD05              ;
122+  AD05              titlescreen_alt_init:
123+  AD05              ; We want a black screen.
124+  AD05 3E 47            ld a,71             ; white ink (7) on black paper (0),
125+  AD07                                      ; bright (64).
126+  AD07 CD 49 81         call utilities_clearscreen
127+  AD0A 32 8D 5C         ld (23693),a        ; set our screen colours.
128+  AD0D 3E 00            ld a,0              ; 2 is the code for red.
129+  AD0F D3 FE            out (254),a         ; write to port 254.
130+  AD11
131+  AD11 C9               ret
132+  AD12
133+  AD12              ;
134+  AD12              ; Horiz, vert
135+  AD12              ;
136+  AD12              titlescreen_logo_data:
137+  AD12 08 00 09 00      defb 8,0,9,0,10,0,12,0,15,0,17,0,18,0,19,0
137+  AD16 0A 00 0C 00
137+  AD1A 0F 00 11 00
137+  AD1E 12 00 13 00
138+  AD22 09 01 0C 01      defb 9,1,12,1,15,1,17,1
138+  AD26 0F 01 11 01
139+  AD2A 09 02 0C 02      defb 9,2,12,2,13,2,14,2,15,2,17,2,18,2,19,2
139+  AD2E 0D 02 0E 02
139+  AD32 0F 02 11 02
139+  AD36 12 02 13 02
140+  AD3A 09 03 0C 03      defb 9,3,12,3,15,3,17,3
140+  AD3E 0F 03 11 03
141+  AD42 09 04 0C 04      defb 9,4,12,4,15,4,17,4,18,4,19,4
141+  AD46 0F 04 11 04
141+  AD4A 12 04 13 04
142+  AD4E 00 06 01 06      defb 0,6,1,6,2,6,3,6,4,6,5,6,6,6,7,6,8,6,9,6,10,6,11,6
142+  AD52 02 06 03 06
142+  AD56 04 06 05 06
142+  AD5A 06 06 07 06
142+  AD5E 08 06 09 06
142+  AD62 0A 06 0B 06
143+  AD66 10 06 11 06      defb 16,6,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6
143+  AD6A 12 06 13 06
143+  AD6E 14 06 15 06
143+  AD72 16 06 17 06
143+  AD76 18 06 19 06
143+  AD7A 1A 06 1B 06
144+  AD7E 02 07 02 08      defb 2,7,2,8,2,9,2,10,2,11,2,12,2,13,2,14,2,15,2,16,2,17,2,18,2,19,2,20,2,21
144+  AD82 02 09 02 0A
144+  AD86 02 0B 02 0C
144+  AD8A 02 0D 02 0E
144+  AD8E 02 0F 02 10
144+  AD92 02 11 02 12
144+  AD96 02 13 02 14
144+  AD9A 02 15
145+  AD9C 19 07 19 08      defb 25,7,25,8,25,9,25,10,25,11,25,12,25,13,25,14,25,15,25,16,25,17,25,18,25,19,25,20,25,21
145+  ADA0 19 09 19 0A
145+  ADA4 19 0B 19 0C
145+  ADA8 19 0D 19 0E
145+  ADAC 19 0F 19 10
145+  ADB0 19 11 19 12
145+  ADB4 19 13 19 14
145+  ADB8 19 15
146+  ADBA 03 0B 04 0B      defb 3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,11,11
146+  ADBE 05 0B 06 0B
146+  ADC2 07 0B 08 0B
146+  ADC6 09 0B 0A 0B
146+  ADCA 0B 0B
147+  ADCC 0B 07 0B 08      defb 11,7,11,8,11,9,11,10
147+  ADD0 0B 09 0B 0A
148+  ADD4 10 0D 10 0F      defb 16,13,16,15,16,16,16,17,16,18,16,19
148+  ADD8 10 10 10 11
148+  ADDC 10 12 10 13
149+  ADE0
# file closed: screen/titlescreen.asm
144   ADE0                  include "screen\lifescreen.asm"
# file opened: screen/lifescreen.asm
  1+  ADE0              ;
  2+  ADE0              ; Draws the life remaining screen
  3+  ADE0              ;
  4+  ADE0              lifescreen_draw:
  5+  ADE0 CD 36 AE         call lifescreen_init
  6+  ADE3
  7+  ADE3 3A 05 C5         ld a,(game_currentplayer)             ; get the current player
  8+  ADE6 C6 30            add 48                                ; add 48 to get char
  9+  ADE8 21 35 84         ld hl,string_lifescreen_player+10
 10+  ADEB 77               ld (hl),a                             ; load this to the string we're about to show
 11+  ADEC
 12+  ADEC 21 2B 84         ld hl,string_lifescreen_player
 13+  ADEF CD 30 86         call string_print
 14+  ADF2
 15+  ADF2 3A FD C5         ld a,(player+9)                       ; get the current player lives
 16+  ADF5 C6 30            add 48                                ; add 48 to get the character
 17+  ADF7 FE 31            cp 49
 18+  ADF9 C2 0C AE         jp nz,lifescreen_draw0
 19+  ADFC 21 45 84         ld hl,string_lifescreen_lastman
 20+  ADFF
 21+  ADFF 06 08            ld b,8
 22+  AE01 3E 0A            ld a,10                                ; set red
 23+  AE03 11 6C 58         ld de,22528+108                        ; attrs here
 24+  AE06 CD A6 A9         call screen_setcolours
 25+  AE09
 26+  AE09 C3 13 AE         jp lifescreen_draw1
 27+  AE0C              lifescreen_draw0:
 28+  AE0C 21 3A 84         ld hl,string_lifescreen_lives+2       ; not last man, so use the normal view
 29+  AE0F 77               ld (hl),a                             ; load this to the string we're about to show
 30+  AE10 21 38 84         ld hl,string_lifescreen_lives
 31+  AE13              lifescreen_draw1:
 32+  AE13 CD 30 86         call string_print
 33+  AE16
 34+  AE16 3E 86            ld a,134
 35+  AE18 11 0B 58         ld de, 22528+11     ; get the colour for the top text
 36+  AE1B 06 0A            ld b,10
 37+  AE1D CD A6 A9         call screen_setcolours
 38+  AE20 3A 08 C5         ld a,(game_control)
 39+  AE23 FE 00            cp 0
 40+  AE25 CA 2D AE         jp z,lifescreen_draw2
 41+  AE28 06 32            ld b,50
 42+  AE2A CD 64 81         call utilities_pauseforframes         ; pause for a second if joystick
 43+  AE2D              lifescreen_draw2:
 44+  AE2D CD 7F B1         call sound_lifestart
 45+  AE30 3E 64            ld a,100                              ; wait for 200 frames
 46+  AE32 CD 25 81         call utilities_waitforkey_forframes   ; wait for keypress
 47+  AE35
 48+  AE35 C9               ret
 49+  AE36
 50+  AE36              ;
 51+  AE36              ; Initialises the screen
 52+  AE36              ;
 53+  AE36              lifescreen_init:
 54+  AE36              ; We want a blue screen.
 55+  AE36                  ;call $0D6B
 56+  AE36 3E 0E            ld a,14             ; yellow ink (6) on blue paper (1),
 57+  AE38                                      ; bright (64).
 58+  AE38 CD 49 81         call utilities_clearscreen
 59+  AE3B 32 8D 5C         ld (23693),a        ; set our screen colours.
 60+  AE3E 3E 01            ld a,1              ; 1 is the code for blue.
 61+  AE40 D3 FE            out (254),a         ; write to port 254.
 62+  AE42                  ;call 3503           ; ROM routine - clears screen, opens chan 2.
 63+  AE42
 64+  AE42 C9               ret
# file closed: screen/lifescreen.asm
145   AE43                  include "screen\gameover.asm"
# file opened: screen/gameover.asm
  1+  AE43              ;
  2+  AE43              ; Draws the game over screen
  3+  AE43              ;
  4+  AE43              gameover_draw:
  5+  AE43 3E 00            ld a,0
  6+  AE45 32 81 AF         ld (gameover_soundplayed),a
  7+  AE48 3E 01            ld a,1
  8+  AE4A 32 05 C5         ld (game_currentplayer),a               ; do the first player first
  9+  AE4D CD 60 C6         call player_init_lifestart              ; get the player config
 10+  AE50 CD A6 AE         call gameover_enterhighscores
 11+  AE53
 12+  AE53 3A 04 C5         ld a,(game_numberplayers)               ; check if we need to do player 2
 13+  AE56 FE 02            cp 2
 14+  AE58 C2 66 AE         jp nz,gameover_draw0
 15+  AE5B 3E 02            ld a,2
 16+  AE5D 32 05 C5         ld (game_currentplayer),a               ; do the second player
 17+  AE60 CD 60 C6         call player_init_lifestart              ; get the player config
 18+  AE63 CD A6 AE         call gameover_enterhighscores
 19+  AE66              gameover_draw0:
 20+  AE66 CD 74 AF         call gameover_init
 21+  AE69
 22+  AE69 21 50 84         ld hl,string_gameoverscreen_gameover
 23+  AE6C CD 30 86         call string_print
 24+  AE6F
 25+  AE6F 21 5C 84         ld hl,string_gameoverscreen_copyright
 26+  AE72 CD 30 86         call string_print
 27+  AE75
 28+  AE75 CD 89 AE         call gameover_commontext
 29+  AE78 CD 82 AF         call gameover_playsound
 30+  AE7B 06 0B            ld b,11
 31+  AE7D 3E 42            ld a,66
 32+  AE7F 11 2B 58         ld de,22528+43                         ; attrs here
 33+  AE82 CD A6 A9         call screen_setcolours
 34+  AE85 CD 10 81         call utilities_waitforkey   ; wait for keypress
 35+  AE88
 36+  AE88 C9               ret
 37+  AE89
 38+  AE89              ;
 39+  AE89              ; Draws text shared by the game over and high score screens
 40+  AE89              ;
 41+  AE89              gameover_commontext:
 42+  AE89 CD 6A A9         call screen_setuptext       ; show scores
 43+  AE8C CD 85 CD         call scores_printscores     ; print the current scores
 44+  AE8F
 45+  AE8F 21 84 84         ld hl,string_gameover_credits
 46+  AE92 CD 30 86         call string_print
 47+  AE95
 48+  AE95 21 70 84         ld hl,string_gameoverscreen_bestscores
 49+  AE98 CD 30 86         call string_print
 50+  AE9B
 51+  AE9B 06 20            ld b,32
 52+  AE9D 3E 45            ld a,69
 53+  AE9F 11 C0 5A         ld de,22528+704                         ; attrs here
 54+  AEA2 CD A6 A9         call screen_setcolours
 55+  AEA5
 56+  AEA5 C9               ret
 57+  AEA6
 58+  AEA6              ;
 59+  AEA6              ; If required, enter highscore
 60+  AEA6              ;
 61+  AEA6              gameover_enterhighscores:
 62+  AEA6                  ; check if we need to enter initial
 63+  AEA6 CD F6 CD         call scores_processhighscores
 64+  AEA9
 65+  AEA9 3A F4 CD         ld a,(scores_highscoretmp)
 66+  AEAC FE 00            cp 0
 67+  AEAE C8               ret z
 68+  AEAF CD 0A AF         call gameover_enterhighscores_init
 69+  AEB2 CD 82 AF         call gameover_playsound
 70+  AEB5                  ; Set the flash
 71+  AEB5 3A F4 CD         ld a,(scores_highscoretmp)              ; scoretmp has the memory offset of the start of the number
 72+  AEB8 1E 05            ld e,5
 73+  AEBA 93               sub e                                   ; get the score position back to coords
 74+  AEBB 11 00 00         ld de,0
 75+  AEBE 5F               ld e,a                                  ; load into de
 76+  AEBF 21 0A CD         ld hl,scores_table
 77+  AEC2 19               add hl,de                               ; get the memory location
 78+  AEC3 4E 23 46 2B      ld bc,(hl)                              ; get the coords
 79+  AEC7 CD 18 AA         call screen_getscreenattradress         ; get the memory location of the cell attr into de
 80+  AECA 1A               ld a,(de)                               ; get the current attr
 81+  AECB F6 80            or 128                                  ; make it flash
 82+  AECD 12               ld (de),a
 83+  AECE 13               inc de
 84+  AECF 12               ld (de),a
 85+  AED0 13               inc de
 86+  AED1 12               ld (de),a                               ; make all three flash
 87+  AED2 3A F4 CD         ld a,(scores_highscoretmp)              ; get the score back again
 88+  AED5 3D               dec a
 89+  AED6 3D               dec a
 90+  AED7 3D               dec a                                   ; get high score location back to position of name
 91+  AED8 16 00            ld d,0
 92+  AEDA 5F               ld e,a
 93+  AEDB 21 0A CD         ld hl,scores_table
 94+  AEDE 19               add hl,de                               ; load memory into hl
 95+  AEDF 08               ex af,af'
 96+  AEE0 06 0F            ld b,15
 97+  AEE2 CD 64 81         call utilities_pauseforframes           ; pause for a little bit
 98+  AEE5 06 03            ld b,3                                  ; collect three chars
 99+  AEE7              gameover_enterhighscores2:
100+  AEE7 C5               push bc
101+  AEE8 E5               push hl
102+  AEE9              gameover_enterhighscores3:
103+  AEE9 CD 68 81         call utilities_readkey               ; get key into a
104+  AEEC FE 41            cp 65
105+  AEEE DA E9 AE         jp c,gameover_enterhighscores3
106+  AEF1 FE 5B            cp 91
107+  AEF3 D2 E9 AE         jp nc,gameover_enterhighscores3      ; if not a letter, get another
108+  AEF6 E1               pop hl
109+  AEF7 77               ld (hl),a
110+  AEF8 23               inc hl
111+  AEF9 E5               push hl
112+  AEFA CD F8 B1         call sound_gemcollected
113+  AEFD CD E1 CD         call scores_showtable
114+  AF00 E1               pop hl
115+  AF01 06 0F            ld b,15
116+  AF03 CD 64 81         call utilities_pauseforframes
117+  AF06 C1               pop bc
118+  AF07 10 DE            djnz gameover_enterhighscores2
119+  AF09 C9               ret
120+  AF0A
121+  AF0A              ;
122+  AF0A              ; Displays the screen text for high score entry
123+  AF0A              ;
124+  AF0A              gameover_enterhighscores_init:
125+  AF0A
126+  AF0A CD 74 AF         call gameover_init
127+  AF0D CD 89 AE         call gameover_commontext
128+  AF10
129+  AF10 21 90 84         ld hl,string_highscore_congratulations
130+  AF13 CD 30 86         call string_print
131+  AF16
132+  AF16 3A 05 C5         ld a,(game_currentplayer)
133+  AF19 FE 01            cp 1
134+  AF1B 21 A2 84         ld hl,string_highscore_player1
135+  AF1E C3 24 AF         jp gameover_enterhighscores_init1
136+  AF21              gameover_enterhighscores_init0:
137+  AF21 21 AD 84         ld hl,string_highscore_player2
138+  AF24              gameover_enterhighscores_init1:
139+  AF24 CD 30 86         call string_print
140+  AF27 06 60            ld b,96
141+  AF29 3E 43            ld a,67
142+  AF2B 11 A0 58         ld de,22528+160                         ; attrs here
143+  AF2E CD A6 A9         call screen_setcolours
144+  AF31
145+  AF31 21 B8 84         ld hl,string_highscore_youhaveearned
146+  AF34 CD 30 86         call string_print
147+  AF37
148+  AF37 3A F4 CD         ld a,(scores_highscoretmp)
149+  AF3A FE 05            cp 5
150+  AF3C CA 4A AF         jp z, gameover_enterhighscores_init2    ; first place
151+  AF3F FE 11            cp 17
152+  AF41 CA 50 AF         jp z, gameover_enterhighscores_init3    ; 2nd place
153+  AF44 21 F4 84         ld hl,string_highscore_place3           ; 3rd place
154+  AF47 C3 56 AF         jp gameover_enterhighscores_init4
155+  AF4A              gameover_enterhighscores_init2
156+  AF4A 21 CA 84         ld hl,string_highscore_place1
157+  AF4D C3 56 AF         jp gameover_enterhighscores_init4
158+  AF50              gameover_enterhighscores_init3
159+  AF50 21 DF 84         ld hl,string_highscore_place2
160+  AF53 C3 56 AF         jp gameover_enterhighscores_init4
161+  AF56              gameover_enterhighscores_init4
162+  AF56 CD 30 86         call string_print
163+  AF59
164+  AF59 06 60            ld b,96
165+  AF5B 3E 42            ld a,66
166+  AF5D 11 40 59         ld de,22528+320                         ; attrs here
167+  AF60 CD A6 A9         call screen_setcolours
168+  AF63
169+  AF63 21 09 85         ld hl,string_highscore_pleaseenter
170+  AF66 CD 30 86         call string_print
171+  AF69
172+  AF69 06 60            ld b,96
173+  AF6B 3E 46            ld a,70
174+  AF6D 11 E0 59         ld de,22528+480                         ; attrs here
175+  AF70 CD A6 A9         call screen_setcolours
176+  AF73 C9               ret
177+  AF74
178+  AF74              ;
179+  AF74              ; Initialises the screen
180+  AF74              ;
181+  AF74              gameover_init:
182+  AF74              ; We want a black screen.
183+  AF74 3E 47            ld a,71             ; white ink (7) on black paper (0),
184+  AF76                                      ; bright (64).
185+  AF76 CD 49 81         call utilities_clearscreen
186+  AF79 32 8D 5C         ld (23693),a        ; set our screen colours.
187+  AF7C 3E 00            ld a,0              ; 2 is the code for red.
188+  AF7E D3 FE            out (254),a         ; write to port 254.
189+  AF80 C9               ret
190+  AF81
191+  AF81              gameover_soundplayed:
192+  AF81 00               defb 0
193+  AF82
194+  AF82              ;
195+  AF82              ; Plays the sound if it hasn't already been played
196+  AF82              ;
197+  AF82              gameover_playsound:
198+  AF82 3A 81 AF         ld a,(gameover_soundplayed)
199+  AF85 FE 01            cp 1
200+  AF87 C8               ret z
201+  AF88 CD AC B1         call sound_gameover
202+  AF8B 3E 01            ld a,1
203+  AF8D 32 81 AF         ld (gameover_soundplayed),a
204+  AF90 C9               ret
# file closed: screen/gameover.asm
146   AF91                  include "screen\endlevel.asm"
# file opened: screen/endlevel.asm
  1+  AF91              ;
  2+  AF91              ; Draws the level transition screen
  3+  AF91              ;
  4+  AF91              endlevel_draw:
  5+  AF91 CD 92 B0         call endlevel_init
  6+  AF94 CD 7B B0         call endlevel_commontext
  7+  AF97
  8+  AF97 21 90 84         ld hl,string_highscore_congratulations
  9+  AF9A CD 30 86         call string_print
 10+  AF9D
 11+  AF9D 3A 05 C5         ld a,(game_currentplayer)
 12+  AFA0 FE 01            cp 1
 13+  AFA2 21 A2 84         ld hl,string_highscore_player1
 14+  AFA5 C3 AB AF         jp endlevel_init1
 15+  AFA8              endlevel_init0:
 16+  AFA8 21 AD 84         ld hl,string_highscore_player2
 17+  AFAB              endlevel_init1:
 18+  AFAB CD 30 86         call string_print
 19+  AFAE
 20+  AFAE 21 26 85         ld hl,string_endlevel_youhaveearned
 21+  AFB1 CD 30 86         call string_print
 22+  AFB4
 23+  AFB4 CD 1A B0         call endlevel_workoutbonus
 24+  AFB7 D5               push de
 25+  AFB8 08               ex af,af'                               ; store the a value for later
 26+  AFB9 CD 30 86         call string_print
 27+  AFBC D1               pop de
 28+  AFBD 62 6B            ld hl,de                                ; get the points text into de
 29+  AFBF CD 30 86         call string_print
 30+  AFC2
 31+  AFC2 21 91 85         ld hl, string_endlevel_anothergo
 32+  AFC5 CD 30 86         call string_print
 33+  AFC8
 34+  AFC8 06 20            ld b,32
 35+  AFCA 3E 23            ld a,35
 36+  AFCC 11 60 59         ld de,22528+352                         ; attrs here
 37+  AFCF CD A6 A9         call screen_setcolours
 38+  AFD2
 39+  AFD2 06 20            ld b,32
 40+  AFD4 3E 25            ld a,37
 41+  AFD6 11 A0 59         ld de,22528+416                         ; attrs here
 42+  AFD9 CD A6 A9         call screen_setcolours
 43+  AFDC
 44+  AFDC 06 20            ld b,32
 45+  AFDE 3E 23            ld a,35
 46+  AFE0 11 E0 59         ld de,22528+480                         ; attrs here
 47+  AFE3 CD A6 A9         call screen_setcolours
 48+  AFE6
 49+  AFE6 06 20            ld b,32
 50+  AFE8 3E 22            ld a,34
 51+  AFEA 11 40 5A         ld de,22528+576                         ; attrs here
 52+  AFED CD A6 A9         call screen_setcolours
 53+  AFF0
 54+  AFF0 08               ex af,af'                               ; get back a value with bonus type
 55+  AFF1 06 14            ld b,20
 56+  AFF3 CD 64 81         call utilities_pauseforframes
 57+  AFF6
 58+  AFF6 47               ld b,a                      ; put the bonus count in b
 59+  AFF7              endlevel_init2:
 60+  AFF7 C5               push bc
 61+  AFF8 06 01            ld b,1
 62+  AFFA CD 2E CD         call scores_addthousands
 63+  AFFD CD C9 B1         call sound_scoretick
 64+  B000 CD BF C6         call player_recordcurrentstate
 65+  B003 CD 45 CD         call scores_printscore     ; print the current scores
 66+  B006 06 0A            ld b,10
 67+  B008 CD 64 81         call utilities_pauseforframes
 68+  B00B C1               pop bc
 69+  B00C 10 E9            djnz endlevel_init2
 70+  B00E
 71+  B00E CD A8 C5         call game_increasedifficulty ; move the difficulty up a level
 72+  B011 CD BF C6         call player_recordcurrentstate
 73+  B014
 74+  B014 3E 64            ld a,100                              ; wait for 200 frames
 75+  B016 CD 25 81         call utilities_waitforkey_forframes   ; wait for keypress
 76+  B019
 77+  B019 C9               ret
 78+  B01A
 79+  B01A              ;
 80+  B01A              ; Works out the bonus
 81+  B01A              ; Outputs:
 82+  B01A              ; a = 15 (all seven)
 83+  B01A              ; a = 10 (3 large or 4 small)
 84+  B01A              ; a = 5 (1 large diamond)
 85+  B01A              ; hl - pointer to bonus text
 86+  B01A              ; de - pointer to points text
 87+  B01A              ;
 88+  B01A              endlevel_workoutbonus:
 89+  B01A 21 D1 B8         ld hl,level_diamonds+2     ; location of state of first diamond
 90+  B01D 06 03            ld b,3                      ; number to check
 91+  B01F 16 00            ld d,0                      ; zero diamond count
 92+  B021              endlevel_workoutbonus0:
 93+  B021 7E               ld a,(hl)                   ; get state
 94+  B022 FE 01            cp 1
 95+  B024 C2 28 B0         jp nz,endlevel_workoutbonus1 ; if not, move on
 96+  B027 14               inc d                       ; increment diamond count
 97+  B028              endlevel_workoutbonus1:
 98+  B028 23               inc hl
 99+  B029 23               inc hl
100+  B02A 23               inc hl
101+  B02B 23               inc hl
102+  B02C 23               inc hl                      ; get to next state
103+  B02D 10 F2            djnz endlevel_workoutbonus0
104+  B02F
105+  B02F 21 E1 B8         ld hl,level_gems+2     ; location of state of first gem
106+  B032 06 04            ld b,4                      ; number to check
107+  B034 1E 00            ld e,0                      ; zero gem count
108+  B036              endlevel_workoutbonus2:
109+  B036 7E               ld a,(hl)                   ; get state
110+  B037 FE 01            cp 1
111+  B039 C2 3D B0         jp nz,endlevel_workoutbonus3 ; if not, move on
112+  B03C 1C               inc e                       ; increment diamond count
113+  B03D              endlevel_workoutbonus3:
114+  B03D 23               inc hl
115+  B03E 23               inc hl
116+  B03F 23               inc hl
117+  B040 23               inc hl
118+  B041 23               inc hl                     ; get to next state
119+  B042 10 F2            djnz endlevel_workoutbonus2
120+  B044
121+  B044 7A               ld a,d
122+  B045 83               add e
123+  B046 FE 07            cp 7                        ; check for max bonus
124+  B048 C2 54 B0         jp nz,endlevel_workoutbonus4 ;
125+  B04B 3E 0F            ld a,15
126+  B04D 21 56 85         ld hl, string_endlevel_bonus3
127+  B050 11 82 85         ld de, string_endlevel_points3
128+  B053 C9               ret                         ; return with bonus of 15
129+  B054              endlevel_workoutbonus4:
130+  B054 7A               ld a,d                      ; check for for diamonds
131+  B055 FE 03            cp 3
132+  B057 C2 63 B0         jp nz,endlevel_workoutbonus5
133+  B05A 3E 0A            ld a,10
134+  B05C 21 47 85         ld hl, string_endlevel_bonus2
135+  B05F 11 73 85         ld de, string_endlevel_points2
136+  B062 C9               ret                         ; return with bonus of ten
137+  B063              endlevel_workoutbonus5:
138+  B063 7B               ld a,e                      ; check for four gems
139+  B064 FE 04            cp 4
140+  B066 C2 72 B0         jp nz,endlevel_workoutbonus6
141+  B069 3E 0A            ld a,10
142+  B06B 21 47 85         ld hl, string_endlevel_bonus2
143+  B06E 11 73 85         ld de, string_endlevel_points2
144+  B071 C9               ret                         ; return with bonus of 10
145+  B072              endlevel_workoutbonus6:
146+  B072 3E 05            ld a,5                      ; otherwise, bonus is 5
147+  B074 21 38 85         ld hl, string_endlevel_bonus1
148+  B077 11 65 85         ld de, string_endlevel_points1
149+  B07A C9               ret
150+  B07B
151+  B07B              ;
152+  B07B              ; Draws text shared by the game over and high score screens
153+  B07B              ;
154+  B07B              endlevel_commontext:
155+  B07B CD 6A A9         call screen_setuptext       ; show scores
156+  B07E CD 85 CD         call scores_printscores     ; print the current scores
157+  B081
158+  B081 21 70 84         ld hl,string_gameoverscreen_bestscores
159+  B084 CD 30 86         call string_print
160+  B087
161+  B087 06 20            ld b,32
162+  B089 3E 45            ld a,69
163+  B08B 11 C0 5A         ld de,22528+704                         ; attrs here
164+  B08E CD A6 A9         call screen_setcolours
165+  B091
166+  B091 C9               ret
167+  B092
168+  B092              ;
169+  B092              ; Initialises the screen
170+  B092              ;
171+  B092              endlevel_init:
172+  B092              ; We want a green screen.
173+  B092 3E 21            ld a,33             ; white ink (7) on black paper (0),
174+  B094                                      ; bright (64).
175+  B094 CD 49 81         call utilities_clearscreen
176+  B097 32 8D 5C         ld (23693),a        ; set our screen colours.
177+  B09A 3E 00            ld a,0              ; 2 is the code for red.
178+  B09C D3 FE            out (254),a         ; write to port 254.
179+  B09E C9               ret
# file closed: screen/endlevel.asm
147   B09F                  include "screen\options.asm"
# file opened: screen/options.asm
  1+  B09F              ;
  2+  B09F              ; Show the options screen
  3+  B09F              ;
  4+  B09F              options_show:
  5+  B09F CD 40 B1         call options_init
  6+  B0A2
  7+  B0A2 21 AC 85         ld hl,string_options_title
  8+  B0A5 CD 30 86         call string_print
  9+  B0A8 21 B6 85         ld hl,string_options_1player
 10+  B0AB CD 30 86         call string_print
 11+  B0AE 21 C6 85         ld hl,string_options_2player
 12+  B0B1 CD 30 86         call string_print
 13+  B0B4 21 D6 85         ld hl,string_options_keyboard
 14+  B0B7 CD 30 86         call string_print
 15+  B0BA 21 E9 85         ld hl,string_options_joystick
 16+  B0BD CD 30 86         call string_print
 17+  B0C0 21 F7 85         ld hl,string_options_start
 18+  B0C3 CD 30 86         call string_print
 19+  B0C6 21 02 86         ld hl,string_options_vanity
 20+  B0C9 CD 30 86         call string_print
 21+  B0CC
 22+  B0CC 3A 04 C5         ld a,(game_numberplayers)
 23+  B0CF FE 01            cp 1
 24+  B0D1 C2 DA B0         jp nz,options_show0
 25+  B0D4 11 C9 58         ld de,22528+201                         ; top row attrs here
 26+  B0D7 C3 DD B0         jp options_show1
 27+  B0DA              options_show0:
 28+  B0DA 11 E9 58         ld de,22528+233                         ; top row attrs here
 29+  B0DD              options_show1:
 30+  B0DD 06 10            ld b,16
 31+  B0DF 3E C7            ld a,199
 32+  B0E1 CD A6 A9         call screen_setcolours                  ; highlight current player
 33+  B0E4
 34+  B0E4 3A 08 C5         ld a,(game_control)
 35+  B0E7 FE 00            cp 0
 36+  B0E9 C2 F2 B0         jp nz,options_show6
 37+  B0EC 11 09 59         ld de,22528+265                         ; top row attrs here
 38+  B0EF C3 F5 B0         jp options_show7
 39+  B0F2              options_show6:
 40+  B0F2 11 29 59         ld de,22528+297                         ; top row attrs here
 41+  B0F5              options_show7:
 42+  B0F5 06 10            ld b,16
 43+  B0F7 3E C7            ld a,199
 44+  B0F9 CD A6 A9         call screen_setcolours                  ; highlight current control
 45+  B0FC              options_show8:
 46+  B0FC CD 68 81         call utilities_readkey
 47+  B0FF FE 31            cp 49                                   ; was 1 pressed
 48+  B101 C2 0C B1         jp nz,options_show2
 49+  B104 21 04 C5         ld hl,game_numberplayers
 50+  B107 36 01            ld (hl),1
 51+  B109 C3 3A B1         jp options_show9
 52+  B10C              options_show2:
 53+  B10C FE 32            cp 50                                   ; was 2 pressed
 54+  B10E C2 19 B1         jp nz,options_show3
 55+  B111 21 04 C5         ld hl,game_numberplayers
 56+  B114 36 02            ld (hl),2
 57+  B116 C3 3A B1         jp options_show9
 58+  B119              options_show3:
 59+  B119 FE 33            cp 51                                   ; was 3 pressed
 60+  B11B C2 26 B1         jp nz,options_show4
 61+  B11E 21 08 C5         ld hl,game_control
 62+  B121 36 00            ld (hl),0
 63+  B123 C3 3A B1         jp options_show9
 64+  B126              options_show4:
 65+  B126 FE 34            cp 52                                   ; was 4 pressed
 66+  B128 C2 33 B1         jp nz,options_show5
 67+  B12B 21 08 C5         ld hl,game_control
 68+  B12E 36 01            ld (hl),1
 69+  B130 C3 3A B1         jp options_show9
 70+  B133              options_show5:
 71+  B133 FE 35            cp 53                                   ; was 5 pressed
 72+  B135 C8               ret z                                   ; exit if so
 73+  B136 C3 FC B0         jp options_show8                         ; otherwise, jump to top
 74+  B139 C9               ret
 75+  B13A              options_show9:
 76+  B13A CD F8 B1         call sound_gemcollected
 77+  B13D C3 9F B0         jp options_show
 78+  B140
 79+  B140              ;
 80+  B140              ; Initialise the options screen
 81+  B140              ;
 82+  B140              options_init:
 83+  B140 3E 47            ld a,71             ; white ink (7) on black paper (0),
 84+  B142                                      ; bright (64).
 85+  B142 CD 49 81         call utilities_clearscreen
 86+  B145 32 8D 5C         ld (23693),a        ; set our screen colours.
 87+  B148 3E 00            ld a,0              ; 2 is the code for red.
 88+  B14A D3 FE            out (254),a         ; write to port 254.
 89+  B14C
 90+  B14C C9               ret
 91+  B14D C9               ret
# file closed: screen/options.asm
148   B14E
149   B14E                  include "sound\sound.asm"
# file opened: sound/sound.asm
  1+  B14E
  2+  B14E
  3+  B14E              ;
  4+  B14E              ; Plays a note
  5+  B14E              ; Inputs:
  6+  B14E              ; d - border
  7+  B14E              ; e - pitch
  8+  B14E              ; bc - duration
  9+  B14E              sound_play:
 10+  B14E 7B               ld a,e
 11+  B14F 32 59 B1         ld (sound_play2+1),a
 12+  B152 7A           	ld a,d
 13+  B153              sound_play0:
 14+  B153 D3 FE            out (254),a
 15+  B155 1D               dec e
 16+  B156 20 04            jr nz,sound_play1
 17+  B158              sound_play2:
 18+  B158 1E 00            ld e,0
 19+  B15A EE 18            xor 24
 20+  B15C              sound_play1:
 21+  B15C 10 F5            djnz sound_play0
 22+  B15E 0D               dec c
 23+  B15F 20 F2            jr nz,sound_play0
 24+  B161 C9               ret
 25+  B162
 26+  B162              sound_gamestart:
 27+  B162 F3               di
 28+  B163 06 03            ld b,3
 29+  B165              sound_gamestart0:
 30+  B165 C5               push bc
 31+  B166 1E 36            ld e,54
 32+  B168 01 4B 00         ld bc,75
 33+  B16B 16 02            ld d,2
 34+  B16D CD 4E B1         call sound_play
 35+  B170 1E 4C            ld e,76
 36+  B172 01 4B 00         ld bc,75
 37+  B175 16 02            ld d,2
 38+  B177 CD 4E B1         call sound_play
 39+  B17A C1               pop bc
 40+  B17B 10 E8            djnz sound_gamestart0
 41+  B17D FB               ei
 42+  B17E C9               ret
 43+  B17F
 44+  B17F              sound_lifestart:
 45+  B17F F3               di
 46+  B180 06 03            ld b,3
 47+  B182              sound_lifestart0:
 48+  B182 C5               push bc
 49+  B183 1E 2D            ld e,45
 50+  B185 01 20 00         ld bc,32
 51+  B188 16 01            ld d,1
 52+  B18A CD 4E B1         call sound_play
 53+  B18D 1E 41            ld e,65
 54+  B18F 01 20 00         ld bc,32
 55+  B192 16 01            ld d,1
 56+  B194 CD 4E B1         call sound_play
 57+  B197 1E 2D            ld e,45
 58+  B199 01 20 00         ld bc,32
 59+  B19C CD 4E B1         call sound_play
 60+  B19F 1E 41            ld e,65
 61+  B1A1 01 20 00         ld bc,32
 62+  B1A4 CD 4E B1         call sound_play
 63+  B1A7 C1               pop bc
 64+  B1A8 10 D8            djnz sound_lifestart0
 65+  B1AA FB               ei
 66+  B1AB C9               ret
 67+  B1AC
 68+  B1AC              sound_gameover:
 69+  B1AC F3               di
 70+  B1AD 06 0A            ld b,10
 71+  B1AF 1E 28            ld e,40
 72+  B1B1              sound_gameover0:
 73+  B1B1 C5               push bc
 74+  B1B2 D5               push de
 75+  B1B3 F5               push af
 76+  B1B4 01 20 00         ld bc,32
 77+  B1B7 16 00            ld d,0
 78+  B1B9 CD 4E B1         call sound_play
 79+  B1BC F1               pop af
 80+  B1BD D1               pop de
 81+  B1BE 3E 0A            ld a,10
 82+  B1C0 83               add e
 83+  B1C1 5F               ld e,a
 84+  B1C2 C6 04            add 4
 85+  B1C4 C1               pop bc
 86+  B1C5 10 EA            djnz sound_gameover0
 87+  B1C7 FB               ei
 88+  B1C8 C9               ret
 89+  B1C9
 90+  B1C9              sound_scoretick:
 91+  B1C9 F3               di
 92+  B1CA 1E 23            ld e,35
 93+  B1CC 01 18 00         ld bc,24
 94+  B1CF 16 00            ld d,0
 95+  B1D1 CD 4E B1         call sound_play
 96+  B1D4 FB               ei
 97+  B1D5 C9               ret
 98+  B1D6
 99+  B1D6              sound_tankalarm:
100+  B1D6 F3               di
101+  B1D7 1E 19            ld e,25
102+  B1D9 01 18 00         ld bc,24
103+  B1DC 16 00            ld d,0
104+  B1DE CD 4E B1         call sound_play
105+  B1E1 FB               ei
106+  B1E2 C9               ret
107+  B1E3
108+  B1E3              sound_laser:
109+  B1E3 16 10        	ld d,16		            ;speaker = bit 4
110+  B1E5 1E 00        	ld e,0		            ;distance between speaker move counter
111+  B1E7 06 80        	ld b,128	            ;overall length counter
112+  B1E9              sound_laser0:
113+  B1E9 7A               ld a,d
114+  B1EA E6 F8        	and 248		            ;keep border colour the same
115+  B1EC D3 FE        	out (254),a	            ;move the speaker in or out depending on bit 4
116+  B1EE 2F           	cpl		                ;toggle, so we alternative between speaker in and out to make sound
117+  B1EF 57           	ld d,a		            ;store it
118+  B1F0 4B           	ld c,e		            ;now a pause
119+  B1F1              sound_laser1:
120+  B1F1 0D               dec c
121+  B1F2 20 FD        	jr nz,sound_laser1
122+  B1F4 1D           	dec e		            ;change to inc e to reverse the sound, or remove to make it a note
123+  B1F5 10 F2        	djnz sound_laser0	;repeat B=255 times
124+  B1F7 C9           	ret
125+  B1F8
126+  B1F8              sound_gemcollected:
127+  B1F8 16 10        	ld d,16		            ;speaker = bit 4
128+  B1FA 1E 00        	ld e,0		            ;distance between speaker move counter
129+  B1FC 06 80        	ld b,128	            ;overall length counter
130+  B1FE              sound_gemcollected0:
131+  B1FE 7A               ld a,d
132+  B1FF E6 F8        	and 248		            ;keep border colour the same
133+  B201 D3 FE        	out (254),a	            ;move the speaker in or out depending on bit 4
134+  B203 2F           	cpl		                ;toggle, so we alternative between speaker in and out to make sound
135+  B204 57           	ld d,a		            ;store it
136+  B205 4B           	ld c,e		            ;now a pause
137+  B206              sound_gemcollected1:
138+  B206 0D               dec c
139+  B207 20 FD        	jr nz,sound_gemcollected1
140+  B209 1C           	inc e		            ;change to inc e to reverse the sound, or remove to make it a note
141+  B20A 10 F2        	djnz sound_gemcollected0	;repeat B=255 times
142+  B20C C9           	ret
143+  B20D
144+  B20D              sound_pitchbend:
145+  B20D 21 F4 01         ld hl,500 ; starting pitch.
146+  B210 06 FA            ld b,250 ; length of pitch bend.
147+  B212              sound_pitchbend0:
148+  B212 C5                push bc
149+  B213 E5               push hl ; store pitch.
150+  B214 11 01 00         ld de,1 ; very short duration.
151+  B217 CD B5 03         call 949 ; ROM beeper routine.
152+  B21A E1               pop hl ; restore pitch.
153+  B21B 23               inc hl ; pitch going up.
154+  B21C C1               pop bc
155+  B21D 10 F3            djnz sound_pitchbend0 ; repeat.
156+  B21F C9               ret
157+  B220
158+  B220              sound_pitchbenddown:
159+  B220 21 EE 02         ld hl,750 ; starting pitch.
160+  B223 06 FA            ld b,250 ; length of pitch bend.
161+  B225              sound_pitchbenddown0:
162+  B225 C5               push bc
163+  B226 E5               push hl ; store pitch.
164+  B227 11 01 00         ld de,1 ; very short duration.
165+  B22A CD B5 03         call 949 ; ROM beeper routine.
166+  B22D E1               pop hl ; restore pitch.
167+  B22E 2B               dec hl ; pitch going down.
168+  B22F C1               pop bc
169+  B230 10 F3            djnz sound_pitchbenddown0 ; repeat.
170+  B232 C9               ret
171+  B233
172+  B233              sound_rockfell:
173+  B233 08               ex af,af'
174+  B234 1E 32            ld e,50 ; repeat 250 times.
175+  B236 21 00 00         ld hl,0 ; start pointer in ROM.
176+  B239              sound_rockfell2
177+  B239 D5               push de
178+  B23A 06 20            ld b,32 ; length of step.
179+  B23C C5           sound_rockfell0 push bc
180+  B23D 7E               ld a,(hl) ; next "random" number.
181+  B23E 23               inc hl ; pointer.
182+  B23F E6 F8            and 248 ; we want a black border.
183+  B241 D3 FE            out (254),a ; write to speaker.
184+  B243 7B               ld a,e ; as e gets smaller...
185+  B244 2F               cpl ; ...we increase the delay.
186+  B245 3D           sound_rockfell1 dec a ; decrement loop counter.
187+  B246 20 FD            jr nz,sound_rockfell1 ; delay loop.
188+  B248 C1               pop bc
189+  B249 10 F1            djnz sound_rockfell0 ; next step.
190+  B24B D1               pop de
191+  B24C 7B               ld a,e
192+  B24D D6 18            sub 24 ; size of step.
193+  B24F FE 1E            cp 30 ; end of range.
194+  B251 CA 62 B2         jp z,sound_rockfell5
195+  B254 DA 62 B2         jp c, sound_rockfell5
196+  B257 5F               ld e,a
197+  B258 2F               cpl
198+  B259 06 28        sound_rockfell3 ld b,40 ; silent period.
199+  B25B 10 FE        sound_rockfell4 djnz sound_rockfell4
200+  B25D 3D               dec a
201+  B25E 20 F9            jr nz,sound_rockfell3
202+  B260 18 D7            jr sound_rockfell2
203+  B262              sound_rockfell5
204+  B262 08               ex af,af'
205+  B263 C9               ret
206+  B264
207+  B264              sound_tankshoot:
208+  B264 08               ex af,af'
209+  B265 1E 32            ld e,50 ; repeat 250 times.
210+  B267 21 00 00         ld hl,0 ; start pointer in ROM.
211+  B26A              sound_tankshoot2
212+  B26A D5               push de
213+  B26B 06 10            ld b,16 ; length of step.
214+  B26D C5           sound_tankshoot0 push bc
215+  B26E 7E               ld a,(hl) ; next "random" number.
216+  B26F 23               inc hl ; pointer.
217+  B270 E6 F8            and 248 ; we want a black border.
218+  B272 D3 FE            out (254),a ; write to speaker.
219+  B274 7B               ld a,e ; as e gets smaller...
220+  B275 2F               cpl ; ...we increase the delay.
221+  B276 3D           sound_tankshoot1 dec a ; decrement loop counter.
222+  B277 20 FD            jr nz,sound_tankshoot1 ; delay loop.
223+  B279 C1               pop bc
224+  B27A 10 F1            djnz sound_tankshoot0 ; next step.
225+  B27C D1               pop de
226+  B27D 7B               ld a,e
227+  B27E D6 18            sub 24 ; size of step.
228+  B280 FE 1E            cp 30 ; end of range.
229+  B282 CA 93 B2         jp z,sound_tankshoot5
230+  B285 DA 93 B2         jp c, sound_tankshoot5
231+  B288 5F               ld e,a
232+  B289 2F               cpl
233+  B28A 06 28        sound_tankshoot3 ld b,40 ; silent period.
234+  B28C 10 FE        sound_tankshoot4 djnz sound_tankshoot4
235+  B28E 3D               dec a
236+  B28F 20 F9            jr nz,sound_tankshoot3
237+  B291 18 D7            jr sound_tankshoot2
238+  B293              sound_tankshoot5
239+  B293 08               ex af,af'
240+  B294 C9               ret
241+  B295
242+  B295              ; Call this every time you want to initialise a sound effect
243+  B295              ; A = Variable 1
244+  B295              ; B = Variable 2
245+  B295              ; C = Duration of overall sound effect
246+  B295              ; D = Duration of each step of the sound effect
247+  B295              ;
248+  B295              soundfx_a_init:
249+  B295 32 BC B2         ld (soundfx_a_v2+1),a
250+  B298 78               ld a,b
251+  B299 32 C5 B2         ld (soundfx_a_v3+1),a
252+  B29C 79               ld a,c
253+  B29D 32 AA B2         ld (soundfx_a_main+1),a
254+  B2A0 7A               ld a,d
255+  B2A1 32 B1 B2         ld (soundfx_a_v1+1),a
256+  B2A4 AF               xor a
257+  B2A5 32 CE B2         ld (soundfx_a_v4),a
258+  B2A8 C9               ret
259+  B2A9
260+  B2A9              ; Call this during your main loop
261+  B2A9              ; It will play one step of the sound effect each pass
262+  B2A9              ; until the complete sound effect has finished
263+  B2A9              ;
264+  B2A9              soundfx_a_main:
265+  B2A9 3E 00            ld a,0
266+  B2AB 3D               dec a
267+  B2AC C8               ret z
268+  B2AD 32 AA B2         ld (soundfx_a_main+1),a
269+  B2B0              soundfx_a_v1:
270+  B2B0 06 00            ld b,0
271+  B2B2 21 CE B2         ld hl,soundfx_a_v4
272+  B2B5              soundfx_a_l1:
273+  B2B5 48               ld c,b
274+  B2B6 3E 08            ld a,%00001000
275+  B2B8 D3 FE            out (254),a
276+  B2BA 7E               ld a,(hl)
277+  B2BB              soundfx_a_v2:
278+  B2BB EE 00            xor 0
279+  B2BD 47               ld b,a
280+  B2BE 10 FE            djnz $
281+  B2C0 AF               xor a
282+  B2C1 D3 FE            out (254),a
283+  B2C3 7E               ld a,(hl)
284+  B2C4              soundfx_a_v3:
285+  B2C4 EE 00            xor 0
286+  B2C6 47               ld b,a
287+  B2C7 10 FE            djnz $
288+  B2C9 35               dec (hl)
289+  B2CA 41               ld b,c
290+  B2CB 10 E8            djnz soundfx_a_l1
291+  B2CD C9               ret
292+  B2CE
293+  B2CE              soundfx_a_v4:
294+  B2CE 00               defb 0
# file closed: sound/sound.asm
150   B2CF
151   B2CF                  include "leveldata\level.asm"
# file opened: leveldata/level.asm
  1+  B2CF              ; ###############################################################
  2+  B2CF              ; Data for level 1
  3+  B2CF              ; ###############################################################
  4+  B2CF              level_layout:
  5+  B2CF
  6+  B2CF                  ;defb 09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09,09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09
  7+  B2CF
  8+  B2CF 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,05,05,02,01,01,01,03,05,05,05,05,05,05,05,05,05,05,05,00,00
  8+  B2D3 05 05 05 05
  8+  B2D7 05 05 05 05
  8+  B2DB 05 05 02 01
  8+  B2DF 01 01 03 05
  8+  B2E3 05 05 05 05
  8+  B2E7 05 05 05 05
  8+  B2EB 05 05 00 00
  9+  B2EF 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,03,05,05,05,05,05,05,05,05,05,00,00
  9+  B2F3 05 05 05 05
  9+  B2F7 05 05 05 05
  9+  B2FB 02 01 01 01
  9+  B2FF 01 01 01 01
  9+  B303 03 05 05 05
  9+  B307 05 05 05 05
  9+  B30B 05 05 00 00
 10+  B30F 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,01,01,01,01,03,05,13,13,13,13,13,13,00,00
 10+  B313 05 05 05 05
 10+  B317 05 05 02 01
 10+  B31B 01 01 01 01
 10+  B31F 01 01 01 01
 10+  B323 01 01 03 05
 10+  B327 0D 0D 0D 0D
 10+  B32B 0D 0D 00 00
 11+  B32F 00 00 01 01      defb 00,00,01,01,01,01,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,03,05,05,05,05,05,05,00,00
 11+  B333 01 01 00 01
 11+  B337 01 01 01 01
 11+  B33B 01 01 01 01
 11+  B33F 01 01 01 01
 11+  B343 01 01 01 03
 11+  B347 05 05 05 05
 11+  B34B 05 05 00 00
 12+  B34F 00 00 01 01      defb 00,00,01,01,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,01,00,00
 12+  B353 04 04 04 04
 12+  B357 04 04 01 01
 12+  B35B 01 01 01 01
 12+  B35F 01 01 01 01
 12+  B363 01 01 01 01
 12+  B367 01 01 01 01
 12+  B36B 00 01 00 00
 13+  B36F 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,01,00,00
 13+  B373 04 04 04 04
 13+  B377 04 04 04 04
 13+  B37B 01 01 01 01
 13+  B37F 01 01 01 01
 13+  B383 01 01 01 01
 13+  B387 00 00 00 00
 13+  B38B 00 01 00 00
 14+  B38F 00 00 01 04      defb 00,00,01,04,04,01,01,01,01,01,04,04,04,04,01,01,01,01,01,01,01,00,00,00,00,01,01,01,01,01,00,00
 14+  B393 04 01 01 01
 14+  B397 01 01 04 04
 14+  B39B 04 04 01 01
 14+  B39F 01 01 01 01
 14+  B3A3 01 00 00 00
 14+  B3A7 00 01 01 01
 14+  B3AB 01 01 00 00
 15+  B3AF 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,01,04,04,04,04,04,04,04,04,00,00,00,00,04,04,04,04,04,04,04,01,00,00
 15+  B3B3 04 04 04 04
 15+  B3B7 04 01 04 04
 15+  B3BB 04 04 04 04
 15+  B3BF 04 04 00 00
 15+  B3C3 00 00 04 04
 15+  B3C7 04 04 04 04
 15+  B3CB 04 01 00 00
 16+  B3CF 00 00 01 01      defb 00,00,01,01,01,04,01,01,01,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 16+  B3D3 01 04 01 01
 16+  B3D7 01 01 04 04
 16+  B3DB 04 04 04 04
 16+  B3DF 04 04 00 04
 16+  B3E3 04 04 04 04
 16+  B3E7 04 04 04 04
 16+  B3EB 04 01 00 00
 17+  B3EF 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 17+  B3F3 00 00 00 00
 17+  B3F7 00 04 04 04
 17+  B3FB 04 04 04 04
 17+  B3FF 04 04 00 04
 17+  B403 04 04 04 04
 17+  B407 04 04 04 04
 17+  B40B 04 01 00 00
 18+  B40F 00 00 01 15      defb 00,00,01,21,21,21,21,21,21,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 18+  B413 15 15 15 15
 18+  B417 15 01 04 04
 18+  B41B 04 04 04 04
 18+  B41F 04 04 00 04
 18+  B423 04 04 04 04
 18+  B427 04 04 04 04
 18+  B42B 04 01 00 00
 19+  B42F 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,00,00,00,01,00,00
 19+  B433 00 00 00 00
 19+  B437 00 01 04 04
 19+  B43B 04 04 04 04
 19+  B43F 04 04 00 04
 19+  B443 04 04 04 04
 19+  B447 04 00 00 00
 19+  B44B 00 01 00 00
 20+  B44F 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 20+  B453 00 00 00 00
 20+  B457 00 01 04 04
 20+  B45B 04 04 04 04
 20+  B45F 04 04 00 04
 20+  B463 04 04 04 04
 20+  B467 04 00 04 04
 20+  B46B 00 01 00 00
 21+  B46F 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 21+  B473 06 06 06 06
 21+  B477 06 01 04 04
 21+  B47B 04 04 04 04
 21+  B47F 04 04 00 04
 21+  B483 04 04 04 04
 21+  B487 04 00 04 04
 21+  B48B 00 01 00 00
 22+  B48F 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,04,00,01,00,00
 22+  B493 1A 1A 1A 1A
 22+  B497 1A 01 04 00
 22+  B49B 00 00 00 00
 22+  B49F 00 00 00 00
 22+  B4A3 00 00 00 00
 22+  B4A7 00 00 04 04
 22+  B4AB 00 01 00 00
 23+  B4AF 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 23+  B4B3 1A 1A 1A 1A
 23+  B4B7 1A 01 04 00
 23+  B4BB 04 04 04 04
 23+  B4BF 04 04 00 04
 23+  B4C3 04 04 00 04
 23+  B4C7 04 04 04 04
 23+  B4CB 00 01 00 00
 24+  B4CF 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 24+  B4D3 1A 1A 1A 1A
 24+  B4D7 1A 01 04 00
 24+  B4DB 04 04 04 04
 24+  B4DF 04 04 00 04
 24+  B4E3 04 04 00 04
 24+  B4E7 04 04 04 04
 24+  B4EB 00 01 00 00
 25+  B4EF 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 25+  B4F3 01 01 01 01
 25+  B4F7 01 01 04 00
 25+  B4FB 04 04 04 04
 25+  B4FF 04 04 00 04
 25+  B503 04 04 00 04
 25+  B507 04 04 04 04
 25+  B50B 00 01 00 00
 26+  B50F 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,00,00,00,00,04,04,04,01,00,00
 26+  B513 04 04 04 04
 26+  B517 04 04 04 00
 26+  B51B 04 04 04 04
 26+  B51F 04 04 00 04
 26+  B523 04 04 00 00
 26+  B527 00 00 04 04
 26+  B52B 04 01 00 00
 27+  B52F 00 00 01 04      defb 00,00,01,04,04,04,00,00,00,00,00,00,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 27+  B533 04 04 00 00
 27+  B537 00 00 00 00
 27+  B53B 04 04 04 04
 27+  B53F 04 04 00 04
 27+  B543 04 04 04 04
 27+  B547 04 00 04 04
 27+  B54B 04 01 00 00
 28+  B54F 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 28+  B553 04 04 00 04
 28+  B557 04 04 04 04
 28+  B55B 04 04 04 04
 28+  B55F 04 04 00 04
 28+  B563 04 04 04 04
 28+  B567 04 00 04 04
 28+  B56B 04 01 00 00
 29+  B56F 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,04,00,04,04,04,01,00,00
 29+  B573 04 04 00 04
 29+  B577 04 04 01 01
 29+  B57B 01 01 01 01
 29+  B57F 01 01 01 01
 29+  B583 01 01 01 01
 29+  B587 04 00 04 04
 29+  B58B 04 01 00 00
 30+  B58F 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 30+  B593 04 04 00 04
 30+  B597 04 04 01 00
 30+  B59B 00 00 00 00
 30+  B59F 00 00 00 00
 30+  B5A3 00 00 00 01
 30+  B5A7 04 00 04 04
 30+  B5AB 04 01 00 00
 31+  B5AF 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 31+  B5B3 04 04 00 04
 31+  B5B7 04 04 01 00
 31+  B5BB 00 00 00 00
 31+  B5BF 00 00 00 00
 31+  B5C3 00 00 00 01
 31+  B5C7 04 00 04 04
 31+  B5CB 04 01 00 00
 32+  B5CF 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 32+  B5D3 04 04 00 04
 32+  B5D7 04 04 01 00
 32+  B5DB 00 00 00 00
 32+  B5DF 00 00 00 00
 32+  B5E3 00 00 00 01
 32+  B5E7 04 00 04 04
 32+  B5EB 04 01 00 00
 33+  B5EF 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,00,00,00,00,00,00,00,00,00,00,00,00,04,04,04,04,04,04,01,00,00
 33+  B5F3 04 04 00 04
 33+  B5F7 04 04 04 00
 33+  B5FB 00 00 00 00
 33+  B5FF 00 00 00 00
 33+  B603 00 00 00 04
 33+  B607 04 04 04 04
 33+  B60B 04 01 00 00
 34+  B60F 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,04,04,04,04,01,00,00
 34+  B613 04 04 04 04
 34+  B617 04 04 01 00
 34+  B61B 00 00 00 00
 34+  B61F 00 00 00 00
 34+  B623 00 00 00 01
 34+  B627 04 04 04 04
 34+  B62B 04 01 00 00
 35+  B62F 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,01,00,00,00,00,01,00,00,00,01,04,04,04,04,04,01,00,00
 35+  B633 04 04 04 04
 35+  B637 04 04 01 00
 35+  B63B 00 00 01 00
 35+  B63F 00 00 00 01
 35+  B643 00 00 00 01
 35+  B647 04 04 04 04
 35+  B64B 04 01 00 00
 36+  B64F 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00
 36+  B653 01 01 01 01
 36+  B657 01 01 01 01
 36+  B65B 01 01 01 01
 36+  B65F 01 01 01 01
 36+  B663 01 01 01 01
 36+  B667 01 01 01 01
 36+  B66B 01 01 00 00
 37+  B66F
 38+  B66F              ; ###############################################################
 39+  B66F              ; Object data: horiz, vert, state, memh, meml
 40+  B66F              ; ###############################################################
 41+  B66F              level_rocks:
 42+  B66F 09 04 00 00      defb 9,4,0,0,0
 42+  B673 00
 43+  B674 0C 07 00 00      defb 12,7,0,0,0
 43+  B678 00
 44+  B679 10 07 00 00      defb 16,7,0,0,0
 44+  B67D 00
 45+  B67E 0B 08 00 00      defb 11,8,0,0,0
 45+  B682 00
 46+  B683 0A 0A 00 00      defb 10,10,0,0,0
 46+  B687 00
 47+  B688 0C 0A 00 00      defb 12,10,0,0,0
 47+  B68C 00
 48+  B68D 0D 09 00 00      defb 13,9,0,0,0
 48+  B691 00
 49+  B692 0E 08 00 00      defb 14,8,0,0,0
 49+  B696 00
 50+  B697 0F 0B 00 00      defb 15,11,0,0,0
 50+  B69B 00
 51+  B69C 0B 0C 00 00      defb 11,12,0,0,0
 51+  B6A0 00
 52+  B6A1 11 0C 00 00      defb 17,12,0,0,0
 52+  B6A5 00
 53+  B6A6 13 08 00 00      defb 19,8,0,0,0
 53+  B6AA 00
 54+  B6AB 16 09 00 00      defb 22,9,0,0,0
 54+  B6AF 00
 55+  B6B0 13 0A 00 00      defb 19,10,0,0,0
 55+  B6B4 00
 56+  B6B5 15 0A 00 00      defb 21,10,0,0,0
 56+  B6B9 00
 57+  B6BA 15 0C 00 00      defb 21,12,0,0,0
 57+  B6BE 00
 58+  B6BF 16 0C 00 00      defb 22,12,0,0,0
 58+  B6C3 00
 59+  B6C4 18 0A 00 00      defb 24,10,0,0,0
 59+  B6C8 00
 60+  B6C9 19 09 00 00      defb 25,9,0,0,0
 60+  B6CD 00
 61+  B6CE 1C 09 00 00      defb 28,9,0,0,0
 61+  B6D2 00
 62+  B6D3 1B 0C 00 00      defb 27,12,0,0,0
 62+  B6D7 00
 63+  B6D8 1A 0D 00 00      defb 26,13,0,0,0
 63+  B6DC 00
 64+  B6DD 19 0E 00 00      defb 25,14,0,0,0
 64+  B6E1 00
 65+  B6E2 19 10 00 00      defb 25,16,0,0,0
 65+  B6E6 00
 66+  B6E7 1A 11 00 00      defb 26,17,0,0,0
 66+  B6EB 00
 67+  B6EC 1B 11 00 00      defb 27,17,0,0,0
 67+  B6F0 00
 68+  B6F1 1C 12 00 00      defb 28,18,0,0,0
 68+  B6F5 00
 69+  B6F6 1A 13 00 00      defb 26,19,0,0,0
 69+  B6FA 00
 70+  B6FB 1B 15 00 00      defb 27,21,0,0,0
 70+  B6FF 00
 71+  B700 1A 17 00 00      defb 26,23,0,0,0
 71+  B704 00
 72+  B705 1B 18 00 00      defb 27,24,0,0,0
 72+  B709 00
 73+  B70A 19 18 00 00      defb 25,24,0,0,0
 73+  B70E 00
 74+  B70F 18 17 00 00      defb 24,23,0,0,0
 74+  B713 00
 75+  B714 13 14 00 00      defb 19,20,0,0,0
 75+  B718 00
 76+  B719 14 12 00 00      defb 20,18,0,0,0
 76+  B71D 00
 77+  B71E 14 10 00 00      defb 20,16,0,0,0
 77+  B722 00
 78+  B723 15 10 00 00      defb 21,16,0,0,0
 78+  B727 00
 79+  B728 16 12 00 00      defb 22,18,0,0,0
 79+  B72C 00
 80+  B72D 11 14 00 00      defb 17,20,0,0,0
 80+  B731 00
 81+  B732 0D 11 00 00      defb 13,17,0,0,0
 81+  B736 00
 82+  B737 0C 13 00 00      defb 12,19,0,0,0
 82+  B73B 00
 83+  B73C 0B 13 00 00      defb 11,19,0,0,0
 83+  B740 00
 84+  B741 0A 11 00 00      defb 10,17,0,0,0
 84+  B745 00
 85+  B746 05 12 00 00      defb 5,18,0,0,0
 85+  B74A 00
 86+  B74B 07 16 00 00      defb 7,22,0,0,0
 86+  B74F 00
 87+  B750 09 16 00 00      defb 9,22,0,0,0
 87+  B754 00
 88+  B755 07 18 00 00      defb 7,24,0,0,0
 88+  B759 00
 89+  B75A 05 18 00 00      defb 5,24,0,0,0
 89+  B75E 00
 90+  B75F 06 19 00 00      defb 6,25,0,0,0
 90+  B763 00
 91+  B764 08 19 00 00      defb 8,25,0,0,0
 91+  B768 00
 92+  B769 04 17 00 00      defb 4,23,0,0,0
 92+  B76D 00
 93+  B76E FF               defb 255
 94+  B76F
 95+  B76F              level_rocks_alt:
 96+  B76F 09 04 00 00      defb 9,4,0,0,0
 96+  B773 00
 97+  B774 0C 07 00 00      defb 12,7,0,0,0
 97+  B778 00
 98+  B779 0B 07 00 00      defb 11,7,0,0,0
 98+  B77D 00
 99+  B77E 0A 08 00 00      defb 10,8,0,0,0
 99+  B782 00
100+  B783 10 07 00 00      defb 16,7,0,0,0
100+  B787 00
101+  B788 0E 08 00 00      defb 14,8,0,0,0
101+  B78C 00
102+  B78D 0D 09 00 00      defb 13,9,0,0,0
102+  B791 00
103+  B792 0C 0A 00 00      defb 12,10,0,0,0
103+  B796 00
104+  B797 0A 0B 00 00      defb 10,11,0,0,0
104+  B79B 00
105+  B79C 0B 0C 00 00      defb 11,12,0,0,0
105+  B7A0 00
106+  B7A1 0F 0B 00 00      defb 15,11,0,0,0
106+  B7A5 00
107+  B7A6 11 0C 00 00      defb 17,12,0,0,0
107+  B7AA 00
108+  B7AB 15 0B 00 00      defb 21,11,0,0,0
108+  B7AF 00
109+  B7B0 16 0C 00 00      defb 22,12,0,0,0
109+  B7B4 00
110+  B7B5 19 09 00 00      defb 25,9,0,0,0
110+  B7B9 00
111+  B7BA 1C 09 00 00      defb 28,9,0,0,0
111+  B7BE 00
112+  B7BF 1B 0C 00 00      defb 27,12,0,0,0
112+  B7C3 00
113+  B7C4 1B 0E 00 00      defb 27,14,0,0,0
113+  B7C8 00
114+  B7C9 1A 0F 00 00      defb 26,15,0,0,0
114+  B7CD 00
115+  B7CE 1B 10 00 00      defb 27,16,0,0,0
115+  B7D2 00
116+  B7D3 1C 12 00 00      defb 28,18,0,0,0
116+  B7D7 00
117+  B7D8 1A 13 00 00      defb 26,19,0,0,0
117+  B7DC 00
118+  B7DD 1A 15 00 00      defb 26,21,0,0,0
118+  B7E1 00
119+  B7E2 1B 17 00 00      defb 27,23,0,0,0
119+  B7E6 00
120+  B7E7 1A 17 00 00      defb 26,23,0,0,0
120+  B7EB 00
121+  B7EC 19 18 00 00      defb 25,24,0,0,0
121+  B7F0 00
122+  B7F1 18 17 00 00      defb 24,23,0,0,0
122+  B7F5 00
123+  B7F6 17 10 00 00      defb 23,16,0,0,0
123+  B7FA 00
124+  B7FB 15 10 00 00      defb 21,16,0,0,0
124+  B7FF 00
125+  B800 14 12 00 00      defb 20,18,0,0,0
125+  B804 00
126+  B805 13 14 00 00      defb 19,20,0,0,0
126+  B809 00
127+  B80A 10 13 00 00      defb 16,19,0,0,0
127+  B80E 00
128+  B80F 0D 14 00 00      defb 13,20,0,0,0
128+  B813 00
129+  B814 0E 11 00 00      defb 14,17,0,0,0
129+  B818 00
130+  B819 0C 12 00 00      defb 12,18,0,0,0
130+  B81D 00
131+  B81E 0A 11 00 00      defb 10,17,0,0,0
131+  B822 00
132+  B823 05 12 00 00      defb 5,18,0,0,0
132+  B827 00
133+  B828 09 14 00 00      defb 9,20,0,0,0
133+  B82C 00
134+  B82D 08 15 00 00      defb 8,21,0,0,0
134+  B831 00
135+  B832 07 16 00 00      defb 7,22,0,0,0
135+  B836 00
136+  B837 08 17 00 00      defb 8,23,0,0,0
136+  B83B 00
137+  B83C 07 18 00 00      defb 7,24,0,0,0
137+  B840 00
138+  B841 08 1A 00 00      defb 8,26,0,0,0
138+  B845 00
139+  B846 06 19 00 00      defb 6,25,0,0,0
139+  B84A 00
140+  B84B 05 18 00 00      defb 5,24,0,0,0
140+  B84F 00
141+  B850 04 17 00 00      defb 4,23,0,0,0
141+  B854 00
142+  B855 FF               defb 255
143+  B856
144+  B856              level_missiles:
145+  B856 0B 17 00 00      defb 11,23,0,0,0
145+  B85A 00
146+  B85B 0B 16 00 00      defb 11,22,0,0,0
146+  B85F 00
147+  B860 0C 17 00 00      defb 12,23,0,0,0
147+  B864 00
148+  B865 0C 16 00 00      defb 12,22,0,0,0
148+  B869 00
149+  B86A 0D 17 00 00      defb 13,23,0,0,0
149+  B86E 00
150+  B86F 0D 16 00 00      defb 13,22,0,0,0
150+  B873 00
151+  B874 0E 17 00 00      defb 14,23,0,0,0
151+  B878 00
152+  B879 0E 16 00 00      defb 14,22,0,0,0
152+  B87D 00
153+  B87E 0F 17 00 00      defb 15,23,0,0,0
153+  B882 00
154+  B883 0F 16 00 00      defb 15,22,0,0,0
154+  B887 00
155+  B888 10 17 00 00      defb 16,23,0,0,0
155+  B88C 00
156+  B88D 10 16 00 00      defb 16,22,0,0,0
156+  B891 00
157+  B892 11 17 00 00      defb 17,23,0,0,0
157+  B896 00
158+  B897 11 16 00 00      defb 17,22,0,0,0
158+  B89B 00
159+  B89C 12 17 00 00      defb 18,23,0,0,0
159+  B8A0 00
160+  B8A1 12 16 00 00      defb 18,22,0,0,0
160+  B8A5 00
161+  B8A6 13 17 00 00      defb 19,23,0,0,0
161+  B8AA 00
162+  B8AB 13 16 00 00      defb 19,22,0,0,0
162+  B8AF 00
163+  B8B0 14 17 00 00      defb 20,23,0,0,0
163+  B8B4 00
164+  B8B5 14 16 00 00      defb 20,22,0,0,0
164+  B8B9 00
165+  B8BA 15 17 00 00      defb 21,23,0,0,0
165+  B8BE 00
166+  B8BF 15 16 00 00      defb 21,22,0,0,0
166+  B8C3 00
167+  B8C4 16 17 00 00      defb 22,23,0,0,0
167+  B8C8 00
168+  B8C9 16 16 00 00      defb 22,22,0,0,0
168+  B8CD 00
169+  B8CE FF               defb 255
170+  B8CF
171+  B8CF              ;
172+  B8CF              ; Diamonds: x,y,state,mem1+mem2
173+  B8CF              ;
174+  B8CF              level_diamonds:
175+  B8CF 0C 1B 00 00      defb 12,27,0,0,0
175+  B8D3 00
176+  B8D4 10 1B 00 00      defb 16,27,0,0,0
176+  B8D8 00
177+  B8D9 15 1B 00 00      defb 21,27,0,0,0
177+  B8DD 00
178+  B8DE FF               defb 255
179+  B8DF
180+  B8DF              level_gems:
181+  B8DF 12 14 00 00      defb 18,20,0,0,0
181+  B8E3 00
182+  B8E4 06 18 00 00      defb 6,24,0,0,0
182+  B8E8 00
183+  B8E9 19 17 00 00      defb 25,23,0,0,0
183+  B8ED 00
184+  B8EE 1C 11 00 00      defb 28,17,0,0,0
184+  B8F2 00
185+  B8F3 FF               defb 255
186+  B8F4              ;
187+  B8F4              ; Score area colours
188+  B8F4              ;
189+  B8F4              score_colours:
190+  B8F4 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,67,67,67,67,67,67,67,67,66,71,71,71,71,71,71,71,71,71,71,71
190+  B8F8 47 47 47 47
190+  B8FC 47 47 47 42
190+  B900 43 43 43 43
190+  B904 43 43 43 43
190+  B908 42 47 47 47
190+  B90C 47 47 47 47
190+  B910 47 47 47 47
191+  B914 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71
191+  B918 47 47 47 47
191+  B91C 47 47 47 46
191+  B920 46 46 46 46
191+  B924 46 46 46 46
191+  B928 46 47 47 47
191+  B92C 47 47 47 47
191+  B930 47 47 47 47
192+  B934
193+  B934              high_score_colours:
194+  B934 00 00 00 42      defb  0, 0, 0,66,66,66,71,71,71,71,71,71,67,67,67,71,71,71,71,71,71,70,70,70,71,71,71,71,71,71,0,0
194+  B938 42 42 47 47
194+  B93C 47 47 47 47
194+  B940 43 43 43 47
194+  B944 47 47 47 47
194+  B948 47 46 46 46
194+  B94C 47 47 47 47
194+  B950 47 47 00 00
# file closed: leveldata/level.asm
152   B954                  include "graphics\font.asm"
# file opened: graphics/font.asm
  1+  B954              font:
  2+  B954 00 00 00...  	defs 256
  3+  BA54              	; end 1
  4+  BA54 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; space
  4+  BA58 00 00 00 00
  5+  BA5C 18 18 18 18  	defb	  24, 24, 24, 24, 24,  0, 24, 0 ;!
  5+  BA60 18 00 18 00
  6+  BA64 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; "
  6+  BA68 00 00 00 00
  7+  BA6C 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; #
  7+  BA70 00 00 00 00
  8+  BA74 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; $
  8+  BA78 00 00 00 00
  9+  BA7C 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; %
  9+  BA80 00 00 00 00
 10+  BA84 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; &
 10+  BA88 00 00 00 00
 11+  BA8C 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; '
 11+  BA90 00 00 00 00
 12+  BA94 0C 18 30 30  	defb	  12, 24, 48, 48, 48, 24, 12, 0; (
 12+  BA98 30 18 0C 00
 13+  BA9C 30 18 0C 0C  	defb	  48, 24, 12, 12, 12, 24, 48,  0 ; )
 13+  BAA0 0C 18 30 00
 14+  BAA4 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; *
 14+  BAA8 00 00 00 00
 15+  BAAC 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; +
 15+  BAB0 00 00 00 00
 16+  BAB4 00 00 00 00  	defb	  0,  0,  0,  0,  0,  32, 96,  0 ; ,
 16+  BAB8 00 20 60 00
 17+  BABC 00 00 00 3C  	defb	  0,  0,  0, 60,  0,  0,  0,  0 ; -
 17+  BAC0 00 00 00 00
 18+  BAC4 00 00 00 00  	defb	  0,  0,  0,  0,  0,  96,96,  0 ; .
 18+  BAC8 00 60 60 00
 19+  BACC 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; /
 19+  BAD0 00 00 00 00
 20+  BAD4 1C 26 63 63  	defb	 28, 38, 99, 99, 99, 50, 28,  0 ; 0
 20+  BAD8 63 32 1C 00
 21+  BADC 0C 1C 0C 0C  	defb	   12, 28, 12, 12, 12, 12, 63,0 ; 1
 21+  BAE0 0C 0C 3F 00
 22+  BAE4 3E 63 07 1E  	defb	  62, 99,  7, 30, 60, 96,127, 0 ; 2
 22+  BAE8 3C 60 7F 00
 23+  BAEC 3F 06 0C 1E  	defb	  63,  6, 12, 30,  3, 51, 30, 0 ; 3
 23+  BAF0 03 33 1E 00
 24+  BAF4 0E 1E 36 66  	defb	  14, 30, 54,102,127,  6,  6, 0 ; 4
 24+  BAF8 7F 06 06 00
 25+  BAFC 7E 40 7E 03  	defb	 126, 64,126,  3,  3, 99, 62, 0 ; 5
 25+  BB00 03 63 3E 00
 26+  BB04 1E 30 60 7E  	defb	 30, 48, 96,126, 99, 99, 62,  0 ; 6
 26+  BB08 63 63 3E 00
 27+  BB0C 7F 63 06 0C  	defb	  127, 99,  6, 12, 24, 24, 24,0 ; 7
 27+  BB10 18 18 18 00
 28+  BB14 3C 62 72 3C  	defb	  60, 98,114, 60, 79, 67,62,0   ; 8
 28+  BB18 4F 43 3E 00
 29+  BB1C 3E 63 63 3F  	defb	  62, 99, 99, 63,  3,  6, 60, 0 ; 9
 29+  BB20 03 06 3C 00
 30+  BB24 00 00 18 18  	defb	  0,  0, 24, 24,  0,  24,24,  0 ; :
 30+  BB28 00 18 18 00
 31+  BB2C 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ;
 31+  BB30 00 00 00 00
 32+  BB34 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; <
 32+  BB38 00 00 00 00
 33+  BB3C 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; =
 33+  BB40 00 00 00 00
 34+  BB44 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; >
 34+  BB48 00 00 00 00
 35+  BB4C 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ?
 35+  BB50 00 00 00 00
 36+  BB54              	; end 2
 37+  BB54 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; @
 37+  BB58 00 00 00 00
 38+  BB5C 1C 36 63 63  	defb	  28, 54, 99, 99,127, 99, 99, 0 ; A
 38+  BB60 7F 63 63 00
 39+  BB64 7E 63 63 7E  	defb	  126, 99, 99,126, 99, 99,126,0 ; B
 39+  BB68 63 63 7E 00
 40+  BB6C 1E 33 60 60  	defb	  30, 51, 96, 96, 96, 51, 30, 0 ; C
 40+  BB70 60 33 1E 00
 41+  BB74 7C 66 63 63  	defb	  124,102, 99, 99, 99,102,124,0 ; D
 41+  BB78 63 66 7C 00
 42+  BB7C 7F 60 60 7E  	defb	  127, 96, 96,126, 96, 96,127,0 ; E
 42+  BB80 60 60 7F 00
 43+  BB84 7F 60 60 7E  	defb	  127, 96, 96,126, 96, 96, 96,0 ; F
 43+  BB88 60 60 60 00
 44+  BB8C 1F 30 60 67  	defb	  31, 48, 96,103, 99, 51, 31, 0 ; G
 44+  BB90 63 33 1F 00
 45+  BB94 63 63 63 7F  	defb	  99, 99, 99,127, 99, 99, 99, 0 ; H
 45+  BB98 63 63 63 00
 46+  BB9C 3F 0C 0C 0C  	defb	  63, 12, 12, 12, 12, 12, 63, 0 ; I
 46+  BBA0 0C 0C 3F 00
 47+  BBA4 03 03 03 03  	defb	  3,  3,  3,  3,  3, 99, 62,  0 ; J
 47+  BBA8 03 63 3E 00
 48+  BBAC 63 66 6C 78  	defb	  99,102,108,120,124,110,103, 0 ; K
 48+  BBB0 7C 6E 67 00
 49+  BBB4 30 30 30 30  	defb	  48, 48, 48, 48, 48, 48, 63, 0 ; L
 49+  BBB8 30 30 3F 00
 50+  BBBC 63 77 7F 7F  	defb	  99,119,127,127,107, 99, 99, 0 ; M
 50+  BBC0 6B 63 63 00
 51+  BBC4 63 73 7B 7F  	defb	  99,115,123,127,111,103, 99, 0 ; N
 51+  BBC8 6F 67 63 00
 52+  BBCC 3E 63 63 63  	defb	  62, 99, 99, 99, 99, 99, 62, 0 ; O
 52+  BBD0 63 63 3E 00
 53+  BBD4 7E 61 61 61  	defb	  126, 97, 97, 97,126, 96, 96,0 ; P
 53+  BBD8 7E 60 60 00
 54+  BBDC 3E 63 63 63  	defb	  62, 99, 99, 99,111,102, 61, 0 ; Q
 54+  BBE0 6F 66 3D 00
 55+  BBE4 7E 63 63 67  	defb	  126, 99, 99,103,124,110,103,0 ; R
 55+  BBE8 7C 6E 67 00
 56+  BBEC 3C 66 60 3E  	defb	  60,102, 96, 62,  3, 99, 62, 0 ; S
 56+  BBF0 03 63 3E 00
 57+  BBF4 7E 18 18 18  	defb	  126, 24, 24, 24, 24, 24, 24,0 ; T
 57+  BBF8 18 18 18 00
 58+  BBFC 63 63 63 63  	defb	  99, 99, 99, 99, 99, 99, 62, 0 ; U
 58+  BC00 63 63 3E 00
 59+  BC04 63 63 63 77  	defb	  99, 99, 99,119, 62, 28,  8, 0 ; V
 59+  BC08 3E 1C 08 00
 60+  BC0C 63 63 6B 7F  	defb	  99, 99,107,127,127, 54, 34, 0 ; W
 60+  BC10 7F 36 22 00
 61+  BC14 63 77 3E 1C  	defb	  99,119, 62, 28, 62,119, 99, 0 ; X
 61+  BC18 3E 77 63 00
 62+  BC1C 33 33 12 1E  	defb	  51, 51, 18, 30, 12, 12, 12, 0 ; Y
 62+  BC20 0C 0C 0C 00
 63+  BC24 7F 07 0E 1C  	defb	  127,  7, 14, 28, 56,112,127,0 ; Z
 63+  BC28 38 70 7F 00
 64+  BC2C 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; [
 64+  BC30 00 00 00 00
 65+  BC34 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; \
 65+  BC38 00 00 00 00
 66+  BC3C 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ]
 66+  BC40 00 00 00 00
 67+  BC44 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ^
 67+  BC48 00 00 00 00
 68+  BC4C 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; _
 68+  BC50 00 00 00 00
 69+  BC54              	; end 3
 70+  BC54 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; 
 70+  BC58 00 00 00 00
 71+  BC5C 1C 36 63 63  	defb	  28, 54, 99, 99,127, 99, 99, 0 ; A
 71+  BC60 7F 63 63 00
 72+  BC64 7E 63 63 7E  	defb	  126, 99, 99,126, 99, 99,126,0 ; B
 72+  BC68 63 63 7E 00
 73+  BC6C 1E 33 60 60  	defb	  30, 51, 96, 96, 96, 51, 30, 0 ; C
 73+  BC70 60 33 1E 00
 74+  BC74 7C 66 63 63  	defb	  124,102, 99, 99, 99,102,124,0 ; D
 74+  BC78 63 66 7C 00
 75+  BC7C 7F 60 60 7E  	defb	  127, 96, 96,126, 96, 96,127,0 ; E
 75+  BC80 60 60 7F 00
 76+  BC84 7F 60 60 7E  	defb	  127, 96, 96,126, 96, 96, 96,0 ; F
 76+  BC88 60 60 60 00
 77+  BC8C 1F 30 60 67  	defb	  31, 48, 96,103, 99, 51, 31, 0 ; G
 77+  BC90 63 33 1F 00
 78+  BC94 63 63 63 7F  	defb	  99, 99, 99,127, 99, 99, 99, 0 ; H
 78+  BC98 63 63 63 00
 79+  BC9C 3F 0C 0C 0C  	defb	  63, 12, 12, 12, 12, 12, 63, 0 ; I
 79+  BCA0 0C 0C 3F 00
 80+  BCA4 03 03 03 03  	defb	  3,  3,  3,  3,  3, 99, 62,  0 ; J
 80+  BCA8 03 63 3E 00
 81+  BCAC 63 66 6C 78  	defb	  99,102,108,120,124,110,103, 0 ; K
 81+  BCB0 7C 6E 67 00
 82+  BCB4 30 30 30 30  	defb	  48, 48, 48, 48, 48, 48, 63, 0 ; L
 82+  BCB8 30 30 3F 00
 83+  BCBC 63 77 7F 7F  	defb	  99,119,127,127,107, 99, 99, 0 ; M
 83+  BCC0 6B 63 63 00
 84+  BCC4 63 73 7B 7F  	defb	  99,115,123,127,111,103, 99, 0 ; N
 84+  BCC8 6F 67 63 00
 85+  BCCC 3E 63 63 63  	defb	  62, 99, 99, 99, 99, 99, 62, 0 ; O
 85+  BCD0 63 63 3E 00
 86+  BCD4 7E 61 61 61  	defb	  126, 97, 97, 97,126, 96, 96,0 ; P
 86+  BCD8 7E 60 60 00
 87+  BCDC 3E 63 63 63  	defb	  62, 99, 99, 99,111,102, 61, 0 ; Q
 87+  BCE0 6F 66 3D 00
 88+  BCE4 7E 63 63 67  	defb	  126, 99, 99,103,124,110,103,0 ; R
 88+  BCE8 7C 6E 67 00
 89+  BCEC 3C 66 60 3E  	defb	  60,102, 96, 62,  3, 99, 62, 0 ; S
 89+  BCF0 03 63 3E 00
 90+  BCF4 7E 18 18 18  	defb	  126, 24, 24, 24, 24, 24, 24,0 ; T
 90+  BCF8 18 18 18 00
 91+  BCFC 63 63 63 63  	defb	  99, 99, 99, 99, 99, 99, 62, 0 ; U
 91+  BD00 63 63 3E 00
 92+  BD04 63 63 63 77  	defb	  99, 99, 99,119, 62, 28,  8, 0 ; V
 92+  BD08 3E 1C 08 00
 93+  BD0C 63 63 6B 7F  	defb	  99, 99,107,127,127, 54, 34, 0 ; W
 93+  BD10 7F 36 22 00
 94+  BD14 63 77 3E 1C  	defb	  99,119, 62, 28, 62,119, 99, 0 ; X
 94+  BD18 3E 77 63 00
 95+  BD1C 33 33 12 1E  	defb	  51, 51, 18, 30, 12, 12, 12, 0 ; Y
 95+  BD20 0C 0C 0C 00
 96+  BD24 7F 07 0E 1C  	defb	  127,  7, 14, 28, 56,112,127,0 ; Z
 96+  BD28 38 70 7F 00
 97+  BD2C 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0
 97+  BD30 00 00 00 00
 98+  BD34 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0
 98+  BD38 00 00 00 00
 99+  BD3C 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0
 99+  BD40 00 00 00 00
100+  BD44 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0
100+  BD48 00 00 00 00
101+  BD4C 3C 42 99 A1  	defb	  60, 66,153,161,161,153, 66, 60 ; 	
101+  BD50 A1 99 42 3C
# file closed: graphics/font.asm
153   BD54                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  BD54              ; Tiles graphics.
  2+  BD54              sprites:
  3+  BD54 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  BD58 00 00 00 00
  4+  BD5C FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  BD60 FF FF FF FF
  5+  BD64 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  BD68 1F 3F 7F FF
  6+  BD6C 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  BD70 F8 FC FE FF
  7+  BD74 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  BD78 55 AA 55 AA
  8+  BD7C 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 5, sky block
  8+  BD80 00 00 00 00
  9+  BD84 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 6, slime block
  9+  BD88 00 00 00 00
 10+  BD8C 00 00 00 00      defb    0  ,0  ,  0,  0,  0,  0,  0,  0   ; 7, for reuse
 10+  BD90 00 00 00 00
 11+  BD94 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52,  24    ; 8, diamond
 11+  BD98 F1 72 34 18
 12+  BD9C 3C 7E FF 7F      defb    60,126,255,127,254,254,255,126    ; 9, rock
 12+  BDA0 FE FE FF 7E
 13+  BDA4 7E FF 7F 7F  	defb	126,255,127,127,254,255,126, 60    ; 10, rock 2
 13+  BDA8 FE FF 7E 3C
 14+  BDAC 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,255,255   ; 11, sky block, pixel trapdoor
 14+  BDB0 00 00 FF FF
 15+  BDB4 99 DB 7E 24  	defb    153,219,126, 36,255, 66, 36, 24   ; 12, missile
 15+  BDB8 FF 42 24 18
 16+  BDBC 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 13, sky block, tank background
 16+  BDC0 00 00 00 00
 17+  BDC4 00 00 00 00  	defb    0,  0,  0,  0,  0, 60, 90, 52     ; 14, gem
 17+  BDC8 00 3C 5A 34
 18+  BDCC FD FE FD FE  	defb	253,254,253,254,253,254,253,254   ; 15, damaged mountain
 18+  BDD0 FD FE FD FE
 19+  BDD4 F4 F8 F4 F8  	defb	244,248,244,248,244,248,244,248   ; 16, damaged mountain 2
 19+  BDD8 F4 F8 F4 F8
 20+  BDDC D0 E0 D0 E0  	defb	208,224,208,224,208,224,208,224   ; 17, damaged mountain 3
 20+  BDE0 D0 E0 D0 E0
 21+  BDE4 40 80 40 80  	defb	 64,128, 64,128, 64,128, 64,128   ; 18, damaged mountain 4
 21+  BDE8 40 80 40 80
 22+  BDEC 00 00 00 ED  	defb	0,  0,  0,237,237,  0,  0,  0	  ; 19, tank missile
 22+  BDF0 ED 00 00 00
 23+  BDF4 99 DB 7E 24  	defb    153,219,126, 36,255,126, 60, 24   ; 20, missile active
 23+  BDF8 FF 7E 3C 18
 24+  BDFC FF FF 00 00      defb	255,255,  0,  0,  0,  0,  0,  0	  ; 21, the pit 1
 24+  BE00 00 00 00 00
 25+  BE04 FC FC 00 00  	defb	252,252,  0,  0,  0,  0,  0,  0	  ; 22, the pit 2
 25+  BE08 00 00 00 00
 26+  BE0C F0 F0 00 00  	defb	240,240,  0,  0,  0,  0,  0,  0	  ; 23, the pit 3
 26+  BE10 00 00 00 00
 27+  BE14 C0 C0 00 00  	defb	192,192,  0,  0,  0,  0,  0,  0	  ; 24, the pit 4
 27+  BE18 00 00 00 00
 28+  BE1C 00 00 00 00  	defb	0,0,  0,  0,  0,  0,  0,  0	  	  ; 25, the pit 5
 28+  BE20 00 00 00 00
 29+  BE24 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 26, slime block, green on green
 29+  BE28 FF FF FF FF
 30+  BE2C 00 00 00 66  	defb    0,  0,  0,102,  0,  0,  0,  0     ; 27, bullet
 30+  BE30 00 00 00 00
 31+  BE34
 32+  BE34
 33+  BE34              sprite_attrs:
 34+  BE34 46               defb    070 ; 0, space
 35+  BE35 4D               defb    077 ; 1, cyan block
 36+  BE36 4D               defb    077 ; 2, slope left
 37+  BE37 4D               defb    077 ; 3, slope right
 38+  BE38 46               defb    070 ; 4, dirt
 39+  BE39 4E               defb    078 ; 5, sky
 40+  BE3A 66               defb    102 ; 6, slime
 41+  BE3B 42               defb    066 ; 7, trapdoor
 42+  BE3C 46               defb    070 ; 8, diamond
 43+  BE3D 42               defb    066 ; 9, rock
 44+  BE3E 42               defb    066 ; 10, rock 2
 45+  BE3F 49           	defb    073 ; 11, sky, trapdoor
 46+  BE40 43           	defb    067 ; 12, missile
 47+  BE41 4A               defb    074 ; 13, sky, red ink (tank)
 48+  BE42 46               defb    070 ; 14, gem
 49+  BE43 4D               defb    077 ; 15, damaged mountain
 50+  BE44 4D               defb    077 ; 16, damaged mountain 2
 51+  BE45 4D               defb    077 ; 17, damaged mountain 3
 52+  BE46 4D               defb    077 ; 18, damaged mountain 4
 53+  BE47 00           	defb 	000 ; 19, tank missile (not used
 54+  BE48 43           	defb    067 ; 20, missile active
 55+  BE49 42           	defb	066	; 21, the pit 1
 56+  BE4A 42           	defb	066	; 22, the pit 2
 57+  BE4B 42           	defb	066	; 23, the pit 3
 58+  BE4C 42           	defb	066	; 24, the pit 4
 59+  BE4D 42           	defb	066	; 25, the pit 5
 60+  BE4E 64           	defb    100 ; 26, slime, green on green
 61+  BE4F 46           	defb 	070 ; 27, bullet
 62+  BE50
 63+  BE50
 64+  BE50              player_sprite:
 65+  BE50 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 0 up/down 1
 65+  BE54 38 3D C3 80
 66+  BE58 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 1 left 1
 66+  BE5C 3C 1C 16 32
 67+  BE60 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 2 right 1
 67+  BE64 3C 38 68 4C
 68+  BE68 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 3 up/down 2
 68+  BE6C 1C BC C3 01
 69+  BE70 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 60,100, 12; 4 left 2
 69+  BE74 3C 3C 64 0C
 70+  BE78 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 60, 38, 48 ; 5 right 2
 70+  BE7C 3C 3C 26 30
 71+  BE80 54 28 10 12  	defb	 84, 40, 16, 18, 30, 92,253, 95 ; 6 shoot up
 71+  BE84 1E 5C FD 5F
 72+  BE88 02 87 42 BF  	defb	 2,135, 66,191, 79,143, 25,  3  ; 7 shoot left
 72+  BE8C 4F 8F 19 03
 73+  BE90 40 E1 42 FD  	defb	 64,225, 66,253,242,241,152,192 ; 8 shoot right
 73+  BE94 F2 F1 98 C0
 74+  BE98 FA BF 3A 78  	defb	 250,191, 58,120, 72,  8, 20, 42 ; 9 shoot down
 74+  BE9C 48 08 14 2A
 75+  BEA0 92 BA 94 78  	defb 	 146,186,148,120, 56,120, 68,195 ; 10 crushed 1
 75+  BEA4 38 78 44 C3
 76+  BEA8 49 5D 29 1E  	defb	  73, 93, 41, 30, 28, 30, 34,195 ; 11 crushed 2
 76+  BEAC 1C 1E 22 C3
 77+  BEB0 72 57 72 67  	defb	114, 87,114,103,111, 69,225,155  ; 12 fight 1
 77+  BEB4 6F 45 E1 9B
 78+  BEB8 4E EA 4E E6  	defb	 78,234, 78,230,246,162,135,217  ; 13 fight 2
 78+  BEBC F6 A2 87 D9
 79+  BEC0
 80+  BEC0              ;
 81+  BEC0              ; First 4 top half, next 4 bottom 1, next 4 bottom 2
 82+  BEC0              ;
 83+  BEC0              ship_sprite:
 84+  BEC0 00 00 00 01  	defb	  0,  0,  0,  1,  3, 31,127,255
 84+  BEC4 03 1F 7F FF
 85+  BEC8 1F 01 7F FF  	defb	 31,  1,127,255,255,255,255,255
 85+  BECC FF FF FF FF
 86+  BED0 F8 80 FE FF  	defb	248,128,254,255,255,255,255,255
 86+  BED4 FF FF FF FF
 87+  BED8 00 00 00 80  	defb	  0,  0,  0,128,192,248,254,255
 87+  BEDC C0 F8 FE FF
 88+  BEE0 B3 B3 7F 1F  	defb	179,179,127, 31,  3,  3,  2,  7
 88+  BEE4 03 03 02 07
 89+  BEE8 8F 8F FF FF  	defb	143,143,255,255,255, 15,  7,131
 89+  BEEC FF 0F 07 83
 90+  BEF0 0F 0F FF FF  	defb	 15, 15,255,255,255, 16, 32,193
 90+  BEF4 FF 10 20 C1
 91+  BEF8 19 19 FE F8  	defb	 25, 25,254,248,192,192, 64,224
 91+  BEFC C0 C0 40 E0
 92+  BF00 98 98 7F 1F  	defb	152,152,127, 31,  3,  3,  2,  7
 92+  BF04 03 03 02 07
 93+  BF08 F0 F0 FF FF  	defb	240,240,255,255,255,  8,  4,131
 93+  BF0C FF 08 04 83
 94+  BF10 F1 F1 FF FF  	defb	241,241,255,255,255,240,224,193
 94+  BF14 FF F0 E0 C1
 95+  BF18 CD CD FE F8  	defb	205,205,254,248,192,192, 64,224
 95+  BF1C C0 C0 40 E0
 96+  BF20
 97+  BF20              ;
 98+  BF20              ;  First 8 frames are tank, last frame is the gun barrel
 99+  BF20              ;
100+  BF20              tank_sprite:
101+  BF20 00 00 00 7F  	defb	  0,  0,  0,127,127,  0,  0,  0
101+  BF24 7F 00 00 00
102+  BF28 01 03 FE FC  	defb	  1,  3,254,252,254,255,127, 64
102+  BF2C FE FF 7F 40
103+  BF30 FF FF 03 F9  	defb	255,255,  3,249,  3,255,255,  1
103+  BF34 03 FF FF 01
104+  BF38 00 00 C0 E0  	defb	  0,  0,192,224,224,192,  0,  0
104+  BF3C E0 C0 00 00
105+  BF40 3F 7F E1 FB  	defb	 63,127,225,251,247,225,127, 63
105+  BF44 F7 E1 7F 3F
106+  BF48 FF FF 16 52  	defb	255,255, 22, 82, 84, 22,255,255
106+  BF4C 54 16 FF FF
107+  BF50 FF FF A8 A9  	defb	255,255,168,169,155,168,255,255
107+  BF54 9B A8 FF FF
108+  BF58 FC FE 8F AF  	defb	252,254,143,175,159,175,254,252
108+  BF5C 9F AF FE FC
109+  BF60 00 00 00 1F  	defb	  0,  0,  0, 31, 31,  0,  0,  0 ; +64
109+  BF64 1F 00 00 00
110+  BF68
111+  BF68              monster_sprite:
112+  BF68 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
112+  BF6C 0B D0 16 68
113+  BF70 19 98 17 E8  	defb	 25,152, 23,232, 53,172,127,254
113+  BF74 35 AC 7F FE
114+  BF78 FE 7F EC 37  	defb	254,127,236, 55,143,241,143,241
114+  BF7C 8F F1 8F F1
115+  BF80 08 10 08 10  	defb	  8, 16,  8, 16, 24, 24,  0,  0		; frame 1
115+  BF84 18 18 00 00
116+  BF88 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
116+  BF8C 0B D0 16 68
117+  BF90 19 98 17 E8  	defb	 25,152, 23,232,245,175,255,255
117+  BF94 F5 AF FF FF
118+  BF98 BC 3D 0E 70  	defb	188, 61, 14,112, 15,240, 15,240
118+  BF9C 0F F0 0F F0
119+  BFA0 10 08 30 0C  	defb	 16,  8, 48, 12,  0,  0,  0,  0		; frame 2
119+  BFA4 00 00 00 00
120+  BFA8
121+  BFA8              robot_sprite:
122+  BFA8 0E 0A CE 3E  	defb	 14, 10,206, 62,206, 18, 34,102		; left 1
122+  BFAC CE 12 22 66
123+  BFB0 0E 0A 4E FE  	defb	 14, 10, 78,254, 78, 18, 36,108		; 2
123+  BFB4 4E 12 24 6C
124+  BFB8 0E 0A 4E FE  	defb	 14, 10, 78,254, 78, 50, 99,  3		; 3
124+  BFBC 4E 32 63 03
125+  BFC0 0E 0A CE 3E  	defb	 14, 10,206, 62,206, 10,  9, 27		; 4
125+  BFC4 CE 0A 09 1B
126+  BFC8 70 50 73 7C  	defb	112, 80,115,124,115, 72, 68,102		; right 1
126+  BFCC 73 48 44 66
127+  BFD0 70 50 72 7F  	defb	112, 80,114,127,114, 72, 36, 54		; 2
127+  BFD4 72 48 24 36
128+  BFD8 70 50 72 7F  	defb	112, 80,114,127,114, 76,198,192		; 3
128+  BFDC 72 4C C6 C0
129+  BFE0 70 50 73 7C  	defb	112, 80,115,124,115, 80,144,216		; 4
129+  BFE4 73 50 90 D8
130+  BFE8 38 A9 BA 7C  	defb     56,169,186,124, 56, 42, 38, 96     ; dead 1
130+  BFEC 38 2A 26 60
131+  BFF0 1C 95 5D 3E  	defb	 28,149, 93, 62, 28, 84,100,  6		; dead 2
131+  BFF4 1C 54 64 06
132+  BFF8
# file closed: graphics/graphics.asm
154   BFF8
155   BFF8                  include "game\control.asm"
# file opened: game/control.asm
  1+  BFF8              ;
  2+  BFF8              ; Check the preferred input method then move
  3+  BFF8              ;
  4+  BFF8              control_input:
  5+  BFF8 3A FF C5         ld a,(player+11)    ; first, check if player is dying
  6+  BFFB FE 04            cp 4                ; is the player falling
  7+  BFFD CC C7 C0         call z, control_fall
  8+  C000 FE 05            cp 5                ; is the player fighting
  9+  C002 CC B4 C0         call z, control_fight
 10+  C005 3A FF C5         ld a,(player+11)    ; first, check if player is dying
 11+  C008 FE 00            cp 0
 12+  C00A C0               ret nz               ; if so, can't move
 13+  C00B 3A F9 C5         ld a,(player+5)      ; next, check if the player has pixels left to move
 14+  C00E FE 00            cp 0
 15+  C010 CA 17 C0         jp z, control_input0
 16+  C013 CD AA C1         call control_automove
 17+  C016 C9               ret
 18+  C017              control_input0:
 19+  C017 3A FA C5         ld a,(player+6)      ; next, check if the player is digging
 20+  C01A FE 00            cp 0
 21+  C01C CA 23 C0         jp z, control_input1
 22+  C01F CD E3 C0         call control_dig
 23+  C022 C9               ret
 24+  C023              control_input1:
 25+  C023 3A 08 C5         ld a,(game_control)
 26+  C026 FE 00            cp 0                ; is this keyboard
 27+  C028 C2 2F C0         jp nz,control_input2
 28+  C02B CD 33 C0         call control_keyboard
 29+  C02E C9               ret
 30+  C02F              control_input2:
 31+  C02F                  ; do joystick
 32+  C02F CD 79 C0         call control_joystick
 33+  C032 C9               ret
 34+  C033
 35+  C033              ;
 36+  C033              ; Check the keyboard
 37+  C033              ;
 38+  C033              control_keyboard:
 39+  C033 01 FE FB         ld bc,64510         ; port for keyboard row q-t.
 40+  C036 ED 78            in a,(c)            ; read keyboard.
 41+  C038 47               ld b,a              ; store result in b register.
 42+  C039 CB 18            rr b                ; check outermost key (q).
 43+  C03B D2 65 C0         jp nc,control_keyboard1
 44+  C03E 01 FE FD         ld bc,65022         ; port for keyboard row a-f.
 45+  C041 ED 78            in a,(c)            ; read keyboard.
 46+  C043 47               ld b,a              ; store result in b register.
 47+  C044 CB 18            rr b                ; check outermost key (a).
 48+  C046 D2 69 C0         jp nc,control_keyboard2
 49+  C049 01 FE DF         ld bc,57342         ; port for keyboard row y-p.
 50+  C04C ED 78            in a,(c)            ; read keyboard.
 51+  C04E 47               ld b,a              ; store result in b register.
 52+  C04F CB 18            rr b                ; check outermost key (p).
 53+  C051 D2 6D C0         jp nc,control_keyboard3
 54+  C054 CB 18            rr b                ; check next key.
 55+  C056 D2 71 C0         jp nc,control_keyboard4
 56+  C059 01 FE 7F         ld bc,32766         ; port for keyboard row b-space.
 57+  C05C ED 78            in a,(c)            ; read keyboard.
 58+  C05E 47               ld b,a              ; store result in b register.
 59+  C05F CB 18            rr b                ; check outermost key (space).
 60+  C061 D2 75 C0         jp nc,control_keyboard5
 61+  C064 C9               ret
 62+  C065              control_keyboard1:
 63+  C065 CD F3 C1         call control_pl_moveup         ; player up.
 64+  C068 C9               ret
 65+  C069              control_keyboard2:
 66+  C069 CD 20 C2         call control_pl_movedown       ; player down.
 67+  C06C C9               ret
 68+  C06D              control_keyboard3:
 69+  C06D CD 7C C2         call control_pl_moveright       ; player left.
 70+  C070 C9               ret
 71+  C071              control_keyboard4:
 72+  C071 CD 4C C2         call control_pl_moveleft       ; player right.
 73+  C074 C9               ret
 74+  C075              control_keyboard5:
 75+  C075 CD AA C2         call control_pl_fire       ; player fire.
 76+  C078 C9               ret
 77+  C079
 78+  C079              ;
 79+  C079              ; Check the joystick
 80+  C079              ;
 81+  C079              control_joystick:
 82+  C079 01 1F 00         ld bc,31                        ; Kempston joystick port.
 83+  C07C ED 78            in a,(c)                        ; read input.
 84+  C07E E6 02            and 2                           ; check "left" bit.
 85+  C080 C2 A8 C0         jp nz,control_joystick3       ; move left.
 86+  C083 ED 78            in a,(c)                        ; read input.
 87+  C085 E6 01            and 1                           ; test "right" bit.
 88+  C087 C2 AC C0         jp nz,control_joystick4       ; move right.
 89+  C08A ED 78            in a,(c)                        ; read input.
 90+  C08C E6 08            and 8                           ; check "up" bit.
 91+  C08E C2 A0 C0         jp nz,control_joystick1       ; move up.
 92+  C091 ED 78            in a,(c)                        ; read input.
 93+  C093 E6 04            and 4                           ; check "down" bit.
 94+  C095 C2 A4 C0         jp nz,control_joystick2       ; move down.
 95+  C098 ED 78            in a,(c)                        ; read input.
 96+  C09A E6 10            and 16                          ; try the fire bit.
 97+  C09C C2 B0 C0         jp nz,control_joystick5       ; fire pressed.
 98+  C09F C9               ret
 99+  C0A0              control_joystick1:
100+  C0A0 CD F3 C1         call control_pl_moveup         ; player up.
101+  C0A3 C9               ret
102+  C0A4              control_joystick2:
103+  C0A4 CD 20 C2         call control_pl_movedown       ; player down.
104+  C0A7 C9               ret
105+  C0A8              control_joystick3:
106+  C0A8 CD 4C C2         call control_pl_moveleft       ; player left.
107+  C0AB C9               ret
108+  C0AC              control_joystick4:
109+  C0AC CD 7C C2         call control_pl_moveright       ; player right.
110+  C0AF C9               ret
111+  C0B0              control_joystick5:
112+  C0B0 CD AA C2         call control_pl_fire
113+  C0B3 C9               ret
114+  C0B4
115+  C0B4              ;
116+  C0B4              ; Fights the player - just flips the players anim frame
117+  C0B4              ;
118+  C0B4              control_fight:
119+  C0B4 3A F7 C5         ld a,(player+3)             ; load the frame
120+  C0B7 FE 0C            cp 12                       ; flip between 12 and 13
121+  C0B9 CA C1 C0         jp z,control_fight0
122+  C0BC 3E 0C            ld a,12
123+  C0BE C3 C3 C0         jp control_fight1
124+  C0C1              control_fight0:
125+  C0C1 3E 0D            ld a,13
126+  C0C3              control_fight1:
127+  C0C3 32 F7 C5         ld (player+3),a           ; save back
128+  C0C6 C9               ret
129+  C0C7
130+  C0C7              ;
131+  C0C7              ; Falls the player
132+  C0C7              ;
133+  C0C7              control_fall:
134+  C0C7 ED 4B F4 C5      ld bc,(player)              ; get coords
135+  C0CB 0C               inc c
136+  C0CC ED 43 F4 C5      ld (player),bc
137+  C0D0 3A F7 C5         ld a,(player+3)             ; load the frame
138+  C0D3 FE 03            cp 3                       ; flip between 3 and 0
139+  C0D5 C2 DD C0         jp nz, control_fall0
140+  C0D8 3E 00            ld a,0
141+  C0DA C3 DF C0         jp control_fall1
142+  C0DD              control_fall0:
143+  C0DD 3E 03            ld a,3
144+  C0DF              control_fall1:
145+  C0DF 32 F7 C5         ld (player+3),a           ; save back
146+  C0E2 C9               ret
147+  C0E3
148+  C0E3              ;
149+  C0E3              ; Performs a dig if the counter has reset, otherwise, messes with the graphics
150+  C0E3              ;
151+  C0E3              control_dig:
152+  C0E3 ED 4B F4 C5      ld bc,(player)      ; load the current coords into bc
153+  C0E7 C5               push bc
154+  C0E8 3A F6 C5         ld a,(player+2)     ; get the direction
155+  C0EB FE 01            cp 1                ; left
156+  C0ED CA 05 C1         jp z,control_dig0
157+  C0F0 FE 02            cp 2                ; right
158+  C0F2 CA 1A C1         jp z,control_dig1
159+  C0F5 FE 03            cp 3                ; down
160+  C0F7 CA 43 C1         jp z,control_dig5
161+  C0FA FE 00            cp 0                ; up
162+  C0FC CA 2E C1         jp z,control_dig4
163+  C0FF 21 FA C5         ld hl,player+6
164+  C102 36 00            ld (hl),0           ; turn off digging
165+  C104 C9               ret                 ; return
166+  C105              control_dig0:           ; going left
167+  C105 CD 1D AC         call sprites_scadd  ; get the current coord
168+  C108 62 6B            ld hl,de
169+  C10A 2B               dec hl              ; move one left
170+  C10B C1               pop bc              ; get the coords back, subtract 8 from horiz, 8 from vert, store (will be coords of space above dug dirt)
171+  C10C 78               ld a,b
172+  C10D 06 08            ld b,8
173+  C10F 90               sub b
174+  C110 47               ld b,a
175+  C111 79               ld a,c
176+  C112 0E 08            ld c,8
177+  C114 91               sub c
178+  C115 4F               ld c,a
179+  C116 C5               push bc
180+  C117 C3 4C C1         jp control_dig2
181+  C11A              control_dig1:
182+  C11A CD 1D AC         call sprites_scadd  ; get the current coord
183+  C11D 62 6B            ld hl,de
184+  C11F 23               inc hl              ; move one right
185+  C120 C1               pop bc              ; get the coords back, add 8 to horiz, subtract 8 from vert store (will be coords of space above dug dirt)
186+  C121 3E 08            ld a,8
187+  C123 80               add a,b
188+  C124 47               ld b,a
189+  C125 79               ld a,c
190+  C126 0E 08            ld c,8
191+  C128 91               sub c
192+  C129 4F               ld c,a
193+  C12A C5               push bc
194+  C12B C3 4C C1         jp control_dig2
195+  C12E              control_dig4:
196+  C12E 3E 01            ld a,1
197+  C130 32 1A A7         ld (buffer_threelinerefresh),a  ; set the three line update flag, since we're digging up
198+  C133 CD 1D AC         call sprites_scadd  ; get the current coord
199+  C136 62 6B            ld hl,de
200+  C138 11 20 00         ld de,32
201+  C13B ED 52            sbc hl,de             ; move one up
202+  C13D C1               pop bc              ; get the coords back, 1 from vert, store, then we'll sub 1 from c for each row later
203+  C13E 0D               dec c
204+  C13F C5               push bc
205+  C140 C3 64 C1         jp control_dig6
206+  C143              control_dig5:
207+  C143 CD 1D AC         call sprites_scadd  ; get the current coord
208+  C146 62 6B            ld hl,de
209+  C148 24               inc h              ; move one down
210+  C149                                     ; not bothered about working out bc here, since rock will never fall if digging down
211+  C149 C3 4C C1         jp control_dig2
212+  C14C              ; Normal (not up) digging
213+  C14C              control_dig2:
214+  C14C 3A FC C5         ld a,(player+8)     ; get the number of rows we need to overwrite
215+  C14F 47               ld b,a              ; rows to copy over
216+  C150 E5               push hl             ; store the memory location of the first row for later
217+  C151              control_dig3:
218+  C151 CD 93 C1         call control_getpixelrow
219+  C154 77               ld (hl),a           ; load contents into row
220+  C155 11 20 00         ld de,32
221+  C158 19               add hl,de           ; move to next row
222+  C159 10 F6            djnz control_dig3
223+  C15B E1               pop hl              ; get the original memory location back
224+  C15C 11 20 00         ld de,32
225+  C15F ED 52            sbc hl,de           ; move to above row, ready for checking for rock
226+  C161 C3 7A C1         jp control_dig10
227+  C164              ; Special case for going up
228+  C164              control_dig6:
229+  C164 3A FC C5         ld a,(player+8)     ; get the number of rows we need to overwrite
230+  C167 47               ld b,a              ; rows to copy over
231+  C168              control_dig7:
232+  C168 CD 93 C1         call control_getpixelrow
233+  C16B              control_dig12:
234+  C16B 77               ld (hl),a           ; load empty into row
235+  C16C 11 20 00         ld de,32
236+  C16F ED 52            sbc hl,de           ; move up to next row
237+  C171 0D               dec c               ; decrease c to track rows
238+  C172 10 F4            djnz control_dig7
239+  C174 79               ld a,c
240+  C175 D6 07            sub 7
241+  C177 C1               pop bc
242+  C178 4F               ld c,a
243+  C179 C5               push bc             ; store the decreased c coord
244+  C17A              control_dig10:
245+  C17A DD 21 FB C5      ld ix,player+7
246+  C17E DD 7E 00         ld a,(ix)     ; get the dig frame number
247+  C181 3D               dec a
248+  C182 DD 77 00         ld (ix),a
249+  C185                  ; call the check for rocks above the removed dirt
250+  C185 DD 21 FA C5      ld ix,player+6
251+  C189 DD 7E 00         ld a,(ix)     ; get the dig state
252+  C18C FE 00            cp 0
253+  C18E C1               pop bc
254+  C18F CC A0 CB         call z, rocks_checkforfalling ; make the check if we're no longer digging
255+  C192 C9               ret
256+  C193
257+  C193              ;
258+  C193              ; Gets a modified pixel row to overwrite dirt - if this is the last dig, overwrite with nothing, otherwise xor to flip the dirt
259+  C193              ; Inputs:
260+  C193              ; hl - memory of pixel row
261+  C193              ; Outputs:
262+  C193              ; a - modified row to write
263+  C193              ;
264+  C193              control_getpixelrow:
265+  C193 3A FB C5         ld a,(player+7)     ; get the dig frame number
266+  C196 FE 00            cp 0                ; is this the last dig
267+  C198 CA 9F C1         jp z,control_getpixelrow1
268+  C19B 7E               ld a,(hl)           ; if not, xor with 255 to flip it
269+  C19C EE FF            xor 255
270+  C19E C9               ret
271+  C19F              control_getpixelrow1:
272+  C19F DD 21 FA C5      ld ix,player+6
273+  C1A3 DD 36 00 00      ld (ix),0           ; turn off digging
274+  C1A7 3E 00            ld a,0              ; if it is, load with empty
275+  C1A9 C9               ret
276+  C1AA
277+  C1AA              ;
278+  C1AA              ; Auto move the player until pixels is zero
279+  C1AA              ;
280+  C1AA              control_automove:
281+  C1AA 5F               ld e,a              ; store the number of pixels left to move in e
282+  C1AB ED 4B F4 C5      ld bc,(player)      ; load the current coords into bc
283+  C1AF 21 F6 C5         ld hl,player+2      ; get the direction
284+  C1B2 7E               ld a,(hl)
285+  C1B3 FE 03            cp 3                ; down
286+  C1B5 CA C9 C1         jp z,control_automove3  ; don't need to do anything
287+  C1B8 FE 00            cp 0                ; going up
288+  C1BA CA D5 C1         jp z,control_automove2
289+  C1BD FE 01            cp 1                ; going left?
290+  C1BF CA E1 C1         jp z,control_automove0
291+  C1C2 78               ld a,b
292+  C1C3 3C               inc a               ; if we're going right, increment a twice for two pixels
293+  C1C4 3C               inc a
294+  C1C5 47               ld b,a
295+  C1C6 C3 E5 C1         jp control_automove1
296+  C1C9              control_automove3:
297+  C1C9 79               ld a,c
298+  C1CA 3C               inc a
299+  C1CB 3C               inc a               ; if we're going down, increment twice
300+  C1CC 4F               ld c,a
301+  C1CD FE 90            cp 144
302+  C1CF CC C3 C2         call z, control_scroll_down
303+  C1D2 C3 E5 C1         jp control_automove1
304+  C1D5              control_automove2:
305+  C1D5 79               ld a,c
306+  C1D6 3D               dec a
307+  C1D7 3D               dec a               ; if we're going up, decrement twice
308+  C1D8 4F               ld c,a
309+  C1D9 FE 60            cp 96
310+  C1DB CC D0 C2         call z, control_scroll_up
311+  C1DE C3 E5 C1         jp control_automove1
312+  C1E1              control_automove0:
313+  C1E1 78               ld a,b
314+  C1E2 3D               dec a               ; if we're going left, decrement a twice
315+  C1E3 3D               dec a
316+  C1E4 47               ld b,a
317+  C1E5              control_automove1:
318+  C1E5 ED 43 F4 C5      ld (player),bc      ; and back to player
319+  C1E9 7B               ld a,e              ; now get the pixel count back
320+  C1EA 3D               dec a               ; decrease by one
321+  C1EB 21 F9 C5         ld hl,player+5
322+  C1EE 77               ld (hl),a           ; copy back
323+  C1EF CD FF C7         call player_justmoved
324+  C1F2 C9               ret
325+  C1F3
326+  C1F3              ;
327+  C1F3              ; Moves the player up
328+  C1F3              ;
329+  C1F3              control_pl_moveup:
330+  C1F3 C5               push bc
331+  C1F4 ED 4B F4 C5      ld bc,(player)          ; get the current coords, b horiz, c vert
332+  C1F8 79               ld a,c                  ; load c into the acc
333+  C1F9 FE 18            cp 24
334+  C1FB CA 19 C2         jp z,control_pl_moveup0 ; are we at the edge of the screen
335+  C1FE FE 60            cp 96
336+  C200 CC D0 C2         call z, control_scroll_up
337+  C203 CD 77 C4         call movement_checkcanmove_up ; check we can move up, e will be 1 if we can
338+  C206 F5               push af
339+  C207 7B               ld a,e                  ; put e in a
340+  C208 FE 00            cp 0
341+  C20A CA 18 C2         jp z,control_pl_moveup1 ; don't move if we can't
342+  C20D F1               pop af
343+  C20E D6 01            sub 1                   ; subtract 1
344+  C210                  ;sub 1                   ; subtract 1
345+  C210 4F               ld c,a                  ; load back to c
346+  C211 ED 43 F4 C5      ld (player),bc          ; load back to player
347+  C215 C3 19 C2         jp control_pl_moveup0
348+  C218              control_pl_moveup1:
349+  C218 F1               pop af                  ; restore af if needed
350+  C219              control_pl_moveup0:
351+  C219 3E 00            ld a,0
352+  C21B 32 F6 C5         ld (player+2),a        ; set direction to up
353+  C21E C1               pop bc
354+  C21F C9               ret
355+  C220              ;
356+  C220              ; Moves the player down
357+  C220              ;
358+  C220              control_pl_movedown:
359+  C220 C5               push bc
360+  C221 ED 4B F4 C5      ld bc,(player)          ; get the current coords, b horiz, c vert
361+  C225 79               ld a,c                  ; load c into the acc
362+  C226 FE E0            cp 224
363+  C228 CA 45 C2         jp z,control_pl_movedown0 ; are we at the edge of the screen
364+  C22B FE 80            cp 128
365+  C22D CC C3 C2         call z, control_scroll_down
366+  C230 CD 4B C4         call movement_checkcanmove_down ; check we can move down, e will be 1 if we can
367+  C233 F5               push af
368+  C234 7B               ld a,e                  ; put e in a
369+  C235 FE 00            cp 0
370+  C237 CA 44 C2         jp z,control_pl_movedown1 ; don't move if we can't
371+  C23A F1               pop af
372+  C23B 3C               inc a                   ; add 1
373+  C23C                  ;inc a                   ; add 1
374+  C23C 4F               ld c,a                  ; load back to c
375+  C23D ED 43 F4 C5      ld (player),bc          ; load back to player
376+  C241 C3 45 C2         jp control_pl_movedown0
377+  C244              control_pl_movedown1:
378+  C244 F1               pop af                  ; restore af if needed
379+  C245              control_pl_movedown0:
380+  C245 3E 03            ld a,3
381+  C247 32 F6 C5         ld (player+2),a        ; set direction to down
382+  C24A C1               pop bc
383+  C24B C9               ret
384+  C24C              ;
385+  C24C              ; Moves the player left
386+  C24C              ;
387+  C24C              control_pl_moveleft:
388+  C24C C5               push bc
389+  C24D ED 4B F4 C5      ld bc,(player)          ; get the current coords, b horiz, c vert
390+  C251 78               ld a,b                  ; load b into the acc
391+  C252 FE 10            cp 16
392+  C254 CA 75 C2         jp z,control_pl_moveleft0 ; are we at the edge of the screen
393+  C257 CD D6 C4         call movement_checkcanmove_left ; check we can move down, e will be 1 if we can
394+  C25A F5               push af
395+  C25B 7B               ld a,e                  ; put e in a
396+  C25C FE 00            cp 0
397+  C25E CA 74 C2         jp z,control_pl_moveleft1 ; don't move if we can't
398+  C261 21 F9 C5         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
399+  C264 3E 03            ld a,3
400+  C266 77               ld (hl),a
401+  C267 F1               pop af
402+  C268 D6 01            sub 1                    ; subtract 2
403+  C26A D6 01            sub 1
404+  C26C 47               ld b,a                  ; load back to c
405+  C26D ED 43 F4 C5      ld (player),bc          ; load back to player
406+  C271 C3 75 C2         jp control_pl_moveleft0
407+  C274              control_pl_moveleft1:
408+  C274 F1               pop af
409+  C275              control_pl_moveleft0:
410+  C275 3E 01            ld a,1
411+  C277 32 F6 C5         ld (player+2),a        ; set direction to left
412+  C27A C1               pop bc
413+  C27B C9               ret
414+  C27C              ;
415+  C27C              ; Moves the player right
416+  C27C              ;
417+  C27C              control_pl_moveright:
418+  C27C C5               push bc
419+  C27D ED 4B F4 C5      ld bc,(player)          ; get the current coords, b horiz, c vert
420+  C281 78               ld a,b                  ; load b into the acc
421+  C282 FE F0            cp 240
422+  C284 CA A3 C2         jp z,control_pl_moveright0 ; are we at the edge of the screen
423+  C287 CD AA C4         call movement_checkcanmove_right ; check we can move down, e will be 1 if we can
424+  C28A F5               push af
425+  C28B 7B               ld a,e                  ; put e in a
426+  C28C FE 00            cp 0
427+  C28E CA A2 C2         jp z,control_pl_moveright1 ; don't move if we can't
428+  C291 21 F9 C5         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
429+  C294 3E 03            ld a,3
430+  C296 77               ld (hl),a
431+  C297 F1               pop af
432+  C298 3C               inc a                   ; add 2
433+  C299 3C               inc a
434+  C29A 47               ld b,a                  ; load back to b
435+  C29B ED 43 F4 C5      ld (player),bc          ; load back to player
436+  C29F C3 A3 C2         jp control_pl_moveright0
437+  C2A2              control_pl_moveright1:
438+  C2A2 F1               pop af                  ; restore af if needed
439+  C2A3              control_pl_moveright0:
440+  C2A3 3E 02            ld a,2
441+  C2A5 32 F6 C5         ld (player+2),a        ; set direction to right
442+  C2A8 C1               pop bc
443+  C2A9 C9               ret
444+  C2AA
445+  C2AA              ;
446+  C2AA              ; Player fires
447+  C2AA              ;
448+  C2AA              control_pl_fire:
449+  C2AA 3A F6 C5         ld a,(player+2)         ; get player direction
450+  C2AD FE 00            cp 0
451+  C2AF C8               ret z
452+  C2B0 FE 03            cp 3
453+  C2B2 C8               ret z                   ; if up or down, don't fire
454+  C2B3 3A E6 D6         ld a,(bullet_state+3)       ; get the state
455+  C2B6 FE 01            cp 1
456+  C2B8 C8               ret z                   ; if currently firing, don't fire
457+  C2B9 CD E7 D6         call bullet_init        ; initialise the bullet
458+  C2BC CD FC D6         call bullet_shoot       ; shoot the bullet
459+  C2BF CD E3 B1         call sound_laser
460+  C2C2 C9               ret
461+  C2C3
462+  C2C3              ;
463+  C2C3              ; Scrolls the screen down
464+  C2C3              ;
465+  C2C3              control_scroll_down:
466+  C2C3 F5               push af
467+  C2C4 3E 08            ld a,8
468+  C2C6 32 E3 A8         ld (screen_offset),a
469+  C2C9 F1               pop af
470+  C2CA 21 30 A7         ld hl,buffer_updateall
471+  C2CD 36 01            ld (hl),1         ; flag as screen needing update
472+  C2CF C9               ret
473+  C2D0
474+  C2D0              ;
475+  C2D0              ; Scrolls the screen up
476+  C2D0              ;
477+  C2D0              control_scroll_up:
478+  C2D0 F5               push af
479+  C2D1 3E 00            ld a,0
480+  C2D3 32 E3 A8         ld (screen_offset),a
481+  C2D6 F1               pop af
482+  C2D7 21 30 A7         ld hl,buffer_updateall
483+  C2DA 36 01            ld (hl),1         ; flag as screen needing update
484+  C2DC C9               ret
485+  C2DD
486+  C2DD
487+  C2DD
488+  C2DD
# file closed: game/control.asm
156   C2DD                  include "game\movement.asm"
# file opened: game/movement.asm
  1+  C2DD              ;
  2+  C2DD              ; The number of frames to dig for
  3+  C2DD              ;
  4+  C2DD              movement_numberdigframes:
  5+  C2DD 0A               defb 10
  6+  C2DE
  7+  C2DE              ;
  8+  C2DE              ; Checks the contents of a cell are empty - ie, all pixel rows are zero
  9+  C2DE              ; Inputs:
 10+  C2DE              ; hl - memory location of top pixel row
 11+  C2DE              ; bc - screen coords, b horiz, c vert
 12+  C2DE              ; Outputs:
 13+  C2DE              ; e - 0 if not empty, 1 if empty
 14+  C2DE              ;
 15+  C2DE              movement_spaceisempty:
 16+  C2DE C5               push bc
 17+  C2DF E5               push hl
 18+  C2E0 CD 08 C3         call movement_spaceisgem        ; check if space is a gem
 19+  C2E3 E1               pop hl
 20+  C2E4 C1               pop bc
 21+  C2E5 7B               ld a,e
 22+  C2E6 FE 01            cp 1
 23+  C2E8 C8               ret z                           ; if e is 1, space is a gem so can move here, return
 24+  C2E9 3E 08            ld a,8                          ; 8 rows to check
 25+  C2EB              movement_spaceisempty0:
 26+  C2EB 08               ex af,af'                       ; store the loop counter
 27+  C2EC 7E               ld a,(hl)                       ; get current pixel row
 28+  C2ED FE 00            cp 0
 29+  C2EF C2 03 C3         jp nz, movement_spaceisempty1    ; row is not empty, can't move here
 30+  C2F2 79               ld a,c                          ; load the vertical coord
 31+  C2F3 3C               inc a                           ; next row down
 32+  C2F4 11 20 00         ld de,32
 33+  C2F7 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 34+  C2F8 4F               ld c,a                          ; copy vert coord back to c
 35+  C2F9 08               ex af,af'                       ; get loop counter back
 36+  C2FA 3D               dec a                           ; decrease loop counter
 37+  C2FB C2 EB C2         jp nz, movement_spaceisempty0
 38+  C2FE 16 00            ld d,0
 39+  C300 1E 01            ld e,1                          ; got to end, so space is empty
 40+  C302 C9               ret
 41+  C303              movement_spaceisempty1:
 42+  C303 16 00            ld d,0
 43+  C305 1E 00            ld e,0                          ; returning false, ie space not empty
 44+  C307 C9               ret
 45+  C308
 46+  C308              ;
 47+  C308              ; Check if a space contains a gem
 48+  C308              ; Inputs:
 49+  C308              ; bc - screen coords
 50+  C308              ; Outputs:
 51+  C308              ; e = 1 if gem
 52+  C308              movement_spaceisgem:
 53+  C308 CD 43 AA         call screen_getcharcoordsfromscreencoords   ; get the char coords we're checking into bc
 54+  C30B 21 CF B8         ld hl,level_diamonds           ; check diamonds first
 55+  C30E              movement_spaceisgem0:
 56+  C30E 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 57+  C312 7B               ld a,e                          ; check for end of data
 58+  C313 FE FF            cp 255
 59+  C315 CA 30 C3         jp z,movement_spaceisgem1       ; if yes, done with diamonds
 60+  C318 23               inc hl
 61+  C319 23               inc hl                          ; move to state
 62+  C31A 7E               ld a,(hl)
 63+  C31B 23               inc hl
 64+  C31C 23               inc hl
 65+  C31D 23               inc hl                          ; get to next
 66+  C31E FE 01            cp 1                            ; check if collected
 67+  C320 CA 0E C3         jp z,movement_spaceisgem0       ; if yes, move to next diamond
 68+  C323 7B               ld a,e                          ; load e again
 69+  C324 B9               cp c                            ; otherwise, compare c with e
 70+  C325 C2 0E C3         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 71+  C328 7A               ld a,d                          ; get d coord
 72+  C329 B8               cp b                            ; compare b with d
 73+  C32A C2 0E C3         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 74+  C32D 1E 01            ld e,1                          ; otherwise, exit with e = 1
 75+  C32F C9               ret
 76+  C330              movement_spaceisgem1:
 77+  C330 21 DF B8         ld hl,level_gems              ; check gems
 78+  C333              movement_spaceisgem2:
 79+  C333 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 80+  C337 7B               ld a,e                          ; check for end of data
 81+  C338 FE FF            cp 255
 82+  C33A CA 55 C3         jp z,movement_spaceisgem3       ; if yes, done with gems
 83+  C33D 23               inc hl
 84+  C33E 23               inc hl                          ; move to state
 85+  C33F 7E               ld a,(hl)
 86+  C340 23               inc hl
 87+  C341 23               inc hl
 88+  C342 23               inc hl                          ; get to next
 89+  C343 FE 01            cp 1                            ; check if collected
 90+  C345 CA 33 C3         jp z,movement_spaceisgem2       ; if yes, move to next diamond
 91+  C348 7B               ld a,e                          ; load e again
 92+  C349 B9               cp c                            ; otherwise, compare c with e
 93+  C34A C2 33 C3         jp nz,movement_spaceisgem2      ; if different, move to next gem
 94+  C34D 7A               ld a,d                          ; get d coord
 95+  C34E B8               cp b                            ; compare b with d
 96+  C34F C2 33 C3         jp nz,movement_spaceisgem2      ; if different, move to next gem
 97+  C352 1E 01            ld e,1                          ; otherwise, exit with e = 1
 98+  C354 C9               ret
 99+  C355              movement_spaceisgem3:
100+  C355 1E 00            ld e,0                          ; nothing found, return e = 0
101+  C357 C9               ret
102+  C358
103+  C358              ;
104+  C358              ; Checks the line of a cell below is empty - ie, first pixel rows is zero
105+  C358              ; Inputs:
106+  C358              ; hl - memory location of top pixel row
107+  C358              ; bc - screen coords, b horiz, c vert
108+  C358              ; Outputs:
109+  C358              ; e - 0 if not empty, 1 if empty
110+  C358              ;
111+  C358              movement_linebelowisempty:
112+  C358 C5               push bc
113+  C359 E5               push hl
114+  C35A CD 08 C3         call movement_spaceisgem        ; check if space is a gem
115+  C35D E1               pop hl
116+  C35E C1               pop bc
117+  C35F 7B               ld a,e
118+  C360 FE 01            cp 1
119+  C362 C8               ret z                           ; if e is 1, space is a gem so can move here, return
120+  C363 7E               ld a,(hl)                       ; get current pixel row
121+  C364 FE 00            cp 0
122+  C366 C2 6E C3         jp nz, movement_linebelowisempty1    ; row is not empty, can't move here
123+  C369 16 00            ld d,0
124+  C36B 1E 01            ld e,1                          ; got to end, so space is empty
125+  C36D C9               ret
126+  C36E              movement_linebelowisempty1:
127+  C36E 16 00            ld d,0
128+  C370 1E 00            ld e,0                          ; returning false, ie space not empty
129+  C372 C9               ret
130+  C373
131+  C373              ;
132+  C373              ; Checks the line of a cell above is empty - ie, last pixel rows are zero
133+  C373              ; Inputs:
134+  C373              ; hl - memory location of top pixel row
135+  C373              ; bc - screen coords, b horiz, c vert
136+  C373              ; Outputs:
137+  C373              ; e - 0 if not empty, 1 if empty
138+  C373              ;
139+  C373              movement_lineaboveisempty:
140+  C373 C5               push bc
141+  C374 E5               push hl
142+  C375 CD 08 C3         call movement_spaceisgem        ; check if space is a gem
143+  C378 E1               pop hl
144+  C379 C1               pop bc
145+  C37A 7B               ld a,e
146+  C37B FE 01            cp 1
147+  C37D C8               ret z
148+  C37E 7E               ld a,(hl)                       ; get current pixel row
149+  C37F FE 00            cp 0
150+  C381 C2 89 C3         jp nz, movement_lineaboveisempty1    ; row is not empty, can't move here
151+  C384 16 00            ld d,0
152+  C386 1E 01            ld e,1                          ; got to end, so space is empty
153+  C388 C9               ret
154+  C389              movement_lineaboveisempty1:
155+  C389 16 00            ld d,0
156+  C38B 1E 00            ld e,0                          ; returning false, ie space not empty
157+  C38D C9               ret
158+  C38E
159+  C38E              ;
160+  C38E              ; Checks the contents of a cell are diggable - ie, all pixel rows are dirt or empty
161+  C38E              ; Inputs:
162+  C38E              ; hl - memory location of top pixel row
163+  C38E              ; bc - screen coords, b horiz, c vert
164+  C38E              ; Outputs:
165+  C38E              ; none - puts player into digging mode
166+  C38E              ;
167+  C38E              movement_spaceisdiggable:
168+  C38E 3E 08            ld a,8                          ; 8 rows to check
169+  C390              movement_spaceisdiggable0:
170+  C390 08               ex af,af'                       ; store the loop counter
171+  C391 7E               ld a,(hl)                       ; get current pixel row
172+  C392 FE 00            cp 0
173+  C394 CA A4 C3         jp z, movement_spaceisdiggable2  ; row is empty, can dig here
174+  C397 FE 55            cp 85
175+  C399 CA A4 C3         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
176+  C39C FE AA            cp 170
177+  C39E CA A4 C3         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
178+  C3A1 C3 BE C3         jp movement_spaceisdiggable1     ; otherwise, stop checking
179+  C3A4              movement_spaceisdiggable2:
180+  C3A4 79               ld a,c                          ; load the vertical coord
181+  C3A5 3C               inc a                           ; next row down
182+  C3A6 11 20 00         ld de,32
183+  C3A9 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
184+  C3AA 4F               ld c,a                          ; copy vert coord back to c
185+  C3AB 08               ex af,af'                       ; get loop counter back
186+  C3AC 3D               dec a                           ; decrease loop counter
187+  C3AD C2 90 C3         jp nz, movement_spaceisdiggable0
188+  C3B0 21 FA C5         ld hl,player+6
189+  C3B3 36 01            ld (hl),1                       ; set the player into digging mode
190+  C3B5 23               inc hl
191+  C3B6 3A DD C2         ld a,(movement_numberdigframes)
192+  C3B9 77               ld (hl),a                       ; set the number of frame to dig for
193+  C3BA 23               inc hl
194+  C3BB 36 08            ld (hl),8                       ; set the number of pixels to dig
195+  C3BD C9               ret
196+  C3BE              movement_spaceisdiggable1:
197+  C3BE 21 FA C5         ld hl,player+6
198+  C3C1 36 00            ld (hl),0                       ; set the player out of digging mode
199+  C3C3 C9               ret
200+  C3C4
201+  C3C4              ;
202+  C3C4              ; Checks the contents of a cell below are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
203+  C3C4              ; Inputs:
204+  C3C4              ; hl - memory location of top pixel row
205+  C3C4              ; bc - screen coords, b horiz, c vert
206+  C3C4              ; Outputs:
207+  C3C4              ; none - puts player into digging mode
208+  C3C4              ;
209+  C3C4              movement_spacebelowisdiggable:
210+  C3C4 7E               ld a,(hl)                       ; get first pixel row
211+  C3C5 FE 55            cp 85
212+  C3C7 CA D2 C3         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
213+  C3CA FE AA            cp 170
214+  C3CC CA D2 C3         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
215+  C3CF C3 BE C3         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
216+  C3D2              movement_spacebelowisdiggable3:
217+  C3D2 3E 08            ld a,8                          ; rows to check
218+  C3D4 1E 00            ld e,0                          ; count of rows to dig
219+  C3D6              movement_spacebelowisdiggable0:
220+  C3D6 08               ex af,af'                       ; store the loop counter
221+  C3D7 7E               ld a,(hl)                       ; get current pixel row
222+  C3D8 FE 55            cp 85
223+  C3DA CA E5 C3         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
224+  C3DD FE AA            cp 170
225+  C3DF CA E5 C3         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
226+  C3E2 C3 F4 C3         jp movement_spacebelowisdiggable5     ; don't count this row and stop counting
227+  C3E5              movement_spacebelowisdiggable4:
228+  C3E5 1C               inc e                           ; inc count of rows to dig
229+  C3E6              movement_spacebelowisdiggable2:
230+  C3E6 79               ld a,c                          ; load the vertical coord
231+  C3E7 3C               inc a                           ; next row down
232+  C3E8 D5               push de                         ; need e for later
233+  C3E9 11 20 00         ld de,32
234+  C3EC 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
235+  C3ED 4F               ld c,a                          ; copy vert coord back to c
236+  C3EE D1               pop de                          ; get e back
237+  C3EF 08               ex af,af'                       ; get loop counter back
238+  C3F0 3D               dec a                           ; incease loop counter
239+  C3F1 C2 D6 C3         jp nz, movement_spacebelowisdiggable0
240+  C3F4              movement_spacebelowisdiggable5:
241+  C3F4 21 FA C5         ld hl,player+6
242+  C3F7 36 01            ld (hl),1                       ; set the player into digging mode
243+  C3F9 23               inc hl
244+  C3FA 3A DD C2         ld a,(movement_numberdigframes)
245+  C3FD 77               ld (hl),a                       ; set the number of frame to dig for
246+  C3FE 23               inc hl
247+  C3FF 73               ld (hl),e                       ; set the number of pixels to dig
248+  C400 C9               ret
249+  C401              movement_spacebelowisdiggable1:
250+  C401 21 FA C5         ld hl,player+6
251+  C404 36 00            ld (hl),0                       ; set the player out of digging mode
252+  C406 C9               ret
253+  C407
254+  C407              ;
255+  C407              ; Checks the contents of a cell above are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
256+  C407              ; Inputs:
257+  C407              ; hl - memory location of top pixel row
258+  C407              ; bc - screen coords, b horiz, c vert
259+  C407              ; Outputs:
260+  C407              ; none - puts player into digging mode
261+  C407              ;
262+  C407              movement_spaceaboveisdiggable:
263+  C407 7E               ld a,(hl)                       ; get first pixel row
264+  C408 FE 55            cp 85
265+  C40A CA 15 C4         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
266+  C40D FE AA            cp 170
267+  C40F CA 15 C4         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
268+  C412 C3 BE C3         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
269+  C415              movement_spaceaboveisdiggable3:
270+  C415 3E 08            ld a,8                          ; rows to check
271+  C417 1E 00            ld e,0                          ; count of rows to dig
272+  C419              movement_spaceaboveisdiggable0:
273+  C419 08               ex af,af'                       ; store the loop counter
274+  C41A 7E               ld a,(hl)                       ; get current pixel row
275+  C41B FE 55            cp 85
276+  C41D CA 28 C4         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
277+  C420 FE AA            cp 170
278+  C422 CA 28 C4         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
279+  C425 C3 38 C4         jp movement_spaceaboveisdiggable5     ; don't count this row and stop counting
280+  C428              movement_spaceaboveisdiggable4:
281+  C428 1C               inc e                           ; inc count of rows to dig
282+  C429              movement_spaceaboveisdiggable2:
283+  C429 79               ld a,c                          ; load the vertical coord
284+  C42A 3D               dec a                           ; next row up
285+  C42B D5               push de                         ; need e for later
286+  C42C 11 20 00         ld de,32
287+  C42F ED 52            sbc hl,de                       ; otherwise, just go one up for hl, which means sub 32, because of course
288+  C431 4F               ld c,a                          ; copy vert coord back to c
289+  C432 D1               pop de                          ; get e back
290+  C433 08               ex af,af'                       ; get loop counter back
291+  C434 3D               dec a                           ; incease loop counter
292+  C435 C2 19 C4         jp nz, movement_spaceaboveisdiggable0
293+  C438              movement_spaceaboveisdiggable5:
294+  C438 21 FA C5         ld hl,player+6
295+  C43B 36 01            ld (hl),1                       ; set the player into digging mode
296+  C43D 23               inc hl
297+  C43E 3A DD C2         ld a,(movement_numberdigframes)
298+  C441 77               ld (hl),a                       ; set the number of frame to dig for
299+  C442 23               inc hl
300+  C443 73               ld (hl),e                       ; set the number of pixels to dig
301+  C444 C9               ret
302+  C445              movement_spaceaboveisdiggable1:
303+  C445 21 FA C5         ld hl,player+6
304+  C448 36 00            ld (hl),0                       ; set the player out of digging mode
305+  C44A C9               ret
306+  C44B
307+  C44B              ;
308+  C44B              ; Checks if the player can move down
309+  C44B              ; Inputs:
310+  C44B              ; bc - player coords, b horiz, c vert
311+  C44B              ; Outputs:
312+  C44B              ; de - 1 can move
313+  C44B              movement_checkcanmove_down:
314+  C44B F5               push af
315+  C44C C5               push bc
316+  C44D CD 1D AC         call sprites_scadd              ; get the memory location of cell into de
317+  C450 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
318+  C452 24               inc h                       ; memory location of cell beneath now in hl
319+  C453 3E 08            ld a,8                       ; look below
320+  C455 81               add c
321+  C456 4F               ld c,a
322+  C457 CD 58 C3         call movement_linebelowisempty       ; check space is empty
323+  C45A 7B               ld a,e                          ; check space empty flag
324+  C45B FE 00            cp 0
325+  C45D CA 66 C4         jp z, movement_checkcanmove_down1 ; can't move
326+  C460 CD FF C7         call player_justmoved
327+  C463 C1               pop bc
328+  C464 F1               pop af
329+  C465 C9               ret
330+  C466              movement_checkcanmove_down1:
331+  C466 C1               pop bc
332+  C467 CD 1D AC         call sprites_scadd              ; get the memory location of cell into de
333+  C46A 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
334+  C46C 24               inc h
335+  C46D C5               push bc
336+  C46E CD C4 C3         call movement_spacebelowisdiggable    ; can't move here, but can we dig
337+  C471 11 00 00         ld de,0
338+  C474 C1               pop bc
339+  C475 F1               pop af
340+  C476 C9               ret
341+  C477
342+  C477              ;
343+  C477              ; Checks if the player can move up
344+  C477              ; Inputs:
345+  C477              ; bc - player coords, b horiz, c vert
346+  C477              ; Outputs:
347+  C477              ; de - 1 can move
348+  C477              movement_checkcanmove_up:
349+  C477 F5               push af
350+  C478 C5               push bc
351+  C479 CD 1D AC         call sprites_scadd              ; get the memory location of cell into de
352+  C47C 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
353+  C47E 11 20 00         ld de,32
354+  C481 ED 52            sbc hl,de                       ; memory location of line above now in hl
355+  C483 0D               dec c                           ; look above
356+  C484 CD 73 C3         call movement_lineaboveisempty       ; check space is empty
357+  C487 7B               ld a,e                          ; check space empty flag
358+  C488 FE 00            cp 0
359+  C48A CA 95 C4         jp z, movement_checkcanmove_up1 ; can't move
360+  C48D 1E 01            ld e,1
361+  C48F CD FF C7         call player_justmoved
362+  C492 C1               pop bc
363+  C493 F1               pop af
364+  C494 C9               ret
365+  C495              movement_checkcanmove_up1:
366+  C495 C1               pop bc
367+  C496 CD 1D AC         call sprites_scadd              ; get the memory location of cell into de
368+  C499 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
369+  C49B 11 20 00         ld de,32
370+  C49E ED 52            sbc hl,de                       ; memory location of line above now in hl
371+  C4A0 C5               push bc
372+  C4A1 CD 07 C4         call movement_spaceaboveisdiggable    ; can't move here, but can we dig
373+  C4A4 11 00 00         ld de,0
374+  C4A7 C1               pop bc
375+  C4A8 F1               pop af
376+  C4A9 C9               ret
377+  C4AA
378+  C4AA              ;
379+  C4AA              ; Checks if the player can move right
380+  C4AA              ; Inputs:
381+  C4AA              ; bc - player coords, b horiz, c vert
382+  C4AA              ; Outputs:
383+  C4AA              ; de - 1 can move
384+  C4AA              movement_checkcanmove_right:
385+  C4AA F5               push af
386+  C4AB C5               push bc
387+  C4AC CD 1D AC         call sprites_scadd              ; get the memory location of cell into de
388+  C4AF 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
389+  C4B1 3E 08            ld a,8
390+  C4B3 80               add b                           ; move one cell right
391+  C4B4 47               ld b,a
392+  C4B5 23               inc hl                          ; memory location of cell to the right now in hl
393+  C4B6 CD DE C2         call movement_spaceisempty       ; check space is empty
394+  C4B9 7B               ld a,e                          ; check space empty flag
395+  C4BA FE 00            cp 0
396+  C4BC CA C5 C4         jp z, movement_checkcanmove_right1 ; can't move
397+  C4BF CD FF C7         call player_justmoved
398+  C4C2 C1               pop bc
399+  C4C3 F1               pop af
400+  C4C4 C9               ret
401+  C4C5              movement_checkcanmove_right1:
402+  C4C5 C1               pop bc
403+  C4C6 CD 1D AC         call sprites_scadd              ; get the memory location of cell into de
404+  C4C9 62 6B            ld hl,de
405+  C4CB 23               inc hl                          ; memory location of cell to the right now in hl
406+  C4CC C5               push bc
407+  C4CD CD 8E C3         call movement_spaceisdiggable    ; can't move here, but can we dig
408+  C4D0 11 00 00         ld de,0
409+  C4D3 C1               pop bc
410+  C4D4 F1               pop af
411+  C4D5 C9               ret
412+  C4D6
413+  C4D6              ;
414+  C4D6              ; Checks if the player can move left
415+  C4D6              ; Inputs:
416+  C4D6              ; bc - player coords, b horiz, c vert
417+  C4D6              ; Outputs:
418+  C4D6              ; de - 1 can move
419+  C4D6              movement_checkcanmove_left:
420+  C4D6 F5               push af
421+  C4D7 C5               push bc
422+  C4D8 CD 1D AC         call sprites_scadd              ; get the memory location of cell into de
423+  C4DB 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
424+  C4DD 78               ld a,b
425+  C4DE 06 08            ld b,8
426+  C4E0 90               sub b                           ; move one cell left
427+  C4E1 47               ld b,a
428+  C4E2 2B               dec hl                          ; memory location of cell to the right now in hl
429+  C4E3 CD DE C2         call movement_spaceisempty       ; check space is empty
430+  C4E6 7B               ld a,e                          ; check space empty flag
431+  C4E7 FE 00            cp 0
432+  C4E9 CA F2 C4         jp z, movement_checkcanmove_left1 ; can't move
433+  C4EC CD FF C7         call player_justmoved
434+  C4EF C1               pop bc
435+  C4F0 F1               pop af
436+  C4F1 C9               ret
437+  C4F2              movement_checkcanmove_left1:
438+  C4F2 C1               pop bc
439+  C4F3 CD 1D AC         call sprites_scadd              ; get the memory location of cell into de
440+  C4F6 62 6B            ld hl,de
441+  C4F8 2B               dec hl                          ; memory location of cell to the right now in hl
442+  C4F9 C5               push bc
443+  C4FA CD 8E C3         call movement_spaceisdiggable    ; can't move here, but can we dig
444+  C4FD 11 00 00         ld de,0
445+  C500 C1               pop bc
446+  C501 F1               pop af
447+  C502 C9               ret
# file closed: game/movement.asm
157   C503                  include "game\game.asm"
# file opened: game/game.asm
  1+  C503              ;
  2+  C503              ; The current frame count, incremented each frame
  3+  C503              ;
  4+  C503              game_framenumber:
  5+  C503 00               defb    0
  6+  C504
  7+  C504              ;
  8+  C504              ; The number of players
  9+  C504              ;
 10+  C504              game_numberplayers:
 11+  C504 01               defb 1
 12+  C505
 13+  C505              ;
 14+  C505              ; The current player
 15+  C505              ;
 16+  C505              game_currentplayer:
 17+  C505 01               defb 1
 18+  C506
 19+  C506              ;
 20+  C506              ; The default number of lives
 21+  C506              ;
 22+  C506              game_numberlives:
 23+  C506 04               defb 4
 24+  C507
 25+  C507              ;
 26+  C507              ; The current difficulty
 27+  C507              ;
 28+  C507              game_difficulty:
 29+  C507 01               defb 1
 30+  C508
 31+  C508              ;
 32+  C508              ; Control method: 0 for keyboard, 1 for kempston
 33+  C508              ;
 34+  C508              game_control:
 35+  C508 00               defb 0
 36+  C509
 37+  C509              ;
 38+  C509              ; The current rocks used
 39+  C509              ;
 40+  C509              game_current_rocks:
 41+  C509 00 00            defb 0,0
 42+  C50B
 43+  C50B
 44+  C50B              game_tankdifficulty:
 45+  C50B 46 41 3C 37      defb 70,65,60,55,50,45,40,35,30,25,20,12
 45+  C50F 32 2D 28 23
 45+  C513 1E 19 14 0C
 46+  C517              game_pitdifficulty:
 47+  C517 07 05 05 04      defb 7,5,5,4,4,4,2,2,2,2,2,2
 47+  C51B 04 04 02 02
 47+  C51F 02 02 02 02
 48+  C523              game_robotdifficulty:
 49+  C523 06 04 04 04      defb 6,4,4,4,3,3,3,2,0,0,0,0
 49+  C527 03 03 03 02
 49+  C52B 00 00 00 00
 50+  C52F              game_digdifficulty:
 51+  C52F 14 0E 0A 0A      defb 20,14,10,10,8,8,8,8,6,6,6,4
 51+  C533 08 08 08 08
 51+  C537 06 06 06 04
 52+  C53B              game_rockdifficulty:
 53+  C53B 28 1C 14 14      defb 40,28,20,20,18,18,18,18,18,18,18,18
 53+  C53F 12 12 12 12
 53+  C543 12 12 12 12
 54+  C547              game_missiledifficulty:
 55+  C547 46 32 2D 2D      defb 70,50,45,45,40,35,35,30,30,25,25,20
 55+  C54B 28 23 23 1E
 55+  C54F 1E 19 19 14
 56+  C553              ;
 57+  C553              ; Moves to the next player
 58+  C553              ;
 59+  C553              game_changeplayer:
 60+  C553 3A 04 C5         ld a,(game_numberplayers)
 61+  C556 FE 01            cp 1
 62+  C558 C8               ret z                       ; if just one player, no need to change
 63+  C559 3A 05 C5         ld a,(game_currentplayer)   ; get current player
 64+  C55C 3D               dec a                       ; otherwise decrease by one
 65+  C55D EE 01            xor 1                       ; xor with one to flip
 66+  C55F 3C               inc a                       ; increment
 67+  C560 21 05 C5         ld hl,game_currentplayer
 68+  C563 77               ld (hl),a                   ; store
 69+  C564 C9               ret
 70+  C565
 71+  C565              ;
 72+  C565              ; Sets the number of players at the start of the game
 73+  C565              ; Inputs:
 74+  C565              ; a - number of players
 75+  C565              game_setnumberofplayers:
 76+  C565 21 04 C5         ld hl,game_numberplayers
 77+  C568 77               ld (hl),a
 78+  C569
 79+  C569              ;
 80+  C569              ; Starts a game
 81+  C569              ;
 82+  C569              game_init:
 83+  C569 3E 01            ld a,1
 84+  C56B 32 05 C5         ld (game_currentplayer),a
 85+  C56E C9               ret
 86+  C56F
 87+  C56F              ;
 88+  C56F              ; Sets the current rock layout. Odd gets 1, even gets 2
 89+  C56F              ;
 90+  C56F              game_setcurrentrocks:
 91+  C56F 3A 07 C5         ld a,(game_difficulty)
 92+  C572 E6 01            and 1
 93+  C574 FE 00            cp 0
 94+  C576 CA 84 C5         jp z,game_setcurrentrocks0
 95+  C579 11 6F B6         ld de,level_rocks
 96+  C57C 21 09 C5         ld hl,game_current_rocks
 97+  C57F 73 23 72 2B      ld (hl),de
 98+  C583 C9               ret
 99+  C584              game_setcurrentrocks0:
100+  C584 11 6F B7         ld de,level_rocks_alt
101+  C587 21 09 C5         ld hl,game_current_rocks
102+  C58A 73 23 72 2B      ld (hl),de
103+  C58E C9               ret
104+  C58F
105+  C58F              ;
106+  C58F              ; Increment frame number by 1
107+  C58F              ;
108+  C58F              game_incrementframe:
109+  C58F 3A 03 C5         ld a,(game_framenumber)
110+  C592 FE FF            cp 255
111+  C594 C2 99 C5         jp nz,game_incrementframe0
112+  C597 3E 00            ld a,0
113+  C599              game_incrementframe0:
114+  C599 3C               inc a
115+  C59A 32 03 C5         ld (game_framenumber),a
116+  C59D C9               ret
117+  C59E
118+  C59E              ;
119+  C59E              ; Returns current frame
120+  C59E              ; Outputs:
121+  C59E              ; a - current frame
122+  C59E              ;
123+  C59E              game_getcurrentframe:
124+  C59E 3A 03 C5         ld a,(game_framenumber)
125+  C5A1 C9               ret
126+  C5A2
127+  C5A2              ;
128+  C5A2              ; Resets current frame
129+  C5A2              ;
130+  C5A2              game_resetcurrentframe:
131+  C5A2 21 03 C5         ld hl,game_framenumber
132+  C5A5 36 00            ld (hl),0
133+  C5A7 C9               ret
134+  C5A8
135+  C5A8              ;
136+  C5A8              ; Increases the current difficulty
137+  C5A8              ;
138+  C5A8              game_increasedifficulty:
139+  C5A8 3A 07 C5         ld a,(game_difficulty)
140+  C5AB 3C               inc a
141+  C5AC 32 07 C5         ld (game_difficulty),a
142+  C5AF
143+  C5AF              ;
144+  C5AF              ; Sets the various difficulties
145+  C5AF              ;
146+  C5AF              game_setdifficulty:
147+  C5AF 3A 07 C5         ld a,(game_difficulty)
148+  C5B2 FE 0D            cp 13
149+  C5B4 C2 B9 C5         jp nz,game_setdifficulty0
150+  C5B7 3E 0C            ld a,12                         ; limit difficulty to twelve
151+  C5B9              game_setdifficulty0:
152+  C5B9 11 00 00         ld de,0
153+  C5BC 5F               ld e,a                          ; keep the difficulty in de
154+  C5BD                  ; Set the tank difficulty
155+  C5BD 21 0B C5         ld hl,game_tankdifficulty
156+  C5C0 2B               dec hl
157+  C5C1 19               add hl,de                       ; add the difficulty
158+  C5C2 7E               ld a,(hl)                       ; get the value
159+  C5C3 32 82 C9         ld (tank_speed),a               ; set the tank speed
160+  C5C6                  ; Set the pit difficulty
161+  C5C6 21 17 C5         ld hl,game_pitdifficulty
162+  C5C9 2B               dec hl
163+  C5CA 19               add hl,de                       ; add the difficulty
164+  C5CB 7E               ld a,(hl)                       ; get the value
165+  C5CC 32 53 D1         ld (thepit_speed),a               ; set the pit speed
166+  C5CF                  ; Set the robot difficulty
167+  C5CF 21 23 C5         ld hl,game_robotdifficulty
168+  C5D2 2B               dec hl
169+  C5D3 19               add hl,de                       ; add the difficulty
170+  C5D4 7E               ld a,(hl)                       ; get the value
171+  C5D5 32 31 D3         ld (robots_robotspeed),a        ; set the robot speed
172+  C5D8                  ; Set the dig difficulty
173+  C5D8 21 2F C5         ld hl,game_digdifficulty
174+  C5DB 2B               dec hl
175+  C5DC 19               add hl,de                       ; add the difficulty
176+  C5DD 7E               ld a,(hl)                       ; get the value
177+  C5DE 32 DD C2         ld (movement_numberdigframes),a ; set the dig frames
178+  C5E1                  ; Set the rock difficulty
179+  C5E1 21 3B C5         ld hl,game_rockdifficulty
180+  C5E4 2B               dec hl
181+  C5E5 19               add hl,de                       ; add the difficulty
182+  C5E6 7E               ld a,(hl)                       ; get the value
183+  C5E7 32 9D CB         ld (rocks_numberofframestowobble),a ; set the wobble frames
184+  C5EA                  ; Set the missile difficulty
185+  C5EA 21 47 C5         ld hl,game_missiledifficulty
186+  C5ED 2B               dec hl
187+  C5EE 19               add hl,de                       ; add the difficulty
188+  C5EF 7E               ld a,(hl)                       ; get the value
189+  C5F0 32 8F CF         ld (missiles_speed),a           ; set the missile difficulty
190+  C5F3 C9               ret
# file closed: game/game.asm
158   C5F4                  include "game\player.asm"
# file opened: game/player.asm
  1+  C5F4              ;
  2+  C5F4              ;   Data for current player
  3+  C5F4              ;
  4+  C5F4              player:
  5+  C5F4 00 00            defb    0,0                 ; horiz,vert (+0,+1)
  6+  C5F6 02 00 01         defb    2,0,1               ; dir (0 up, 1 left, 2 right, 3 down), frame, frame transition count (+2,+3,+4)
  7+  C5F9 00               defb    0                   ; auto move remaining (+5)
  8+  C5FA 00 00 00         defb    0,0,0               ; is digging (0 no), digging count, pixels to di (+6,+7,+8)
  9+  C5FD 00               defb    0                   ; lives remaining (+9)
 10+  C5FE 00               defb    0                   ; died this life (+10)
 11+  C5FF 00 00            defb    0,0                 ; dying (+11), frames (+12)
 12+  C601 00               defb    0                   ; can finish level, whether can finish level or not (+13)
 13+  C602 00               defb    0                   ; difficulty (+14)
 14+  C603
 15+  C603              player_location:
 16+  C603 00               defb 0                      ; 0 normal, 1 diamond cavern, 2 the pit
 17+  C604
 18+  C604              ;
 19+  C604              ; Works out which part of the screen the player is in
 20+  C604              ; Pit is between 3,9 and 8,9
 21+  C604              ; Diamond cavern is between 11,22 and 22,28
 22+  C604              ;
 23+  C604              player_getlocation:
 24+  C604 ED 4B F4 C5      ld bc,(player)              ; get screen coords
 25+  C608 CD 43 AA         call screen_getcharcoordsfromscreencoords ; get char coords, c horiz
 26+  C60B 78               ld a,b                      ; check for pit first
 27+  C60C FE 09            cp 9                        ; if not on this row, not in the pit
 28+  C60E C2 1D C6         jp nz,player_getlocation0
 29+  C611 79               ld a,c                      ; check horizontal
 30+  C612 FE 09            cp 9
 31+  C614 D2 1D C6         jp nc, player_getlocation0  ; if more than 9, not in the pit
 32+  C617 21 03 C6         ld hl,player_location
 33+  C61A 36 02            ld (hl),2                   ; load location with 2, the pit
 34+  C61C C9               ret                         ; done
 35+  C61D              player_getlocation0:            ; check for diamond cavern
 36+  C61D 78               ld a,b                      ; first check vertical
 37+  C61E FE 16            cp 22                       ; if above row 22, then not in cavern
 38+  C620 DA 34 C6         jp c,player_getlocation1
 39+  C623 79               ld a,c                      ; get the horizontal next
 40+  C624 FE 0B            cp 11
 41+  C626 DA 34 C6         jp c,player_getlocation1    ; if less than 11 not in diamond cave
 42+  C629 FE 17            cp 23
 43+  C62B D2 34 C6         jp nc,player_getlocation1    ; if less than 11 not in diamond cave
 44+  C62E 21 03 C6         ld hl,player_location
 45+  C631 36 01            ld (hl),1                   ; load location with 1, the cavern
 46+  C633 C9               ret
 47+  C634              player_getlocation1:
 48+  C634 21 03 C6         ld hl,player_location
 49+  C637 36 00            ld (hl),0                   ; load location with 2, the pit
 50+  C639 C9               ret                         ; done
 51+  C63A
 52+  C63A
 53+  C63A              ;
 54+  C63A              ; Initializes a player at start of game
 55+  C63A              ; Copy initial coords, copy lives, copy score
 56+  C63A              ;
 57+  C63A              player_init_gamestart:
 58+  C63A 3A 06 C5         ld a,(game_numberlives)
 59+  C63D 32 FB C6         ld (player1_lives),a
 60+  C640 32 FC C6         ld (player2_lives),a                        ; set the initial number of lives at game start
 61+  C643
 62+  C643 21 FF C6         ld hl,player1_score+2
 63+  C646 06 06            ld b,6
 64+  C648              player_init_gamestart0:
 65+  C648 36 30            ld (hl),48
 66+  C64A 23               inc hl
 67+  C64B 10 FB            djnz player_init_gamestart0                 ; zero out player 1 score
 68+  C64D 21 08 C7         ld hl,player2_score+2
 69+  C650 06 06            ld b,6
 70+  C652              player_init_gamestart1:
 71+  C652 36 30            ld (hl),48
 72+  C654 23               inc hl
 73+  C655 10 FB            djnz player_init_gamestart1                 ; zero out player 2 score
 74+  C657 3E 01            ld a,1
 75+  C659 32 0F C7         ld (player1_difficulty),a
 76+  C65C 32 10 C7         ld (player2_difficulty),a                   ; set player difficulties to zero
 77+  C65F C9               ret
 78+  C660
 79+  C660              ;
 80+  C660              ; Initializes a player at start of a life
 81+  C660              ; Copy initial coords, copy lives, copy score
 82+  C660              ;
 83+  C660              player_init_lifestart:
 84+  C660 21 F9 C5         ld hl,player+5
 85+  C663 06 09            ld b,9                      ; initialise 9 properties
 86+  C665              player_init_lifestart2:
 87+  C665 36 00            ld (hl),0
 88+  C667 23               inc hl
 89+  C668 10 FB            djnz player_init_lifestart2
 90+  C66A
 91+  C66A 21 F6 C5         ld hl,player+2              ; initialise some properties
 92+  C66D 36 02            ld (hl),2
 93+  C66F 23               inc hl
 94+  C670 36 00            ld (hl),0
 95+  C672 23               inc hl
 96+  C673 36 01            ld (hl),1
 97+  C675
 98+  C675 ED 4B EB 80      ld bc,(init_coord)
 99+  C679 ED 43 F4 C5      ld (player),bc
100+  C67D
101+  C67D 3A 05 C5         ld a,(game_currentplayer)
102+  C680 FE 01            cp 1
103+  C682 C2 8F C6         jp nz,player_init_lifestart4
104+  C685 01 FD C5         ld bc,player+9
105+  C688 3A FB C6         ld a,(player1_lives)
106+  C68B 02               ld (bc),a
107+  C68C C3 96 C6         jp player_init_lifestart3
108+  C68F              player_init_lifestart4:
109+  C68F 01 FD C5         ld bc,player+9
110+  C692 3A FC C6         ld a,(player2_lives)
111+  C695 02               ld (bc),a
112+  C696              player_init_lifestart3:
113+  C696 CD 57 CF         call diamonds_init      ; initialise gems
114+  C699 01 06 00         ld bc,6
115+  C69C 11 00 CD         ld de,scores_current+2
116+  C69F 3A 05 C5         ld a,(game_currentplayer)
117+  C6A2 FE 01            cp 1
118+  C6A4 C2 B3 C6         jp nz,player_init_lifestart0
119+  C6A7 3A 0F C7         ld a,(player1_difficulty)       ; initialise player 1 difficulty
120+  C6AA 32 07 C5         ld (game_difficulty),a
121+  C6AD 21 FF C6         ld hl,player1_score+2           ; itialise player 1 scores
122+  C6B0 C3 BC C6         jp player_init_lifestart1
123+  C6B3              player_init_lifestart0:
124+  C6B3 3A 10 C7         ld a,(player2_difficulty)       ; initialise player 2 difficulty
125+  C6B6 32 07 C5         ld (game_difficulty),a
126+  C6B9 21 08 C7         ld hl,player2_score+2           ; initialise player 2 scores
127+  C6BC              player_init_lifestart1:
128+  C6BC ED B0            ldir
129+  C6BE C9               ret
130+  C6BF
131+  C6BF
132+  C6BF              ;
133+  C6BF              ; Copies the current score and difficulty in the current player
134+  C6BF              ;
135+  C6BF              player_recordcurrentstate:
136+  C6BF 01 06 00         ld bc,6                  ; copy current score back to correct player
137+  C6C2 21 00 CD         ld hl,scores_current+2
138+  C6C5 3A 05 C5         ld a,(game_currentplayer)
139+  C6C8 FE 01            cp 1
140+  C6CA C2 DF C6         jp nz,player_recordcurrentstate0
141+  C6CD 3A 07 C5         ld a,(game_difficulty)
142+  C6D0 32 0F C7         ld (player1_difficulty),a       ; store difficulty
143+  C6D3 11 FF C6         ld de,player1_score+2
144+  C6D6 3A FD C5         ld a,(player+9)
145+  C6D9 32 FB C6         ld (player1_lives),a              ; record lives
146+  C6DC C3 EE C6         jp player_recordcurrentstate1
147+  C6DF              player_recordcurrentstate0:         ; do player 2
148+  C6DF 3A 07 C5         ld a,(game_difficulty)
149+  C6E2 32 10 C7         ld (player2_difficulty),a       ; store difficulty
150+  C6E5 3A FD C5         ld a,(player+9)
151+  C6E8 32 FC C6         ld (player2_lives),a              ; record lives
152+  C6EB 11 08 C7         ld de,player2_score+2
153+  C6EE              player_recordcurrentstate1:
154+  C6EE ED B0            ldir
155+  C6F0 C9               ret
156+  C6F1
157+  C6F1              ;
158+  C6F1              ; Player just died, subtract a life
159+  C6F1              ;
160+  C6F1              player_died:
161+  C6F1 01 FD C5         ld bc,player+9
162+  C6F4 0A               ld a,(bc)
163+  C6F5 3D               dec a
164+  C6F6 02               ld (bc),a
165+  C6F7 CD BF C6         call player_recordcurrentstate
166+  C6FA C9               ret
167+  C6FB
168+  C6FB              ;
169+  C6FB              ; Player lives
170+  C6FB              ;
171+  C6FB              player1_lives:
172+  C6FB 03               defb 3
173+  C6FC              player2_lives:
174+  C6FC 03               defb 3
175+  C6FD
176+  C6FD              ;
177+  C6FD              ; Player scores
178+  C6FD              ;
179+  C6FD              player1_score:
180+  C6FD 04 01 30 30      defb 4,1,'000000',255
180+  C701 30 30 30 30
180+  C705 FF
181+  C706              player2_score:
182+  C706 16 01 30 30      defb 22,1,'000000',255
182+  C70A 30 30 30 30
182+  C70E FF
183+  C70F
184+  C70F              ;
185+  C70F              ; Player difficulties
186+  C70F              ;
187+  C70F              player1_difficulty:
188+  C70F 00               defb 0
189+  C710              player2_difficulty:
190+  C710 00               defb 0
191+  C711
192+  C711              ;
193+  C711              ; Kills a player this life
194+  C711              ;
195+  C711              player_killplayer:
196+  C711 21 FE C5         ld hl,player+10
197+  C714 36 01            ld (hl),1
198+  C716 C9               ret
199+  C717
200+  C717              ;
201+  C717              ; Crush a player this life
202+  C717              ;
203+  C717              player_crushplayer:
204+  C717 21 FF C5         ld hl,player+11             ; mark as crushed
205+  C71A 36 01            ld (hl),1
206+  C71C C9               ret
207+  C71D
208+  C71D              player_tankkillplayer
209+  C71D 21 FF C5         ld hl,player+11             ; mark as tanked
210+  C720 36 02            ld (hl),2
211+  C722 C9               ret
212+  C723
213+  C723              player_zonkplayer
214+  C723 21 FF C5         ld hl,player+11             ; mark as zonked (missile)
215+  C726 36 03            ld (hl),3
216+  C728 C9               ret
217+  C729
218+  C729              player_pitkillplayer
219+  C729 21 FF C5         ld hl,player+11             ; mark as pit killed
220+  C72C 36 04            ld (hl),4
221+  C72E C9               ret
222+  C72F
223+  C72F              player_robotkillplayer
224+  C72F 21 FF C5         ld hl,player+11             ; mark as robot killed
225+  C732 36 05            ld (hl),5
226+  C734 C9               ret
227+  C735
228+  C735              ;
229+  C735              ; Draws the player at the current position or deletes them
230+  C735              ;
231+  C735              player_drawplayer:
232+  C735 3A F6 C5         ld a,(player+2)             ; get the current direction
233+  C738 FE 03            cp 3
234+  C73A C2 3F C7         jp nz,player_drawplayer0
235+  C73D 3E 00            ld a,0                      ; if 3, then down, so set the direction to 0 since the sprite is the same as up
236+  C73F              player_drawplayer0:             ; DYING CHECKS
237+  C73F 5F               ld e,a                      ; store in e
238+  C740 3A FF C5         ld a,(player+11)             ; get the dying flag
239+  C743 FE 01            cp 1
240+  C745 CA 7F C7         jp z,player_drawplayer3     ; if it's one, we're being crushed
241+  C748 FE 04            cp 4
242+  C74A CA C7 C7         jp z,player_drawplayer9     ; player is falling into the pit
243+  C74D FE 05            cp 5
244+  C74F CA E3 C7         jp z,player_drawplayer12    ; player has been killed by a robot
245+  C752              player_drawplayer4:             ; CHECK FOR DIGGING
246+  C752 3A FA C5         ld a,(player+6)             ; get the dig flag
247+  C755 FE 01            cp 1
248+  C757 CA 68 C7         jp z,player_drawplayer1    ; get dig frame
249+  C75A 3A F7 C5         ld a,(player+3)             ; this is normal movement so get the current frame
250+  C75D 83               add a,e
251+  C75E C3 6D C7         jp player_drawplayer2
252+  C761              player_drawplayer6:             ; GETTING THE DIG FRAM
253+  C761 E6 01            and 1                       ; check for odd
254+  C763 C6 0A            add 10                      ; add 10, to get either 10 or 11
255+  C765 C3 6D C7         jp player_drawplayer2
256+  C768              player_drawplayer1:             ; GET THE NORMAL FRAME
257+  C768 3A F6 C5         ld a,(player+2)             ; digging, get the current direction again, because want all four
258+  C76B C6 06            add a,6                     ; add direction to 6 to get frame
259+  C76D              player_drawplayer2:             ; WORK OUT THE FRAME
260+  C76D 07               rlca
261+  C76E 07               rlca
262+  C76F 07               rlca                        ; multiply by eight
263+  C770 6F               ld l,a
264+  C771 26 00            ld h,0
265+  C773 11 50 BE         ld de,player_sprite
266+  C776 19               add hl,de                   ; load hl with the location of the player sprite data
267+  C777              player_drawplayer7:             ; DRAW THE PlAYER
268+  C777 ED 4B F4 C5      ld bc,(player)              ; load bc with the start coords
269+  C77B CD 15 AB         call sprites_drawsprite     ; call the routine to draw the sprite
270+  C77E                  ;call player_storeupdatedlines ; log updated rows
271+  C77E C9               ret
272+  C77F              ;
273+  C77F              ; CRUSHING
274+  C77F              ;
275+  C77F              player_drawplayer3:
276+  C77F 21 00 C6         ld hl,player+12
277+  C782 7E               ld a,(hl)                  ; crushing, so get the current anim flag
278+  C783 FE 00            cp 0
279+  C785 C2 8E C7         jp nz,player_drawplayer5    ; if this isn't zero, then this isn't the first time round, so do the crush anim
280+  C788 3E 64            ld a,100
281+  C78A 77               ld (hl),a                   ; otherwise, load up the anim frames
282+  C78B C3 52 C7         jp player_drawplayer4       ; and return to the main loop to remove the current frame
283+  C78E              player_drawplayer5:
284+  C78E 3D               dec a
285+  C78F 77               ld (hl),a
286+  C790 FE 00            cp 0
287+  C792 CC 11 C7         call z,player_killplayer     ; final animation, so kill the player
288+  C795 FE 0A            cp 10                         ; play the sound
289+  C797 CC 33 B2         call z, sound_rockfell
290+  C79A FE 14            cp 20                        ; check if we should move the rock
291+  C79C C2 B0 C7         jp nz,player_drawplayer8
292+  C79F D9               exx
293+  C7A0 F5               push af
294+  C7A1 ED 4B 9E CB      ld bc,(rocks_killerrock)    ; get the coords of the rock that killed us
295+  C7A5 21 9C BD         ld hl,sprites+72
296+  C7A8 CD 15 AB         call sprites_drawsprite     ; draw a rock over current
297+  C7AB F1               pop af
298+  C7AC D9               exx
299+  C7AD C3 61 C7         jp player_drawplayer6       ; continue drawing player
300+  C7B0              player_drawplayer8:
301+  C7B0 FE 14            cp 20
302+  C7B2 D2 61 C7         jp nc,player_drawplayer6    ; if not in last 10 frames, draw as normal
303+  C7B5 ED 4B F4 C5      ld bc,(player)
304+  C7B9 CD 43 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
305+  C7BC 3E 42            ld a,66             ; load red
306+  C7BE CD 9B AA         call screen_setattr
307+  C7C1 21 9C BD         ld hl,sprites+72            ; otherwise, player is rock
308+  C7C4 C3 77 C7         jp player_drawplayer7
309+  C7C7              ;
310+  C7C7              ; FALLING
311+  C7C7              ;
312+  C7C7              player_drawplayer9:             ; player is falling into the pit
313+  C7C7 21 00 C6         ld hl,player+12
314+  C7CA 7E               ld a,(hl)                   ; get the frames
315+  C7CB FE 00            cp 0
316+  C7CD C2 D6 C7         jp nz,player_drawplayer10    ; if this isn't zero, then this isn't the first time round, so do the crush anim
317+  C7D0 3E 50            ld a,80
318+  C7D2 77               ld (hl),a                   ; otherwise, load up the anim frames
319+  C7D3 C3 52 C7         jp player_drawplayer4       ; and return to the main loop to remove the current frame
320+  C7D6              player_drawplayer10:
321+  C7D6 3D               dec a
322+  C7D7 77               ld (hl),a
323+  C7D8 FE 00            cp 0
324+  C7DA CC 11 C7         call z,player_killplayer     ; final frame, so kill the player
325+  C7DD 3A F7 C5         ld a,(player+3)
326+  C7E0 C3 6D C7         jp player_drawplayer2
327+  C7E3              ;
328+  C7E3              ; ROBOT KILLED
329+  C7E3              ;
330+  C7E3              player_drawplayer12:
331+  C7E3 21 00 C6         ld hl,player+12
332+  C7E6 7E               ld a,(hl)                   ; get the frames
333+  C7E7 FE 00            cp 0
334+  C7E9 C2 F2 C7         jp nz,player_drawplayer13    ; if this isn't zero, then this isn't the first time round, so do the crush anim
335+  C7EC 3E C8            ld a,200
336+  C7EE 77               ld (hl),a                   ; otherwise, load up the anim frames
337+  C7EF C3 52 C7         jp player_drawplayer4       ; and return to the main loop to remove the current frame
338+  C7F2              player_drawplayer13:
339+  C7F2 3D               dec a
340+  C7F3 77               ld (hl),a
341+  C7F4 FE 00            cp 0
342+  C7F6 CC 11 C7         call z,player_killplayer     ; final frame, so kill the player
343+  C7F9 3A F7 C5         ld a,(player+3)
344+  C7FC C3 6D C7         jp player_drawplayer2
345+  C7FF
346+  C7FF              ;
347+  C7FF              ; Runs after the player just moved. Changes animation frame if required
348+  C7FF              ;
349+  C7FF              player_justmoved:
350+  C7FF D9               exx
351+  C800 3A F8 C5         ld a,(player+4)             ; get the transition count
352+  C803 FE 00            cp 0
353+  C805 CA 0B C8         jp z, player_justmoved2     ; if zero reset and change the frame
354+  C808 C3 25 C8         jp player_justmoved1       ; otherwise decrease and continue
355+  C80B              player_justmoved2:
356+  C80B                  ; reset and change frame in here
357+  C80B 3E 01            ld a,1
358+  C80D 32 F8 C5         ld (player+4),a            ; reset back to whatever
359+  C810 3A F7 C5         ld a,(player+3)             ; load the frame
360+  C813 FE 03            cp 3                       ; flip between 3 and 0
361+  C815 C2 1D C8         jp nz, player_justmoved4
362+  C818 3E 00            ld a,0
363+  C81A C3 1F C8         jp player_justmoved5
364+  C81D              player_justmoved4:
365+  C81D 3E 03            ld a,3
366+  C81F              player_justmoved5:
367+  C81F 32 F7 C5         ld (player+3),a           ; save back
368+  C822 C3 29 C8         jp player_justmoved3
369+  C825              player_justmoved1:
370+  C825                  ; decrease count
371+  C825 3D               dec a
372+  C826 32 F8 C5         ld (player+4),a
373+  C829              player_justmoved3:
374+  C829 D9               exx;
375+  C82A C9               ret
376+  C82B
377+  C82B              ;
378+  C82B              ; Called if the player has collected a diamond. Checks the current coord. If it is the start coord, then return complete
379+  C82B              ; Outputs:
380+  C82B              ; a - 1 for completed level
381+  C82B              player_checkforexit:
382+  C82B ED 4B F4 C5      ld bc,(player)                 ; get player coords
383+  C82F ED 5B EB 80      ld de,(init_coord)             ; get start coords
384+  C833 78               ld a,b
385+  C834 BA               cp d                         ; compare horiz
386+  C835 C2 40 C8         jp nz,player_checkforexit1
387+  C838 79               ld a,c
388+  C839 BB               cp e                        ; compare vert
389+  C83A C2 40 C8         jp nz,player_checkforexit1
390+  C83D              player_checkforexit0:
391+  C83D 3E 01            ld a,1                       ; hasn't completed
392+  C83F C9               ret
393+  C840              player_checkforexit1:
394+  C840 3E 00            ld a,0                       ; has completed
395+  C842 C9               ret
# file closed: game/player.asm
159   C843                  include "game\ship.asm"
# file opened: game/ship.asm
  1+  C843              ;
  2+  C843              ; Ship initial position: vert,horiz
  3+  C843              ;
  4+  C843              ship_initpos:
  5+  C843 00 24            defb 0,36
  6+  C845              ship_initpos2:
  7+  C845 00 00            defb 0,0
  8+  C847              ship_frame:
  9+  C847 00               defb 0
 10+  C848              ;
 11+  C848              ; The current memory location
 12+  C848              ;
 13+  C848              ship_current_sprite:
 14+  C848 00 00            defb 0,0
 15+  C84A
 16+  C84A              ship_current_coords:
 17+  C84A 00 00            defb 0,0
 18+  C84C
 19+  C84C              ship_process:
 20+  C84C 3A FF C5         ld a,(player+11)
 21+  C84F FE 02            cp 2                        ; has the player been killed by tank?
 22+  C851 C0               ret nz                      ; do nothing if not
 23+  C852 CD D0 C2         call control_scroll_up           ; make sure the screen is on the top screen
 24+  C855 CD CF C8         call ship_takeoff           ; bye bye
 25+  C858 CD 11 C7         call player_killplayer      ; killed
 26+  C85B 06 32            ld b,50
 27+  C85D CD 64 81         call utilities_pauseforframes
 28+  C860 C9               ret
 29+  C861
 30+  C861              ;
 31+  C861              ;   Draw and land the ship - first move the ship down, then across, drawing the player in the middle
 32+  C861              ;
 33+  C861              ship_land:
 34+  C861 ED 4B 43 C8      ld bc,(ship_initpos)
 35+  C865 ED 43 45 C8      ld (ship_initpos2),bc        ; save the initial position for later use
 36+  C869 1E 00            ld e,0                      ; store a flag to track first time round
 37+  C86B 06 09            ld b,9                      ; move down 8 pixels
 38+  C86D              ship_land0:
 39+  C86D C5               push bc
 40+  C86E 7B               ld a,e
 41+  C86F D5               push de                     ; store de for next time round
 42+  C870 FE 01            cp 1                        ; check first time flag
 43+  C872 C2 87 C8         jp nz,ship_land1             ; don't draw over previous one if first time
 44+  C875 CD 1A C9         call ship_draw_full         ; delete old one
 45+  C878 CD FE C8         call ship_change_frame      ; increment the frame
 46+  C87B ED 4B 45 C8      ld bc,(ship_initpos2)       ; get the current coords
 47+  C87F 81 C6 01         add c,1                     ; move down one pixels
 48+  C882 4F               ld c,a
 49+  C883 ED 43 45 C8      ld (ship_initpos2),bc
 50+  C887              ship_land1:
 51+  C887 CD 1A C9         call ship_draw_full         ; draw the ship
 52+  C88A D1               pop de
 53+  C88B 7B               ld a,e
 54+  C88C FE 00            cp 0
 55+  C88E C2 94 C8         jp nz,ship_land4
 56+  C891 CD 0D B2         call sound_pitchbend        ; play sound if first frame
 57+  C894              ship_land4:
 58+  C894 D5               push de
 59+  C895 CD 13 C9         call ship_draw_screen
 60+  C898 D1               pop de
 61+  C899 1E 01            ld e,1
 62+  C89B C1               pop bc
 63+  C89C 10 CF            djnz ship_land0             ; repeat for downward movement
 64+  C89E                  ; done moving down
 65+  C89E                  ; now move across
 66+  C89E CD 35 C7         call player_drawplayer      ; draw player
 67+  C8A1 CD 1A C9         call ship_draw_full         ; delete old one
 68+  C8A4 1E 00            ld e,0                      ; store a flag to track first time round
 69+  C8A6 06 14            ld b,20                      ; move back 20 pixels pixels
 70+  C8A8              ship_land3:
 71+  C8A8 C5               push bc
 72+  C8A9 7B               ld a,e
 73+  C8AA D5               push de                     ; store de for next time round
 74+  C8AB FE 01            cp 1                        ; check first time flag
 75+  C8AD C2 C2 C8         jp nz,ship_land2             ; don't draw over previous one if first time
 76+  C8B0 CD 1A C9         call ship_draw_full         ; delete old one
 77+  C8B3 CD FE C8         call ship_change_frame      ; increment the frame
 78+  C8B6 ED 4B 45 C8      ld bc,(ship_initpos2)       ; get the current coords
 79+  C8BA 78               ld a,b
 80+  C8BB D6 01            sub 1                       ; move back one pixels
 81+  C8BD 47               ld b,a
 82+  C8BE ED 43 45 C8      ld (ship_initpos2),bc
 83+  C8C2              ship_land2:
 84+  C8C2 CD 1A C9         call ship_draw_full         ; draw the ship
 85+  C8C5 CD 13 C9         call ship_draw_screen       ; draw the frame to screen by clearing the buffer
 86+  C8C8 D1               pop de
 87+  C8C9 1E 01            ld e,1                      ; set e to 1 to indicate >1 time
 88+  C8CB C1               pop bc
 89+  C8CC 10 DA            djnz ship_land3             ; repeat for vertical movement
 90+  C8CE C9               ret
 91+  C8CF
 92+  C8CF              ;
 93+  C8CF              ;   Take off the ship
 94+  C8CF              ;
 95+  C8CF              ship_takeoff:
 96+  C8CF CD 20 B2         call sound_pitchbenddown
 97+  C8D2 1E 01            ld e,1                      ; store a flag to track first time round
 98+  C8D4 06 08            ld b,8                      ; move up 8 pixels
 99+  C8D6              ship_takeoff0:
100+  C8D6 C5               push bc
101+  C8D7 7B               ld a,e
102+  C8D8 D5               push de                     ; store de for next time round
103+  C8D9 FE 01            cp 1                        ; check first time flag
104+  C8DB C2 F1 C8         jp nz,ship_takeoff1             ; don't draw over previous one if first time
105+  C8DE ED 4B 45 C8      ld bc,(ship_initpos2)       ; get the current coords
106+  C8E2 CD 1A C9         call ship_draw_full         ; delete old one
107+  C8E5 CD FE C8         call ship_change_frame      ; increment the frame
108+  C8E8 ED 4B 45 C8      ld bc,(ship_initpos2)       ; get the current coords
109+  C8EC 0D               dec c                       ; move up one pixels
110+  C8ED ED 43 45 C8      ld (ship_initpos2),bc
111+  C8F1              ship_takeoff1:
112+  C8F1 CD 1A C9         call ship_draw_full         ; draw the ship
113+  C8F4 CD 13 C9         call ship_draw_screen
114+  C8F7 D1               pop de
115+  C8F8 1E 01            ld e,1
116+  C8FA C1               pop bc
117+  C8FB 10 D9            djnz ship_takeoff0             ; repeat for upward movement
118+  C8FD                  ; done moving up
119+  C8FD C9               ret
120+  C8FE
121+  C8FE              ;
122+  C8FE              ; Swap the animation frame between 0 and 32. This will be added to the memory location later
123+  C8FE              ;
124+  C8FE              ship_change_frame:
125+  C8FE F5               push af
126+  C8FF 3A 47 C8         ld a,(ship_frame)
127+  C902 FE 00            cp 0
128+  C904 CA 0C C9         jp z,ship_change_frame0
129+  C907 3E 00            ld a,0                      ; flip to 0
130+  C909 C3 0E C9         jp ship_change_frame1
131+  C90C              ship_change_frame0:
132+  C90C 3E 20            ld a,32                      ; flip to 32
133+  C90E              ship_change_frame1:
134+  C90E 32 47 C8         ld (ship_frame),a            ; save the frame
135+  C911 F1               pop af
136+  C912 C9               ret
137+  C913
138+  C913              ship_draw_screen:
139+  C913 76               halt
140+  C914 F3               di
141+  C915 CD 0C A8         call buffer_buffertoscreen  ; copy buffer to screen
142+  C918 FB               ei                          ; enable interupts
143+  C919 C9               ret
144+  C91A
145+  C91A              ship_draw_full:
146+  C91A 21 C0 BE         ld hl,ship_sprite
147+  C91D ED 4B 45 C8      ld bc,(ship_initpos2)         ; load bc with the start coords
148+  C921 22 48 C8         ld (ship_current_sprite),hl  ; put into memory
149+  C924 ED 43 4A C8      ld (ship_current_coords),bc  ; put into memory
150+  C928 CD 47 C9         call ship_draw
151+  C92B 08               ex af,af'
152+  C92C 3A 47 C8         ld a,(ship_frame)            ; get the animation frame
153+  C92F 16 00            ld d,0
154+  C931 5F               ld e,a
155+  C932 19               add hl,de
156+  C933 22 48 C8         ld (ship_current_sprite),hl  ; put into memory
157+  C936 08               ex af,af'
158+  C937 ED 4B 45 C8      ld bc,(ship_initpos2)         ; load bc with the start coords
159+  C93B 81 C6 08         add c,8                      ; move one line down
160+  C93E 4F               ld c,a
161+  C93F ED 43 4A C8      ld (ship_current_coords),bc  ; put into memory
162+  C943 CD 47 C9         call ship_draw
163+  C946 C9               ret
164+  C947
165+  C947              ;
166+  C947              ; Draw the ship
167+  C947              ; Inputs:
168+  C947              ; None, all in memory
169+  C947              ;
170+  C947              ship_draw:
171+  C947 3E 04            ld a,4                              ; 4 pieces per half
172+  C949              ship_draw0:
173+  C949 F5               push af
174+  C94A 2A 48 C8         ld hl,(ship_current_sprite)
175+  C94D ED 4B 4A C8      ld bc,(ship_current_coords)         ; load bc with the start coords
176+  C951 CD 15 AB         call sprites_drawsprite
177+  C954 2A 48 C8         ld hl,(ship_current_sprite)
178+  C957 ED 4B 4A C8      ld bc,(ship_current_coords)         ; load bc with the start coords
179+  C95B 11 08 00         ld de,8
180+  C95E 19               add hl,de
181+  C95F 80 C6 08         add b,8
182+  C962 47               ld b,a
183+  C963 22 48 C8         ld (ship_current_sprite),hl         ; put into memory
184+  C966 ED 43 4A C8      ld (ship_current_coords),bc         ; put into memory
185+  C96A F1               pop af
186+  C96B 3D               dec a
187+  C96C FE 00            cp 0
188+  C96E C2 49 C9         jp nz,ship_draw0
189+  C971
190+  C971 C9               ret
191+  C972
# file closed: game/ship.asm
160   C972                  include "game\tank.asm"
# file opened: game/tank.asm
  1+  C972              ;
  2+  C972              ; tank initial position: vert,horiz
  3+  C972              ;
  4+  C972              tank_initpos:
  5+  C972 10 D0            defb 16,208
  6+  C974              tank_initpos2:
  7+  C974 00 00            defb 0,0
  8+  C976              tank_frame:
  9+  C976 00               defb 0
 10+  C977              tank_anim:
 11+  C977 11               defb 17
 12+  C978
 13+  C978              ;
 14+  C978              ; The damage countdown
 15+  C978              ;
 16+  C978              tank_currentdamage:
 17+  C978 F0               defb 240
 18+  C979
 19+  C979              ;
 20+  C979              ; The damage coordinate
 21+  C979              ;
 22+  C979              tank_currentdamagecoord:
 23+  C979 16 02            defb 22,2
 24+  C97B
 25+  C97B              ;
 26+  C97B              ; Controls when the tank shoots
 27+  C97B              ;
 28+  C97B              tank_count:
 29+  C97B 00               defb 0
 30+  C97C
 31+  C97C              ;
 32+  C97C              ; Holds the block number of the current damage sprite
 33+  C97C              ;
 34+  C97C              tank_damageframe:
 35+  C97C 00               defb 0
 36+  C97D
 37+  C97D              ;
 38+  C97D              ; The current memory location
 39+  C97D              ;
 40+  C97D              tank_current_sprite:
 41+  C97D 00 00            defb 0,0
 42+  C97F
 43+  C97F              tank_current_coords:
 44+  C97F 00 00            defb 0,0
 45+  C981
 46+  C981              ;
 47+  C981              ; Is the missile displayed - will be 19 if so, 0 if not
 48+  C981              ;
 49+  C981              tank_missile_displayed:
 50+  C981 00               defb 0
 51+  C982
 52+  C982              ;
 53+  C982              ; Speed that the tank fires
 54+  C982              ;
 55+  C982              tank_speed:
 56+  C982 00               defb 0
 57+  C983
 58+  C983              ;
 59+  C983              ; Initialise the tank
 60+  C983              ;
 61+  C983              tank_init:
 62+  C983 ED 4B 72 C9      ld bc,(tank_initpos)
 63+  C987 ED 43 74 C9      ld (tank_initpos2),bc       ; save the initial position for later use
 64+  C98B 21 76 C9         ld hl,tank_frame
 65+  C98E 36 00            ld (hl),0
 66+  C990 21 77 C9         ld hl,tank_anim
 67+  C993 36 11            ld (hl),17
 68+  C995 21 7C C9         ld hl,tank_damageframe              ; reset tank
 69+  C998 36 00            ld (hl),0
 70+  C99A 21 7B C9         ld hl,tank_count
 71+  C99D 36 00            ld (hl),0
 72+  C99F 21 78 C9         ld hl,tank_currentdamage
 73+  C9A2 36 F0            ld (hl),240
 74+  C9A4 21 79 C9         ld hl,tank_currentdamagecoord
 75+  C9A7 36 16            ld (hl),22
 76+  C9A9 23               inc hl
 77+  C9AA 36 02            ld (hl),2
 78+  C9AC 21 81 C9         ld hl,tank_missile_displayed
 79+  C9AF 36 00            ld (hl),0
 80+  C9B1
 81+  C9B1 C9               ret
 82+  C9B2
 83+  C9B2              ;
 84+  C9B2              ;   Draw and move the tank
 85+  C9B2              ;   Start processing at frame 75
 86+  C9B2              ;   Don't move if anim is zero
 87+  C9B2              ;   Decrement frame if moved
 88+  C9B2              ;
 89+  C9B2              tank_process:
 90+  C9B2 3A 77 C9         ld a,(tank_anim)
 91+  C9B5 FE 00            cp 0
 92+  C9B7 C2 BE C9         jp nz,tank_process0         ; fire the tank if we've already moved, or jump to movement
 93+  C9BA CD D7 C9         call tank_fire
 94+  C9BD C9               ret
 95+  C9BE              tank_process0:
 96+  C9BE CD 9E C5         call game_getcurrentframe   ; get the current frame number into a
 97+  C9C1 FE 4B            cp 75
 98+  C9C3 D8               ret c                       ; return if the frame number is below 75
 99+  C9C4 CD 11 CB         call tank_move              ; move tank if not
100+  C9C7 3A 77 C9         ld a,(tank_anim)
101+  C9CA 3D               dec a
102+  C9CB 32 77 C9         ld (tank_anim),a            ; decrease the anim count
103+  C9CE FE 00            cp 0
104+  C9D0 C0               ret nz
105+  C9D1 3E 01            ld a,1
106+  C9D3 32 29 D3         ld (robots_spawntimer),a ; set the spawn speed low so that a robot spawns soon after the tank stops moving
107+  C9D6 C9               ret
108+  C9D7
109+  C9D7              ;
110+  C9D7              ; Fires the tank
111+  C9D7              ;
112+  C9D7              tank_fire:
113+  C9D7 3A 7B C9         ld a,(tank_count)            ; if not, don't do anything
114+  C9DA 3C               inc a                        ; increment
115+  C9DB ED 5B 82 C9      ld de,(tank_speed)
116+  C9DF BB               cp e                        ; have we reached the speed
117+  C9E0 C2 E5 C9         jp nz,tank_fire0
118+  C9E3 3E 00            ld a,0                       ; reset if reached fifty
119+  C9E5              tank_fire0:                      ; DEALING WITH A NEW BLOCK
120+  C9E5 32 7B C9         ld (tank_count),a            ; store tank count
121+  C9E8 FE 00            cp 0
122+  C9EA CA 0B CA         jp z,tank_fire7              ; If this is zero, fire
123+  C9ED 3A 81 C9         ld a,(tank_missile_displayed) ; is the missile displaying?
124+  C9F0 FE 00            cp 0
125+  C9F2 C8               ret z                       ; don't do anything if not
126+  C9F3 CD CB CA         call tank_missilegraphic     ; if not, overwrite the previous tank missile
127+  C9F6 3E 00            ld a,0                       ; reset the flag
128+  C9F8 32 81 C9         ld (tank_missile_displayed),a
129+  C9FB 3E 02            ld a,2
130+  C9FD ED 4B 79 C9      ld bc,(tank_currentdamagecoord)
131+  CA01 0C               inc c
132+  CA02 0C               inc c
133+  CA03 ED 43 3F AC      ld (origcoords),bc
134+  CA07 CD 31 A7         call buffer_marklineforupdate
135+  CA0A C9               ret                        ; only shoot if we're on 0
136+  CA0B              tank_fire7:
137+  CA0B 3A 78 C9         ld a,(tank_currentdamage)    ; get the damage countdown
138+  CA0E E6 07            and 7                       ; check if multiple of 8 - house keeping when moving onto a new block
139+  CA10 C2 46 CA         jp nz,tank_fire1            ; not, so just do a normal frame
140+  CA13 ED 4B 79 C9      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
141+  CA17 79               ld a,c
142+  CA18 FE 0A            cp 10
143+  CA1A C2 21 CA         jp nz, tank_fire6
144+  CA1D CD 03 CB         call tank_killedbytank      ; we're through, so the player has died. Kill them.
145+  CA20 C9               ret                         ; return if we're through the mountain
146+  CA21              tank_fire6:
147+  CA21 3E 0F            ld a,15
148+  CA23 32 7C C9         ld (tank_damageframe),a     ; reset the damage frame
149+  CA26 21 54 BD         ld hl,sprites               ; location of the empty block
150+  CA29 CD 6D AA         call screen_showchar        ; show this character here
151+  CA2C ED 4B 79 C9      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
152+  CA30 05               dec b                       ; look one above
153+  CA31 CD D1 AA         call screen_ischarempty     ; check if it is empty
154+  CA34 ED 4B 79 C9      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc again
155+  CA38 FE 01            cp 1
156+  CA3A C2 7D CA         jp nz,tank_fire2             ; block above isn't empty, so can't move on, copy down above blocks
157+  CA3D ED 4B 79 C9      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
158+  CA41 0D               dec c
159+  CA42 ED 43 79 C9      ld (tank_currentdamagecoord),bc ; store the coord
160+  CA46              tank_fire1:                         ; DEALING WITH NORMAL DAMAGE
161+  CA46 ED 4B 79 C9      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
162+  CA4A 3A 78 C9         ld a,(tank_currentdamage)    ; get the damage countdown
163+  CA4D E6 07            and 7                       ; is it a multiple of 8? only want to do the first line check then
164+  CA4F C2 5A CA         jp nz, tank_fire5
165+  CA52 CD 01 AB         call screen_getcharfirstbyte    ; get the first byte to check if this is a slope
166+  CA55 FE FF            cp 255                      ; if it's a full line, it will be 255 and not a slope
167+  CA57 C2 9B CA         jp nz,tank_fire3            ; if it's a slope, handle this differently
168+  CA5A              tank_fire5:
169+  CA5A 3A 7C C9         ld a,(tank_damageframe)
170+  CA5D CD 90 AA         call screen_getblock        ; get the block data into hl
171+  CA60 CD 6D AA         call screen_showchar        ; show this character here
172+  CA63 3A 7C C9         ld a,(tank_damageframe)
173+  CA66 3C               inc a
174+  CA67 32 7C C9         ld (tank_damageframe),a     ; increment the damage block and store
175+  CA6A 3A 78 C9         ld a,(tank_currentdamage)    ; get the damage countdown
176+  CA6D 3D               dec a
177+  CA6E 3D               dec a
178+  CA6F 32 78 C9         ld (tank_currentdamage),a     ; decrease current damage by 2 and store
179+  CA72 3A 81 C9         ld a,(tank_missile_displayed) ; is the missile displaying?
180+  CA75 FE 00            cp 0
181+  CA77 CC CB CA         call z, tank_missilegraphic
182+  CA7A C3 A4 CA         jp tank_fire4
183+  CA7D              tank_fire2:                     ; DEALING WITH COPYING BLOCKS FROM ABOVE
184+  CA7D 05               dec b
185+  CA7E C5               push bc
186+  CA7F CD EA AA         call screen_copyblockdown       ; copy the block down
187+  CA82 ED 4B 79 C9      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
188+  CA86 C1               pop bc                      ; get the coord we just checked back
189+  CA87 78               ld a,b
190+  CA88 FE 00            cp 0
191+  CA8A CA 46 CA         jp z,tank_fire1             ; if we're at the top of the screen, don't check any more
192+  CA8D C5               push bc
193+  CA8E 05               dec b
194+  CA8F CD D1 AA         call screen_ischarempty     ; check if it is empty
195+  CA92 C1               pop bc
196+  CA93 FE 01            cp 1                        ; if empty
197+  CA95 C2 7D CA         jp nz, tank_fire2            ; copy another one down
198+  CA98 C3 46 CA         jp tank_fire1               ; otherwise, return to main thread
199+  CA9B              tank_fire3:                      ; dealing with slopes
200+  CA9B 3A 78 C9         ld a,(tank_currentdamage)    ; get the damage countdown
201+  CA9E 06 08            ld b,8
202+  CAA0 90               sub b                        ; special case for slopes
203+  CAA1 32 78 C9         ld (tank_currentdamage),a    ; decrease the damage countdown by 8, so that next time, we get rid of this block without eroding it
204+  CAA4              tank_fire4:                     ; TIDY UP
205+  CAA4 ED 4B 79 C9      ld bc,(tank_currentdamagecoord)
206+  CAA8 ED 43 3F AC      ld (origcoords),bc
207+  CAAC CD 31 A7         call buffer_marklineforupdate
208+  CAAF 3E 01            ld a,1
209+  CAB1 CD 31 A7         call buffer_marklineforupdate
210+  CAB4 3E 02            ld a,2
211+  CAB6 CD 31 A7         call buffer_marklineforupdate
212+  CAB9 ED 4B 79 C9      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
213+  CABD 79               ld a,c
214+  CABE FE 0D            cp 13
215+  CAC0 DA C7 CA         jp c, tank_fire8                ; play alarm instead if getting close
216+  CAC3 CD 64 B2         call sound_tankshoot
217+  CAC6 C9               ret
218+  CAC7              tank_fire8:
219+  CAC7 CD D6 B1         call sound_tankalarm
220+  CACA C9               ret
221+  CACB
222+  CACB              ;
223+  CACB              ; Displays or hides the missile graphic, and changes the gun
224+  CACB              ;
225+  CACB              tank_missilegraphic:
226+  CACB 3A 81 C9         ld a,(tank_missile_displayed)
227+  CACE FE 00            cp 0
228+  CAD0 C2 D8 CA         jp nz,tank_missilegraphic0
229+  CAD3 3E 13            ld a,19
230+  CAD5 C3 DA CA         jp tank_missilegraphic1
231+  CAD8              tank_missilegraphic0:
232+  CAD8 3E 00            ld a,0
233+  CADA              tank_missilegraphic1:
234+  CADA 32 81 C9         ld (tank_missile_displayed),a ; store the flipped graphic
235+  CADD ED 4B 79 C9      ld bc,(tank_currentdamagecoord)
236+  CAE1 0C               inc c
237+  CAE2 0C               inc c                   ; print the graphic 2 spaces right
238+  CAE3 CD 90 AA         call screen_getblock        ; get the block data into hl
239+  CAE6 CD 6D AA         call screen_showchar        ; show this character here
240+  CAE9 06 02            ld b,2
241+  CAEB 0E 18            ld c,24                     ; set gunbarrel coords
242+  CAED 11 00 00         ld de,0
243+  CAF0 21 20 BF         ld hl,tank_sprite           ; set hl to gunbarrel gfx, shooting is +64
244+  CAF3 3A 81 C9         ld a,(tank_missile_displayed)
245+  CAF6 FE 00            cp 0
246+  CAF8 CA FE CA         jp z,tank_missilegraphic2
247+  CAFB 11 40 00         ld de,64
248+  CAFE              tank_missilegraphic2:
249+  CAFE 19               add hl,de                   ; work out missile graphic
250+  CAFF CD 6D AA         call screen_showchar        ; show this character here
251+  CB02 C9               ret
252+  CB03
253+  CB03              ;
254+  CB03              ; Deal with the player being killed by the tank
255+  CB03              ;
256+  CB03              tank_killedbytank:
257+  CB03 ED 4B 79 C9      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
258+  CB07 21 54 BD         ld hl,sprites                   ; empty sprite
259+  CB0A CD 6D AA         call screen_showchar            ; hide the last piece of dirt
260+  CB0D CD 1D C7         call player_tankkillplayer
261+  CB10 C9               ret
262+  CB11
263+  CB11              tank_move:
264+  CB11 ED 4B 74 C9      ld bc,(tank_initpos2)
265+  CB15 C5               push bc
266+  CB16 3A 77 C9         ld a,(tank_anim)
267+  CB19 FE 11            cp 17                       ; check first time flag
268+  CB1B CA 2D CB         jp z,tank_move1             ; don't draw over previous one if first time
269+  CB1E CD 32 CB         call tank_draw_full         ; delete old one
270+  CB21 ED 4B 74 C9      ld bc,(tank_initpos2)       ; get the current coords
271+  CB25 78               ld a,b
272+  CB26 D6 01            sub 1                       ; move back one pixels
273+  CB28 47               ld b,a
274+  CB29 ED 43 74 C9      ld (tank_initpos2),bc
275+  CB2D              tank_move1:
276+  CB2D CD 32 CB         call tank_draw_full         ; draw the tank
277+  CB30 C1               pop bc
278+  CB31 C9               ret
279+  CB32
280+  CB32              tank_draw_full:
281+  CB32 21 20 BF         ld hl,tank_sprite
282+  CB35 ED 4B 74 C9      ld bc,(tank_initpos2)         ; load bc with the start coords
283+  CB39 22 7D C9         ld (tank_current_sprite),hl  ; put into memory
284+  CB3C ED 43 7F C9      ld (tank_current_coords),bc  ; put into memory
285+  CB40 CD 5F CB         call tank_draw
286+  CB43 08               ex af,af'
287+  CB44 3A 76 C9         ld a,(tank_frame)            ; get the animation frame
288+  CB47 16 00            ld d,0
289+  CB49 5F               ld e,a
290+  CB4A 19               add hl,de
291+  CB4B 22 7D C9         ld (tank_current_sprite),hl  ; put into memory
292+  CB4E 08               ex af,af'
293+  CB4F ED 4B 74 C9      ld bc,(tank_initpos2)         ; load bc with the start coords
294+  CB53 81 C6 08         add c,8                      ; move one line down
295+  CB56 4F               ld c,a
296+  CB57 ED 43 7F C9      ld (tank_current_coords),bc  ; put into memory
297+  CB5B CD 5F CB         call tank_draw
298+  CB5E C9               ret
299+  CB5F
300+  CB5F              ;
301+  CB5F              ; Draw the tank
302+  CB5F              ; Inputs:
303+  CB5F              ; None, all in memory
304+  CB5F              ;
305+  CB5F              tank_draw:
306+  CB5F 3E 04            ld a,4                              ; 4 pieces per half
307+  CB61              tank_draw0:
308+  CB61 F5               push af
309+  CB62 2A 7D C9         ld hl,(tank_current_sprite)
310+  CB65 ED 4B 7F C9      ld bc,(tank_current_coords)         ; load bc with the start coords
311+  CB69 CD 15 AB         call sprites_drawsprite
312+  CB6C 2A 7D C9         ld hl,(tank_current_sprite)
313+  CB6F ED 4B 7F C9      ld bc,(tank_current_coords)         ; load bc with the start coords
314+  CB73 11 08 00         ld de,8
315+  CB76 19               add hl,de
316+  CB77 80 C6 08         add b,8
317+  CB7A 47               ld b,a
318+  CB7B 22 7D C9         ld (tank_current_sprite),hl         ; put into memory
319+  CB7E ED 43 7F C9      ld (tank_current_coords),bc         ; put into memory
320+  CB82 F1               pop af
321+  CB83 3D               dec a
322+  CB84 FE 00            cp 0
323+  CB86 C2 61 CB         jp nz,tank_draw0
324+  CB89
325+  CB89 C9               ret
326+  CB8A
# file closed: game/tank.asm
161   CB8A                  include "game\rocks.asm"
# file opened: game/rocks.asm
  1+  CB8A              ;
  2+  CB8A              ; A structure of falling rocks
  3+  CB8A              ; Assume we'll never have more than 4 falling at any one time
  4+  CB8A              ; (1,2 - 16 bit memory location for rock graphic),state (0 fell, 1 falling, 2 wobbling), countdown
  5+  CB8A              ;
  6+  CB8A              rocks_falling:
  7+  CB8A 00 00 00 00      defb 0,0,0,0
  8+  CB8E 00 00 00 00      defb 0,0,0,0
  9+  CB92 00 00 00 00      defb 0,0,0,0
 10+  CB96 00 00 00 00      defb 0,0,0,0
 11+  CB9A
 12+  CB9A              rocks_tmp:
 13+  CB9A 00               defb 0
 14+  CB9B
 15+  CB9B              rocks_tmp2:
 16+  CB9B 00 00            defb 0,0
 17+  CB9D
 18+  CB9D              ;
 19+  CB9D              ; The number of frames to wobble for
 20+  CB9D              ; Must always be 10 more than the number of frames a player digs
 21+  CB9D              ;
 22+  CB9D              rocks_numberofframestowobble:
 23+  CB9D 14               defb 20
 24+  CB9E
 25+  CB9E              ;
 26+  CB9E              ; Coords of the rock that killed us
 27+  CB9E              ;
 28+  CB9E              rocks_killerrock:
 29+  CB9E 00 00            defb 0,0
 30+  CBA0
 31+  CBA0              ;
 32+  CBA0              ; Checks for a rock that needs to start falling. Takes a memory location of the first line at the bottom of the space.
 33+  CBA0              ; Checks to see if the pixel row in that location is a rock bottom. If it is, mark this rock as ready to fall.
 34+  CBA0              ; If the pixel row is not the rock bottom, stop checking.
 35+  CBA0              ; Inputs:
 36+  CBA0              ; hl- memory location
 37+  CBA0              ;
 38+  CBA0              rocks_checkforfalling:
 39+  CBA0 7E               ld a,(hl)           ; get the pixel row in this memory location
 40+  CBA1 FE 7E            cp 126              ; check against the bottom pixel row of the rock graphic
 41+  CBA3 C2 A9 CB         jp nz,rocks_checkforfalling2 ; not a rock, stop
 42+  CBA6 CD AA CB         call rocks_addrocktofalling ; mark the rock as falling
 43+  CBA9              rocks_checkforfalling2:
 44+  CBA9 C9               ret
 45+  CBAA
 46+  CBAA              ;
 47+  CBAA              ; Adds the rock to the structure that tracks falling rocks
 48+  CBAA              ; Inputs:
 49+  CBAA              ; hl - memory location of falling rock graphic
 50+  CBAA              ; bc - coords of rock, c vert
 51+  CBAA              rocks_addrocktofalling:
 52+  CBAA C5               push bc             ; store the coords
 53+  CBAB 11 8A CB         ld de,rocks_falling
 54+  CBAE 06 04            ld b,4              ; number of possible falling rocks
 55+  CBB0              rocks_addrocktofalling0:
 56+  CBB0 13               inc de
 57+  CBB1                  ;inc de
 58+  CBB1 13               inc de              ; move three along to get the state
 59+  CBB2 1A               ld a,(de)           ; load the state
 60+  CBB3 FE 00            cp 0                ; check if this is not falling
 61+  CBB5 C2 CC CB         jp nz,rocks_addrocktofalling1 ; continue the loop if not 0
 62+  CBB8 13               inc de              ; move to frame
 63+  CBB9 3A 9D CB         ld a,(rocks_numberofframestowobble) ; load the number of frames to wobble
 64+  CBBC 12               ld (de),a
 65+  CBBD 1B               dec de              ; move de back to state
 66+  CBBE 3E 02            ld a,2
 67+  CBC0 12               ld (de),a           ; set the state to wobbling
 68+  CBC1 1B               dec de              ; move back coords
 69+  CBC2 C1               pop bc              ; get back coords
 70+  CBC3 78               ld a,b
 71+  CBC4 12               ld (de),a           ; store the vertical
 72+  CBC5 1B               dec de
 73+  CBC6 79               ld a,c
 74+  CBC7 12               ld (de),a           ; store the horizontal
 75+  CBC8 C5               push bc
 76+  CBC9 C3 D0 CB         jp rocks_addrocktofalling2 ; done
 77+  CBCC              rocks_addrocktofalling1:
 78+  CBCC 13               inc de
 79+  CBCD 13               inc de              ; move memory along to next rock
 80+  CBCE 10 E0            djnz rocks_addrocktofalling0 ; try the next rock
 81+  CBD0              rocks_addrocktofalling2: ; done, return
 82+  CBD0 C1               pop bc              ; to tidy up
 83+  CBD1 C9               ret
 84+  CBD2
 85+  CBD2              ;
 86+  CBD2              ; Processes any falling rocks
 87+  CBD2              ;
 88+  CBD2              rocks_processrocks:
 89+  CBD2 DD 21 8A CB      ld ix,rocks_falling
 90+  CBD6 06 04            ld b,4              ; the number of rocks to check
 91+  CBD8              rocks_processrocks0:
 92+  CBD8 C5               push bc             ; store loop count
 93+  CBD9 DD 4E 00 DD      ld bc,(ix)          ; load the coords for this rock into bc
 93+  CBDD 46 01
 94+  CBDF DD 23            inc ix
 95+  CBE1 DD 23            inc ix              ; move to the state
 96+  CBE3 DD 7E 00         ld a,(ix)           ; load the state into a
 97+  CBE6 FE 00            cp 0
 98+  CBE8 CA 09 CC         jp z,rocks_processrocks3 ; if not falling, check next
 99+  CBEB FE 02            cp 2
100+  CBED C2 FD CB         jp nz, rocks_processrocks2
101+  CBF0                  ; we're wobbling
102+  CBF0 DD 23            inc ix              ; get frame number for wobble
103+  CBF2 DD 7E 00         ld a,(ix)           ; get wobble frame into a
104+  CBF5 CD CC CC         call rocks_wobble
105+  CBF8 DD 23            inc ix              ; increment for next
106+  CBFA C3 0D CC         jp rocks_processrocks1  ; do next rock
107+  CBFD              rocks_processrocks2:
108+  CBFD                  ; we're falling
109+  CBFD C5               push bc
110+  CBFE CD 11 CC         call rocks_fall
111+  CC01 C1               pop bc
112+  CC02 DD 23            inc ix
113+  CC04 DD 23            inc ix              ; inc ix to get to next
114+  CC06 C3 0D CC         jp rocks_processrocks1
115+  CC09              rocks_processrocks3:
116+  CC09 DD 23            inc ix
117+  CC0B DD 23            inc ix
118+  CC0D              rocks_processrocks1:
119+  CC0D C1               pop bc              ; get loop count back
120+  CC0E 10 C8            djnz rocks_processrocks0
121+  CC10 C9               ret
122+  CC11
123+  CC11              ;
124+  CC11              ; Falls a rock one pixel, checks the next square down to see if it is empty, if not, stop falling
125+  CC11              ; bc - coord of current rock graphic on screen
126+  CC11              ; ix - memory location of current rock in rock list, currently at the 3rd position (rock state)
127+  CC11              ;
128+  CC11              rocks_fall:
129+  CC11 DD 2B            dec ix
130+  CC13 DD 2B            dec ix              ; decrease ix back to coords
131+  CC15 ED 43 9B CB      ld (rocks_tmp2),bc  ; store original coords
132+  CC19 3E 03            ld a,3              ; move this number of pixels
133+  CC1B              rocks_fall1:
134+  CC1B 32 9A CB         ld (rocks_tmp),a    ; store loop counter
135+  CC1E DD 4E 00 DD      ld bc,(ix)          ; get current coords
135+  CC22 46 01
136+  CC24 CD 1D AC         call sprites_scadd  ; get the memory of the coords into de
137+  CC27 14               inc d               ; add 256 to get next row
138+  CC28 1A               ld a,(de)           ; get the contents of the next row
139+  CC29 FE 00            cp 0
140+  CC2B C2 8B CC         jp nz,rocks_fall3    ; move the rock if the row is empty
141+  CC2E 0C               inc c               ; increment the vertical
142+  CC2F DD 71 00 DD      ld (ix),bc          ; store the new coords
142+  CC33 70 01
143+  CC35 79               ld a,c              ; get the vertical coord into a
144+  CC36 E6 07            and 7               ; divisible by 8?
145+  CC38 FE 00            cp 0
146+  CC3A C2 57 CC         jp nz,rocks_fall4   ; if not, carry on
147+  CC3D CD 43 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
148+  CC40 3E 42            ld a,66             ; load red
149+  CC42 CD 9B AA         call screen_setattr
150+  CC45 DD 4E 00 DD      ld bc,(ix)
150+  CC49 46 01
151+  CC4B 79               ld a,c              ; get vertical
152+  CC4C D6 08            sub 8               ; look up one square
153+  CC4E 4F               ld c,a              ; put a back in c
154+  CC4F CD 43 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
155+  CC52 3E 46            ld a,70             ; load yellow
156+  CC54 CD 9B AA         call screen_setattr
157+  CC57              rocks_fall4:
158+  CC57 3A 9A CB         ld a,(rocks_tmp)    ; get the loop counter
159+  CC5A 3D               dec a
160+  CC5B FE 00            cp 0
161+  CC5D C2 1B CC         jp nz,rocks_fall1   ; do another pixel if needed
162+  CC60              rocks_fall2:
163+  CC60 3E 09            ld a,9              ; rock graphic
164+  CC62 ED 4B 9B CB      ld bc,(rocks_tmp2)  ; get the original coords
165+  CC66 CD 90 AA         call screen_getblock     ; get the memory into hl
166+  CC69 CD 15 AB         call sprites_drawsprite  ; draw the sprite - over the top of the current one
167+  CC6C 3E 09            ld a,9
168+  CC6E DD 4E 00 DD      ld bc,(ix)          ; get the new coords
168+  CC72 46 01
169+  CC74 CD 90 AA         call screen_getblock     ; get the memory into hl
170+  CC77 CD 15 AB         call sprites_drawsprite  ; draw the sprite - over the top of the current one
171+  CC7A DD 4E 00 DD      ld bc,(ix)          ; get the coords again
171+  CC7E 46 01
172+  CC80 CD B1 CC         call rocks_checkforplayer ; check to see if we hit a player
173+  CC83 DD 23            inc ix
174+  CC85 DD 23            inc ix                  ; get ix back to state
175+  CC87 CD A1 CC         call rocks_makesound
176+  CC8A C9               ret
177+  CC8B              rocks_fall3:
178+  CC8B 3E 00            ld a,0              ; set the state to fell
179+  CC8D DD 77 02         ld (ix+2),a           ; store the falling state
180+  CC90 DD 4E 00 DD      ld bc,(ix)          ; get the coords
180+  CC94 46 01
181+  CC96 CD 43 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
182+  CC99 3E 42            ld a,66             ; load magenta
183+  CC9B CD 9B AA         call screen_setattr
184+  CC9E C3 60 CC         jp rocks_fall2      ; rejoin main loop
185+  CCA1
186+  CCA1              ;
187+  CCA1              ; Makes the rock sound if we're no longer falling, and if we didn't hit a player
188+  CCA1              ;
189+  CCA1              rocks_makesound:
190+  CCA1 DD 7E 00         ld a,(ix)           ; get the state
191+  CCA4 FE 00            cp 0
192+  CCA6 C0               ret nz              ; if we haven't fallen, don't do anything
193+  CCA7 21 FF C5         ld hl,player+11
194+  CCAA 7E               ld a,(hl)
195+  CCAB FE 01            cp 1
196+  CCAD C4 33 B2         call nz, sound_rockfell ; only make sound if didn't kill player
197+  CCB0 C9               ret
198+  CCB1
199+  CCB1              ;
200+  CCB1              ; Checks to see if the rock is hitting a player
201+  CCB1              ; Inputs:
202+  CCB1              ; bc - coords of rock we're checking
203+  CCB1              rocks_checkforplayer:
204+  CCB1 ED 5B F4 C5      ld de,(player)       ; get the player coords
205+  CCB5 7B               ld a,e               ; get the vert coord first
206+  CCB6 91               sub c                ; subtract the rock vertical coord from players
207+  CCB7 FE 08            cp 8                 ; the rock will only hit a player if the player is directly underneath, so this must be 8
208+  CCB9 C0               ret nz               ; if not, hasn't hit
209+  CCBA 7A               ld a,d               ; get the player horiz coord
210+  CCBB 90               sub b                ; subtract rock coord
211+  CCBC C6 07            add 7                ; add max distance
212+  CCBE FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
213+  CCC0 DA C4 CC         jp c,rocks_checkforplayer0
214+  CCC3 C9               ret
215+  CCC4              rocks_checkforplayer0:
216+  CCC4 ED 43 9E CB      ld (rocks_killerrock),bc; store the coords of the killer rock
217+  CCC8 CD 17 C7         call player_crushplayer ; if so, jump out
218+  CCCB C9               ret
219+  CCCC
220+  CCCC              ;
221+  CCCC              ; Wobbles a rocks
222+  CCCC              ; Inputs:
223+  CCCC              ; bc - coord of current rock graphic on screen
224+  CCCC              ; ix - memory location of current rock in rock list, currently at the 4th position (wobble count)
225+  CCCC              ; a - wobble frame
226+  CCCC              rocks_wobble:
227+  CCCC DD 7E 00         ld a,(ix)           ; get the wobble count, which we'll use as frame toggle
228+  CCCF E6 01            and 1               ; is it odd or even, gets 1 or 0
229+  CCD1 1E 09            ld e,9              ; this is the rock frame
230+  CCD3 83               add a,e             ; add the frame toggle
231+  CCD4 C5               push bc
232+  CCD5 CD 90 AA         call screen_getblock     ; get the memory into hl
233+  CCD8 CD 15 AB         call sprites_drawsprite  ; draw the sprite - over the top of the current one
234+  CCDB DD 7E 00         ld a,(ix)           ; get the frame toggle again
235+  CCDE 3D               dec a               ; decrease
236+  CCDF DD 77 00         ld (ix),a           ; store
237+  CCE2 E6 01            and 1
238+  CCE4 1E 09            ld e,9              ; this is the rock frame
239+  CCE6 83               add a,e             ; add the frame toggle
240+  CCE7 CD 90 AA         call screen_getblock     ; get the memory into hl
241+  CCEA C1               pop bc
242+  CCEB CD 15 AB         call sprites_drawsprite  ; draw the sprite again with the new frame - next time it will do the opposite
243+  CCEE DD 7E 00         ld a,(ix)           ; get the wobble count back
244+  CCF1 FE 00            cp 0
245+  CCF3 C0               ret nz              ; if we're not at zero, return
246+  CCF4 DD 2B            dec ix              ; otherwise look to state location
247+  CCF6 3E 01            ld a,1              ; set the state to falling
248+  CCF8 DD 77 00         ld (ix),a           ; store the falling state
249+  CCFB DD 23            inc ix              ; set ix back to location of wobble count, and we're done
250+  CCFD C9               ret
251+  CCFE
# file closed: game/rocks.asm
162   CCFE                  include "game\scores.asm"
# file opened: game/scores.asm
  1+  CCFE              ;
  2+  CCFE              ; The score of the current player
  3+  CCFE              ;
  4+  CCFE              scores_current:
  5+  CCFE 04 01 30 30      defb 4,1,'000000',255       ;+2
  5+  CD02 30 30 30 30
  5+  CD06 FF
  6+  CD07
  7+  CD07              scores_defaultname:
  8+  CD07 2D 2D 2D         defb '---'
  9+  CD0A
 10+  CD0A              ;
 11+  CD0A              ; The current high score table
 12+  CD0A              ;
 13+  CD0A              scores_table:
 14+  CD0A 03 17 47 41      defb 03,23,'GAM000000',255         ;+0, +2, +5
 14+  CD0E 4D 30 30 30
 14+  CD12 30 30 30 FF
 15+  CD16 0C 17 47 41      defb 12,23,'GAM000000',255        ;+12, +14, +17
 15+  CD1A 4D 30 30 30
 15+  CD1E 30 30 30 FF
 16+  CD22 15 17 47 41      defb 21,23,'GAM000000',255        ;+24, +26, +29
 16+  CD26 4D 30 30 30
 16+  CD2A 30 30 30 FF
 17+  CD2E
 18+  CD2E              ;
 19+  CD2E              ; Add thousands to the score
 20+  CD2E              ; Inputs:
 21+  CD2E              ; b - number to add
 22+  CD2E              ;
 23+  CD2E              scores_addthousands:
 24+  CD2E 21 02 CD         ld hl,scores_current+4
 25+  CD31 CD 92 CD         call scores_update
 26+  CD34 C9               ret
 27+  CD35
 28+  CD35              ;
 29+  CD35              ; Add hundreds to the score
 30+  CD35              ; Inputs:
 31+  CD35              ; b - number to add
 32+  CD35              ;
 33+  CD35              scores_addhundreds:
 34+  CD35 21 03 CD         ld hl,scores_current+5
 35+  CD38 CD 92 CD         call scores_update
 36+  CD3B C9               ret
 37+  CD3C
 38+  CD3C              ;
 39+  CD3C              ; Temporary area for printing scores
 40+  CD3C              ;
 41+  CD3C              scores_printscore_tmp:
 42+  CD3C 00 00 00 00      defb 0,0,0,0,0,0,0,0,255
 42+  CD40 00 00 00 00
 42+  CD44 FF
 43+  CD45
 44+  CD45              ;
 45+  CD45              ; Prints the score to screen
 46+  CD45              ;
 47+  CD45              scores_printscore:
 48+  CD45 3A 05 C5         ld a,(game_currentplayer)   ; get current player
 49+  CD48 21 FE CC         ld hl,scores_current
 50+  CD4B FE 01            cp 1
 51+  CD4D C2 55 CD         jp nz, score_printscore0    ; if not player 1
 52+  CD50 36 04            ld (hl),4       ; set position for player 1
 53+  CD52 C3 57 CD         jp score_printscore1
 54+  CD55              score_printscore0:
 55+  CD55 36 16            ld (hl),22       ; set position for player 2
 56+  CD57              score_printscore1:
 57+  CD57 CD 5B CD         call score_printscoreformatted
 58+  CD5A C9               ret
 59+  CD5B
 60+  CD5B              ;
 61+  CD5B              ; Formats a score and prints to the top screen
 62+  CD5B              ; Inputs:
 63+  CD5B              ; hl - where is the score
 64+  CD5B              score_printscoreformatted:
 65+  CD5B 01 08 00         ld bc,8
 66+  CD5E 11 3C CD         ld de,scores_printscore_tmp
 67+  CD61 ED B0            ldir                        ; copy to temp
 68+  CD63 21 3C CD         ld hl,scores_printscore_tmp
 69+  CD66 E5 DD E1         ld ix,hl
 70+  CD69 DD 7E 02         ld a,(ix+2)
 71+  CD6C FE 30            cp 48                   ; is it a leading zero?
 72+  CD6E C2 81 CD         jp nz,score_printscore2
 73+  CD71 DD 36 02 20      ld (ix+2),32              ; load it with a space
 74+  CD75 DD 7E 03         ld a,(ix+3)
 75+  CD78 FE 30            cp 48                   ; is it a leading zero?
 76+  CD7A C2 81 CD         jp nz,score_printscore2
 77+  CD7D DD 36 03 20      ld (ix+3),32              ; load it with a space
 78+  CD81              score_printscore2:
 79+  CD81 CD 30 86         call string_print
 80+  CD84 C9               ret
 81+  CD85
 82+  CD85              ;
 83+  CD85              ; Prints both scores to screen
 84+  CD85              ;
 85+  CD85              scores_printscores:
 86+  CD85 21 FD C6         ld hl,player1_score
 87+  CD88 CD 5B CD         call score_printscoreformatted
 88+  CD8B 21 06 C7         ld hl,player2_score
 89+  CD8E CD 5B CD         call score_printscoreformatted
 90+  CD91 C9               ret
 91+  CD92
 92+  CD92              ;
 93+  CD92              ; Updates the current score.
 94+  CD92              ; Inputs:
 95+  CD92              ; hl - memory location of the score column
 96+  CD92              ; b - number to add
 97+  CD92              ;
 98+  CD92              scores_update:
 99+  CD92 7E               ld a,(hl)           ; current value of digit.
100+  CD93 80               add a,b             ; add points to this digit.
101+  CD94 77               ld (hl),a           ; place new digit back in string.
102+  CD95 FE 3A            cp 58               ; more than ASCII value '9'?
103+  CD97 D8               ret c               ; no - relax.
104+  CD98 D6 0A            sub 10              ; subtract 10.
105+  CD9A 77               ld (hl),a           ; put new character back in string.
106+  CD9B              scores_update0:
107+  CD9B 2B               dec hl              ; previous character in string.
108+  CD9C 34               inc (hl)            ; up this by one.
109+  CD9D 7E               ld a,(hl)           ; what's the new value?
110+  CD9E FE 3A            cp 58               ; gone past ASCII nine?
111+  CDA0 D8               ret c               ; no, scoring done.
112+  CDA1 D6 0A            sub 10              ; down by ten.
113+  CDA3 77               ld (hl),a           ; put it back
114+  CDA4 C3 9B CD         jp scores_update0   ; go round again.
115+  CDA7
116+  CDA7
117+  CDA7              ;
118+  CDA7              ; Temporary area to store score
119+  CDA7              ;
120+  CDA7              scores_showtable_tmp:
121+  CDA7 00 00 00 00      defb 0,0,0,0,0,0,0,0,0,0,0,255
121+  CDAB 00 00 00 00
121+  CDAF 00 00 00 FF
122+  CDB3
123+  CDB3              ;
124+  CDB3              ; Processes a score
125+  CDB3              ; Inputs:
126+  CDB3              ; hl - location on table
127+  CDB3              ;
128+  CDB3              scores_showtable_process:
129+  CDB3 01 0B 00         ld bc,11                     ; copy this many
130+  CDB6 11 A7 CD         ld de,scores_showtable_tmp
131+  CDB9 ED B0            ldir
132+  CDBB DD 21 A7 CD      ld ix,scores_showtable_tmp   ; decide whether to show five or six numbers
133+  CDBF DD 7E 05         ld a,(ix+5)
134+  CDC2 FE 30            cp 48                        ; is this a zero?
135+  CDC4 C2 DA CD         jp nz,scores_showtable_process0 ; if not, show the whole thing
136+  CDC7 01 05 00         ld bc,5                      ; copy this many
137+  CDCA DD E5 E1         ld hl,ix
138+  CDCD 11 06 00         ld de,6
139+  CDD0 19               add hl,de                    ; move to second digit
140+  CDD1 54 5D            ld de,hl
141+  CDD3 1B               dec de
142+  CDD4 ED B0            ldir
143+  CDD6 DD 36 0A 20      ld (ix+10),32                ; stick a space at the end
144+  CDDA              scores_showtable_process0:
145+  CDDA 21 A7 CD         ld hl,scores_showtable_tmp
146+  CDDD CD 30 86         call string_print
147+  CDE0 C9               ret
148+  CDE1
149+  CDE1              ;
150+  CDE1              ; Displays the high score table at the bottom of the screen
151+  CDE1              ;
152+  CDE1              scores_showtable:
153+  CDE1 21 0A CD         ld hl, scores_table
154+  CDE4 CD B3 CD         call scores_showtable_process
155+  CDE7 21 16 CD         ld hl, scores_table+12
156+  CDEA CD B3 CD         call scores_showtable_process
157+  CDED 21 22 CD         ld hl, scores_table+24
158+  CDF0 CD B3 CD         call scores_showtable_process
159+  CDF3 C9               ret
160+  CDF4
161+  CDF4              ;
162+  CDF4              ; Place to store the current position we're checking
163+  CDF4              ;
164+  CDF4              scores_highscoretmp:
165+  CDF4 00               defb 0
166+  CDF5
167+  CDF5              ;
168+  CDF5              ; Place to store the equal indicator
169+  CDF5              ;
170+  CDF5              scores_highscoretmp2:
171+  CDF5 00               defb 0
172+  CDF6
173+  CDF6              ;
174+  CDF6              ; Updates the highscore table. Start at bottom score. Work way from left. Compare each digit. If current is higher than one we're checking,
175+  CDF6              ; copy checking one down (or erase) then copy current over that one. Then move up one and do the same
176+  CDF6              ;
177+  CDF6              scores_processhighscores:
178+  CDF6 21 F4 CD         ld hl,scores_highscoretmp
179+  CDF9 36 00            ld (hl),0  ; load up the tracking byte with 0 (ie, not on the table)
180+  CDFB 3E 1D            ld a,29
181+  CDFD              scores_processhighscores3:
182+  CDFD 21 0A CD         ld hl,scores_table          ; position of first score column
183+  CE00 5F               ld e,a
184+  CE01 16 00            ld d,0
185+  CE03 19               add hl,de
186+  CE04 08               ex af,af'                   ; store a for later
187+  CE05 11 00 CD         ld de,scores_current+2      ; position of current score column
188+  CE08 3E 01            ld a,1
189+  CE0A 32 F5 CD         ld (scores_highscoretmp2),a ; set the equal indicator to 1 - this will be set to zero if a different number is found
190+  CE0D 06 06            ld b,6                      ; times to loop
191+  CE0F              scores_processhighscores0:
192+  CE0F 7E               ld a,(hl)
193+  CE10 4F               ld c,a                      ; get first score column
194+  CE11 1A               ld a,(de)                   ; get first current column
195+  CE12 B9               cp c                        ; compare current with first
196+  CE13 DA 38 CE         jp c,scores_processhighscores4  ; if c is bigger, then this is not a higher score, so end
197+  CE16 CA 21 CE         jp z,scores_processhighscores5  ; if c is equal, then don't clear the equality flag
198+  CE19 3E 00            ld a,0                      ; this must be bigger, so no need to check further
199+  CE1B 32 F5 CD         ld (scores_highscoretmp2),a ; zero the equality indicator
200+  CE1E C3 25 CE         jp scores_processhighscores6
201+  CE21              scores_processhighscores5:
202+  CE21 23               inc hl
203+  CE22 13               inc de                      ; move to next column
204+  CE23 10 EA            djnz scores_processhighscores0 ; loop
205+  CE25              scores_processhighscores6:
206+  CE25 3A F5 CD         ld a,(scores_highscoretmp2)   ; get the equality indicator
207+  CE28 FE 01            cp 1
208+  CE2A CA 38 CE         jp z,scores_processhighscores4 ; if it is equal, not a highscore
209+  CE2D B7               or a                            ; clear the carry flag
210+  CE2E 08               ex af,af'                     ; still here, so must be bigger
211+  CE2F 32 F4 CD         ld (scores_highscoretmp),a  ; store the position indicator in the tracking byte
212+  CE32 0E 0C            ld c,12
213+  CE34 91               sub c
214+  CE35 D2 FD CD         jp nc,scores_processhighscores3 ; if the place we're looking is less than zero, we've gone to far, so continue, otherwise go again
215+  CE38              scores_processhighscores4
216+  CE38 CD 3C CE         call scores_updatehighscores
217+  CE3B C9               ret
218+  CE3C
219+  CE3C              ;
220+  CE3C              ; Update score table
221+  CE3C              ;
222+  CE3C              scores_updatehighscores:
223+  CE3C 3A F4 CD         ld a,(scores_highscoretmp)  ; get the place we want to overwrite
224+  CE3F FE 00            cp 0
225+  CE41 C8               ret z                       ; if this is 0, didn't get a high score
226+  CE42 FE 1D            cp 29                       ; check against 29... if it's equal, we don't want to copy the current score down one
227+  CE44 CA 77 CE         jp z, scores_updatehighscores3
228+  CE47                                              ; copy old score over one below, if not first
229+  CE47 21 0A CD         ld hl,scores_table
230+  CE4A 11 11 00         ld de,17                    ; start at second score, because this is the first one we'd ever need to copy...
231+  CE4D 19               add hl,de                   ; position of first column
232+  CE4E 2B               dec hl
233+  CE4F 2B               dec hl
234+  CE50 2B               dec hl
235+  CE51 E5               push hl
236+  CE52 11 0C 00         ld de,12
237+  CE55 19               add hl,de                   ; get position of next score
238+  CE56 54 5D            ld de,hl
239+  CE58 E1               pop hl                      ; get hl back
240+  CE59 01 09 00         ld bc,9
241+  CE5C ED B0            ldir
242+  CE5E FE 11            cp 17                       ; see if we're copying into the second place slot (17 memory offset). If so, stop copying back the scores
243+  CE60 CA 77 CE         jp z,scores_updatehighscores3
244+  CE63 21 0A CD         ld hl,scores_table
245+  CE66 11 02 00         ld de,2                    ; ... otherwise, copy back the first score
246+  CE69 19               add hl,de                   ; position of first column
247+  CE6A E5               push hl
248+  CE6B 11 0C 00         ld de,12
249+  CE6E 19               add hl,de                   ; get position of next score
250+  CE6F 54 5D            ld de,hl
251+  CE71 E1               pop hl                      ; get hl back
252+  CE72 01 09 00         ld bc,9
253+  CE75 ED B0            ldir
254+  CE77              scores_updatehighscores3:
255+  CE77 06 06            ld b,6                      ; now overwrite
256+  CE79 21 0A CD         ld hl,scores_table
257+  CE7C 16 00            ld d,0
258+  CE7E 5F               ld e,a
259+  CE7F 19               add hl,de                   ; position of first column
260+  CE80 08               ex af,af'
261+  CE81 11 00 CD         ld de,scores_current+2      ; position of current score column
262+  CE84              scores_updatehighscores2:
263+  CE84 1A               ld a,(de)
264+  CE85 77               ld (hl),a
265+  CE86 23               inc hl
266+  CE87 13               inc de
267+  CE88 10 FA            djnz scores_updatehighscores2
268+  CE8A 11 09 00         ld de,9
269+  CE8D ED 52            sbc hl,de
270+  CE8F 54 5D            ld de,hl                    ; get back to start of entry
271+  CE91 21 07 CD         ld hl,scores_defaultname    ; still need to overwrite the name
272+  CE94 01 03 00         ld bc,3                      ; 3 chars to copy
273+  CE97 ED B0            ldir
274+  CE99 C9               ret
# file closed: game/scores.asm
163   CE9A                  include "game\diamonds.asm"
# file opened: game/diamonds.asm
  1+  CE9A              diamonds_tmp:
  2+  CE9A 00               defb 0
  3+  CE9B
  4+  CE9B              diamonds_tmp2:
  5+  CE9B 00               defb 0
  6+  CE9C
  7+  CE9C              ;
  8+  CE9C              ; Holds the number of thousands for the current gem type
  9+  CE9C              ;
 10+  CE9C              diamonds_score:
 11+  CE9C 00               defb 0
 12+  CE9D
 13+  CE9D              ;
 14+  CE9D              ; Changes the attribute of gem and diamond cells based on the frame count
 15+  CE9D              ; Inputs:
 16+  CE9D              ; hl - memory location of gem type
 17+  CE9D              diamonds_twinkle_type:
 18+  CE9D CD 9E C5         call game_getcurrentframe       ; get current frame number
 19+  CEA0 E6 07            and 7                           ; want a number from 0-7
 20+  CEA2 C6 40            add 64                          ; add to 60 to get attr colour
 21+  CEA4 32 9B CE         ld (diamonds_tmp2),a             ; store the colour
 22+  CEA7              diamonds_twinkle_type0:
 23+  CEA7 4E 23 46 2B      ld bc,(hl)                      ; get coords into bc
 24+  CEAB 79               ld a,c                          ; load c into a
 25+  CEAC FE FF            cp 255                          ; is this the end?
 26+  CEAE CA D6 CE         jp z,diamonds_twinkle_type1           ; step out if so
 27+  CEB1 23               inc hl
 28+  CEB2 23               inc hl
 29+  CEB3 7E               ld a,(hl)                       ; check the state, don't process if collected
 30+  CEB4 FE 01            cp 1
 31+  CEB6 CA D7 CE         jp z,diamonds_twinkle_type2           ; step out if so
 32+  CEB9 CD 17 CF         call diamonds_checkforplayer    ; check to see if we've collided with player
 33+  CEBC DC DE CE         call c,diamonds_collect     ; we collided
 34+  CEBF 23               inc hl
 35+  CEC0 E5               push hl
 36+  CEC1 E5 DD E1         ld ix,hl
 37+  CEC4 DD 4E FD DD      ld bc,(ix-3)                    ; get coords again
 37+  CEC8 46 FE
 38+  CECA 3A 9B CE         ld a,(diamonds_tmp2)
 39+  CECD CD 9B AA         call screen_setattr
 40+  CED0 E1               pop hl
 41+  CED1 23               inc hl
 42+  CED2 23               inc hl                          ; move to next diamond
 43+  CED3 C3 A7 CE         jp diamonds_twinkle_type0
 44+  CED6              diamonds_twinkle_type1:
 45+  CED6 C9               ret
 46+  CED7              diamonds_twinkle_type2:
 47+  CED7 23               inc hl                          ; do stuff the we would have done anyway to get to next gem
 48+  CED8 23               inc hl
 49+  CED9 23               inc hl
 50+  CEDA 08               ex af,af'
 51+  CEDB C3 A7 CE         jp diamonds_twinkle_type0       ; rejoin main loop
 52+  CEDE
 53+  CEDE              ;
 54+  CEDE              ; Collect the diamond we collided with
 55+  CEDE              ; Inputs:
 56+  CEDE              ; hl - memory location of current diamond, currently on state
 57+  CEDE              ; Output:
 58+  CEDE              ; a - 70 - for yellow on black
 59+  CEDE              diamonds_collect:
 60+  CEDE 36 01            ld (hl),1                       ; collected
 61+  CEE0 E5               push hl
 62+  CEE1 2B               dec hl
 63+  CEE2 2B               dec hl
 64+  CEE3 4E 23 46 2B      ld bc,(hl)                      ; get the coords
 65+  CEE7 CD 53 AA         call screen_getscreencoordsfromcharcoords ; get the screen coords into bc
 66+  CEEA ED 5B 9A CE      ld de,(diamonds_tmp)            ; tmp stores the offset for this type of gem
 67+  CEEE 16 00            ld d,0
 68+  CEF0 21 54 BD         ld hl,sprites
 69+  CEF3 19               add hl,de
 70+  CEF4 CD 15 AB         call sprites_drawsprite     ; call the routine to draw the sprite
 71+  CEF7 E1               pop hl
 72+  CEF8 3E 46            ld a,70                     ; pass this back to overwrite the attr
 73+  CEFA 32 9B CE         ld (diamonds_tmp2),a
 74+  CEFD D9               exx
 75+  CEFE 3A 9C CE         ld a,(diamonds_score)
 76+  CF01 47               ld b,a
 77+  CF02 CD 2E CD         call scores_addthousands
 78+  CF05 3A 9A CE         ld a,(diamonds_tmp)
 79+  CF08 FE 40            cp 64                       ; check the gem type offset, if its 64 this is a diamond, so mark the level as completable
 80+  CF0A C2 12 CF         jp nz,diamonds_collect0
 81+  CF0D 21 01 C6         ld hl,player+13
 82+  CF10 36 01            ld (hl),1                   ; mark the player as able to complete the level
 83+  CF12              diamonds_collect0:
 84+  CF12 CD F8 B1         call sound_gemcollected
 85+  CF15 D9               exx
 86+  CF16 C9               ret
 87+  CF17
 88+  CF17              ;
 89+  CF17              ; Checks to see if the gem is hitting a player
 90+  CF17              ; Inputs:
 91+  CF17              ; bc - coords of diamond we're checking
 92+  CF17              diamonds_checkforplayer:
 93+  CF17 78               ld a,b               ; multiply b by 8
 94+  CF18 07               rlca
 95+  CF19 07               rlca
 96+  CF1A 07               rlca
 97+  CF1B 47               ld b,a
 98+  CF1C ED 5B F4 C5      ld de,(player)       ; get the player coords
 99+  CF20 7B               ld a,e               ; get the vert coord first
100+  CF21 90               sub b                ; subtract the diamond vertical coord from players
101+  CF22 C6 04            add 4                ; add the max distance
102+  CF24 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
103+  CF26 D0               ret nc               ; if not, hasn't hit
104+  CF27 79               ld a,c               ; multiply c by 8
105+  CF28 07               rlca
106+  CF29 07               rlca
107+  CF2A 07               rlca
108+  CF2B 4F               ld c,a
109+  CF2C 7A               ld a,d               ; get the player horiz coord
110+  CF2D 91               sub c                ; subtract rock coord
111+  CF2E C6 04            add 4                ; add max distance
112+  CF30 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
113+  CF32 D0               ret nc
114+  CF33 3E 00            ld a,0
115+  CF35 C9               ret
116+  CF36
117+  CF36
118+  CF36              ;
119+  CF36              ; Initialise diamonds and gems
120+  CF36              ;
121+  CF36              diamonds_twinkle
122+  CF36 21 9C CE         ld hl,diamonds_score
123+  CF39 36 02            ld (hl),2         ; store the score we'll add
124+  CF3B 21 9A CE         ld hl,diamonds_tmp
125+  CF3E 36 40            ld (hl),64         ; store the location the diamond sprite
126+  CF40 21 CF B8         ld hl, level_diamonds
127+  CF43 CD 9D CE         call diamonds_twinkle_type
128+  CF46 21 9C CE         ld hl,diamonds_score
129+  CF49 36 01            ld (hl),1         ; store the score we'll add
130+  CF4B 21 9A CE         ld hl,diamonds_tmp
131+  CF4E 36 70            ld (hl),112         ; store the location the gem sprite
132+  CF50 21 DF B8         ld hl, level_gems
133+  CF53 CD 9D CE         call diamonds_twinkle_type
134+  CF56 C9               ret
135+  CF57
136+  CF57              ;
137+  CF57              ; Initialise diamonds and gems
138+  CF57              ;
139+  CF57              diamonds_init:
140+  CF57 21 CF B8         ld hl, level_diamonds
141+  CF5A CD 64 CF         call diamonds_init_type
142+  CF5D 21 DF B8         ld hl, level_gems
143+  CF60 CD 64 CF         call diamonds_init_type
144+  CF63 C9               ret
145+  CF64
146+  CF64              ;
147+  CF64              ; Initialise diamonds or gems, get memory addresses
148+  CF64              ; Inputs:
149+  CF64              ; hl - memory location
150+  CF64              diamonds_init_type:
151+  CF64 4E               ld c,(hl)                      ; get coords into c
152+  CF65 79               ld a,c                          ; load c into add
153+  CF66 FE FF            cp 255                          ; is this the end?
154+  CF68 CA 7F CF         jp z,diamonds_init_type1             ; step out if so
155+  CF6B 23               inc hl
156+  CF6C 46               ld b,(hl)                       ; get coords into b
157+  CF6D E5               push hl
158+  CF6E CD 04 AA         call screen_getcellattroffset ; get memory of attr for this diamond into de
159+  CF71 E1               pop hl
160+  CF72 23               inc hl                          ; move to state
161+  CF73 36 00            ld (hl),0
162+  CF75 23               inc hl                          ; move to memory
163+  CF76 73 23 72 2B      ld (hl),de                      ; store the memory location
164+  CF7A 23               inc hl                          ; move to next diamond
165+  CF7B 23               inc hl
166+  CF7C C3 64 CF         jp diamonds_init_type
167+  CF7F              diamonds_init_type1:
168+  CF7F C9               ret
# file closed: game/diamonds.asm
164   CF80                  include "game\missiles.asm"
# file opened: game/missiles.asm
  1+  CF80              ;
  2+  CF80              ; Controls when missiles fall
  3+  CF80              ;
  4+  CF80              missiles_count:
  5+  CF80 00               defb 0
  6+  CF81
  7+  CF81              ;
  8+  CF81              ; A structure of falling missiles
  9+  CF81              ; Assume we'll never have more than 4 falling at any one time
 10+  CF81              ; (1,2 - 16 bit memory location for missile graphic),state (0 fell, 1 falling)
 11+  CF81              ;
 12+  CF81              missiles_falling:
 13+  CF81 00 00 00         defb 0,0,0
 14+  CF84 00 00 00         defb 0,0,0
 15+  CF87 00 00 00         defb 0,0,0
 16+  CF8A 00 00 00         defb 0,0,0
 17+  CF8D
 18+  CF8D              ;
 19+  CF8D              ; The coords of the missile that killed us
 20+  CF8D              ;
 21+  CF8D              missiles_killermissile:
 22+  CF8D 00 00            defb 0,0
 23+  CF8F
 24+  CF8F              ;
 25+  CF8F              ; The speed of the missiles
 26+  CF8F              ;
 27+  CF8F              missiles_speed:
 28+  CF8F 00               defb 0
 29+  CF90
 30+  CF90              ;
 31+  CF90              ; Zeroes the state of each missile
 32+  CF90              ;
 33+  CF90              missiles_init:
 34+  CF90 06 0C            ld b,12
 35+  CF92 DD 21 56 B8      ld ix,level_missiles
 36+  CF96              missiles_init0:
 37+  CF96 DD 36 02 00      ld (ix+2),0               ; set the state to zero
 38+  CF9A 11 05 00         ld de,5
 39+  CF9D DD 19            add ix,de
 40+  CF9F DD 36 02 00      ld (ix+2),0
 41+  CFA3 DD 19            add ix,de
 42+  CFA5 10 EF            djnz missiles_init0
 43+  CFA7 06 04            ld b,4                  ; reset four falling missiles
 44+  CFA9 21 81 CF         ld hl,missiles_falling
 45+  CFAC              missiles_init1:
 46+  CFAC 36 00            ld (hl),0
 47+  CFAE 23               inc hl
 48+  CFAF 36 00            ld (hl),0
 49+  CFB1 23               inc hl
 50+  CFB2 36 00            ld (hl),0
 51+  CFB4 23               inc hl
 52+  CFB5 10 F5            djnz missiles_init1
 53+  CFB7 C9               ret
 54+  CFB8
 55+  CFB8              ;
 56+  CFB8              ; Runs each frame and checks if a missile can fall, then selects one at random and adds to the falling missiles
 57+  CFB8              ; Processes any already falling missiles
 58+  CFB8              ;
 59+  CFB8              missiles_process:
 60+  CFB8 3A FF C5         ld a,(player+11)                        ; check if the player was hit by a missile previously
 61+  CFBB FE 03            cp 3
 62+  CFBD C2 C4 CF         jp nz,missiles_process3                 ; if not, continue
 63+  CFC0 CD 04 D1         call missiles_zonkplayer
 64+  CFC3 C9               ret
 65+  CFC4              missiles_process3:
 66+  CFC4 3A 03 C6         ld a,(player_location)
 67+  CFC7 FE 01            cp 1
 68+  CFC9 C2 3A D0         jp nz, missiles_process0                ; if not 1 we're not in the cavern so no need to make any more fall
 69+  CFCC 21 01 C6         ld hl,player+13
 70+  CFCF 7E               ld a,(hl)                               ; check if player has collected a diamond
 71+  CFD0 FE 01            cp 1
 72+  CFD2 C2 3A D0         jp nz, missiles_process0                ; don't activate if not
 73+  CFD5 21 80 CF         ld hl,missiles_count
 74+  CFD8 7E               ld a,(hl)                   ; get the missiles count
 75+  CFD9 3C               inc a
 76+  CFDA ED 5B 8F CF      ld de,(missiles_speed)
 77+  CFDE BB               cp e                                   ; have we reached the count yet
 78+  CFDF CA E6 CF         jp z,missiles_process2                 ; if not, don't activate a new one
 79+  CFE2 77               ld (hl),a                               ; store the updated count, and continue without activating
 80+  CFE3 C3 3A D0         jp missiles_process0
 81+  CFE6              missiles_process2:
 82+  CFE6 36 00            ld (hl),0                               ; zero the counter
 83+  CFE8 1E 0C            ld e,12
 84+  CFEA CD B8 81         call utilities_randomupper              ; get random number from 0 to 11
 85+  CFED 11 0A 00         ld de,10
 86+  CFF0 CD 03 81         call utilities_multiply                 ; multiple random number by 10
 87+  CFF3 54 5D            ld de,hl                                ; this is the offset for the random missile
 88+  CFF5 DD 21 56 B8      ld ix,level_missiles                   ; load the location of the missile definitions
 89+  CFF9 DD 19            add ix,de                               ; get to location of missile
 90+  CFFB DD 7E 02         ld a,(ix+2)
 91+  CFFE FE 00            cp 0
 92+  D000 CA 10 D0         jp z,missiles_process1                  ; if this missile isn't active, activate it
 93+  D003 11 05 00         ld de,5                                 ; otherwise, check the missile above
 94+  D006 DD 19            add ix,de
 95+  D008 DD 7E 02         ld a,(ix+2)
 96+  D00B FE 00            cp 0
 97+  D00D C2 3A D0         jp nz,missiles_process0                 ; if this is active as well, the player got lucky
 98+  D010              missiles_process1:                          ; activate a missile
 99+  D010 DD 36 02 01      ld (ix+2),1                               ; mark this missile as active
100+  D014 DD 4E 00 DD      ld bc,(ix)                              ; get char coords from the missile
100+  D018 46 01
101+  D01A 78               ld a,b
102+  D01B ED 5B E3 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows
103+  D01F 93               sub e
104+  D020 CD 53 AA         call screen_getscreencoordsfromcharcoords ; get screen coords into bc
105+  D023 C5               push bc
106+  D024 3E 0C            ld a,12                                 ; inactive missile sprite
107+  D026 CD 90 AA         call screen_getblock
108+  D029 CD 15 AB         call sprites_drawsprite                 ; draw the sprite over the old one
109+  D02C C1               pop bc
110+  D02D C5               push bc
111+  D02E 3E 14            ld a,20                                 ; active missile sprite
112+  D030 CD 90 AA         call screen_getblock
113+  D033 CD 15 AB         call sprites_drawsprite                 ; draw the sprite over the old one
114+  D036 C1               pop bc
115+  D037 CD C8 D0         call missiles_addmissiletofalling
116+  D03A              missiles_process0:
117+  D03A CD 3E D0         call missiles_fall
118+  D03D C9               ret
119+  D03E
120+  D03E              ;
121+  D03E              ; Processes falling missiles
122+  D03E              ;
123+  D03E              missiles_fall:
124+  D03E 06 04            ld b,4              ; number of possible falling missiles
125+  D040 DD 21 81 CF      ld ix,missiles_falling
126+  D044              missiles_fall0:
127+  D044 C5               push bc
128+  D045 DD 7E 02         ld a,(ix+2)
129+  D048 FE 00            cp 0
130+  D04A CA A7 D0         jp z,missiles_fall1 ; not falling move to next
131+  D04D FE 01            cp 1                ; is this ready to fall
132+  D04F CA 55 D0         jp z, missiles_fall3
133+  D052 C3 C1 D0         jp missiles_fall4   ; if not, decrease the countdown
134+  D055              missiles_fall3:
135+  D055 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
135+  D059 46 01
136+  D05B CD 1D AC         call sprites_scadd  ; get the memory of the coords into de
137+  D05E 14               inc d               ; add 256 to get next row
138+  D05F 1A               ld a,(de)           ; get the contents of the next row
139+  D060 FE 00            cp 0
140+  D062 C2 BA D0         jp nz,missiles_fall2 ; if this is not empty, stop this missile falling
141+  D065 3E 14            ld a,20                                 ; active missile sprite
142+  D067 CD 90 AA         call screen_getblock
143+  D06A CD 15 AB         call sprites_drawsprite                 ; draw the sprite over the old one
144+  D06D DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
144+  D071 46 01
145+  D073 0C               inc c               ; move down one pixel
146+  D074 DD 71 00 DD      ld (ix),bc          ; store the new coords
146+  D078 70 01
147+  D07A 3E 14            ld a,20                                 ; active missile sprite
148+  D07C CD 90 AA         call screen_getblock
149+  D07F CD 15 AB         call sprites_drawsprite                 ; draw the sprite
150+  D082 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
150+  D086 46 01
151+  D088 79               ld a,c              ; get the vertical coord into a
152+  D089 E6 07            and 7               ; divisible by 8?
153+  D08B FE 00            cp 0
154+  D08D C2 A7 D0         jp nz,missiles_fall1   ; if not, carry on
155+  D090 CD 43 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
156+  D093 3E 43            ld a,67             ; load magenta
157+  D095 CD 9B AA         call screen_setattr
158+  D098 DD 4E 00 DD      ld bc,(ix)
158+  D09C 46 01
159+  D09E CD 43 AA         call screen_getcharcoordsfromscreencoords ; get the attr address into de
160+  D0A1 05               dec b               ; look one square above
161+  D0A2 3E 46            ld a,70             ; load yellow
162+  D0A4 CD 9B AA         call screen_setattr
163+  D0A7              missiles_fall1:         ; hl at state
164+  D0A7 DD 4E 00 DD      ld bc,(ix)          ; get coords back
164+  D0AB 46 01
165+  D0AD CD E9 D0         call missiles_checkforplayer ; check for player
166+  D0B0 DD 23            inc ix
167+  D0B2 DD 23            inc ix
168+  D0B4 DD 23            inc ix              ; get to next missile
169+  D0B6 C1               pop bc
170+  D0B7 10 8B            djnz missiles_fall0
171+  D0B9 C9               ret
172+  D0BA              missiles_fall2:
173+  D0BA DD 36 02 00      ld (ix+2),0
174+  D0BE C3 A7 D0         jp missiles_fall1   ; rejoin the loop
175+  D0C1              missiles_fall4:
176+  D0C1 3D               dec a               ; decrease the countdown
177+  D0C2 DD 77 02         ld (ix+2),a         ; store back
178+  D0C5 C3 A7 D0         jp missiles_fall1   ; do next missile
179+  D0C8
180+  D0C8              ;
181+  D0C8              ; Adds the missile to the structure that tracks falling missile
182+  D0C8              ; Inputs:
183+  D0C8              ; bc - coords of missile, c vert
184+  D0C8              missiles_addmissiletofalling:
185+  D0C8 C5               push bc             ; store the coords
186+  D0C9 11 81 CF         ld de,missiles_falling
187+  D0CC 06 04            ld b,4              ; number of possible falling missiles
188+  D0CE              missiles_addmissiletofalling0:
189+  D0CE 13               inc de
190+  D0CF 13               inc de              ; move three along to get the state
191+  D0D0 1A               ld a,(de)           ; load the state
192+  D0D1 FE 00            cp 0                ; check if this is not falling
193+  D0D3 C2 E4 D0         jp nz,missiles_addmissiletofalling1 ; continue the loop if not 0
194+  D0D6 3E 19            ld a,25
195+  D0D8 12               ld (de),a           ; set the state to pre-falling
196+  D0D9 1B               dec de              ; move back coords
197+  D0DA C1               pop bc              ; get back coords
198+  D0DB 78               ld a,b
199+  D0DC 12               ld (de),a           ; store the vertical
200+  D0DD 1B               dec de
201+  D0DE 79               ld a,c
202+  D0DF 12               ld (de),a           ; store the horizontal
203+  D0E0 C5               push bc
204+  D0E1 C3 E7 D0         jp missiles_addmissiletofalling2 ; done
205+  D0E4              missiles_addmissiletofalling1:
206+  D0E4 13               inc de              ; move memory along to next rock
207+  D0E5 10 E7            djnz missiles_addmissiletofalling0 ; try the next missile
208+  D0E7              missiles_addmissiletofalling2: ; done, return
209+  D0E7 C1               pop bc              ; to tidy up
210+  D0E8 C9               ret
211+  D0E9
212+  D0E9              ;
213+  D0E9              ; Checks to see if the missile is hitting a player
214+  D0E9              ; Inputs:
215+  D0E9              ; bc - coords of missile we're checking
216+  D0E9              missiles_checkforplayer:
217+  D0E9 ED 5B F4 C5      ld de,(player)       ; get the player coords
218+  D0ED 7B               ld a,e               ; get the vert coord first
219+  D0EE 91               sub c                ; subtract the missile vertical coord from players
220+  D0EF FE 08            cp 8                 ; the missile will only hit a player if the player is directly underneath, so this must be 8
221+  D0F1 C0               ret nz               ; if not, hasn't hit
222+  D0F2 7A               ld a,d               ; get the player horiz coord
223+  D0F3 90               sub b                ; subtract missile coord
224+  D0F4 C6 07            add 7                ; add max distance
225+  D0F6 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
226+  D0F8 DA FC D0         jp c,missiles_checkforplayer0
227+  D0FB C9               ret
228+  D0FC              missiles_checkforplayer0:
229+  D0FC ED 43 8D CF      ld (missiles_killermissile),bc; store the coords of the killer missile
230+  D100 CD 23 C7         call player_zonkplayer ; if so, jump out
231+  D103 C9               ret
232+  D104
233+  D104              ;
234+  D104              ; Player has been hit, so draw text over them and mark as dead
235+  D104              ;
236+  D104              missiles_zonkplayer:
237+  D104 CD 11 C7         call player_killplayer      ; mark as dead
238+  D107 ED 4B F4 C5      ld bc,(player)              ; get player coords
239+  D10B CD 43 AA         call screen_getcharcoordsfromscreencoords
240+  D10E 0D               dec c
241+  D10F 0D               dec c
242+  D110 04               inc b
243+  D111 C5               push bc
244+  D112 3E 42            ld a,66
245+  D114 CD 9B AA         call screen_setattr
246+  D117 0C               inc c
247+  D118 CD 9B AA         call screen_setattr
248+  D11B 0C               inc c
249+  D11C CD 9B AA         call screen_setattr
250+  D11F 0C               inc c
251+  D120 CD 9B AA         call screen_setattr
252+  D123 0C               inc c
253+  D124 CD 9B AA         call screen_setattr
254+  D127 0C               inc c
255+  D128 CD 9B AA         call screen_setattr
256+  D12B C1               pop bc
257+  D12C ED 5B E3 A8      ld de,(screen_offset)
258+  D130 78               ld a,b
259+  D131 93               sub e
260+  D132 47               ld b,a                      ; subtract the offset
261+  D133 04               inc b
262+  D134 04               inc b                       ; add two for the score rows
263+  D135 ED 43 A3 85      ld (string_zonk),bc         ; set coords of string
264+  D139 21 A3 85         ld hl,string_zonk
265+  D13C CD 30 86         call string_print
266+  D13F 06 14            ld b,20
267+  D141 CD 64 81         call utilities_pauseforframes ; pause
268+  D144 C9               ret
269+  D145
# file closed: game/missiles.asm
165   D145                  include "game\thepit.asm"
# file opened: game/thepit.asm
  1+  D145              ;
  2+  D145              ; Timer for deciding how fast the trap withdraws
  3+  D145              ;
  4+  D145              thepit_timer:
  5+  D145 00               defb 0
  6+  D146
  7+  D146              ;
  8+  D146              ; Ticks for the trap state. Will count to 3 then reset
  9+  D146              ;
 10+  D146              thepit_trapcount:
 11+  D146 00               defb 0
 12+  D147
 13+  D147              ;
 14+  D147              ; The horizontal coordinate of the current pit trap
 15+  D147              ;
 16+  D147              thepit_trapcoord:
 17+  D147 08               defb 8
 18+  D148
 19+  D148              ;
 20+  D148              ; Initialises the pit
 21+  D148              ;
 22+  D148              thepit_init:
 23+  D148 21 47 D1         ld hl,thepit_trapcoord
 24+  D14B 36 08            ld (hl),8
 25+  D14D 21 46 D1         ld hl,thepit_trapcount
 26+  D150 36 00            ld (hl),0
 27+  D152 C9               ret
 28+  D153              ;
 29+  D153              ; The speed the pit will withdraw
 30+  D153              ;
 31+  D153              thepit_speed:
 32+  D153 00               defb 0
 33+  D154
 34+  D154              ;
 35+  D154              ; Performs per frame processing on the pit room
 36+  D154              ;
 37+  D154              thepit_process:
 38+  D154 3A 03 C6         ld a,(player_location)
 39+  D157 FE 02            cp 2                            ; if two, the player is in the pit, so process the trap
 40+  D159 C2 C3 D1         jp nz,thepit_process0
 41+  D15C ED 4B F4 C5      ld bc,(player)                  ; get the player's coords to check if about to fall
 42+  D160 3E 08            ld a,8
 43+  D162 81               add a,c
 44+  D163 4F               ld c,a                          ; look at the square underneath
 45+  D164 CD 43 AA         call screen_getcharcoordsfromscreencoords ; get the cell coords
 46+  D167 CD D1 AA         call screen_ischarempty
 47+  D16A FE 01            cp 1                            ; check if this is 1=empty
 48+  D16C CA C4 D1         jp z,thepit_process2
 49+  D16F 3A 45 D1         ld a,(thepit_timer)             ; get the timer
 50+  D172 3C               inc a
 51+  D173 32 45 D1         ld (thepit_timer),a             ; store
 52+  D176 ED 5B 53 D1      ld de,(thepit_speed)            ; get the speed
 53+  D17A BB               cp e                           ; have we reached the trigger?
 54+  D17B C2 C3 D1         jp nz, thepit_process0          ; no need to do anything
 55+  D17E 3E 00            ld a,0
 56+  D180 32 45 D1         ld (thepit_timer),a             ; zero the timer and process
 57+  D183 3A 46 D1         ld a,(thepit_trapcount)         ; get the current count
 58+  D186 3C               inc a
 59+  D187 32 46 D1         ld (thepit_trapcount),a         ; reset the trap count
 60+  D18A FE 04            cp 4                            ; do we need to begin another character?
 61+  D18C C2 AB D1         jp nz,thepit_process1           ; if not, draw as normal
 62+  D18F 3E 00            ld a,0
 63+  D191 32 46 D1         ld (thepit_trapcount),a         ; reset the trap count
 64+  D194 3A 47 D1         ld a,(thepit_trapcoord)         ; get the trap horiz coord
 65+  D197 FE 02            cp 2
 66+  D199 CA C3 D1         jp z,thepit_process0
 67+  D19C 4F               ld c,a
 68+  D19D 06 0A            ld b,10
 69+  D19F 3E 46            ld a,70
 70+  D1A1 CD 9B AA         call screen_setattr             ; set the attr of the empty square to yellow on black
 71+  D1A4 3A 47 D1         ld a,(thepit_trapcoord)         ; get the trap horiz coord
 72+  D1A7 3D               dec a
 73+  D1A8 32 47 D1         ld (thepit_trapcoord),a         ; store the reduced coord
 74+  D1AB
 75+  D1AB              thepit_process1:                    ; draw the trapdoor in current position
 76+  D1AB 3A 47 D1         ld a,(thepit_trapcoord)
 77+  D1AE FE 02            cp 2
 78+  D1B0 CA C3 D1         jp z, thepit_process0           ; don't process outside of the pit
 79+  D1B3 4F               ld c,a
 80+  D1B4 06 0A            ld b,10                         ; vertical coord will always be the same
 81+  D1B6 3A 46 D1         ld a,(thepit_trapcount)         ; get the trap count
 82+  D1B9 5F               ld e,a                          ; store in e
 83+  D1BA 3E 16            ld a,22                         ; 21 is full trapdoor
 84+  D1BC 83               add a,e
 85+  D1BD CD 90 AA         call screen_getblock
 86+  D1C0 CD 6D AA         call screen_showchar            ; show the char
 87+  D1C3
 88+  D1C3              thepit_process0:
 89+  D1C3 C9               ret
 90+  D1C4              thepit_process2:
 91+  D1C4 CD 29 C7         call player_pitkillplayer
 92+  D1C7 C9               ret
 93+  D1C8
# file closed: game/thepit.asm
166   D1C8                  include "game\monster.asm"
# file opened: game/monster.asm
  1+  D1C8
  2+  D1C8              ;
  3+  D1C8              ; Where the monster currently is
  4+  D1C8              ;
  5+  D1C8              monster_currentcoords:
  6+  D1C8 00 00            defb 0,0
  7+  D1CA
  8+  D1CA              ;
  9+  D1CA              ; The start coords of the monster
 10+  D1CA              ;
 11+  D1CA              monster_initcoords:
 12+  D1CA 70 1B            defb 112,27
 13+  D1CC
 14+  D1CC              ;
 15+  D1CC              ; Store the memory location of the current jump position
 16+  D1CC              ;
 17+  D1CC              monster_jumppos:
 18+  D1CC 00 00            defb 0,0
 19+  D1CE
 20+  D1CE              ;
 21+  D1CE              ; The jump table for the monster.
 22+  D1CE              ;
 23+  D1CE              monster_jumptable:
 24+  D1CE FF 03 02 02      defb 255,3,2,2,2,2,2,2,2,2,1,1,1,1,1,1,255
 24+  D1D2 02 02 02 02
 24+  D1D6 02 02 01 01
 24+  D1DA 01 01 01 01
 24+  D1DE FF
 25+  D1DF
 26+  D1DF              ;
 27+  D1DF              ; The vertical direction: 0 up, 1 down
 28+  D1DF              ;
 29+  D1DF              monster_jumpdirectionvert:
 30+  D1DF 00               defb 0
 31+  D1E0
 32+  D1E0              ;
 33+  D1E0              ; The horiz direction: 0 right, 1 left
 34+  D1E0              ;
 35+  D1E0              monster_jumpdirectionhoriz:
 36+  D1E0 00               defb 0
 37+  D1E1
 38+  D1E1              ;
 39+  D1E1              ; Frame offset, 0 or 32
 40+  D1E1              ;
 41+  D1E1              monster_frameoffset:
 42+  D1E1 00               defb 0
 43+  D1E2
 44+  D1E2              ;
 45+  D1E2              ; Monster tick
 46+  D1E2              ;
 47+  D1E2              monster_tick:
 48+  D1E2 00               defb 0
 49+  D1E3
 50+  D1E3              ;
 51+  D1E3              ; The colour of the monster
 52+  D1E3              ;
 53+  D1E3              monster_colour:
 54+  D1E3 06               defb 6
 55+  D1E4
 56+  D1E4              ;
 57+  D1E4              ; Initialises the pit monster
 58+  D1E4              ;
 59+  D1E4              monster_init:
 60+  D1E4 ED 4B CA D1      ld bc,(monster_initcoords)              ; load the initial coords
 61+  D1E8 ED 43 C8 D1      ld (monster_currentcoords),bc           ; save in current coords
 62+  D1EC 21 CF D1         ld hl,monster_jumptable+1
 63+  D1EF 22 CC D1         ld (monster_jumppos),hl                 ; store the initial position in the jump table
 64+  D1F2 3E 00            ld a,0
 65+  D1F4 32 DF D1         ld (monster_jumpdirectionvert),a        ; going up
 66+  D1F7 32 E1 D1         ld (monster_frameoffset),a
 67+  D1FA 32 E2 D1         ld (monster_tick),a
 68+  D1FD CD 87 D2         call monster_draw                       ; the monster
 69+  D200 C9               ret
 70+  D201
 71+  D201              ;
 72+  D201              ; Animate the monster
 73+  D201              ;
 74+  D201              monster_process:
 75+  D201 3A E2 D1         ld a,(monster_tick)                     ; check if we should draw this frame
 76+  D204 FE 01            cp 1
 77+  D206 CA 0E D2         jp z,monster_process6
 78+  D209 3C               inc a
 79+  D20A 32 E2 D1         ld (monster_tick),a                     ; increase the tick and continue
 80+  D20D C9               ret
 81+  D20E              monster_process6:
 82+  D20E 3E 00            ld a,0
 83+  D210 32 E2 D1         ld (monster_tick),a                     ; zero the tick
 84+  D213 CD 87 D2         call monster_draw                       ; overwrite the old sprite
 85+  D216 3A E1 D1         ld a,(monster_frameoffset)              ; get the anim frame offset
 86+  D219 EE 20            xor 32                                  ; flip between 0 and 32
 87+  D21B 32 E1 D1         ld (monster_frameoffset),a              ; store
 88+  D21E ED 4B C8 D1      ld bc,(monster_currentcoords)           ; get the current coords
 89+  D222 2A CC D1         ld hl,(monster_jumppos)                 ; get the position in the jump table
 90+  D225 56               ld d,(hl)                               ; get the jump modifier
 91+  D226 3A DF D1         ld a,(monster_jumpdirectionvert)        ; get the vertical direction
 92+  D229 FE 00            cp 0                                    ; if 0, going up, so dec vert
 93+  D22B C2 34 D2         jp nz,monster_process0
 94+  D22E 79               ld a,c
 95+  D22F 92               sub d
 96+  D230 23               inc hl                                  ; move forward a jump pos
 97+  D231 C3 37 D2         jp monster_process1
 98+  D234              monster_process0:
 99+  D234 79               ld a,c                                   ; going down so inc c
100+  D235 82               add a,d
101+  D236 2B               dec hl                                  ; move back a jump pos
102+  D237              monster_process1:
103+  D237 4F               ld c,a                                  ; get the vertical coord back
104+  D238 7E               ld a,(hl)                               ; check the next jump pos
105+  D239 FE FF            cp 255                                  ; if 255 reverse
106+  D23B CA 44 D2         jp z,monster_process3
107+  D23E 22 CC D1         ld (monster_jumppos),hl                 ; store the new pos
108+  D241 C3 56 D2         jp monster_process2                     ; keep going
109+  D244              monster_process3:
110+  D244 3A DF D1         ld a,(monster_jumpdirectionvert)        ; get the direction
111+  D247 EE 01            xor 1                                   ; flip it
112+  D249 32 DF D1         ld (monster_jumpdirectionvert),a        ; store it
113+  D24C FE 01            cp 1
114+  D24E CA 56 D2         jp z,monster_process2
115+  D251 D9               exx
116+  D252 CD 9A D2         call monster_colourchange
117+  D255 D9               exx
118+  D256              monster_process2:
119+  D256 3A E0 D1         ld a,(monster_jumpdirectionhoriz)       ; get the horiz direction
120+  D259 FE 00            cp 0                                    ; is it right?
121+  D25B C2 70 D2         jp nz,monster_process4
122+  D25E 04               inc b                                   ; 1 pixel right
123+  D25F 78               ld a,b
124+  D260 FE 38            cp 56                                   ; reached the edge of the pit?
125+  D262 C2 7F D2         jp nz,monster_process5
126+  D265 3A E0 D1         ld a,(monster_jumpdirectionhoriz)
127+  D268 EE 01            xor 1
128+  D26A 32 E0 D1         ld (monster_jumpdirectionhoriz),a       ; flip direction
129+  D26D C3 7F D2         jp monster_process5
130+  D270              monster_process4:
131+  D270 05               dec b                                   ; 1 pixel left
132+  D271 78               ld a,b
133+  D272 FE 18            cp 24                                   ; reached the edge of the pit?
134+  D274 C2 7F D2         jp nz,monster_process5
135+  D277 3A E0 D1         ld a,(monster_jumpdirectionhoriz)
136+  D27A EE 01            xor 1
137+  D27C 32 E0 D1         ld (monster_jumpdirectionhoriz),a       ; flip direction
138+  D27F              monster_process5:
139+  D27F ED 43 C8 D1      ld (monster_currentcoords),bc           ; store the new vertical coords
140+  D283 CD 87 D2         call monster_draw                       ; finally, draw the monster
141+  D286 C9               ret
142+  D287
143+  D287              ;
144+  D287              ; Draw the monster at the current location
145+  D287              ;
146+  D287              monster_draw:
147+  D287 ED 4B C8 D1      ld bc,(monster_currentcoords)
148+  D28B 3A E1 D1         ld a,(monster_frameoffset)
149+  D28E 11 00 00         ld de,0
150+  D291 5F               ld e,a
151+  D292 21 68 BF         ld hl,monster_sprite                    ; load the first frame
152+  D295 19               add hl,de
153+  D296 CD 73 AB         call sprites_draw2by2sprite
154+  D299 C9               ret
155+  D29A
156+  D29A              ;
157+  D29A              ; Changes the monster colour whenever it reaches the bottom of its jump
158+  D29A              ;
159+  D29A              monster_colourchange:
160+  D29A 3A E3 D1         ld a,(monster_colour)
161+  D29D 3C               inc a
162+  D29E FE 07            cp 7
163+  D2A0 C2 A5 D2         jp nz, monster_colourchange0
164+  D2A3 3E 01            ld a,1
165+  D2A5              monster_colourchange0:
166+  D2A5 32 E3 D1         ld (monster_colour),a                   ; save the monster colour
167+  D2A8 3A E3 A8         ld a,(screen_offset)
168+  D2AB FE 00            cp 0
169+  D2AD CA DA D2         jp z,monster_colourchange1
170+  D2B0 3A E3 D1         ld a,(monster_colour)                   ; get the monster colour
171+  D2B3 06 06            ld b,6
172+  D2B5 0E 40            ld c,64
173+  D2B7 81               add c                                   ; want this with black background, so add 64
174+  D2B8 11 A3 58         ld de,22528+163                         ; attrs here
175+  D2BB CD A6 A9         call screen_setcolours
176+  D2BE 3A E3 D1         ld a,(monster_colour)                   ; get the monster colour
177+  D2C1 06 06            ld b,6
178+  D2C3 0E 40            ld c,64
179+  D2C5 81               add c                                   ; want this with black background, so add 64
180+  D2C6 11 C3 58         ld de,22528+195                         ; attrs here
181+  D2C9 CD A6 A9         call screen_setcolours
182+  D2CC 3A E3 D1         ld a,(monster_colour)                   ; get the monster colour
183+  D2CF F6 60            or 96
184+  D2D1 06 06            ld b,6
185+  D2D3 11 E3 58         ld de,22528+227                         ; attrs here
186+  D2D6 CD A6 A9         call screen_setcolours
187+  D2D9 C9               ret
188+  D2DA              monster_colourchange1:
189+  D2DA 3A E3 D1         ld a,(monster_colour)                   ; get the monster colour
190+  D2DD 06 06            ld b,6
191+  D2DF 0E 40            ld c,64
192+  D2E1 81               add c                                   ; want this with black background, so add 64
193+  D2E2 11 A3 59         ld de,22528+419                         ; attrs here
194+  D2E5 CD A6 A9         call screen_setcolours
195+  D2E8 3A E3 D1         ld a,(monster_colour)                   ; get the monster colour
196+  D2EB 06 06            ld b,6
197+  D2ED 0E 40            ld c,64
198+  D2EF 81               add c                                   ; want this with black background, so add 64
199+  D2F0 11 C3 59         ld de,22528+451                         ; attrs here
200+  D2F3 CD A6 A9         call screen_setcolours
201+  D2F6 3A E3 D1         ld a,(monster_colour)                   ; get the monster colour
202+  D2F9 F6 60            or 96
203+  D2FB 06 06            ld b,6
204+  D2FD 11 E3 59         ld de,22528+483                         ; attrs here
205+  D300 CD A6 A9         call screen_setcolours
206+  D303 C9               ret
# file closed: game/monster.asm
167   D304                  include "game\robots.asm"
# file opened: game/robots.asm
  1+  D304
  2+  D304              ;
  3+  D304              ; Array of robot states
  4+  D304              ; x,y,state (0 inactive, 1 active), direction (0 left, 1 right), anim offset, automove frames remaining, move direction (0 left, 1 right, 3 up, 4 down)
  5+  D304              robots_robots:
  6+  D304 00 00 00 00      defb 0,0,0,0,0,0,0
  6+  D308 00 00 00
  7+  D30B 00 00 00 00      defb 0,0,0,0,0,0,0
  7+  D30F 00 00 00
  8+  D312 00 00 00 00      defb 0,0,0,0,0,0,0
  8+  D316 00 00 00
  9+  D319 00 00 00 00      defb 0,0,0,0,0,0,0
  9+  D31D 00 00 00
 10+  D320 00 00 00 00      defb 0,0,0,0,0,0,0
 10+  D324 00 00 00
 11+  D327
 12+  D327              robots_initcoords:
 13+  D327 18 E8            defb 24,232
 14+  D329
 15+  D329              ;
 16+  D329              ; When this reaches zero, spawn a new robot
 17+  D329              ;
 18+  D329              robots_spawntimer:
 19+  D329 FA               defb 250
 20+  D32A
 21+  D32A              ;
 22+  D32A              ; When this reaches max, change the anim frame
 23+  D32A              ;
 24+  D32A              robots_animtimer:
 25+  D32A 00               defb 0
 26+  D32B
 27+  D32B              ;
 28+  D32B              ; When this reaches max, change move the robot
 29+  D32B              ;
 30+  D32B              robots_movetimer:
 31+  D32B 00               defb 0
 32+  D32C
 33+  D32C
 34+  D32C              ;
 35+  D32C              ; The number of robots active
 36+  D32C              ;
 37+  D32C              robots_numberactive:
 38+  D32C 00               defb 0
 39+  D32D
 40+  D32D              ;
 41+  D32D              ; Tracks which directions a robot can move
 42+  D32D              ; up,down,left,right
 43+  D32D              robots_canmovedirections:
 44+  D32D 00 00 00 00      defb 0,0,0,0
 45+  D331
 46+  D331              ;
 47+  D331              ; The current robot speed
 48+  D331              ;
 49+  D331              robots_robotspeed:
 50+  D331 02               defb 2
 51+  D332
 52+  D332              ;
 53+  D332              ; The current robot spawn speed
 54+  D332              ;
 55+  D332              robots_robotspawnspeed:
 56+  D332 04               defb 4
 57+  D333
 58+  D333              ;
 59+  D333              ; The current max robots
 60+  D333              ;
 61+  D333              robots_robotsmax:
 62+  D333 03               defb 3
 63+  D334
 64+  D334              ;
 65+  D334              ; Initialises the robots
 66+  D334              ;
 67+  D334              robots_init:
 68+  D334 06 23            ld b,35
 69+  D336 DD 21 04 D3      ld ix,robots_robots
 70+  D33A              robots_init0:
 71+  D33A DD 36 00 00      ld (ix),0                       ; reset robot states back to zero
 72+  D33E DD 23            inc ix
 73+  D340 10 F8            djnz robots_init0
 74+  D342 3E 00            ld a,0
 75+  D344 32 2C D3         ld (robots_numberactive),a
 76+  D347 3E FA            ld a,250
 77+  D349 32 29 D3         ld (robots_spawntimer),a
 78+  D34C                  ; Self writing code
 79+  D34C                  ; Robot speed
 80+  D34C 3A 31 D3         ld a,(robots_robotspeed)
 81+  D34F 32 00 D4         ld (robots_process7+1),a
 82+  D352 3C               inc a
 83+  D353 32 30 D4         ld (robots_process6+1),a
 84+  D356                  ; Robots max
 85+  D356 3A 33 D3         ld a,(robots_robotsmax)
 86+  D359 32 6A D3         ld (robots_spawn+1),a
 87+  D35C 32 C1 D3         ld (robots_process8+1),a
 88+  D35F 32 EE D3         ld (robots_process0+1),a
 89+  D362 3A 32 D3         ld a,(robots_robotspawnspeed)
 90+  D365 32 D2 D3         ld (robots_process10+1),a
 91+  D368 C9               ret
 92+  D369
 93+  D369              ;
 94+  D369              ; Spawns a new robot
 95+  D369              ; Inputs:
 96+  D369              ; ix - pointer to start of robot array entry
 97+  D369              ;
 98+  D369              robots_spawn:
 99+  D369 06 03            ld b,3                      ;(SELF WRITING CODE)
100+  D36B DD 21 04 D3      ld ix,robots_robots
101+  D36F              robots_spawn0:
102+  D36F DD 7E 02         ld a,(ix+2)                 ; get the state
103+  D372 FE 00            cp 0
104+  D374 C2 A0 D3         jp nz,robots_spawn1         ; if already active, move on
105+  D377 ED 4B 27 D3      ld bc,(robots_initcoords)
106+  D37B DD 71 00 DD      ld (ix),bc
106+  D37F 70 01
107+  D381 DD 36 02 01      ld (ix+2),1
108+  D385 DD 36 03 00      ld (ix+3),0
109+  D389 DD 36 04 00      ld (ix+4),0
110+  D38D DD 36 05 00      ld (ix+5),0
111+  D391 DD 36 06 00      ld (ix+6),0
112+  D395 3A 2C D3         ld a,(robots_numberactive)
113+  D398 3C               inc a
114+  D399 32 2C D3         ld (robots_numberactive),a  ; increase the number active
115+  D39C CD 74 D6         call robots_draw            ; draw initial frame
116+  D39F C9               ret
117+  D3A0              robots_spawn1:
118+  D3A0 11 07 00         ld de,7
119+  D3A3 DD 19            add ix,de
120+  D3A5 10 C8            djnz robots_spawn0
121+  D3A7 C9               ret
122+  D3A8              ;
123+  D3A8              ; Kills robot
124+  D3A8              ; Inputs:
125+  D3A8              ; ix - pointer to start of robot array entry
126+  D3A8              ;
127+  D3A8              robots_kill:
128+  D3A8 3A 2C D3         ld a,(robots_numberactive)
129+  D3AB 3D               dec a
130+  D3AC 32 2C D3         ld (robots_numberactive),a
131+  D3AF DD 36 02 00      ld (ix+2),0                     ; set to inactive
132+  D3B3 C5               push bc
133+  D3B4 E5               push hl
134+  D3B5 06 01            ld b,1
135+  D3B7 CD 35 CD         call scores_addhundreds
136+  D3BA E1               pop hl
137+  D3BB C1               pop bc
138+  D3BC C9               ret
139+  D3BD
140+  D3BD              ;
141+  D3BD              ; Processes the robots
142+  D3BD              ;
143+  D3BD              robots_process:
144+  D3BD 3A 2C D3         ld a,(robots_numberactive)              ; first, check if we need to spawn a new robot
145+  D3C0              robots_process8:
146+  D3C0 FE 03            cp 3                                    ; 3 is the maximum
147+  D3C2 CA ED D3         jp z,robots_process0                    ; if already three, nothing to do
148+  D3C5 3A 32 D3         ld a,(robots_robotspawnspeed)                ; now check the spawn speed timer
149+  D3C8 3D               dec a
150+  D3C9 32 32 D3         ld (robots_robotspawnspeed),a           ; store the spawn speed timer
151+  D3CC FE 00            cp 0
152+  D3CE C2 ED D3         jp nz,robots_process0                   ; if it hasn't reached zero yet, just move
153+  D3D1              robots_process10:
154+  D3D1 3E 04            ld a,4                                  ; SELF WRITING CODE
155+  D3D3 32 32 D3         ld (robots_robotspawnspeed),a                ; reset the spawn speed timer
156+  D3D6 3A 29 D3         ld a,(robots_spawntimer)                ; now check the spawn timer
157+  D3D9 FE 00            cp 0
158+  D3DB C2 E9 D3         jp nz,robots_process1                   ; if it hasn't reached zero yet, just decrease
159+  D3DE 3E FA            ld a,250
160+  D3E0 32 29 D3         ld (robots_spawntimer),a                ; reset the spawn timer
161+  D3E3 CD 69 D3         call robots_spawn                       ; spawn a robot
162+  D3E6 C3 ED D3         jp robots_process0                      ; carry on
163+  D3E9              robots_process1:
164+  D3E9 3D               dec a
165+  D3EA 32 29 D3         ld (robots_spawntimer),a                ; decrease the spawn timer and store
166+  D3ED              robots_process0:
167+  D3ED 06 03            ld b,3                                  ; max number of robots (SELF WRITING CODE)
168+  D3EF DD 21 04 D3      ld ix, robots_robots                    ; point ix at the robot array
169+  D3F3              robots_process2:
170+  D3F3 C5               push bc
171+  D3F4 DD 7E 02         ld a,(ix+2)                             ; check the state
172+  D3F7 FE 00            cp 0
173+  D3F9 CA 15 D4         jp z,robots_process3                    ; if not active, move on
174+  D3FC 3A 2B D3         ld a,(robots_movetimer)
175+  D3FF              robots_process7:                            ; self writing code - the number in the comparison will be ovewritten
176+  D3FF FE 04            cp 4
177+  D401 C2 15 D4         jp nz,robots_process3                   ; can we move this frame
178+  D404 CD 74 D6         call robots_draw                        ; draw over existing
179+  D407 CD 3A D4         call robots_move                        ; move the
180+  D40A DD 7E 02         ld a,(ix+2)                             ; get the state again
181+  D40D FE 00            cp 0
182+  D40F CA 15 D4         jp z,robots_process3                    ; move to next if this robot has become inactive
183+  D412 CD 74 D6         call robots_draw                        ; draw the new robot
184+  D415              robots_process3:
185+  D415 C1               pop bc
186+  D416 11 07 00         ld de,7
187+  D419 DD 19            add ix,de
188+  D41B 10 D6            djnz robots_process2
189+  D41D 3A 2A D3         ld a,(robots_animtimer)
190+  D420 3C               inc a
191+  D421 FE 08            cp 8
192+  D423 C2 28 D4         jp nz,robots_process4
193+  D426 3E 00            ld a,0                                  ; reset if we reached max
194+  D428              robots_process4:
195+  D428 32 2A D3         ld (robots_animtimer),a
196+  D42B 3A 2B D3         ld a,(robots_movetimer)                 ; increment the robot move timer
197+  D42E 3C               inc a
198+  D42F              robots_process6:                            ; self writing code - the number in the comparison will be ovewritten
199+  D42F FE 05            cp 5                                    ; there is another reference to this number above
200+  D431 C2 36 D4         jp nz,robots_process5
201+  D434 3E 00            ld a,0
202+  D436              robots_process5:
203+  D436 32 2B D3         ld (robots_movetimer),a
204+  D439
205+  D439 C9               ret
206+  D43A
207+  D43A
208+  D43A              ;
209+  D43A              ; Moves a robot
210+  D43A              ; Inputs:
211+  D43A              ; ix - points to first byte of robot in array
212+  D43A              robots_move:
213+  D43A DD 7E 02         ld a,(ix+2)                             ; get the state
214+  D43D FE 02            cp 2
215+  D43F CA 70 D4         jp z,robots_move4                       ; don't move if shot, just change the anim
216+  D442 3A 2A D3         ld a,(robots_animtimer)                 ; get the anim timer
217+  D445 FE 07            cp 7                                    ; compare with 8
218+  D447 C2 5A D4         jp nz,robots_move1                       ; if even, don't increment frame
219+  D44A DD 7E 04         ld a,(ix+4)                             ; get the anim frame
220+  D44D 06 08            ld b,8
221+  D44F 80               add a,b                                 ; add to anim frame
222+  D450 FE 20            cp 32
223+  D452 C2 57 D4         jp nz,robots_move0                      ; if not 32, then just store
224+  D455 3E 00            ld a,0                                  ; otherwise, reset
225+  D457              robots_move0:
226+  D457 DD 77 04         ld (ix+4),a                             ; store
227+  D45A              robots_move1:
228+  D45A DD 7E 05         ld a,(ix+5)
229+  D45D FE 00            cp 0                                    ; are we automoving
230+  D45F CA 68 D4         jp z,robots_move2                       ; if not, keep directions
231+  D462 CD 84 D4         call robots_automove
232+  D465 C3 6C D4         jp robots_move3
233+  D468              robots_move2:
234+  D468 CD B9 D4         call robots_checkdirectionsandmove
235+  D46B C9               ret
236+  D46C              robots_move3:
237+  D46C CD BD D6         call robots_checkforplayer              ; check to see if we collided with a player
238+  D46F C9               ret
239+  D470              robots_move4:
240+  D470 DD 7E 04         ld a,(ix+4)
241+  D473 FE 48            cp 72
242+  D475 C2 7E D4         jp nz,robots_move5
243+  D478 3E 40            ld a,64
244+  D47A DD 77 04         ld (ix+4),a
245+  D47D C9               ret
246+  D47E              robots_move5:
247+  D47E 3E 48            ld a,72
248+  D480 DD 77 04         ld (ix+4),a
249+  D483 C9               ret
250+  D484
251+  D484
252+  D484              ;
253+  D484              ; Processes automove
254+  D484              ; Inputs:
255+  D484              ; ix - points to the current robot
256+  D484              ; a - number of frames left to move
257+  D484              robots_automove:
258+  D484 3D               dec a
259+  D485 DD 77 05         ld (ix+5),a                         ; store the decreased frames
260+  D488 DD 4E 00 DD      ld bc,(ix)                          ; get coords
260+  D48C 46 01
261+  D48E DD 7E 06         ld a,(ix+6)                         ; get the direction
262+  D491 FE 00            cp 0                                ; left
263+  D493 CA A4 D4         jp z,robots_automove1
264+  D496 FE 02            cp 2                                ; up
265+  D498 CA A8 D4         jp z,robots_automove3
266+  D49B FE 03            cp 3                                ; down
267+  D49D CA AD D4         jp z,robots_automove4
268+  D4A0 04               inc b                               ; right
269+  D4A1 C3 B2 D4         jp robots_automove2
270+  D4A4              robots_automove1:
271+  D4A4 05               dec b
272+  D4A5 C3 B2 D4         jp robots_automove2
273+  D4A8              robots_automove3:
274+  D4A8 0D               dec c
275+  D4A9 0D               dec c
276+  D4AA C3 B2 D4         jp robots_automove2
277+  D4AD              robots_automove4:
278+  D4AD 0C               inc c
279+  D4AE 0C               inc c
280+  D4AF C3 B2 D4         jp robots_automove2
281+  D4B2              robots_automove2:
282+  D4B2 DD 71 00 DD      ld (ix),bc
282+  D4B6 70 01
283+  D4B8 C9               ret
284+  D4B9
285+  D4B9              ;
286+  D4B9              ; Checks if a robot can move in all directions, then picks one and moves there.
287+  D4B9              ; This looks complicated, but really what it does is:
288+  D4B9              ; 1) Look at the current direction
289+  D4B9              ; 2) Randomly determine which orthoganal direction check first
290+  D4B9              ; 3) If orthogonal can't be moved, keep going in direction we're going
291+  D4B9              ; 4) Otherwise, back the way we came
292+  D4B9              ; Inputs:
293+  D4B9              ; ix - points to the current robot
294+  D4B9              ;
295+  D4B9              robots_checkdirectionsandmove:
296+  D4B9 DD 7E 06         ld a,(ix+6)                 ; get the direction
297+  D4BC FE 00            cp 0                        ; left
298+  D4BE C2 E5 D4         jp nz,robots_checkdirectionsandmove0
299+  D4C1                  ; random check
300+  D4C1 CD 9E C5         call game_getcurrentframe
301+  D4C4 E6 01            and 1                       ; odd or even
302+  D4C6 CA D2 D4         jp z,robots_checkdirectionsandmove3
303+  D4C9 CD 6B D5         call robots_checkupthendown ; prefer up over down
304+  D4CC FE 01            cp 1
305+  D4CE C8               ret z
306+  D4CF C3 D8 D4         jp robots_checkdirectionsandmove4
307+  D4D2              robots_checkdirectionsandmove3:
308+  D4D2 CD 61 D5         call robots_checkdownthenup ; prefer down over up
309+  D4D5 FE 01            cp 1
310+  D4D7 C8               ret z
311+  D4D8              robots_checkdirectionsandmove4:
312+  D4D8                  ; check left
313+  D4D8 CD FD D5         call robots_checkleftandmove
314+  D4DB FE 01            cp 1
315+  D4DD C8               ret z                       ; if we moved, don't check again
316+  D4DE                  ; check right
317+  D4DE CD 36 D6         call robots_checkrightandmove
318+  D4E1 FE 01            cp 1
319+  D4E3 C8               ret z                       ; if we moved, don't check again
320+  D4E4                  ; if we're here and haven't moved...
321+  D4E4 C9               ret
322+  D4E5              robots_checkdirectionsandmove0
323+  D4E5 FE 01            cp 1                        ; right
324+  D4E7 C2 0E D5         jp nz,robots_checkdirectionsandmove1
325+  D4EA                  ; ALREADY MOVING RIGHT
326+  D4EA                  ; random check
327+  D4EA CD 9E C5         call game_getcurrentframe
328+  D4ED E6 01            and 1                       ; odd or even
329+  D4EF CA FB D4         jp z,robots_checkdirectionsandmove5
330+  D4F2 CD 61 D5         call robots_checkdownthenup ; prefer down over up
331+  D4F5 FE 01            cp 1
332+  D4F7 C8               ret z
333+  D4F8 C3 01 D5         jp robots_checkdirectionsandmove6
334+  D4FB              robots_checkdirectionsandmove5:
335+  D4FB CD 6B D5         call robots_checkupthendown ; prefer down over up
336+  D4FE FE 01            cp 1
337+  D500 C8               ret z
338+  D501              robots_checkdirectionsandmove6:
339+  D501                  ; check right
340+  D501 CD 36 D6         call robots_checkrightandmove
341+  D504 FE 01            cp 1
342+  D506 C8               ret z                       ; if we moved, don't check again
343+  D507                  ; check left
344+  D507 CD FD D5         call robots_checkleftandmove
345+  D50A FE 01            cp 1
346+  D50C C8               ret z                       ; if we moved, don't check again
347+  D50D                  ; if we're here and haven't moved...
348+  D50D C9               ret
349+  D50E              robots_checkdirectionsandmove1
350+  D50E FE 02            cp 2                        ; up
351+  D510 C2 37 D5         jp nz,robots_checkdirectionsandmove2
352+  D513                  ; ALREADY MOVING UP
353+  D513                  ; random check
354+  D513 CD 9E C5         call game_getcurrentframe
355+  D516 E6 01            and 1                       ; odd or even
356+  D518 CA 24 D5         jp z,robots_checkdirectionsandmove7
357+  D51B CD 81 D5         call robots_checkleftthenright ; prefer left over right
358+  D51E FE 01            cp 1
359+  D520 C8               ret z
360+  D521 C3 2A D5         jp robots_checkdirectionsandmove8
361+  D524              robots_checkdirectionsandmove7:
362+  D524 CD 77 D5         call robots_checkrightthenleft ; prefer right over left
363+  D527 FE 01            cp 1
364+  D529 C8               ret z
365+  D52A              robots_checkdirectionsandmove8:
366+  D52A                  ; check up
367+  D52A CD 8D D5         call robots_checkupandmove
368+  D52D FE 01            cp 1
369+  D52F C8               ret z                       ; if we moved, don't check again
370+  D530                  ; check down
371+  D530 CD C7 D5         call robots_checkdownandmove
372+  D533 FE 01            cp 1
373+  D535 C8               ret z                       ; if we moved, don't check again
374+  D536                  ; if we're here and haven't moved...
375+  D536 C9               ret
376+  D537              robots_checkdirectionsandmove2
377+  D537                  ; ALREADY MOVING DOWN
378+  D537                  ; random check
379+  D537 CD 9E C5         call game_getcurrentframe
380+  D53A E6 01            and 1                       ; odd or even
381+  D53C CA 48 D5         jp z,robots_checkdirectionsandmove9
382+  D53F CD 77 D5         call robots_checkrightthenleft ; prefer right over left
383+  D542 FE 01            cp 1
384+  D544 C8               ret z
385+  D545 C3 4E D5         jp robots_checkdirectionsandmove10
386+  D548              robots_checkdirectionsandmove9:
387+  D548 CD 81 D5         call robots_checkleftthenright ; prefer left over right
388+  D54B FE 01            cp 1
389+  D54D C8               ret z
390+  D54E              robots_checkdirectionsandmove10:
391+  D54E                  ; check down
392+  D54E CD C7 D5         call robots_checkdownandmove
393+  D551 FE 01            cp 1
394+  D553 C8               ret z                       ; if we moved, don't check again
395+  D554                  ; check right first
396+  D554 CD 36 D6         call robots_checkrightandmove
397+  D557 FE 01            cp 1
398+  D559 C8               ret z                       ; if we moved, don't check again
399+  D55A                  ; check up
400+  D55A CD 8D D5         call robots_checkupandmove
401+  D55D FE 01            cp 1
402+  D55F C8               ret z                       ; if we moved, don't check again
403+  D560                  ; if we're here and haven't moved...
404+  D560 C9               ret
405+  D561
406+  D561              ;
407+  D561              ; Different orders of checking directions, for pseudo random motion
408+  D561              ;
409+  D561              robots_checkdownthenup:
410+  D561                  ; check down
411+  D561 CD C7 D5         call robots_checkdownandmove
412+  D564 FE 01            cp 1
413+  D566 C8               ret z                       ; if we moved, don't check again
414+  D567                  ; check up
415+  D567 CD 8D D5         call robots_checkupandmove
416+  D56A C9               ret
417+  D56B
418+  D56B              robots_checkupthendown:
419+  D56B                  ; check up
420+  D56B CD 8D D5         call robots_checkupandmove
421+  D56E FE 01            cp 1
422+  D570 C8               ret z
423+  D571                  ; check down
424+  D571 CD C7 D5         call robots_checkdownandmove
425+  D574 FE 01            cp 1
426+  D576 C9               ret
427+  D577              robots_checkrightthenleft:
428+  D577                  ; check right
429+  D577 CD 36 D6         call robots_checkrightandmove
430+  D57A FE 01            cp 1
431+  D57C C8               ret z                       ; if we moved, don't check again
432+  D57D                  ; check left
433+  D57D CD FD D5         call robots_checkleftandmove
434+  D580 C9               ret
435+  D581
436+  D581              robots_checkleftthenright:
437+  D581                  ; check left
438+  D581 CD FD D5         call robots_checkleftandmove
439+  D584 FE 01            cp 1
440+  D586 C8               ret z
441+  D587                  ; check right
442+  D587 CD 36 D6         call robots_checkrightandmove
443+  D58A FE 01            cp 1
444+  D58C C9               ret
445+  D58D
446+  D58D              ;
447+  D58D              ; Checks up for movement
448+  D58D              ; Outputs:
449+  D58D              ; a - 1 if have moved
450+  D58D              robots_checkupandmove:
451+  D58D                  ; check above
452+  D58D DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
452+  D591 46 01
453+  D593 79               ld a,c
454+  D594 FE 28            cp 40
455+  D596 D8               ret c
456+  D597 CD 1D AC         call sprites_scadd              ; get the memory location of cell into de
457+  D59A 62 6B            ld hl,de                        ; look at cell directly above (subtract 256)
458+  D59C 25               dec h
459+  D59D 79               ld a,c
460+  D59E 0E 08            ld c,8
461+  D5A0 91               sub c
462+  D5A1 4F               ld c,a
463+  D5A2 CD DE C2         call movement_spaceisempty       ; check space is empty
464+  D5A5 7B               ld a,e                          ; check space empty flag
465+  D5A6 FE 00            cp 0
466+  D5A8 CA C4 D5         jp z,robots_checkupandmove0    ; can't move here so return
467+  D5AB DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
467+  D5AF 46 01
468+  D5B1 0D               dec c                       ; move up
469+  D5B2 0D               dec c
470+  D5B3 DD 71 00 DD      ld (ix),bc
470+  D5B7 70 01
471+  D5B9 DD 36 06 02      ld (ix+6),2
472+  D5BD DD 36 05 03      ld (ix+5),3                 ; set the auto move frames
473+  D5C1 3E 01            ld a,1
474+  D5C3 C9               ret
475+  D5C4              robots_checkupandmove0:
476+  D5C4 3E 00            ld a,0
477+  D5C6 C9               ret
478+  D5C7
479+  D5C7              ;
480+  D5C7              ; Checks down for movement
481+  D5C7              ; Outputs:
482+  D5C7              ; a - 1 if have moved
483+  D5C7              robots_checkdownandmove:
484+  D5C7                  ; check below
485+  D5C7 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
485+  D5CB 46 01
486+  D5CD CD 1D AC         call sprites_scadd              ; get the memory location of cell into de
487+  D5D0 62 6B            ld hl,de                        ; look at cell directly above (add 256)
488+  D5D2 24               inc h
489+  D5D3 79               ld a,c
490+  D5D4 0E 08            ld c,8
491+  D5D6 81               add c
492+  D5D7 4F               ld c,a
493+  D5D8 CD DE C2         call movement_spaceisempty       ; check space is empty
494+  D5DB 7B               ld a,e                          ; check space empty flag
495+  D5DC FE 00            cp 0
496+  D5DE CA FA D5         jp z,robots_checkdownandmove0    ; can't move here so return
497+  D5E1 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
497+  D5E5 46 01
498+  D5E7 0C               inc c                       ; move up
499+  D5E8 0C               inc c
500+  D5E9 DD 71 00 DD      ld (ix),bc
500+  D5ED 70 01
501+  D5EF DD 36 06 03      ld (ix+6),3
502+  D5F3 DD 36 05 03      ld (ix+5),3                 ; set the auto move frames
503+  D5F7 3E 01            ld a,1
504+  D5F9 C9               ret
505+  D5FA              robots_checkdownandmove0:
506+  D5FA 3E 00            ld a,0
507+  D5FC C9               ret
508+  D5FD
509+  D5FD              ;
510+  D5FD              ; Checks left for movement
511+  D5FD              ; Outputs:
512+  D5FD              ; a - 1 if have moved
513+  D5FD              robots_checkleftandmove:
514+  D5FD                  ; check below
515+  D5FD DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
515+  D601 46 01
516+  D603 CD 1D AC         call sprites_scadd              ; get the memory location of cell into de
517+  D606 62 6B            ld hl,de                        ; look at cell directly to the left (sub 1)
518+  D608 78               ld a,b
519+  D609 06 08            ld b,8
520+  D60B 90               sub b                           ; move one cell left
521+  D60C 47               ld b,a
522+  D60D 2B               dec hl                          ; memory location of cell to the right now in hl
523+  D60E CD DE C2         call movement_spaceisempty       ; check space is empty
524+  D611 7B               ld a,e                          ; check space empty flag
525+  D612 FE 00            cp 0
526+  D614 CA 33 D6         jp z,robots_checkleftandmove0    ; if zero can't move
527+  D617 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
527+  D61B 46 01
528+  D61D 05               dec b
529+  D61E DD 71 00 DD      ld (ix),bc
529+  D622 70 01
530+  D624 DD 36 06 00      ld (ix+6),0
531+  D628 DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
532+  D62C DD 36 03 00      ld (ix+3),0                 ; set to right
533+  D630 3E 01            ld a,1
534+  D632 C9               ret
535+  D633              robots_checkleftandmove0:
536+  D633 3E 00            ld a,0
537+  D635 C9               ret
538+  D636
539+  D636              ;
540+  D636              ; Checks right for movement
541+  D636              ; Outputs:
542+  D636              ; a - 1 if have moved
543+  D636              robots_checkrightandmove:
544+  D636                  ; check below
545+  D636 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
545+  D63A 46 01
546+  D63C 78               ld a,b
547+  D63D FE E8            cp 232
548+  D63F CA 71 D6         jp z,robots_checkrightandmove0  ; can't move if at edge
549+  D642 CD 1D AC         call sprites_scadd              ; get the memory location of cell into de
550+  D645 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
551+  D647 3E 08            ld a,8
552+  D649 80               add b                           ; move one cell right
553+  D64A 47               ld b,a
554+  D64B 23               inc hl                          ; memory location of cell to the right now in hl
555+  D64C CD DE C2         call movement_spaceisempty       ; check space is empty
556+  D64F 7B               ld a,e                          ; check space empty flag
557+  D650 FE 00            cp 0
558+  D652 CA 71 D6         jp z,robots_checkrightandmove0    ; if zero can't move
559+  D655 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
559+  D659 46 01
560+  D65B 04               inc b
561+  D65C DD 71 00 DD      ld (ix),bc
561+  D660 70 01
562+  D662 DD 36 06 01      ld (ix+6),1
563+  D666 DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
564+  D66A DD 36 03 01      ld (ix+3),1                 ; set to right
565+  D66E 3E 01            ld a,1
566+  D670 C9               ret
567+  D671              robots_checkrightandmove0:
568+  D671 3E 00            ld a,0
569+  D673 C9               ret
570+  D674
571+  D674              ;
572+  D674              ; Draws a robot
573+  D674              ; Inputs:
574+  D674              ; ix - points to first byte of robot in array
575+  D674              robots_draw:
576+  D674 DD 4E 00 DD      ld bc,(ix)
576+  D678 46 01
577+  D67A 21 A8 BF         ld hl,robot_sprite                      ; set to the robot sprite
578+  D67D DD 7E 02         ld a,(ix+2)                             ; get the state
579+  D680 FE 02            cp 2                                    ; is this dying
580+  D682 CA 9D D6         jp z,robots_draw1
581+  D685              robots_draw3:
582+  D685 DD 7E 03         ld a,(ix+3)                             ; get the direction
583+  D688 FE 00            cp 0
584+  D68A CA 91 D6         jp z,robots_draw0                       ; if left, nothing to do
585+  D68D 11 20 00         ld de,32
586+  D690 19               add hl,de                               ; add four frames to sprite
587+  D691              robots_draw0:
588+  D691 DD 7E 04         ld a,(ix+4)                             ; get the anim frame
589+  D694 11 00 00         ld de,0
590+  D697 5F               ld e,a
591+  D698 19               add hl,de                               ; add to base
592+  D699 CD 15 AB         call sprites_drawsprite
593+  D69C C9               ret
594+  D69D              ;
595+  D69D              ; Dying
596+  D69D              ;
597+  D69D              robots_draw1:
598+  D69D DD 7E 05         ld a,(ix+5)                             ; get anim frames
599+  D6A0 FE 00            cp 0                                    ; if zero this is the first time around
600+  D6A2 C2 AD D6         jp nz,robots_draw2
601+  D6A5 3E 18            ld a,24
602+  D6A7 DD 77 05         ld (ix+5),a                             ; load up the anim frames
603+  D6AA C3 85 D6         jp robots_draw3                         ; return to main loop to draw as normal
604+  D6AD              robots_draw2:
605+  D6AD 3D               dec a
606+  D6AE DD 77 05         ld (ix+5),a
607+  D6B1 FE 00            cp 0                                    ; have we reached the end yet
608+  D6B3 C2 B9 D6         jp nz, robots_draw4
609+  D6B6 CD A8 D3         call robots_kill
610+  D6B9              robots_draw4:
611+  D6B9 C3 91 D6         jp robots_draw0
612+  D6BC C9               ret
613+  D6BD
614+  D6BD              ;
615+  D6BD              ; Checks to see if the robot is hitting a player
616+  D6BD              ; Inputs:
617+  D6BD              ; ix - memory location of robot we're checking
618+  D6BD              robots_checkforplayer:
619+  D6BD 3A FF C5         ld a,(player+11)     ; get player state
620+  D6C0 FE 00            cp 0
621+  D6C2 C0               ret nz               ; if already dying, don't kill again
622+  D6C3 DD 4E 00 DD      ld bc,(ix)           ; get coords
622+  D6C7 46 01
623+  D6C9 ED 5B F4 C5      ld de,(player)       ; get the player coords
624+  D6CD 7B               ld a,e               ; get the vert coord first
625+  D6CE 91               sub c                ; subtract the diamond vertical coord from players
626+  D6CF C6 08            add 8                ; add the max distance
627+  D6D1 FE 11            cp 17                ; compare to max*2+1? if carry flag set, they've hit
628+  D6D3 D0               ret nc               ; if not, hasn't hit
629+  D6D4 7A               ld a,d               ; get the player horiz coord
630+  D6D5 90               sub b                ; subtract rock coord
631+  D6D6 C6 08            add 8                ; add max distance
632+  D6D8 FE 11            cp 17                ; compare to max*2+1? if carry flag set, they've hit
633+  D6DA D0               ret nc
634+  D6DB DD 36 02 00      ld (ix+2),0          ; mark as inactive
635+  D6DF CD 2F C7         call player_robotkillplayer ; mark the player as killed
636+  D6E2 C9               ret
# file closed: game/robots.asm
168   D6E3                  include "game\bullet.asm"
# file opened: game/bullet.asm
  1+  D6E3              ;
  2+  D6E3              ; Current state: x & y coords (screen), direction (0 left, 1 right), state
  3+  D6E3              ;
  4+  D6E3              bullet_state:
  5+  D6E3 00 00 00 00      defb 0,0,0,0
  6+  D6E7
  7+  D6E7              ;
  8+  D6E7              ; Initialise a the bullet
  9+  D6E7              ;
 10+  D6E7              bullet_init:
 11+  D6E7 DD 21 E3 D6      ld ix,bullet_state
 12+  D6EB DD 36 00 00      ld (ix),0
 13+  D6EF DD 36 01 00      ld (ix+1),0
 14+  D6F3 DD 36 02 00      ld (ix+2),0
 15+  D6F7 DD 36 03 00      ld (ix+3),0
 16+  D6FB C9               ret
 17+  D6FC
 18+  D6FC              ;
 19+  D6FC              ; Shoots the bullet
 20+  D6FC              ;
 21+  D6FC              bullet_shoot:
 22+  D6FC DD 21 E3 D6      ld ix,bullet_state
 23+  D700 ED 4B F4 C5      ld bc,(player)              ; get the player coords
 24+  D704 3A F6 C5         ld a,(player+2)             ; get the player direction
 25+  D707 FE 01            cp 1                        ; going left?
 26+  D709 CA 17 D7         jp z,bullet_shoot0
 27+  D70C 3E 08            ld a,8
 28+  D70E 80               add a,b                     ; going right so add eight to start coords
 29+  D70F 47               ld b,a
 30+  D710 DD 36 02 01      ld (ix+2),1                 ; set right
 31+  D714 C3 20 D7         jp bullet_shoot1
 32+  D717              bullet_shoot0:
 33+  D717 78               ld a,b
 34+  D718 06 08            ld b,8
 35+  D71A 90               sub b
 36+  D71B 47               ld b,a                      ; going left so subtract eight to start coords
 37+  D71C DD 36 02 00      ld (ix+2),0                 ; set right
 38+  D720              bullet_shoot1:
 39+  D720 DD 71 00 DD      ld (ix),bc        ; store coords
 39+  D724 70 01
 40+  D726 DD 36 03 01      ld (ix+3),1       ; set state to 1
 41+  D72A CD 80 D7         call bullet_draw ; draw the initial frame
 42+  D72D C9               ret
 43+  D72E
 44+  D72E              ;
 45+  D72E              ; Performs bullet processing
 46+  D72E              ;
 47+  D72E              bullet_process:
 48+  D72E 3A E6 D6         ld a,(bullet_state+3)       ; get the state
 49+  D731 FE 00            cp 0
 50+  D733 C8               ret z                       ; don't draw if this has become inactive
 51+  D734 CD 80 D7         call bullet_draw            ; delete current frame
 52+  D737 CD 44 D7         call bullet_move            ; move the bullet
 53+  D73A 3A E6 D6         ld a,(bullet_state+3)       ; get the state
 54+  D73D FE 00            cp 0
 55+  D73F C8               ret z                       ; don't draw if this has become inactive
 56+  D740 CD 80 D7         call bullet_draw            ; draw new frame
 57+  D743 C9               ret
 58+  D744
 59+  D744              ;
 60+  D744              ; Moves the bullet, checking for collisions
 61+  D744              ;
 62+  D744              bullet_move:
 63+  D744 DD 21 E3 D6      ld ix,bullet_state
 64+  D748 DD 4E 00 DD      ld bc,(ix)
 64+  D74C 46 01
 65+  D74E DD 7E 02         ld a,(ix+2)                 ; get the direction
 66+  D751 FE 00            cp 0                        ; going left?
 67+  D753 CA 5D D7         jp z,bullet_move0
 68+  D756 3E 08            ld a,8
 69+  D758 80               add b
 70+  D759 47               ld b,a                      ; add 8 since going right
 71+  D75A C3 62 D7         jp bullet_move1
 72+  D75D              bullet_move0:
 73+  D75D 78               ld a,b
 74+  D75E 06 08            ld b,8
 75+  D760 90               sub b
 76+  D761 47               ld b,a                      ; subtract 8 since going left
 77+  D762              bullet_move1:
 78+  D762 DD 71 00 DD      ld (ix),bc                  ; store new coords
 78+  D766 70 01
 79+  D768 C5               push bc
 80+  D769 CD 8D D7         call bullets_checkforrobot
 81+  D76C C1               pop bc
 82+  D76D FE 01            cp 1                        ; if we hit a robot, keep moving
 83+  D76F C8               ret z
 84+  D770 CD 1D AC         call sprites_scadd          ; get memory loc of this block into de
 85+  D773 21 60 00         ld hl,96
 86+  D776 19               add hl,de
 87+  D777 7E               ld a,(hl)                   ; get the content
 88+  D778 FE 00            cp 0
 89+  D77A C8               ret z                       ; if empty, continue
 90+  D77B DD 36 03 00      ld (ix+3),0                 ; otherwise, mark bullet as inactive
 91+  D77F C9               ret
 92+  D780
 93+  D780              ;
 94+  D780              ; Draw the bullet
 95+  D780              ;
 96+  D780              bullet_draw:
 97+  D780 ED 4B E3 D6      ld bc,(bullet_state)        ; get coords
 98+  D784 3E 1B            ld a,27
 99+  D786 CD 90 AA         call screen_getblock        ; get the block address
100+  D789 CD 15 AB         call sprites_drawsprite     ; draw the sprite
101+  D78C C9               ret
102+  D78D
103+  D78D              ;
104+  D78D              ; Checks to see if the robot is hitting a bullet
105+  D78D              ; Outputs:
106+  D78D              ; a = 0 if not robot hit
107+  D78D              ; a = 1 if robot not hit
108+  D78D              bullets_checkforrobot:
109+  D78D 3E 00            ld a,0
110+  D78F 32 E3 D7         ld (bullets_tmp),a
111+  D792 3A 33 D3         ld a,(robots_robotsmax) ; robots to check
112+  D795 47               ld b,a
113+  D796 FD 21 04 D3      ld iy,robots_robots   ; start of robot array
114+  D79A              bullets_checkforrobot0:
115+  D79A C5               push bc
116+  D79B FD 7E 02         ld a,(iy+2)             ; get the state
117+  D79E FE 01            cp 1
118+  D7A0 C2 D7 D7         jp nz,bullets_checkforrobot1 ; if not active, don't check
119+  D7A3 FD 5E 00 FD      ld de,(iy)              ; get robot coords
119+  D7A7 56 01
120+  D7A9 7A               ld a,d
121+  D7AA E6 F8            and 248                 ; get nearest multiple of 8
122+  D7AC 57               ld d,a
123+  D7AD ED 4B E3 D6      ld bc,(bullet_state)    ; get bullet coords
124+  D7B1 7A               ld a,d               ; get the player horiz coord
125+  D7B2 90               sub b                ; subtract robot coord
126+  D7B3 FE 00            cp 0                ; should be the same
127+  D7B5 C2 C1 D7         jp nz,bullets_checkforrobot2 ; if not, might have hit, so check the next char along... if matched, check vert
128+  D7B8 3E 08            ld a,8
129+  D7BA 82               add a,d
130+  D7BB 90               sub b                ; check again for the next char along
131+  D7BC FE 00            cp 0
132+  D7BE C2 D7 D7         jp nz,bullets_checkforrobot1 ; if not, haven't hit
133+  D7C1              bullets_checkforrobot2:
134+  D7C1 7B               ld a,e               ; get the vert coord
135+  D7C2 91               sub c                ; subtract the bullet vertical coord from robots
136+  D7C3 C6 04            add 4                ; add the max distance
137+  D7C5 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
138+  D7C7 D2 D7 D7         jp nc,bullets_checkforrobot1   ; if not, hasn't hit
139+  D7CA FD 36 02 02      ld (iy+2),2             ; mark the robot as killed
140+  D7CE FD 36 05 00      ld (iy+5),0             ; mark the anim frames as zero
141+  D7D2 3E 01            ld a,1
142+  D7D4 32 E3 D7         ld (bullets_tmp),a      ; hit the flag to say we killed a robot
143+  D7D7              bullets_checkforrobot1:
144+  D7D7 11 07 00         ld de,7
145+  D7DA FD 19            add iy,de              ; move to next robot
146+  D7DC C1               pop bc
147+  D7DD 10 BB            djnz bullets_checkforrobot0
148+  D7DF 3A E3 D7         ld a,(bullets_tmp)
149+  D7E2 C9               ret
150+  D7E3
151+  D7E3              bullets_tmp:
152+  D7E3 00               defb 0
153+  D7E4
# file closed: game/bullet.asm
169   D7E4
170   D7E4              ;===========================================================================
171   D7E4              ; Stack.
172   D7E4              ;===========================================================================
173   D7E4
174   D7E4              ; Stack: this area is reserved for the stack
175   D7E4              STACK_SIZE: equ 100    ; in words
176   D7E4
177   D7E4              ; Reserve stack space
178   D7E4 00 00            defw 0  ; WPMEM, 2
179   D7E6              stack_bottom:
180   D7E6 00 00 00...      defs    STACK_SIZE*2, 0
181   D8AE              stack_top:
182   D8AE 00 00            defw 0  ; WPMEM, 2
183   D8B0
184   D8B0                     SAVESNA "./dist/ThePit.sna", main
185   D8B0                     ;SAVETAP "./dist/ThePit.tap", main
# file closed: main.asm
