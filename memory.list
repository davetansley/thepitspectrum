# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;
  6   8000              ; Main entry point
  7   8000              ;
  8   8000              main:
  9   8000 21 6D B9         ld hl,font
 10   8003 22 36 5C         ld (23606),hl
 11   8006 CD B8 B0         call options_show
 12   8009                  ; Show the red pre-title screen
 13   8009 CD 60 AC         call titlescreen_preshow
 14   800C
 15   800C                  ; Draw the title screen
 16   800C              main_titlescreen:
 17   800C CD 6C AC         call titlescreen_show
 18   800F CD 63 C6         call player_init_gamestart
 19   8012
 20   8012              main_lifestart:
 21   8012
 22   8012 CD 8E C6         call player_init_lifestart
 23   8015 CD 98 C5         call game_setcurrentrocks   ; set the current rocks based on the level
 24   8018                  ;ld a,6
 25   8018                  ;ld (game_difficulty),a
 26   8018 CD D8 C5         call game_setdifficulty     ; set the current difficulty
 27   801B
 28   801B CD F9 AD         call lifescreen_draw        ; show the lives remaining screen
 29   801E
 30   801E CD C9 80         call init_start
 31   8021 CD 12 A9         call screen_draw
 32   8024 CD 61 A8         call buffer_allbuffertoscreen
 33   8027
 34   8027 CD EE CF         call missiles_init
 35   802A CD BA C8         call ship_land              ; land the ship
 36   802D CD E1 C9         call tank_init
 37   8030 CD B5 CF         call diamonds_init
 38   8033 CD A6 D1         call thepit_init
 39   8036 CD 41 D2         call monster_init
 40   8039 CD 91 D3         call robots_init
 41   803C CD 9D D7         call bullet_init
 42   803F
 43   803F              mloop:
 44   803F                  ;halt
 45   803F CD 86 80         call main_loop_processing
 46   8042
 47   8042                  ;
 48   8042                  ; Check if the player died
 49   8042                  ;
 50   8042 21 27 C6         ld hl,player+10
 51   8045 7E               ld a,(hl)                   ; check if the player died this frame
 52   8046 FE 01            cp 1
 53   8048 C2 72 80         jp nz,mloop0
 54   804B CD 1F C7         call player_died        ; do end of life housekeeping
 55   804E 06 28            ld b,40
 56   8050 CD 64 81         call utilities_pauseforframes
 57   8053
 58   8053 21 26 C6         ld hl,player+9        ; check lives remaining
 59   8056 7E               ld a,(hl)
 60   8057 FE 00            cp 0
 61   8059 C2 6C 80         jp nz,mloop1         ; haven't finished, so keep going
 62   805C
 63   805C 3A 2D C5         ld a,(game_numberplayers) ; get the number of players
 64   805F FE 01            cp 1
 65   8061 CA BA 80         jp z,main_gameover   ; if just one player, then this is game over
 66   8064
 67   8064 3A 2E C5         ld a,(game_currentplayer) ; get the current player
 68   8067 FE 02            cp 2                    ; if we're here, we have no lives, and if the current player is 2, then we're done
 69   8069 CA BA 80         jp z,main_gameover            ; if it's  two game over
 70   806C
 71   806C              mloop1:
 72   806C CD 7C C5         call game_changeplayer ; change player if needed
 73   806F C3 12 80         jp main_lifestart    ; otherwise, start a new life
 74   8072              mloop0:
 75   8072                  ;
 76   8072                  ; Check if the player completed the level
 77   8072                  ;
 78   8072 21 2A C6         ld hl,player+13
 79   8075 7E               ld a,(hl)
 80   8076 FE 01            cp 1
 81   8078 C2 3F 80         jp nz,mloop
 82   807B CD 59 C8         call player_checkforexit
 83   807E FE 01            cp 1                        ; look at return, if 1, level has been completed
 84   8080 CA C0 80         jp z,main_endlevel          ; jump to level transition screen
 85   8083 C3 3F 80         jp mloop                ; start the loop again
 86   8086
 87   8086
 88   8086              main_loop_processing:
 89   8086
 90   8086 CD 20 A8         call buffer_buffertoscreen  ; copy buffer to screen
 91   8089 CD 85 A7         call buffer_clearlist       ; zero the updated lines list
 92   808C CD 2D C6         call player_getlocation     ; figure out where the player is
 93   808F CD 63 C7         call player_drawplayer      ; delete player
 94   8092 CD 11 C0         call control_input          ; check input
 95   8095 CD 63 C7         call player_drawplayer      ; draw player
 96   8098 CD 10 CA         call tank_process           ; prcoess the tank
 97   809B CD 7B C8         call ship_process           ; proces the ship
 98   809E CD 30 CC         call rocks_processrocks     ; process falling rocks
 99   80A1 CD B2 D1         call thepit_process         ; process the pit trap
100   80A4 CD 16 D0         call missiles_process       ; process missiles
101   80A7 CD 5E D2         call monster_process        ; process monster
102   80AA CD 22 D4         call robots_process         ; process robots
103   80AD CD E9 D7         call bullet_process         ; process the bullet
104   80B0 CD 94 CF         call diamonds_twinkle       ; make the diamonds twinkle
105   80B3 CD A3 CD         call scores_printscore      ; update the score on screen
106   80B6 CD B8 C5         call game_incrementframe    ; increment the game frame
107   80B9
108   80B9 C9               ret
109   80BA
110   80BA              main_gameover:
111   80BA CD 5C AE         call gameover_draw          ; show the game over screen
112   80BD C3 0C 80         jp main_titlescreen         ; go back to title
113   80C0
114   80C0              main_endlevel:
115   80C0 CD ED C6         call player_recordcurrentstate
116   80C3 CD AA AF         call endlevel_draw          ; show the end level screen
117   80C6 C3 12 80         jp main_lifestart           ; start a new life
118   80C9
119   80C9
120   80C9              ;===========================================================================
121   80C9              ; Include modules
122   80C9              ;===========================================================================
123   80C9                  include "init.asm"
# file opened: init.asm
  1+  80C9              ;
  2+  80C9              ; Set up at start up
  3+  80C9              ;
  4+  80C9              init_start:
  5+  80C9              ; We want a black screen.
  6+  80C9
  7+  80C9 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  80CB                                      ; bright (64).
  9+  80CB CD 49 81         call utilities_clearscreen
 10+  80CE 32 8D 5C         ld (23693),a        ; set our screen colours.
 11+  80D1 AF               xor a               ; quick way to load accumulator with zero.
 12+  80D2 CD 9B 22         call 8859           ; set permanent border colours.
 13+  80D5
 14+  80D5 21 F7 A8         ld hl,screen_offset ; reset some temp variables
 15+  80D8 36 00            ld (hl),0
 16+  80DA 21 F8 A8         ld hl,screen_tmp
 17+  80DD 36 00            ld (hl),0
 18+  80DF 21 2C A7         ld hl,buffer_tmp
 19+  80E2 36 00            ld (hl),0
 20+  80E4 23               inc hl
 21+  80E5 36 00            ld (hl),0
 22+  80E7
 23+  80E7 CD CB C5         call game_resetcurrentframe ; reset current frame
 24+  80EA
 25+  80EA C9               ret
 26+  80EB
 27+  80EB              ;
 28+  80EB              ;   Start coord
 29+  80EB              ;   vert c, horiz b
 30+  80EB              init_coord:
 31+  80EB 18 30            defb 24,48
 32+  80ED
 33+  80ED              ;
 34+  80ED              ; Number of lives to start
 35+  80ED              ;
 36+  80ED              init_lives:
 37+  80ED 03               defb 3
 38+  80EE
 39+  80EE              ;
 40+  80EE              ; Score to start
 41+  80EE              ;
 42+  80EE              init_score:
 43+  80EE 30 30 30 30      defb '000000'
 43+  80F2 30 30
# file closed: init.asm
124   80F4                  include "utilities.asm"
# file opened: utilities.asm
  1+  80F4              ; ##########################################################################
  2+  80F4              ; Print a character
  3+  80F4              ; Inputs:
  4+  80F4              ; b - x coord
  5+  80F4              ; c - y coord
  6+  80F4              ; d - character
  7+  80F4              ; e - colour
  8+  80F4              ; ##########################################################################
  9+  80F4              utilities_print_char:
 10+  80F4 7B               ld a,e
 11+  80F5 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  80F8 3E 16            ld a,22
 13+  80FA D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  80FB 78               ld a,b              ; Gets the X co-ordinate
 15+  80FC 3D               dec a
 16+  80FD D7               rst 16
 17+  80FE 79               ld a,c              ; and the Y co-ordinate
 18+  80FF D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  8100 7A               ld a,d              ; ASCII code for udg.
 20+  8101 D7               rst 16              ; draw block.
 21+  8102 C9               ret
 22+  8103
 23+  8103
 24+  8103              ;Inputs:
 25+  8103              ;     DE and A are factors
 26+  8103              ;Outputs:
 27+  8103              ;     A is not changed
 28+  8103              ;     B is 0
 29+  8103              ;     C is not changed
 30+  8103              ;     DE is not changed
 31+  8103              ;     HL is the product
 32+  8103              ;Time:
 33+  8103              ;     342+6x
 34+  8103              ;
 35+  8103              utilities_multiply:
 36+  8103 06 08            ld b,8          ;7           7
 37+  8105 21 00 00         ld hl,0         ;10         10
 38+  8108 29               add hl,hl     ;11*8       88
 39+  8109 07               rlca          ;4*8        32
 40+  810A 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  810C 19                   add hl,de   ;--         --
 42+  810D 10 F9            djnz $-5      ;13*7+8     99
 43+  810F C9               ret             ;10         10
 44+  8110
 45+  8110              utilities_waitforkey:
 46+  8110 21 08 5C         ld hl,23560         ; LAST K system variable.
 47+  8113 36 00            ld (hl),0           ; put null value there.
 48+  8115              utilities_waitforkey0:
 49+  8115 7E               ld a,(hl)           ; new value of LAST K.
 50+  8116 FE 00            cp 0                ; is it still zero?
 51+  8118 20 0A            jr nz,utilities_waitforkey1           ; yes, so no key pressed.
 52+  811A 01 1F 00         ld bc,31                        ; Kempston joystick port.
 53+  811D ED 78            in a,(c)                        ; read input.
 54+  811F E6 10            and 16
 55+  8121 CA 15 81         jp z,utilities_waitforkey0
 56+  8124              utilities_waitforkey1:
 57+  8124 C9               ret                 ; key was pressed.
 58+  8125
 59+  8125              ;
 60+  8125              ; Waits number of frames for keypress. If got, returns 1, if not 0
 61+  8125              ; Inputs:
 62+  8125              ; a - number of frames to waits
 63+  8125              ; Ouputs:
 64+  8125              ; e - 0 not pressed, 1 pressed
 65+  8125              utilities_waitforkey_forframes:
 66+  8125 21 08 5C         ld hl,23560         ; LAST K system variable.
 67+  8128 36 00            ld (hl),0           ; put null value there.
 68+  812A 47               ld b,a              ; number of frames to wait
 69+  812B              utilities_waitforkey_forframes0:
 70+  812B 7E               ld a,(hl)           ; new value of LAST K.
 71+  812C FE 00            cp 0                ; is it still zero?
 72+  812E 28 03            jr z,utilities_waitforkey_forframes1           ; yes, so no key pressed.
 73+  8130 1E 01            ld e,1              ; set the pressed flag
 74+  8132 C9               ret                 ; key was pressed.
 75+  8133              utilities_waitforkey_forframes1:
 76+  8133 C5               push bc
 77+  8134 01 1F 00         ld bc,31                        ; Kempston joystick port.
 78+  8137 ED 78            in a,(c)                        ; read input.
 79+  8139 C1               pop bc
 80+  813A E6 10            and 16
 81+  813C CA 42 81         jp z,utilities_waitforkey_forframes2
 82+  813F 1E 01            ld e,1              ; set the pressed flag
 83+  8141 C9               ret                 ; key was pressed.
 84+  8142              utilities_waitforkey_forframes2:
 85+  8142 76               halt                ; wait for frame
 86+  8143 76               halt                ; wait for frame
 87+  8144 10 E5            djnz utilities_waitforkey_forframes0 ; loop again
 88+  8146 1E 00            ld e,0              ; nothing pressed in time
 89+  8148 C9               ret
 90+  8149
 91+  8149              ;
 92+  8149              ; Clears the screen
 93+  8149              ; Inputs:
 94+  8149              ; a - attribute colour
 95+  8149              utilities_clearscreen:
 96+  8149 76               halt
 97+  814A 21 00 58         ld hl,22528         ; attr
 98+  814D 11 01 58         ld de,22529         ; attr+1
 99+  8150 01 FF 02         ld bc,767
100+  8153 77               ld (hl),a
101+  8154 ED B0            ldir
102+  8156
103+  8156 21 00 40         ld hl, 16384        ;pixels
104+  8159 11 01 40         ld de, 16385        ;pixels + 1
105+  815C 01 FF 17         ld bc, 6143         ;pixels area length - 1
106+  815F 36 00            ld (hl), 0          ;set first byte to '0'
107+  8161 ED B0            ldir                ;copy bytes
108+  8163
109+  8163 C9               ret
110+  8164
111+  8164              ;
112+  8164              ; Wait for a number of frames
113+  8164              ; Inputs:
114+  8164              ; b - number of frames
115+  8164              utilities_pauseforframes:
116+  8164 76               halt
117+  8165 10 FD            djnz utilities_pauseforframes
118+  8167 C9               ret
119+  8168
120+  8168              utilities_readkey:
121+  8168 21 88 81         LD HL,utilties_keymap              ; Point HL at the keyboard list
122+  816B 16 08            LD D,8                                  ; This is the number of ports (rows) to check
123+  816D 0E FE            LD C,$FE                            ; C is always FEh for reading keyboard ports
124+  816F              utilities_readkey_0:
125+  816F 46               LD B,(HL)                               ; Get the keyboard port address from table
126+  8170 23               INC HL                                  ; Increment to list of keys
127+  8171 ED 78            IN A,(C)                                ; Read the row of keys in
128+  8173 E6 1F            AND $1F                                     ; We are only interested in the first five bits
129+  8175 1E 05            LD E,5                                  ; This is the number of keys in the row
130+  8177              utilities_readkey_1:
131+  8177 CB 3F            SRL A                                   ; Shift A right; bit 0 sets carry bit
132+  8179 30 0B            JR NC,utilities_readkey_2   ; If the bit is 0, we've found our key
133+  817B 23               INC HL                                  ; Go to next table address
134+  817C 1D               DEC E                                   ; Decrement key loop counter
135+  817D 20 F8            JR NZ,utilities_readkey_1   ; Loop around until this row finished
136+  817F 15               DEC D                                   ; Decrement row loop counter
137+  8180 20 ED            JR NZ,utilities_readkey_0   ; Loop around until we are done
138+  8182 A7               AND A                                   ; Clear A (no key found)
139+  8183 C3 68 81         jp utilities_readkey
140+  8186              utilities_readkey_2:
141+  8186 7E               LD A,(HL)                               ; We've found a key at this point; fetch the character code!
142+  8187 C9               RET
143+  8188
144+  8188              utilties_keymap:
145+  8188 FE 23 5A 58      defb $FE,"#","Z","X","C","V"
145+  818C 43 56
146+  818E FD 41 53 44      defb $FD,"A","S","D","F","G"
146+  8192 46 47
147+  8194 FB 51 57 45      defb $FB,"Q","W","E","R","T"
147+  8198 52 54
148+  819A F7 31 32 33      defb $F7,"1","2","3","4","5"
148+  819E 34 35
149+  81A0 EF 30 39 38      defb $EF,"0","9","8","7","6"
149+  81A4 37 36
150+  81A6 DF 50 4F 49      defb $DF,"P","O","I","U","Y"
150+  81AA 55 59
151+  81AC BF 23 4C 4B      defb $BF,"#","L","K","J","H"
151+  81B0 4A 48
152+  81B2 7F 20 23 4D      defb $7F," ","#","M","N","B"
152+  81B6 4E 42
153+  81B8
154+  81B8
155+  81B8              ;
156+  81B8              ; Generates a randomish number in the range 0 to e
157+  81B8              ; Inputs:
158+  81B8              ; e - upper value
159+  81B8              ; Outputs:
160+  81B8              ; a - random number
161+  81B8              utilities_randomupper
162+  81B8 3A 2C C5         ld a,(game_framenumber)
163+  81BB 6F               ld l,a
164+  81BC 26 00            ld h,0
165+  81BE 16 00            ld d,0
166+  81C0 42 4B            ld bc,de
167+  81C2              utilities_randomupper0:
168+  81C2 B7               or a
169+  81C3 ED 42            sbc hl,bc
170+  81C5 F2 C2 81         jp p,utilities_randomupper0
171+  81C8 09               add hl,bc
172+  81C9 01 00 00         ld bc,0
173+  81CC 09               add hl,bc
174+  81CD 7D               ld a,l
175+  81CE C9               ret
176+  81CF
177+  81CF              ;
178+  81CF              ; A pointer to somewhere in the first 8k of ram
179+  81CF              ;
180+  81CF              utilities_rampointer:
181+  81CF 40 1F            defb 64,31
182+  81D1
183+  81D1              utilities_randomfromram:
184+  81D1 2A CF 81         ld hl,(utilities_rampointer)
185+  81D4 2B               dec hl
186+  81D5 7C               ld a,h
187+  81D6 FE 00            cp 0
188+  81D8 C2 DE 81         jp nz,utilities_randomfromram0
189+  81DB 21 40 1F         ld hl,8000                        ; check if pointer high byte has reached zero, if so, set to 8000
190+  81DE              utilities_randomfromram0:
191+  81DE 22 CF 81         ld (utilities_rampointer),hl
192+  81E1 7E               ld a,(hl)                         ; get a byte from here
193+  81E2 C9               ret
194+  81E3
# file closed: utilities.asm
125   81E3                  include "strings.asm"
# file opened: strings.asm
  1+  81E3              string_score1:
  2+  81E3 04 00 53 43      defb 4,0,'SCORE1',255
  2+  81E7 4F 52 45 31
  2+  81EB FF
  3+  81EC              string_scorenumbers1:
  4+  81EC 04 01 30 30      defb 4,1,'000000',255
  4+  81F0 30 30 30 30
  4+  81F4 FF
  5+  81F5              string_company:
  6+  81F5 0C 00 43 45      defb 12,0,'CENTURI',255
  6+  81F9 4E 54 55 52
  6+  81FD 49 FF
  7+  81FF              string_player1:
  8+  81FF 0C 01 50 4C      defb 12,1,'PLAYER 1',255
  8+  8203 41 59 45 52
  8+  8207 20 31 FF
  9+  820A              string_player2:
 10+  820A 0C 01 50 4C      defb 12,1,'PLAYER 2',255
 10+  820E 41 59 45 52
 10+  8212 20 32 FF
 11+  8215              string_score2:
 12+  8215 16 00 53 43      defb 22,0,'SCORE2',255
 12+  8219 4F 52 45 32
 12+  821D FF
 13+  821E              string_scorenumbers2:
 14+  821E 16 01 30 30      defb 22,1,'000000',255
 14+  8222 30 30 30 30
 14+  8226 FF
 15+  8227              string_titlescreen_copyright:
 16+  8227 06 15 7F 31      defb 6,21, 127,'1982  CENTURI INC',255
 16+  822B 39 38 32 20
 16+  822F 20 43 45 4E
 16+  8233 54 55 52 49
 16+  8237 20 49 4E 43
 16+  823B FF
 17+  823C
 18+  823C
 19+  823C              string_alttitlescreen_1:
 20+  823C 0C 00 43 52      defb 12,0,'CREDITS 1',255
 20+  8240 45 44 49 54
 20+  8244 53 20 31 FF
 21+  8248              string_alttitlescreen_2:
 22+  8248 00 02 20 20      defb 0,2,'           THE OBJECT',254
 22+  824C 20 20 20 20
 22+  8250 20 20 20 20
 22+  8254 20 54 48 45
 22+  8258 20 4F 42 4A
 22+  825C 45 43 54 FE
 23+  8260 00 03 20 20      defb 0,3,'          OF THIS GAME',254
 23+  8264 20 20 20 20
 23+  8268 20 20 20 20
 23+  826C 4F 46 20 54
 23+  8270 48 49 53 20
 23+  8274 47 41 4D 45
 23+  8278 FE
 24+  8279 00 04 20 20      defb 0,4,'         IS TO DIG DOWN',254
 24+  827D 20 20 20 20
 24+  8281 20 20 20 49
 24+  8285 53 20 54 4F
 24+  8289 20 44 49 47
 24+  828D 20 44 4F 57
 24+  8291 4E FE
 25+  8293 00 05 20 20      defb 0,5,'        TO THE BOTTOM PIT',254
 25+  8297 20 20 20 20
 25+  829B 20 20 54 4F
 25+  829F 20 54 48 45
 25+  82A3 20 42 4F 54
 25+  82A7 54 4F 4D 20
 25+  82AB 50 49 54 FE
 26+  82AF 00 06 20 20      defb 0,6,'               AND',254
 26+  82B3 20 20 20 20
 26+  82B7 20 20 20 20
 26+  82BB 20 20 20 20
 26+  82BF 20 41 4E 44
 26+  82C3 FE
 27+  82C4 00 07 20 20      defb 0,7,'        COLLECT AT LEAST',254
 27+  82C8 20 20 20 20
 27+  82CC 20 20 43 4F
 27+  82D0 4C 4C 45 43
 27+  82D4 54 20 41 54
 27+  82D8 20 4C 45 41
 27+  82DC 53 54 FE
 28+  82DF 00 08 20 20      defb 0,8,'         ONE LARGE JEWEL',254
 28+  82E3 20 20 20 20
 28+  82E7 20 20 20 4F
 28+  82EB 4E 45 20 4C
 28+  82EF 41 52 47 45
 28+  82F3 20 4A 45 57
 28+  82F7 45 4C FE
 29+  82FA 00 09 20 20      defb 0,9,'              THEN',254
 29+  82FE 20 20 20 20
 29+  8302 20 20 20 20
 29+  8306 20 20 20 20
 29+  830A 54 48 45 4E
 29+  830E FE
 30+  830F 00 0A 20 20      defb 0,10,'         RETURN TO SHIP',254
 30+  8313 20 20 20 20
 30+  8317 20 20 20 52
 30+  831B 45 54 55 52
 30+  831F 4E 20 54 4F
 30+  8323 20 53 48 49
 30+  8327 50 FE
 31+  8329 00 0B 20 20      defb 0,11,'         THRU UPPER PIT',255
 31+  832D 20 20 20 20
 31+  8331 20 20 20 54
 31+  8335 48 52 55 20
 31+  8339 55 50 50 45
 31+  833D 52 20 50 49
 31+  8341 54 FF
 32+  8343              string_alttitlescreen_3:
 33+  8343 00 0D 20 20      defb 0,13,'    SINGLE BONUS  5000 POINTS',254
 33+  8347 20 20 53 49
 33+  834B 4E 47 4C 45
 33+  834F 20 42 4F 4E
 33+  8353 55 53 20 20
 33+  8357 35 30 30 30
 33+  835B 20 50 4F 49
 33+  835F 4E 54 53 FE
 34+  8363 00 0E 20 20      defb 0,14,'      COLLECT 1 LARGE JEWEL',254
 34+  8367 20 20 20 20
 34+  836B 43 4F 4C 4C
 34+  836F 45 43 54 20
 34+  8373 31 20 4C 41
 34+  8377 52 47 45 20
 34+  837B 4A 45 57 45
 34+  837F 4C FE
 35+  8381 00 0F 20 20      defb 0,15,'       AND RETURN TO SHIP',254
 35+  8385 20 20 20 20
 35+  8389 20 41 4E 44
 35+  838D 20 52 45 54
 35+  8391 55 52 4E 20
 35+  8395 54 4F 20 53
 35+  8399 48 49 50 FE
 36+  839D 00 11 20 20      defb 0,17,'    DOUBLE BONUS  10000 POINTS',254
 36+  83A1 20 20 44 4F
 36+  83A5 55 42 4C 45
 36+  83A9 20 42 4F 4E
 36+  83AD 55 53 20 20
 36+  83B1 31 30 30 30
 36+  83B5 30 20 50 4F
 36+  83B9 49 4E 54 53
 36+  83BD FE
 37+  83BE 00 12 20 20      defb 0,18,'    COLLECT ALL 3 LARGE JEWELS',254
 37+  83C2 20 20 43 4F
 37+  83C6 4C 4C 45 43
 37+  83CA 54 20 41 4C
 37+  83CE 4C 20 33 20
 37+  83D2 4C 41 52 47
 37+  83D6 45 20 4A 45
 37+  83DA 57 45 4C 53
 37+  83DE FE
 38+  83DF 00 13 20 20      defb 0,19,'       OR   ALL 4 SMALL JEWELS',254
 38+  83E3 20 20 20 20
 38+  83E7 20 4F 52 20
 38+  83EB 20 20 41 4C
 38+  83EF 4C 20 34 20
 38+  83F3 53 4D 41 4C
 38+  83F7 4C 20 4A 45
 38+  83FB 57 45 4C 53
 38+  83FF FE
 39+  8400 00 15 20 20      defb 0,21,'    TRIPLE BONUS  15000 POINTS',254
 39+  8404 20 20 54 52
 39+  8408 49 50 4C 45
 39+  840C 20 42 4F 4E
 39+  8410 55 53 20 20
 39+  8414 31 35 30 30
 39+  8418 30 20 50 4F
 39+  841C 49 4E 54 53
 39+  8420 FE
 40+  8421 00 16 20 20      defb 0,22,'       COLLECT ALL 7 JEWELS',255
 40+  8425 20 20 20 20
 40+  8429 20 43 4F 4C
 40+  842D 4C 45 43 54
 40+  8431 20 41 4C 4C
 40+  8435 20 37 20 4A
 40+  8439 45 57 45 4C
 40+  843D 53 FF
 41+  843F
 42+  843F              string_lifescreen_player:
 43+  843F 0B 00 20 50      defb 11,0,' PLAYER 1 ',255
 43+  8443 4C 41 59 45
 43+  8447 52 20 31 20
 43+  844B FF
 44+  844C              string_lifescreen_lives:
 45+  844C 0B 03 30 20      defb 11,3,48,' MEN LEFT',255
 45+  8450 4D 45 4E 20
 45+  8454 4C 45 46 54
 45+  8458 FF
 46+  8459              string_lifescreen_lastman:
 47+  8459 0C 03 4C 41      defb 12,3,'LAST MAN',255
 47+  845D 53 54 20 4D
 47+  8461 41 4E FF
 48+  8464
 49+  8464              string_gameoverscreen_gameover:
 50+  8464 0B 06 47 41      defb 11,6,'GAME OVER',255
 50+  8468 4D 45 20 4F
 50+  846C 56 45 52 FF
 51+  8470              string_gameoverscreen_copyright:
 52+  8470 07 12 7F 31      defb 7,18,127,'1982 CENTURI INC',255
 52+  8474 39 38 32 20
 52+  8478 43 45 4E 54
 52+  847C 55 52 49 20
 52+  8480 49 4E 43 FF
 53+  8484              string_gameoverscreen_bestscores:
 54+  8484 07 16 42 45      defb 7,22,'BEST SCORES TODAY',255
 54+  8488 53 54 20 53
 54+  848C 43 4F 52 45
 54+  8490 53 20 54 4F
 54+  8494 44 41 59 FF
 55+  8498              string_gameover_credits:
 56+  8498 0C 01 43 52      defb 12,1,'CREDITS 0',255
 56+  849C 45 44 49 54
 56+  84A0 53 20 30 FF
 57+  84A4
 58+  84A4              string_highscore_congratulations:
 59+  84A4 08 05 43 4F      defb 8,5,'CONGRATULATIONS',255
 59+  84A8 4E 47 52 41
 59+  84AC 54 55 4C 41
 59+  84B0 54 49 4F 4E
 59+  84B4 53 FF
 60+  84B6              string_highscore_player1:
 61+  84B6 0C 07 50 4C      defb 12,7,'PLAYER 1',255
 61+  84BA 41 59 45 52
 61+  84BE 20 31 FF
 62+  84C1              string_highscore_player2:
 63+  84C1 0C 07 50 4C      defb 12,7,'PLAYER 2',255
 63+  84C5 41 59 45 52
 63+  84C9 20 32 FF
 64+  84CC              string_highscore_youhaveearned:
 65+  84CC 08 0A 59 4F      defb 8,10,'YOU HAVE EARNED',255
 65+  84D0 55 20 48 41
 65+  84D4 56 45 20 45
 65+  84D8 41 52 4E 45
 65+  84DC 44 FF
 66+  84DE              string_highscore_place1:
 67+  84DE 06 0C 54 48      defb 6,12,'THE GREATEST SCORE',255
 67+  84E2 45 20 47 52
 67+  84E6 45 41 54 45
 67+  84EA 53 54 20 53
 67+  84EE 43 4F 52 45
 67+  84F2 FF
 68+  84F3              string_highscore_place2:
 69+  84F3 06 0C 54 48      defb 6,12,'THE 2ND BEST SCORE',255
 69+  84F7 45 20 32 4E
 69+  84FB 44 20 42 45
 69+  84FF 53 54 20 53
 69+  8503 43 4F 52 45
 69+  8507 FF
 70+  8508              string_highscore_place3:
 71+  8508 06 0C 54 48      defb 6,12,'THE 3RD BEST SCORE',255
 71+  850C 45 20 33 52
 71+  8510 44 20 42 45
 71+  8514 53 54 20 53
 71+  8518 43 4F 52 45
 71+  851C FF
 72+  851D              string_highscore_pleaseenter
 73+  851D 03 0F 52 45      defb 3,15,'RECORD YOUR INITIALS BELOW',255
 73+  8521 43 4F 52 44
 73+  8525 20 59 4F 55
 73+  8529 52 20 49 4E
 73+  852D 49 54 49 41
 73+  8531 4C 53 20 42
 73+  8535 45 4C 4F 57
 73+  8539 FF
 74+  853A
 75+  853A              string_endlevel_youhaveearned:
 76+  853A 08 0B 59 4F      defb 8,11,'YOU HAVE EARNED',255
 76+  853E 55 20 48 41
 76+  8542 56 45 20 45
 76+  8546 41 52 4E 45
 76+  854A 44 FF
 77+  854C              string_endlevel_bonus1:
 78+  854C 09 0D 53 49      defb 9,13,'SINGLE BONUS',255
 78+  8550 4E 47 4C 45
 78+  8554 20 42 4F 4E
 78+  8558 55 53 FF
 79+  855B              string_endlevel_bonus2:
 80+  855B 09 0D 44 4F      defb 9,13,'DOUBLE BONUS',255
 80+  855F 55 42 4C 45
 80+  8563 20 42 4F 4E
 80+  8567 55 53 FF
 81+  856A              string_endlevel_bonus3:
 82+  856A 09 0D 54 52      defb 9,13,'TRIPLE BONUS',255
 82+  856E 49 50 4C 45
 82+  8572 20 42 4F 4E
 82+  8576 55 53 FF
 83+  8579              string_endlevel_points1:
 84+  8579 0A 0F 35 30      defb 10,15,'5000 POINTS',255
 84+  857D 30 30 20 50
 84+  8581 4F 49 4E 54
 84+  8585 53 FF
 85+  8587              string_endlevel_points2:
 86+  8587 09 0F 31 30      defb 9,15,'10000 POINTS',255
 86+  858B 30 30 30 20
 86+  858F 50 4F 49 4E
 86+  8593 54 53 FF
 87+  8596              string_endlevel_points3:
 88+  8596 09 0F 31 35      defb 9,15,'15000 POINTS',255
 88+  859A 30 30 30 20
 88+  859E 50 4F 49 4E
 88+  85A2 54 53 FF
 89+  85A5              string_endlevel_anothergo:
 90+  85A5 08 12 48 41      defb 8,18,'HAVE ANOTHER GO',255
 90+  85A9 56 45 20 41
 90+  85AD 4E 4F 54 48
 90+  85B1 45 52 20 47
 90+  85B5 4F FF
 91+  85B7
 92+  85B7              string_zonk:
 93+  85B7 00 00 5A 4F      defb 0,0,'ZONK!!',255
 93+  85BB 4E 4B 21 21
 93+  85BF FF
 94+  85C0
 95+  85C0
 96+  85C0              string_options_title:
 97+  85C0 0D 03 54 48      defb 13,3,'THE PIT',255
 97+  85C4 45 20 50 49
 97+  85C8 54 FF
 98+  85CA              string_options_1player:
 99+  85CA 09 06 31 2E      defb 9,6,'1. ONE PLAYER',255
 99+  85CE 20 4F 4E 45
 99+  85D2 20 50 4C 41
 99+  85D6 59 45 52 FF
100+  85DA              string_options_2player:
101+  85DA 09 07 32 2E      defb 9,7,'2. TWO PLAYER',255
101+  85DE 20 54 57 4F
101+  85E2 20 50 4C 41
101+  85E6 59 45 52 FF
102+  85EA              string_options_keyboard:
103+  85EA 09 08 33 2E      defb 9,8,'3. KEYS (QAOPSp)',255
103+  85EE 20 4B 45 59
103+  85F2 53 20 28 51
103+  85F6 41 4F 50 53
103+  85FA 70 29 FF
104+  85FD              string_options_joystick:
105+  85FD 09 09 34 2E      defb 9,9,'4. KEMPSTON',255
105+  8601 20 4B 45 4D
105+  8605 50 53 54 4F
105+  8609 4E FF
106+  860B              string_options_start:
107+  860B 09 0A 35 2E      defb 9,10,'5. START',255
107+  860F 20 53 54 41
107+  8613 52 54 FF
108+  8616              string_options_vanity:
109+  8616 08 16 53 70      defb 8,22,'Spectrum Conversion',254
109+  861A 65 63 74 72
109+  861E 75 6D 20 43
109+  8622 6F 6E 76 65
109+  8626 72 73 69 6F
109+  862A 6E FE
110+  862C 07 17 62 79      defb 7,23,'by Dave Tansley, 2020',255
110+  8630 20 44 61 76
110+  8634 65 20 54 61
110+  8638 6E 73 6C 65
110+  863C 79 2C 20 32
110+  8640 30 32 30 FF
111+  8644
112+  8644              ;
113+  8644              ; Prints specified string
114+  8644              ; Inputs:
115+  8644              ; de: pointer to string
116+  8644              ; bc: length of string
117+  8644              ;
118+  8644              ; Print String Data
119+  8644              ; First two bytes of string contain X and Y char position, then the string
120+  8644              ; Individual strings are terminated with 0xFE
121+  8644              ; End of data is terminated with 0xFF
122+  8644              ; HL: Address of string
123+  8644              ;
124+  8644 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
125+  8645 23                                   INC HL                          ; Increase HL to the next memory location
126+  8646 56                                   LD D,(HL)                       ; Fetch the Y coordinate
127+  8647 23                                   INC HL                          ; Increase HL to the next memory location
128+  8648 CD 5B 86                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
129+  864B 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
130+  864C 23                                   INC HL                          ; Increase HL to the next character
131+  864D FE FE                                CP 0xFE                         ; Compare with 0xFE
132+  864F 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
133+  8651 D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
134+  8652 E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
135+  8653 CD 6B 86                             CALL Print_Char                 ; Print the character
136+  8656 E1                                   POP HL                          ; Retrieve HL back off the stack
137+  8657 1C                                   INC E                           ; Go to the next screen address
138+  8658 18 F1                                JR string_print_0               ; Loop back to print next character
139+  865A C9                                   RET
140+  865B
141+  865B              ; Get screen address
142+  865B              ; D = Y character position
143+  865B              ; E = X character position
144+  865B              ; Returns address in DE
145+  865B              ;
146+  865B 7A           string_getcharaddress:       LD A,D
147+  865C E6 07                                AND %00000111
148+  865E 1F                                   RRA
149+  865F 1F                                   RRA
150+  8660 1F                                   RRA
151+  8661 1F                                   RRA
152+  8662 B3                                   OR E
153+  8663 5F                                   LD E,A
154+  8664 7A                                   LD A,D
155+  8665 E6 18                                AND %00011000
156+  8667 F6 40                                OR %01000000
157+  8669 57                                   LD D,A
158+  866A C9                                   RET                             ; Returns screen address in DE
159+  866B
160+  866B              ; Print a single character out
161+  866B              ; A:  Character to print
162+  866B              ; DE: Screen address to print character at
163+  866B              ;
164+  866B 2A 36 5C     Print_Char:             LD HL,(23606)                    ; Address of character set table in ROM
165+  866E 06 00                                LD B,0                          ; Set BC to A
166+  8670 4F                                   LD C,A
167+  8671 E6 FF                                AND 0xFF                        ; Clear the carry bit
168+  8673 CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
169+  8675 CB 10                                RL B
170+  8677 CB 11                                RL C
171+  8679 CB 10                                RL B
172+  867B CB 11                                RL C
173+  867D CB 10                                RL B
174+  867F 09                                   ADD HL,BC                       ; Get the character address in HL
175+  8680 0E 08                                LD C,8                          ; Loop counter
176+  8682 D5                                   PUSH DE
177+  8683 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
178+  8684 12                                   LD (DE),A                       ; Stick A onto the screen
179+  8685 14                                   INC D                           ; Goto next line on screen
180+  8686 23                                   INC HL                           ; Goto next byte of character
181+  8687 0D                                   DEC C                           ; Decrease the loop counter
182+  8688 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
183+  868A D1                                   POP DE
184+  868B C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
126   868C                  include "screen\buffer.asm"
# file opened: screen/buffer.asm
  1+  868C              buffer_buffer:
  2+  868C 00 00 00...      defs 7424                   ; area reserved for screen
  3+  A38C
  4+  A38C              buffer_attr_buffer:
  5+  A38C 00 00 00...      defs 928                    ; attrs buffer area
  6+  A72C
  7+  A72C              buffer_tmp:
  8+  A72C 00 00            defb 0,0                    ; temp area
  9+  A72E
 10+  A72E              ;
 11+  A72E              ; If this is set to one, three lines will be refreshed for the screen coord redraw
 12+  A72E              ; This is used when digging to make sure that the above/below dug block gets redrawn
 13+  A72E              ; 1 - above
 14+  A72E              ; 2 - below
 15+  A72E              ;
 16+  A72E              buffer_threelinerefresh:
 17+  A72E 00               defb 0
 18+  A72F
 19+  A72F              ;
 20+  A72F              ; This list stores lines to be updated by the buffer.
 21+  A72F              ; This is done by half line. Lines are encded with.
 22+  A72F              ; 00hlllll
 23+  A72F              ; Where h is the half of the screen (0 or 1), lllll is the line number
 24+  A72F              buffer_updatedlines:
 25+  A72F FF FF FF...      defs 21,255
 26+  A744
 27+  A744              buffer_updateall:
 28+  A744 00               defb 0
 29+  A745
 30+  A745              ;
 31+  A745              ; Stores a line number in the update list
 32+  A745              ; Inputs:
 33+  A745              ; a - row number
 34+  A745              buffer_marklineforupdate:
 35+  A745 FE 15            cp 21
 36+  A747 D0               ret nc                          ; dont store lines that we shouldn't draw
 37+  A748 5F               ld e,a                          ; store in e
 38+  A749 ED 4B 58 AC      ld bc,(origcoords)              ; this should hold the coords of what was drawn
 39+  A74D 79               ld a,c                          ; get the horiz coord
 40+  A74E FE 0F            cp 15
 41+  A750 CA 67 A7         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 42+  A753 FE 10            cp 16                           ; if this is 15 or less, the first half of screen
 43+  A755 CA 67 A7         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 44+  A758 DA 63 A7         jp c,buffer_marklineforupdate4  ; if first half, nothing to do
 45+  A75B 78               ld a,b                          ; get the vertical
 46+  A75C 3E 20            ld a,32                         ; set the 6th bit by adding 32
 47+  A75E 83               add a,e
 48+  A75F 5F               ld e,a                          ; store this value
 49+  A760 C3 6E A7         jp buffer_marklineforupdate2
 50+  A763              buffer_marklineforupdate4:
 51+  A763 78               ld a,b
 52+  A764 C3 6E A7         jp buffer_marklineforupdate2    ; just get the vertical
 53+  A767              buffer_marklineforupdate3:          ; special case for 15,16 - need to render both halves, since might be between
 54+  A767 CD 72 A7         call buffer_storelineforupdate  ; call store update for e
 55+  A76A 3E 20            ld a,32
 56+  A76C 83               add a,e
 57+  A76D 5F               ld e,a
 58+  A76E              buffer_marklineforupdate2:
 59+  A76E CD 72 A7         call buffer_storelineforupdate  ; call store update for e
 60+  A771 C9               ret
 61+  A772
 62+  A772
 63+  A772              ;
 64+  A772              ; Stores the calculated line and half if needed
 65+  A772              ; Inputs:
 66+  A772              ; e - half/row
 67+  A772              ;
 68+  A772              buffer_storelineforupdate:
 69+  A772 06 15            ld b,21
 70+  A774 21 2F A7         ld hl,buffer_updatedlines
 71+  A777              buffer_storelineforupdate0:
 72+  A777 7E               ld a,(hl)                       ; get the line stored in updated lines
 73+  A778 BB               cp e                            ; is this the same as the row number passed in?
 74+  A779 C8               ret z                           ; if so, don't need to do anything
 75+  A77A FE FF            cp 255                          ; is this 255, ie the end of the buffer
 76+  A77C C2 81 A7         jp nz,buffer_storelineforupdate1 ; if not, move to next
 77+  A77F 73               ld (hl),e
 78+  A780 C9               ret
 79+  A781              buffer_storelineforupdate1:
 80+  A781 23               inc hl
 81+  A782 10 F3            djnz buffer_storelineforupdate0
 82+  A784 C9               ret
 83+  A785
 84+  A785              ;
 85+  A785              ; Zeroes the updated lines list
 86+  A785              ;
 87+  A785              buffer_clearlist:
 88+  A785 06 15            ld b,21
 89+  A787 21 2F A7         ld hl,buffer_updatedlines
 90+  A78A              buffer_clearlist0:
 91+  A78A 36 FF            ld (hl),255
 92+  A78C 23               inc hl
 93+  A78D 10 FB            djnz buffer_clearlist0
 94+  A78F C9               ret
 95+  A790
 96+  A790              ;
 97+  A790              ; Which half are we displaying? 0 left 1 right
 98+  A790              ;
 99+  A790              buffer_bufferhalf:
100+  A790 00               defb 0
101+  A791
102+  A791              ;
103+  A791              ; Copies the buffer to the screen. Use stack.
104+  A791              ; Inputs:
105+  A791              ; hl - half/line number to display - 0 is first half, 0 is first line
106+  A791              ;
107+  A791              buffer_bufferlinetoscreen:
108+  A791 7C               ld a,h
109+  A792 32 90 A7         ld (buffer_bufferhalf),a        ; store the half
110+  A795 7D               ld a,l
111+  A796 4F               ld c,a                          ; store a
112+  A797 ED 5B F7 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows, want it *256
113+  A79B 83               add a,e                       ; add the row number
114+  A79C 11 00 01         ld de,256
115+  A79F CD 03 81         call utilities_multiply
116+  A7A2 54 5D            ld de,hl
117+  A7A4 21 8C 86         ld hl,buffer_buffer
118+  A7A7 19               add hl,de                   ; add the offset
119+  A7A8 79               ld a,c                      ; get original row back
120+  A7A9 ED 73 1C A8      ld (buffer_bufferlinetoscreen3+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
121+  A7AD D9               exx
122+  A7AE 0E 00            ld c,0                      ; zero horizontal
123+  A7B0 47               ld b,a                      ; load the row number into vertical coord
124+  A7B1 04               inc b
125+  A7B2 04               inc b                       ; move forward 2 to allow for scores
126+  A7B3 CD EF A9         call screen_getcelladdress  ; get the memory into de
127+  A7B6 21 10 00         ld hl,16                    ; offset by 16 chars to get to the centre, since populating stack from right
128+  A7B9 19               add hl,de
129+  A7BA 3A 90 A7         ld a,(buffer_bufferhalf)    ; get the half
130+  A7BD FE 01            cp 1
131+  A7BF CA EC A7         jp z,buffer_bufferlinetoscreen4
132+  A7C2              buffer_bufferlinetoscreen0:     ; PROCESS THE LEFT HALF
133+  A7C2 D9               exx                         ; hl is now buffer
134+  A7C3 23               inc hl
135+  A7C4 23               inc hl                      ; move hl forward 2 to skip first two blocks
136+  A7C5 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
137+  A7C6 F1               pop af
138+  A7C7 C1               pop bc
139+  A7C8 D1               pop de
140+  A7C9 DD E1            pop ix
141+  A7CB D9               exx                         ; hl is now screen
142+  A7CC 08               ex af,af'
143+  A7CD F1               pop af
144+  A7CE C1               pop bc
145+  A7CF D1               pop de
146+  A7D0 F9               ld sp,hl                    ; sp pointing at screen
147+  A7D1 D5               push de
148+  A7D2 C5               push bc
149+  A7D3 F5               push af
150+  A7D4 08               ex af,af'
151+  A7D5 D9               exx                         ; hl is now buffer
152+  A7D6 DD E5            push ix
153+  A7D8 D5               push de
154+  A7D9 C5               push bc
155+  A7DA F5               push af
156+  A7DB 11 1E 00         ld de,30                    ; add thirty to get to next line
157+  A7DE 19               add hl,de
158+  A7DF F9               ld sp,hl                    ; sp pointing at buffer
159+  A7E0 D9               exx                         ; hl is now screen
160+  A7E1 08               ex af,af'
161+  A7E2 24               inc h
162+  A7E3 7C               ld a,h
163+  A7E4 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
164+  A7E6 C2 C2 A7         jp nz,buffer_bufferlinetoscreen0 ; next line in cell
165+  A7E9              buffer_bufferlinetoscreen1:
166+  A7E9 C3 1B A8         jp buffer_bufferlinetoscreen3
167+  A7EC              buffer_bufferlinetoscreen4:     ; PROCESS THE RIGHT HALF
168+  A7EC D9               exx                         ; hl is buffer
169+  A7ED 11 10 00         ld de,16
170+  A7F0 19               add hl,de                   ; move halfway across
171+  A7F1 D9               exx                         ; hl is screen
172+  A7F2 11 0E 00         ld de,14
173+  A7F5 19               add hl,de
174+  A7F6              buffer_bufferlinetoscreen2:
175+  A7F6 D9               exx                         ; hl is now buffer
176+  A7F7 F9               ld sp,hl                    ; do first fourteen for right hand side, sp pointing at buffer
177+  A7F8 F1               pop af
178+  A7F9 C1               pop bc
179+  A7FA D1               pop de
180+  A7FB DD E1            pop ix
181+  A7FD D9               exx                         ; hl is now screen
182+  A7FE 08               ex af,af'
183+  A7FF F1               pop af
184+  A800 C1               pop bc
185+  A801 D1               pop de
186+  A802 F9               ld sp,hl                    ; sp pointing at screen
187+  A803 D5               push de
188+  A804 C5               push bc
189+  A805 F5               push af
190+  A806 08               ex af,af'
191+  A807 D9               exx                         ; hl is now buffer
192+  A808 DD E5            push ix
193+  A80A D5               push de
194+  A80B C5               push bc
195+  A80C F5               push af
196+  A80D 11 20 00         ld de,32                    ; add thirty two to get to next line
197+  A810 19               add hl,de
198+  A811 F9               ld sp,hl                    ; sp pointing at buffer
199+  A812 D9               exx                         ; hl is now screen
200+  A813 08               ex af,af'
201+  A814 24               inc h
202+  A815 7C               ld a,h
203+  A816 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
204+  A818 C2 F6 A7         jp nz,buffer_bufferlinetoscreen2 ; next line in cell
205+  A81B              buffer_bufferlinetoscreen3:
206+  A81B 31 00 00         ld sp,0
207+  A81E D9               exx
208+  A81F C9               ret
209+  A820
210+  A820              ;
211+  A820              ; Copies the buffer to the screen for updated lines. Use stack.
212+  A820              ; Inputs: none
213+  A820              ;
214+  A820              buffer_buffertoscreen:
215+  A820 3A 44 A7         ld a,(buffer_updateall)      ; get the all update flag
216+  A823 FE 00            cp 0
217+  A825 CA 31 A8         jp z,buffer_buffertoscreen2  ; if not set, draw only updated
218+  A828 CD 61 A8         call buffer_allbuffertoscreen ; otherwise, draw whole screen
219+  A82B 21 44 A7         ld hl,buffer_updateall
220+  A82E 36 00            ld (hl),0                    ; reset flag
221+  A830 C9               ret
222+  A831              buffer_buffertoscreen2:
223+  A831 06 15            ld b,21
224+  A833 FD 21 2F A7      ld iy,buffer_updatedlines    ; the location of the updated lines
225+  A837              buffer_buffertoscreen0:
226+  A837 FD 7E 00         ld a,(iy)
227+  A83A FE FF            cp 255
228+  A83C CA 60 A8         jp z,buffer_buffertoscreen1                       ; if this is 255, then we're at the end of the updated list
229+  A83F 6F               ld l,a
230+  A840 26 00            ld h,0
231+  A842 E6 20            and 32                      ; and with 32 to see if 6th bit is set
232+  A844 FE 20            cp 32                       ; if so, second half of screen
233+  A846 C2 51 A8         jp nz,buffer_buffertoscreen3
234+  A849 26 01            ld h,1                      ; store half in h
235+  A84B FD 7E 00         ld a,(iy)
236+  A84E D6 20            sub 32                      ; remove 32
237+  A850 6F               ld l,a                      ; stor in line number
238+  A851              buffer_buffertoscreen3:
239+  A851 C5               push bc
240+  A852 FD E5            push iy
241+  A854 F3               di
242+  A855 CD 91 A7         call buffer_bufferlinetoscreen      ; hl has h=half (0 or 1), l=line
243+  A858 FB               ei
244+  A859 FD E1            pop iy
245+  A85B C1               pop bc
246+  A85C FD 23            inc iy
247+  A85E 10 D7            djnz buffer_buffertoscreen0
248+  A860              buffer_buffertoscreen1:
249+  A860                  ;call buffer_buffertoattrsfast
250+  A860 C9               ret
251+  A861
252+  A861              ;
253+  A861              ; Copies the buffer to the screen. Use stack.
254+  A861              ; Inputs: none
255+  A861              ;
256+  A861              buffer_allbuffertoscreen:
257+  A861 06 15            ld b,21
258+  A863 3E 00            ld a,0
259+  A865              buffer_allbuffertoscreen0:
260+  A865 C5               push bc
261+  A866 F5               push af
262+  A867 F3               di
263+  A868 26 00            ld h,0
264+  A86A 6F               ld l,a
265+  A86B CD 91 A7         call buffer_bufferlinetoscreen
266+  A86E FB               ei
267+  A86F F1               pop af
268+  A870 F5               push af
269+  A871 F3               di
270+  A872 26 01            ld h,1
271+  A874 6F               ld l,a
272+  A875 CD 91 A7         call buffer_bufferlinetoscreen
273+  A878 FB               ei
274+  A879 F1               pop af
275+  A87A C1               pop bc
276+  A87B 3C               inc a
277+  A87C 10 E7            djnz buffer_allbuffertoscreen0
278+  A87E F3               di
279+  A87F CD 84 A8         call buffer_buffertoattrsfast
280+  A882 FB               ei
281+  A883 C9               ret
282+  A884
283+  A884              ;
284+  A884              ; Copies the attrs buffer to screen with the stack
285+  A884              ;
286+  A884              buffer_buffertoattrsfast:
287+  A884 ED 73 F3 A8      ld (buffer_buffertoattrsfast1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
288+  A888 3A F7 A8         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
289+  A88B 11 20 00         ld de,32
290+  A88E CD 03 81         call utilities_multiply
291+  A891 54 5D            ld de,hl
292+  A893 21 8C A3         ld hl,buffer_attr_buffer
293+  A896 19               add hl,de                       ; add the offset, start of attr buffer now in hl
294+  A897 D9               exx
295+  A898 21 50 58         ld hl,22528+80                  ; start of attr memory + 2 lines for score + 16 to start at right side
296+  A89B FD 21 2C A7      ld iy,buffer_tmp
297+  A89F FD 36 00 15      ld (iy),21              ; number of times to loop
298+  A8A3              buffer_buffertoattrsfast0:
299+  A8A3 D9               exx                         ; hl is now buffer
300+  A8A4 23               inc hl
301+  A8A5 23               inc hl                      ; move hl forward 2 to skip first two blocks
302+  A8A6 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
303+  A8A7 F1               pop af
304+  A8A8 C1               pop bc
305+  A8A9 D1               pop de
306+  A8AA DD E1            pop ix
307+  A8AC D9               exx                         ; hl is now screen
308+  A8AD 08               ex af,af'
309+  A8AE F1               pop af
310+  A8AF C1               pop bc
311+  A8B0 D1               pop de
312+  A8B1 F9               ld sp,hl                    ; sp pointing at screen
313+  A8B2 D5               push de
314+  A8B3 C5               push bc
315+  A8B4 F5               push af
316+  A8B5 08               ex af,af'
317+  A8B6 D9               exx                         ; hl is now buffer
318+  A8B7 DD E5            push ix
319+  A8B9 D5               push de
320+  A8BA C5               push bc
321+  A8BB F5               push af
322+  A8BC 1E 0E            ld e,14                    ; do another fourteen for right hand side
323+  A8BE 16 00            ld d,0
324+  A8C0 19               add hl,de
325+  A8C1 F9               ld sp,hl                    ; sp pointing at buffer
326+  A8C2 F1               pop af
327+  A8C3 C1               pop bc
328+  A8C4 D1               pop de
329+  A8C5 DD E1            pop ix
330+  A8C7 D9               exx                         ; hl is now screen
331+  A8C8 08               ex af,af'
332+  A8C9 1E 0E            ld e,14
333+  A8CB 16 00            ld d,0
334+  A8CD 19               add hl,de
335+  A8CE F1               pop af
336+  A8CF C1               pop bc
337+  A8D0 D1               pop de
338+  A8D1 F9               ld sp,hl                    ; sp pointing at screen
339+  A8D2 D5               push de
340+  A8D3 C5               push bc
341+  A8D4 F5               push af
342+  A8D5 08               ex af,af'
343+  A8D6 D9               exx                         ; hl is now buffer
344+  A8D7 DD E5            push ix
345+  A8D9 D5               push de
346+  A8DA C5               push bc
347+  A8DB F5               push af
348+  A8DC 1E 10            ld e,16
349+  A8DE 16 00            ld d,0
350+  A8E0 19               add hl,de
351+  A8E1 D9               exx                         ; hl is now screen
352+  A8E2 11 12 00         ld de,18
353+  A8E5 19               add hl,de
354+  A8E6 FD 7E 00         ld a,(iy)
355+  A8E9 3D               dec a
356+  A8EA FE 00            cp 0
357+  A8EC FD 77 00         ld (iy),a
358+  A8EF C2 A3 A8         jp nz,buffer_buffertoattrsfast0 ; do another row
359+  A8F2              buffer_buffertoattrsfast1:
360+  A8F2 31 00 00         ld sp,0
361+  A8F5 D9               exx
362+  A8F6 C9               ret
# file closed: screen/buffer.asm
127   A8F7                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  A8F7              screen_offset:
  2+  A8F7 00               defb 0                      ; offset from top of screen in lines
  3+  A8F8
  4+  A8F8              screen_tmp:
  5+  A8F8 00 00            defb 0,0                      ; temporary memory
  6+  A8FA
  7+  A8FA              screen_setscorecolours:
  8+  A8FA 21 0D B9         ld hl,score_colours
  9+  A8FD 11 00 58         ld de,22528                     ; attrs here
 10+  A900 01 40 00         ld bc,64
 11+  A903 ED B0            ldir
 12+  A905 C9               ret
 13+  A906
 14+  A906              screen_sethighscorecolours:
 15+  A906 21 4D B9         ld hl,high_score_colours
 16+  A909 11 E0 5A         ld de,22528+736                 ; attrs here
 17+  A90C 01 20 00         ld bc,32
 18+  A90F ED B0            ldir
 19+  A911 C9               ret
 20+  A912
 21+  A912              ; Draw the screen
 22+  A912              ; Inputs:
 23+  A912              ; none
 24+  A912              ; Notes:
 25+  A912              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
 26+  A912              screen_draw:
 27+  A912                  ;call clear_screen
 28+  A912 0E 00            ld c,0                      ; horiz
 29+  A914 06 00            ld b,0                      ; vert, 0 at top
 30+  A916 DD 21 E8 B2      ld ix,level_layout               ; point ix at level data
 31+  A91A FD 21 8C A3      ld iy,buffer_attr_buffer    ; point iy at attr data
 32+  A91E              screen_draw0:
 33+  A91E DD 7E 00         ld a,(ix)                   ; load the block number
 34+  A921 C5               push bc                     ; store bc, contains loop count
 35+  A922 CD DD AA         call screen_getattr         ; get the memory location for this cell's attr into hl
 36+  A925 7E               ld a,(hl)                   ; get the attr value at the address
 37+  A926 FD 77 00         ld (iy),a                   ; load the attr into memory
 38+  A929 DD 7E 00         ld a,(ix)                   ; load the block number
 39+  A92C CD A4 AA         call screen_getblock        ; get the block data into hl
 40+  A92F CD 81 AA         call screen_showchar        ; show this character here
 41+  A932 C1               pop bc                      ; get the loop counter back
 42+  A933 DD 23            inc ix                      ; increment level location
 43+  A935 FD 23            inc iy                      ; increment attr location
 44+  A937 0C               inc c                       ; increment horiz
 45+  A938 79               ld a,c
 46+  A939 FE 20            cp 32                       ; check if horiz has reach edge of screen
 47+  A93B C2 1E A9         jp nz,screen_draw0          ; if not, loop
 48+  A93E 0E 00            ld c,0                      ; if so, reset horiz
 49+  A940 04               inc b                       ; increment vertical
 50+  A941 78               ld a,b
 51+  A942 FE 1D            cp 29                       ; check if at bottom
 52+  A944 C2 1E A9         jp nz,screen_draw0          ; if not, loop
 53+  A947 21 F8 A8         ld hl, screen_tmp
 54+  A94A 36 09            ld (hl),9                   ; load the block number into memory
 55+  A94C DD 2A 32 C5      ld ix,(game_current_rocks)  ; current rock memory
 56+  A950 CD BF A9         call screen_initobjects     ; draw rocks
 57+  A953 21 F8 A8         ld hl, screen_tmp
 58+  A956 36 0C            ld (hl),12                  ; load the block number into memory
 59+  A958 DD 21 6F B8      ld ix,level_missiles       ; missile memory
 60+  A95C CD BF A9         call screen_initobjects     ; draw missiles
 61+  A95F 21 F8 A8         ld hl, screen_tmp
 62+  A962 36 08            ld (hl),08                  ; load the block number into memory
 63+  A964 DD 21 E8 B8      ld ix,level_diamonds       ; diamond memory
 64+  A968 CD BF A9         call screen_initobjects     ; draw diamonds
 65+  A96B 21 F8 A8         ld hl, screen_tmp
 66+  A96E 36 0E            ld (hl),14                  ; load the block number into memory
 67+  A970 DD 21 F8 B8      ld ix,level_gems           ; gems memory
 68+  A974 CD BF A9         call screen_initobjects     ; draw gems
 69+  A977 CD 7E A9         call screen_setuptext       ; draws text on the screen
 70+  A97A CD E3 CD         call scores_printscores     ; print the current scores
 71+  A97D C9               ret
 72+  A97E
 73+  A97E              ;
 74+  A97E              ; Sets up text on the screen
 75+  A97E              ;
 76+  A97E              screen_setuptext:
 77+  A97E CD 3F CE         call scores_showtable
 78+  A981 CD 06 A9         call screen_sethighscorecolours
 79+  A984 21 E3 81         ld hl, string_score1
 80+  A987 CD 44 86         call string_print
 81+  A98A 21 EC 81         ld hl, string_scorenumbers1
 82+  A98D CD 44 86         call string_print
 83+  A990 21 F5 81         ld hl, string_company
 84+  A993 CD 44 86         call string_print
 85+  A996 21 15 82         ld hl, string_score2
 86+  A999 CD 44 86         call string_print
 87+  A99C 21 1E 82         ld hl, string_scorenumbers2
 88+  A99F CD 44 86         call string_print
 89+  A9A2 3A 2E C5         ld a,(game_currentplayer)
 90+  A9A5 FE 01            cp 1
 91+  A9A7 C2 B0 A9         jp nz,screen_setuptext0
 92+  A9AA 21 FF 81         ld hl, string_player1
 93+  A9AD C3 B3 A9         jp screen_setuptext1
 94+  A9B0              screen_setuptext0:
 95+  A9B0 21 0A 82         ld hl, string_player2
 96+  A9B3              screen_setuptext1:
 97+  A9B3 CD 44 86         call string_print
 98+  A9B6 CD FA A8         call screen_setscorecolours
 99+  A9B9 C9               ret
100+  A9BA
101+  A9BA              ;
102+  A9BA              ; Sets a line of colours
103+  A9BA              ; Inputs:
104+  A9BA              ; a - colour to set
105+  A9BA              ; b - number to set
106+  A9BA              ; de - start memory location
107+  A9BA              ;
108+  A9BA              screen_setcolours:
109+  A9BA 12               ld (de),a
110+  A9BB 13               inc de
111+  A9BC 10 FC            djnz screen_setcolours
112+  A9BE C9               ret
113+  A9BF
114+  A9BF              ;
115+  A9BF              ; Draw initial object positions
116+  A9BF              ; Inputs:
117+  A9BF              ; ix - memory location of objects
118+  A9BF              ; a - graphic
119+  A9BF              screen_initobjects:
120+  A9BF DD 4E 00         ld c,(ix)                   ; get the horiz coord
121+  A9C2 79               ld a,c
122+  A9C3 FE FF            cp 255
123+  A9C5 CA EE A9         jp z,screen_initobjects2
124+  A9C8 DD 23            inc ix                      ; move to next
125+  A9CA DD 46 00         ld b,(ix)                   ; get the vert coord
126+  A9CD DD 23            inc ix
127+  A9CF CD 00 AA         call screen_getcellattradress ; get the memory address of b,c attr into de
128+  A9D2 D5               push de
129+  A9D3 3A F8 A8         ld a,(screen_tmp)                  ; get the block number back
130+  A9D6 CD DD AA         call screen_getattr         ; get the memory location for this cell's attr into hl
131+  A9D9 D1               pop de
132+  A9DA 7E               ld a,(hl)                   ; get the attr value at the address
133+  A9DB 12               ld (de),a                   ; load the attr into memory
134+  A9DC 3A F8 A8         ld a,(screen_tmp)                  ; get the block number back
135+  A9DF CD A4 AA         call screen_getblock        ; get the block data into hl
136+  A9E2 CD 81 AA         call screen_showchar        ; show this character here
137+  A9E5
138+  A9E5              screen_initobjects1:
139+  A9E5 DD 23            inc ix                      ; move past state
140+  A9E7 DD 23            inc ix
141+  A9E9 DD 23            inc ix                      ; move past mem
142+  A9EB C3 BF A9         jp screen_initobjects
143+  A9EE              screen_initobjects2:
144+  A9EE C9               ret
145+  A9EF
146+  A9EF
147+  A9EF              ;
148+  A9EF              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
149+  A9EF              ; Inputs:
150+  A9EF              ; bc: coords
151+  A9EF              ; Outputs:
152+  A9EF              ; de: memory location
153+  A9EF              ;
154+  A9EF              screen_getcelladdress:
155+  A9EF 78               ld a,b      ; vertical position.
156+  A9F0 E6 18            and 24      ; which segment, 0, 1 or 2?
157+  A9F2 C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
158+  A9F4 57               ld d,a      ; this is our high byte.
159+  A9F5 78               ld a,b      ; what was that vertical position again?
160+  A9F6 E6 07            and 7       ; which row within segment?
161+  A9F8 0F               rrca        ; multiply row by 32.
162+  A9F9 0F               rrca
163+  A9FA 0F               rrca
164+  A9FB 5F               ld e,a      ; low byte.
165+  A9FC 79               ld a,c      ; add on y coordinate.
166+  A9FD 83               add a,e     ; mix with low byte.
167+  A9FE 5F               ld e,a      ; address of screen position in de.
168+  A9FF C9               ret
169+  AA00
170+  AA00              ;
171+  AA00              ; Calculate buffer address of attribute for character at (b, c).
172+  AA00              ; Inputs:
173+  AA00              ; bc: coords
174+  AA00              ; Outputs:
175+  AA00              ; de: memory location
176+  AA00              ;
177+  AA00              screen_getcellattradress:
178+  AA00 11 8C A3         ld de,buffer_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
179+  AA03 69               ld l,c      ; x position.
180+  AA04 26 00            ld h,0      ; 0 h
181+  AA06 19               add hl,de
182+  AA07 54 5D            ld de,hl    ; horiz done
183+  AA09 78               ld a,b      ; do vert
184+  AA0A D5               push de
185+  AA0B C5               push bc
186+  AA0C 11 20 00         ld de,32
187+  AA0F CD 03 81         call utilities_multiply
188+  AA12 C1               pop bc
189+  AA13 D1               pop de
190+  AA14 19               add hl,de
191+  AA15 54 5D            ld de,hl    ; vert done
192+  AA17 C9               ret
193+  AA18
194+  AA18              ;
195+  AA18              ; Calculate buffer address offset of attribute for character at (b, c).
196+  AA18              ; Inputs:
197+  AA18              ; bc: coords
198+  AA18              ; Outputs:
199+  AA18              ; de: memory location
200+  AA18              ;
201+  AA18              screen_getcellattroffset:
202+  AA18 69               ld l,c      ; x position.
203+  AA19 26 00            ld h,0      ; 0 h
204+  AA1B 54 5D            ld de,hl    ; horiz done
205+  AA1D 78               ld a,b      ; do vert
206+  AA1E D5               push de
207+  AA1F C5               push bc
208+  AA20 11 20 00         ld de,32
209+  AA23 CD 03 81         call utilities_multiply
210+  AA26 C1               pop bc
211+  AA27 D1               pop de
212+  AA28 19               add hl,de
213+  AA29 54 5D            ld de,hl    ; vert done
214+  AA2B C9               ret
215+  AA2C
216+  AA2C              ;
217+  AA2C              ; Calculate buffer address of attribute for character at (b, c).
218+  AA2C              ; Inputs:
219+  AA2C              ; bc: coords
220+  AA2C              ; Outputs:
221+  AA2C              ; de: memory location
222+  AA2C              ;
223+  AA2C              screen_getscreenattradress:
224+  AA2C 11 00 58         ld de,22528 ; memory is at base + horiz (c) + vert*32 (b)
225+  AA2F 69               ld l,c      ; x position.
226+  AA30 26 00            ld h,0      ; 0 h
227+  AA32 19               add hl,de
228+  AA33 54 5D            ld de,hl    ; horiz done
229+  AA35 78               ld a,b      ; do vert
230+  AA36 D5               push de
231+  AA37 C5               push bc
232+  AA38 11 20 00         ld de,32
233+  AA3B CD 03 81         call utilities_multiply
234+  AA3E C1               pop bc
235+  AA3F D1               pop de
236+  AA40 19               add hl,de
237+  AA41 54 5D            ld de,hl    ; vert done
238+  AA43 C9               ret
239+  AA44
240+  AA44              ;
241+  AA44              ; Gets the attr memory location for a screen coord
242+  AA44              ; Will overwrite bc
243+  AA44              ; Inputs:
244+  AA44              ; bc - screen coords
245+  AA44              ; Outputs:
246+  AA44              ; de - memory location
247+  AA44              ; bc - character coords
248+  AA44              ;
249+  AA44              screen_getattraddressfromscreencoords:
250+  AA44 78               ld a,b                          ; get the player block coords of current block
251+  AA45 E6 F8            and 248                         ; find closest multiple of eight
252+  AA47 0F               rrca
253+  AA48 0F               rrca
254+  AA49 0F               rrca                ; divide by 8
255+  AA4A 47               ld b,a
256+  AA4B 79               ld a,c
257+  AA4C 48               ld c,b                         ; swap b and c
258+  AA4D E6 F8            and 248
259+  AA4F 0F               rrca
260+  AA50 0F               rrca
261+  AA51 0F               rrca                ; divide by 8
262+  AA52 47               ld b,a
263+  AA53 CD 00 AA         call screen_getcellattradress   ; work out memory location of current block attributes, memory in de
264+  AA56 C9               ret
265+  AA57
266+  AA57
267+  AA57              ; Gets the nearest cell coords for a screen coord
268+  AA57              ; Will overwrite bc
269+  AA57              ; Inputs:
270+  AA57              ; bc - screen coords
271+  AA57              ; Outputs:
272+  AA57              ; bc - character coords
273+  AA57              ;
274+  AA57              screen_getcharcoordsfromscreencoords:
275+  AA57 78               ld a,b                          ; get the player block coords of current block
276+  AA58 E6 F8            and 248                         ; find closest multiple of eight
277+  AA5A 0F               rrca
278+  AA5B 0F               rrca
279+  AA5C 0F               rrca                ; divide by 8
280+  AA5D 47               ld b,a
281+  AA5E 79               ld a,c
282+  AA5F 48               ld c,b                         ; swap b and c
283+  AA60 E6 F8            and 248
284+  AA62 0F               rrca
285+  AA63 0F               rrca
286+  AA64 0F               rrca                ; divide by 8
287+  AA65 47               ld b,a
288+  AA66 C9               ret
289+  AA67
290+  AA67              ; Gets the screen coords for a cell coord
291+  AA67              ; Will overwrite bc
292+  AA67              ; Inputs:
293+  AA67              ; bc - char coords
294+  AA67              ; Outputs:
295+  AA67              ; bc - screen coords
296+  AA67              ;
297+  AA67              screen_getscreencoordsfromcharcoords:
298+  AA67 78               ld a,b                          ; get the player block coords of current block
299+  AA68 07               rlca
300+  AA69 07               rlca
301+  AA6A 07               rlca                ; multiply by 8
302+  AA6B 47               ld b,a
303+  AA6C 79               ld a,c
304+  AA6D 48               ld c,b                         ; swap b and c
305+  AA6E 07               rlca
306+  AA6F 07               rlca
307+  AA70 07               rlca                ; divide by 8
308+  AA71 47               ld b,a
309+  AA72 C9               ret
310+  AA73
311+  AA73              ;
312+  AA73              ; Get buffer address for a character at b,c - b vert
313+  AA73              ; Buffer memory is stored as sequential block
314+  AA73              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
315+  AA73              ; Inputs:
316+  AA73              ; bc - coords
317+  AA73              ; Outputs:
318+  AA73              ; de - memory location of first byte
319+  AA73              screen_getbufferaddress:
320+  AA73 21 8C 86         ld hl, buffer_buffer    ; first get screen buffer start
321+  AA76 50               ld d,b                  ; then work out vertical offset
322+  AA77 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
323+  AA79 19               add hl,de               ; add to base
324+  AA7A 59               ld e,c                  ; then add horizontal offset (c)
325+  AA7B 16 00            ld d,0
326+  AA7D 19               add hl,de               ; add to base
327+  AA7E 54 5D            ld de,hl
328+  AA80 C9               ret
329+  AA81
330+  AA81              ;
331+  AA81              ; Display character hl at (b, c) to buffer.
332+  AA81              ; Stored sequentially
333+  AA81              ; Inputs:
334+  AA81              ; hl: block address
335+  AA81              ; bc: coords
336+  AA81              ;
337+  AA81              screen_showchar:
338+  AA81 ED 43 58 AC      ld (origcoords),bc   ; store char coords
339+  AA85 3E 00            ld a,0
340+  AA87 E5               push hl
341+  AA88 CD 73 AA         call screen_getbufferaddress ; get the current screen buffer pointer
342+  AA8B E1               pop hl
343+  AA8C 06 08            ld b,8              ; number of pixels high.
344+  AA8E              screen_showchar0:
345+  AA8E 7E               ld a,(hl)           ; source graphic.
346+  AA8F 12               ld (de),a           ; transfer to screen.
347+  AA90 23               inc hl              ; next piece of data.
348+  AA91 E5               push hl             ; store hl
349+  AA92 62 6B            ld hl,de            ; put de in hl
350+  AA94 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
351+  AA96 16 00            ld d,0
352+  AA98 19               add hl,de              ; add de to hl
353+  AA99 54 5D            ld de,hl            ; load back to de
354+  AA9B E1               pop hl              ; restore hl
355+  AA9C
356+  AA9C 10 F0            djnz screen_showchar0 ; repeat
357+  AA9E 2E 01            ld l,1
358+  AAA0 CD 09 AC         call sprites_marklinesforupdatechar
359+  AAA3
360+  AAA3 C9               ret
361+  AAA4
362+  AAA4
363+  AAA4              ;
364+  AAA4              ; Get cell graphic.
365+  AAA4              ; Inputs:
366+  AAA4              ; a: block
367+  AAA4              ; Outputs:
368+  AAA4              ; hl: memory
369+  AAA4              ;
370+  AAA4              screen_getblock:
371+  AAA4 07               rlca                        ; multiply block number by eight.
372+  AAA5 07               rlca
373+  AAA6 07               rlca
374+  AAA7 5F               ld e,a                      ; displacement to graphic address.
375+  AAA8 16 00            ld d,0                      ; no high byte.
376+  AAAA 21 6D BD         ld hl,sprites               ; address of character blocks.
377+  AAAD 19               add hl,de                   ; point to block.
378+  AAAE C9               ret
379+  AAAF
380+  AAAF              ;
381+  AAAF              ; Set a the attr of a coord
382+  AAAF              ; Inputs:
383+  AAAF              ; bc - char coords
384+  AAAF              ; a - attr
385+  AAAF              ;
386+  AAAF              screen_setattr:
387+  AAAF DD E5            push ix
388+  AAB1 C5               push bc
389+  AAB2 08               ex af, af'
390+  AAB3 CD 18 AA         call screen_getcellattroffset   ; get offset into de
391+  AAB6 21 8C A3         ld hl,buffer_attr_buffer
392+  AAB9 19               add hl,de                       ; get the memory location
393+  AABA 08               ex af, af'                      ; get attr back
394+  AABB 77               ld (hl),a                         ; set the attr
395+  AABC 08               ex af, af'                      ; get attr back
396+  AABD ED 5B F7 A8      ld de,(screen_offset)           ; get the offset
397+  AAC1 78               ld a,b                          ; get the vertical
398+  AAC2 93               sub e                           ; subtract the offset
399+  AAC3 DA D9 AA         jp c,screen_setattr0            ; if less than zero, don't update the attr on screen
400+  AAC6 FE 15            cp 21
401+  AAC8 D2 D9 AA         jp nc,screen_setattr0           ; if more than 21, don't update the attr on screen
402+  AACB 47               ld b,a                          ; put the coord back in b
403+  AACC CD 2C AA         call screen_getscreenattradress ; screen attr address in de
404+  AACF 21 40 00         ld hl,64                        ; attr memory + two rows for scores
405+  AAD2 19               add hl,de
406+  AAD3 08               ex af, af'                      ; get attr back
407+  AAD4 77               ld (hl),a
408+  AAD5 C1               pop bc
409+  AAD6 DD E1            pop ix
410+  AAD8 C9               ret
411+  AAD9              screen_setattr0:
412+  AAD9 C1               pop bc
413+  AADA DD E1            pop ix
414+  AADC C9               ret
415+  AADD
416+  AADD              ;
417+  AADD              ; Get cell attribute.
418+  AADD              ; Inputs:
419+  AADD              ; a: block
420+  AADD              ; Outputs:
421+  AADD              ; hl: memory
422+  AADD              ;
423+  AADD              screen_getattr:
424+  AADD 5F               ld e,a                      ; displacement to attribute address.
425+  AADE 16 00            ld d,0                      ; no high byte.
426+  AAE0 21 4D BE         ld hl,sprite_attrs          ; address of block attributes.
427+  AAE3 19               add hl,de                   ; point to attribute.
428+  AAE4 C9               ret
429+  AAE5
430+  AAE5              ;
431+  AAE5              ; Checks whether a character block has anything in it
432+  AAE5              ; Inputs:
433+  AAE5              ; bc - char coords
434+  AAE5              ; Outputs:
435+  AAE5              ; a - 1, empty
436+  AAE5              screen_ischarempty:
437+  AAE5 CD 73 AA         call screen_getbufferaddress ; get the current screen buffer pointer
438+  AAE8 06 08            ld b,8                      ; check 8 rows
439+  AAEA              screen_ischarempty2:
440+  AAEA 1A               ld a,(de)                   ; check line
441+  AAEB FE 00            cp 0
442+  AAED C2 FB AA         jp nz,screen_ischarempty1   ; if not zero, jump out with false
443+  AAF0 21 20 00         ld hl,32
444+  AAF3 19               add hl,de
445+  AAF4 54 5D            ld de,hl                    ; move to next row
446+  AAF6 10 F2            djnz screen_ischarempty2
447+  AAF8              screen_ischarempty0:
448+  AAF8 3E 01            ld a,1
449+  AAFA C9               ret
450+  AAFB              screen_ischarempty1:
451+  AAFB 3E 00            ld a,0
452+  AAFD C9               ret
453+  AAFE
454+  AAFE              ;
455+  AAFE              ; Copies a block from one place to another directly underneath, leaves the original empty
456+  AAFE              ; Inputs:
457+  AAFE              ; bc - coords of block to copy from
458+  AAFE              screen_copyblockdown
459+  AAFE CD 73 AA         call screen_getbufferaddress ; get the current screen buffer pointer for source
460+  AB01 06 08            ld b,8                      ; copy 8 rows
461+  AB03              screen_copyblock0:
462+  AB03 1A               ld a,(de)                    ; get what we're copying
463+  AB04 08               ex af,af'
464+  AB05 3E 00            ld a,0
465+  AB07 12               ld (de),a                    ; replace with empty
466+  AB08 08               ex af,af'
467+  AB09 14               inc d                        ; add 256 to get to the next row
468+  AB0A 12               ld (de),a                    ; copy to the next row
469+  AB0B 15               dec d
470+  AB0C 21 20 00         ld hl,32
471+  AB0F 19               add hl,de                       ; return back to source, next row down
472+  AB10 54 5D            ld de,hl
473+  AB12 10 EF            djnz screen_copyblock0
474+  AB14 C9               ret
475+  AB15
476+  AB15              ;
477+  AB15              ; Returns the first byte of a character. Useful for figuring out what's there
478+  AB15              ; Inputs:
479+  AB15              ; bc - coords
480+  AB15              ; Outputs:
481+  AB15              ; a - first byte
482+  AB15              ;
483+  AB15              screen_getcharfirstbyte:
484+  AB15 CD 73 AA         call screen_getbufferaddress ; get the current screen buffer pointer for source
485+  AB18 1A               ld a,(de)
486+  AB19 C9               ret
487+  AB1A
# file closed: screen/screen.asm
128   AB1A                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  AB1A              ;
  2+  AB1A              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  AB1A              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  AB1A              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  AB1A              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  AB1A              ; routine takes care of all the shifting itself. This means that sprite
  7+  AB1A              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  AB1A              ; space they would require in pre-shifted form.
  9+  AB1A              ; Inputs:
 10+  AB1A              ; hl - sprite data
 11+  AB1A              ; bc - screen coords
 12+  AB1A              ;
 13+  AB1A              sprites_drawsprite7:
 14+  AB1A EE 07            xor 7               ; complement last 3 bits.
 15+  AB1C 3C               inc a               ; add one for luck!
 16+  AB1D              sprites_drawsprite3:
 17+  AB1D CB 11            rl c                ; ...into middle byte...
 18+  AB1F CB 12            rl d                ; ...and finally into left character cell.
 19+  AB21 3D               dec a               ; count shifts we've done.
 20+  AB22 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  AB24                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  AB24 79               ld a,c              ; left edge of image is currently in e.
 23+  AB25 4A               ld c,d              ; put right edge there instead.
 24+  AB26 57               ld d,a              ; and the left edge back into c.
 25+  AB27 18 29            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  AB29              sprites_drawsprite:
 27+  AB29 ED 43 58 AC      ld (origcoords),bc  ; store coords
 28+  AB2D ED 43 5A AC      ld (dispx),bc       ; store coords in dispx for now.
 29+  AB31 E5               push hl
 30+  AB32 CD 36 AC         call sprites_scadd  ; calculate screen address.
 31+  AB35 E1               pop hl
 32+  AB36 3E 08            ld a,8              ; height of sprite in pixels.
 33+  AB38              sprites_drawsprite1:
 34+  AB38 08               ex af,af'           ; store loop counter.
 35+  AB39 D5               push de             ; store screen address.
 36+  AB3A 4E               ld c,(hl)           ; first sprite graphic.
 37+  AB3B 23               inc hl              ; increment poiinter to sprite data.
 38+  AB3C 22 5C AC         ld (sprtmp),hl      ; store it for later.
 39+  AB3F 16 00            ld d,0              ; blank right byte for now.
 40+  AB41 78               ld a,b              ; b holds y position.
 41+  AB42 E6 07            and 7               ; how are we straddling character cells?
 42+  AB44 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 43+  AB46 FE 05            cp 5                ; 5 or more right shifts needed?
 44+  AB48 30 D0            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 45+  AB4A A7               and a               ; oops, carry flag is set so clear it.
 46+  AB4B              sprites_drawsprite2:
 47+  AB4B CB 19            rr c                ; rotate left byte right...
 48+  AB4D CB 1A            rr d                ; ...into right byte.
 49+  AB4F 3D               dec a               ; one less shift to do.
 50+  AB50 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 51+  AB52              sprites_drawsprite0:
 52+  AB52 E1               pop hl              ; pop screen address from stack.
 53+  AB53 7E               ld a,(hl)           ; what's there already.
 54+  AB54 A9               xor c               ; merge in image data.
 55+  AB55 77               ld (hl),a           ; place onto screen.
 56+  AB56 23               inc hl
 57+  AB57 7E               ld a,(hl)           ; what's already there.
 58+  AB58 AA               xor d               ; right edge of sprite image data.
 59+  AB59 77               ld (hl),a           ; plonk it on screen.
 60+  AB5A 3A 5A AC         ld a,(dispx)        ; vertical coordinate.
 61+  AB5D 3C               inc a               ; next line down.
 62+  AB5E 32 5A AC         ld (dispx),a        ; store new position.
 63+  AB61 2B               dec hl
 64+  AB62 11 20 00         ld de,32            ; add 32 to get to the next row
 65+  AB65 19               add hl,de           ; add 32
 66+  AB66              sprites_drawsprite6:
 67+  AB66 EB               ex de,hl            ; screen address in de.
 68+  AB67 2A 5C AC         ld hl,(sprtmp)      ; restore graphic address.
 69+  AB6A 08               ex af,af'           ; restore loop counter.
 70+  AB6B 3D               dec a               ; decrement it.
 71+  AB6C C2 38 AB         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 72+  AB6F 2E 02            ld l,2
 73+  AB71 CD E0 AB         call sprites_marklinesforupdatescreen
 74+  AB74 C9               ret                 ; job done.
 75+  AB75
 76+  AB75              ; Inputs:
 77+  AB75              ; hl - sprite data
 78+  AB75              ; bc - screen coords
 79+  AB75              ;
 80+  AB75              sprites_draw2by2sprite7
 81+  AB75 EE 07            xor 7               ; complement last 3 bits.
 82+  AB77 3C               inc a               ; add one for luck!
 83+  AB78              sprites_draw2by2sprite3
 84+  AB78 CB 12            rl d                ; rotate left...
 85+  AB7A CB 11            rl c                ; ...into middle byte...
 86+  AB7C CB 13            rl e                ; ...and finally into left character cell.
 87+  AB7E 3D               dec a               ; count shifts we've done.
 88+  AB7F 20 F7            jr nz,sprites_draw2by2sprite3 ; return until all shifts complete.
 89+  AB81                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 90+  AB81 7B               ld a,e              ; left edge of image is currently in e.
 91+  AB82 5A               ld e,d              ; put right edge there instead.
 92+  AB83 51               ld d,c              ; middle bit goes in d.
 93+  AB84 4F               ld c,a              ; and the left edge back into c.
 94+  AB85 18 31            jr sprites_draw2by2sprite0 ; we've done the switch so transfer to screen.
 95+  AB87              sprites_draw2by2sprite
 96+  AB87 ED 43 58 AC      ld (origcoords),bc  ; store coords
 97+  AB8B ED 43 5A AC      ld (dispx),bc       ; store coords in dispx for now.
 98+  AB8F 79               ld a,c
 99+  AB90 32 5E AC         ld (sprtmp0),a         ; store vertical.
100+  AB93 E5               push hl
101+  AB94 CD 36 AC         call sprites_scadd          ; calculate screen address.
102+  AB97 E1               pop hl
103+  AB98 3E 10            ld a,16             ; height of sprite in pixels.
104+  AB9A              sprites_draw2by2sprite1
105+  AB9A 08               ex af,af'           ; store loop counter.
106+  AB9B D5               push de             ; store screen address.
107+  AB9C 4E               ld c,(hl)           ; first sprite graphic.
108+  AB9D 23               inc hl              ; increment poiinter to sprite data.
109+  AB9E 56               ld d,(hl)           ; next bit of sprite image.
110+  AB9F 23               inc hl              ; point to next row of sprite data.
111+  ABA0 22 5C AC         ld (sprtmp),hl        ; store in tmp0 for later.
112+  ABA3 1E 00            ld e,0              ; blank right byte for now.
113+  ABA5 78               ld a,b              ; b holds y position.
114+  ABA6 E6 07            and 7               ; how are we straddling character cells?
115+  ABA8 28 0E            jr z,sprites_draw2by2sprite0 ; we're not straddling them, don't bother shifting.
116+  ABAA FE 05            cp 5                ; 5 or more right shifts needed?
117+  ABAC 30 C7            jr nc,sprites_draw2by2sprite7 ; yes, shift from left as it's quicker.
118+  ABAE A7               and a               ; oops, carry flag is set so clear it.
119+  ABAF              sprites_draw2by2sprite2
120+  ABAF CB 19            rr c                ; rotate left byte right...
121+  ABB1 CB 1A            rr d                ; ...through middle byte...
122+  ABB3 CB 1B            rr e                ; ...into right byte.
123+  ABB5 3D               dec a               ; one less shift to do.
124+  ABB6 20 F7            jr nz,sprites_draw2by2sprite2 ; return until all shifts complete.
125+  ABB8              sprites_draw2by2sprite0
126+  ABB8 E1               pop hl              ; pop screen address from stack.
127+  ABB9 7E               ld a,(hl)           ; what's there already.
128+  ABBA A9               xor c               ; merge in image data.
129+  ABBB 77               ld (hl),a           ; place onto screen.
130+  ABBC 23               inc hl               ; next character cell to right please.
131+  ABBD 7E               ld a,(hl)           ; what's there already.
132+  ABBE AA               xor d               ; merge with middle bit of image.
133+  ABBF 77               ld (hl),a           ; put back onto screen.
134+  ABC0 23               inc hl              ; next bit of screen area.
135+  ABC1 7E               ld a,(hl)           ; what's already there.
136+  ABC2 AB               xor e               ; right edge of sprite image data.
137+  ABC3 77               ld (hl),a           ; plonk it on screen.
138+  ABC4 3A 5E AC         ld a,(sprtmp0)         ; temporary vertical coordinate.
139+  ABC7 3C               inc a               ; next line down.
140+  ABC8 32 5E AC         ld (sprtmp0),a         ; store new position.
141+  ABCB 2B               dec hl
142+  ABCC 2B               dec hl
143+  ABCD 11 20 00         ld de,32            ; add 32 to get to the next row
144+  ABD0 19               add hl,de           ; add 32
145+  ABD1              sprites_draw2by2sprite6
146+  ABD1 EB               ex de,hl            ; screen address in de.
147+  ABD2 2A 5C AC         ld hl,(sprtmp)        ; restore graphic address.
148+  ABD5 08               ex af,af'           ; restore loop counter.
149+  ABD6 3D               dec a               ; decrement it.
150+  ABD7 C2 9A AB         jp nz,sprites_draw2by2sprite1 ; not reached bottom of sprite yet to repeat.
151+  ABDA 2E 03            ld l,3
152+  ABDC CD E0 AB         call sprites_marklinesforupdatescreen
153+  ABDF C9               ret                 ; job done.
154+  ABE0
155+  ABE0              ;
156+  ABE0              ; Marks lines for update with screen coords
157+  ABE0              ; Inputs:
158+  ABE0              ; l - number to update
159+  ABE0              ;
160+  ABE0              sprites_marklinesforupdatescreen:
161+  ABE0 F5               push af
162+  ABE1 ED 4B 58 AC      ld bc,(origcoords)
163+  ABE5 CD 57 AA         call screen_getcharcoordsfromscreencoords
164+  ABE8 ED 43 58 AC      ld (origcoords),bc
165+  ABEC 3A 2E A7         ld a,(buffer_threelinerefresh)              ; check the three line update flag
166+  ABEF FE 00            cp 0
167+  ABF1 CA 04 AC         jp z,sprites_marklinesforupdatescreen0      ; if not set, don't do anything
168+  ABF4 FE 02            cp 2
169+  ABF6 CA FA AB         jp z,sprites_marklinesforupdatescreen1      ; if set to below, increase number of lines to three, but don't look above
170+  ABF9 05               dec b                                       ; digging up, so dec vertical coord by one to render one extra above
171+  ABFA              sprites_marklinesforupdatescreen1:
172+  ABFA 2C               inc l                                       ; increase number to 3
173+  ABFB ED 43 58 AC      ld (origcoords),bc                           ; decrease vertical coord
174+  ABFF 3E 00            ld a,0
175+  AC01 32 2E A7         ld (buffer_threelinerefresh),a              ; reset the flag
176+  AC04              sprites_marklinesforupdatescreen0:
177+  AC04 CD 13 AC         call sprites_marklinesforupdate
178+  AC07 F1               pop af
179+  AC08 C9               ret
180+  AC09
181+  AC09              ;
182+  AC09              ; Marks lines for update with char coords
183+  AC09              ; Inputs:
184+  AC09              ; l - number to update
185+  AC09              ;
186+  AC09              sprites_marklinesforupdatechar:
187+  AC09 F5               push af
188+  AC0A ED 43 58 AC      ld (origcoords),bc
189+  AC0E CD 13 AC         call sprites_marklinesforupdate
190+  AC11 F1               pop af
191+  AC12 C9               ret
192+  AC13
193+  AC13              ;
194+  AC13              ; Marks lines for update
195+  AC13              ; Inputs:
196+  AC13              ; l - number to update
197+  AC13              ;
198+  AC13              sprites_marklinesforupdate:
199+  AC13 ED 4B 58 AC      ld bc,(origcoords)
200+  AC17 ED 5B F7 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows
201+  AC1B 78               ld a,b
202+  AC1C 93               sub e
203+  AC1D 47               ld b,a
204+  AC1E 7D               ld a,l                          ; get loop counter
205+  AC1F              sprites_marklinesforupdate0:
206+  AC1F C5               push bc
207+  AC20 08               ex af,af'                     ; store loop counter
208+  AC21 78               ld a,b
209+  AC22 CD 45 A7         call buffer_marklineforupdate ; mark this line for update
210+  AC25 ED 4B 58 AC      ld bc,(origcoords)            ; move the coords for the next line
211+  AC29 04               inc b
212+  AC2A ED 43 58 AC      ld (origcoords),bc
213+  AC2E C1               pop bc
214+  AC2F 04               inc b
215+  AC30 08               ex af,af'                     ; restore loop counter
216+  AC31 3D               dec a
217+  AC32 C2 1F AC         jp nz,sprites_marklinesforupdate0
218+  AC35 C9               ret
219+  AC36
220+  AC36              ;
221+  AC36              ; This routine returns a buffer address for (c, b) in de (c vert).
222+  AC36              ; For example: 0,0 will be at memory offset 0
223+  AC36              ; 1,0 (1 down) will be at memory offset 1
224+  AC36              ; 0,7 will be at memory offset 0
225+  AC36              ; 9,1 will be at memory offset 8+1
226+  AC36              ; 8,0 will be at memory offset 256
227+  AC36              ; 9,0 will be at memory offset 257
228+  AC36              ; Outputs:
229+  AC36              ; de - coords
230+  AC36              ;
231+  AC36              sprites_scadd:
232+  AC36 79               ld a,c               ; calculate vertical offset
233+  AC37 E6 F8            and 248             ;  to get nearest multiple of 8
234+  AC39 0F               rrca
235+  AC3A 0F               rrca
236+  AC3B 0F               rrca                ; divide by 8
237+  AC3C 67               ld h,a
238+  AC3D 78               ld a,b               ; calculate horizontal offset
239+  AC3E E6 F8            and 248             ;  to get nearest multiple of 8
240+  AC40 0F               rrca
241+  AC41 0F               rrca
242+  AC42 0F               rrca                ; divide by 8
243+  AC43 6F               ld l,a
244+  AC44 C5               push bc             ; store the screen coords
245+  AC45 44 4D            ld bc,hl            ; load bc with the character coords
246+  AC47 CD 73 AA         call screen_getbufferaddress
247+  AC4A C1               pop bc              ; get back screen coords, de is now memory of character
248+  AC4B 79               ld a,c              ; now add the vertical within the cell
249+  AC4C E6 07            and 7
250+  AC4E 0F               rrca                ; multiply by 32.
251+  AC4F 0F               rrca
252+  AC50 0F               rrca
253+  AC51 6F               ld l,a
254+  AC52 26 00            ld h,0
255+  AC54 19               add hl,de
256+  AC55 54 5D            ld de,hl
257+  AC57 C9               ret
258+  AC58
259+  AC58 00 00        origcoords   defb 0,0           ; general-use coordinates.
260+  AC5A
261+  AC5A 00           dispx   defb 0           ; general-use coordinates.
262+  AC5B 00           dispy   defb 0
263+  AC5C 00 00        sprtmp  defb 0,0           ; sprite temporary address.
264+  AC5E 00 00        sprtmp0  defb 0,0           ; sprite temporary address.
265+  AC60
# file closed: screen/sprites.asm
129   AC60                  include "screen\titlescreen.asm"
# file opened: screen/titlescreen.asm
  1+  AC60              titlescreen_preshow:
  2+  AC60 CD 11 AD         call titlescreen_preinit
  3+  AC63 CD 7B B1         call sound_gamestart
  4+  AC66 06 3C            ld b,60
  5+  AC68 CD 64 81         call utilities_pauseforframes         ; pause for a second
  6+  AC6B C9               ret
  7+  AC6C
  8+  AC6C              ;
  9+  AC6C              ; Draws the title screen
 10+  AC6C              ;
 11+  AC6C              titlescreen_show:
 12+  AC6C CD FE AC         call titlescreen_init
 13+  AC6F CD A7 AC         call titlescreen_drawtitle
 14+  AC72 3A 31 C5         ld a,(game_control)
 15+  AC75 FE 00            cp 0
 16+  AC77 CA 7F AC         jp z,titlescreen_show1
 17+  AC7A 06 32            ld b,50
 18+  AC7C CD 64 81         call utilities_pauseforframes         ; pause for a second
 19+  AC7F              titlescreen_show1:
 20+  AC7F 3E FA            ld a,250                              ; wait for 200 frames
 21+  AC81 CD 25 81         call utilities_waitforkey_forframes   ; wait for keypress
 22+  AC84 7B               ld a,e
 23+  AC85 FE 01            cp 1                                  ; was anything pressed?
 24+  AC87 C8               ret z                                 ; end titlescreen if so
 25+  AC88
 26+  AC88 CD 1E AD         call titlescreen_alt_init             ; otherwise, draw alt screen
 27+  AC8B CD C3 AC         call titlescreen_alt_drawtitle
 28+  AC8E 3A 31 C5         ld a,(game_control)
 29+  AC91 FE 00            cp 0
 30+  AC93 CA 9B AC         jp z,titlescreen_show0
 31+  AC96 06 32            ld b,50
 32+  AC98 CD 64 81         call utilities_pauseforframes         ; pause for a second if joystick
 33+  AC9B              titlescreen_show0:
 34+  AC9B 3E FA            ld a,250                              ; wait for 200 frames
 35+  AC9D CD 25 81         call utilities_waitforkey_forframes   ; wait for keypress
 36+  ACA0 7B               ld a,e
 37+  ACA1 FE 01            cp 1                                  ; was anything pressed?
 38+  ACA3 C2 6C AC         jp nz,titlescreen_show               ; start again if not
 39+  ACA6 C9               ret
 40+  ACA7
 41+  ACA7              ;
 42+  ACA7              ; Draws the iconic logo
 43+  ACA7              ;
 44+  ACA7              titlescreen_drawtitle:
 45+  ACA7 06 67            ld b,103              ; number of points
 46+  ACA9 DD 21 2B AD      ld ix,titlescreen_logo_data
 47+  ACAD              titlescreen_drawtitle0:
 48+  ACAD C5               push bc
 49+  ACAE DD 4E 00         ld c,(ix)                   ; got horiz
 50+  ACB1 DD 23            inc ix
 51+  ACB3 DD 46 00         ld b,(ix)                   ; got vert
 52+  ACB6 DD 23            inc ix
 53+  ACB8 CD 2C AA         call screen_getscreenattradress ; memory in de
 54+  ACBB 13               inc de                      ; slide one to the right, since I'm too lazy to change the data
 55+  ACBC 3E 13            ld a,19
 56+  ACBE 12               ld (de),a
 57+  ACBF C1               pop bc
 58+  ACC0 10 EB            djnz titlescreen_drawtitle0 ; loop if we're not at the end
 59+  ACC2 C9               ret
 60+  ACC3
 61+  ACC3              ;
 62+  ACC3              ; Draws the alternate title screen
 63+  ACC3              ;
 64+  ACC3              titlescreen_alt_drawtitle:
 65+  ACC3 21 3C 82         ld hl,string_alttitlescreen_1
 66+  ACC6 CD 44 86         call string_print
 67+  ACC9 21 48 82         ld hl,string_alttitlescreen_2
 68+  ACCC CD 44 86         call string_print
 69+  ACCF 21 43 83         ld hl,string_alttitlescreen_3
 70+  ACD2 CD 44 86         call string_print
 71+  ACD5 06 20            ld b,32
 72+  ACD7 3E 43            ld a,67
 73+  ACD9 11 00 58         ld de,22528                         ; top row attrs here
 74+  ACDC CD BA A9         call screen_setcolours
 75+  ACDF 06 20            ld b,32
 76+  ACE1 3E 46            ld a,70
 77+  ACE3 11 A0 59         ld de,22528+416                     ; 13th row attrs here
 78+  ACE6 CD BA A9         call screen_setcolours
 79+  ACE9 06 20            ld b,32
 80+  ACEB 3E 43            ld a,67
 81+  ACED 11 20 5A         ld de,22528+544                         ; 17th row attrs here
 82+  ACF0 CD BA A9         call screen_setcolours
 83+  ACF3 06 20            ld b,32
 84+  ACF5 3E 42            ld a,66
 85+  ACF7 11 A0 5A         ld de,22528+672                         ; 21st row attrs here
 86+  ACFA CD BA A9         call screen_setcolours
 87+  ACFD C9               ret
 88+  ACFE
 89+  ACFE              ;
 90+  ACFE              ; Initialises the screen
 91+  ACFE              ;
 92+  ACFE              titlescreen_init:
 93+  ACFE              ; We want a black screen.
 94+  ACFE 3E 0B            ld a,11             ; magenta ink (7) on blue paper (0),
 95+  AD00                                      ; bright (64).
 96+  AD00 CD 49 81         call utilities_clearscreen
 97+  AD03 32 8D 5C         ld (23693),a        ; set our screen colours.
 98+  AD06 3E 01            ld a,1              ; 2 is the code for red.
 99+  AD08 D3 FE            out (254),a         ; write to port 254.
100+  AD0A
101+  AD0A 21 27 82         ld hl,string_titlescreen_copyright
102+  AD0D CD 44 86         call string_print
103+  AD10
104+  AD10 C9               ret
105+  AD11
106+  AD11              ;
107+  AD11              ; Initialises the pre-screen
108+  AD11              ;
109+  AD11              titlescreen_preinit:
110+  AD11              ; We want a red screen.
111+  AD11 3E 10            ld a,16             ; magenta ink (7) on blue paper (0),
112+  AD13                                      ; bright (64).
113+  AD13 CD 49 81         call utilities_clearscreen
114+  AD16 32 8D 5C         ld (23693),a        ; set our screen colours.
115+  AD19 3E 02            ld a,2              ; 2 is the code for red.
116+  AD1B D3 FE            out (254),a         ; write to port 254.
117+  AD1D C9               ret
118+  AD1E
119+  AD1E              ;
120+  AD1E              ; Initialises the screen
121+  AD1E              ;
122+  AD1E              titlescreen_alt_init:
123+  AD1E              ; We want a black screen.
124+  AD1E 3E 47            ld a,71             ; white ink (7) on black paper (0),
125+  AD20                                      ; bright (64).
126+  AD20 CD 49 81         call utilities_clearscreen
127+  AD23 32 8D 5C         ld (23693),a        ; set our screen colours.
128+  AD26 3E 00            ld a,0              ; 2 is the code for red.
129+  AD28 D3 FE            out (254),a         ; write to port 254.
130+  AD2A
131+  AD2A C9               ret
132+  AD2B
133+  AD2B              ;
134+  AD2B              ; Horiz, vert
135+  AD2B              ;
136+  AD2B              titlescreen_logo_data:
137+  AD2B 08 00 09 00      defb 8,0,9,0,10,0,12,0,15,0,17,0,18,0,19,0
137+  AD2F 0A 00 0C 00
137+  AD33 0F 00 11 00
137+  AD37 12 00 13 00
138+  AD3B 09 01 0C 01      defb 9,1,12,1,15,1,17,1
138+  AD3F 0F 01 11 01
139+  AD43 09 02 0C 02      defb 9,2,12,2,13,2,14,2,15,2,17,2,18,2,19,2
139+  AD47 0D 02 0E 02
139+  AD4B 0F 02 11 02
139+  AD4F 12 02 13 02
140+  AD53 09 03 0C 03      defb 9,3,12,3,15,3,17,3
140+  AD57 0F 03 11 03
141+  AD5B 09 04 0C 04      defb 9,4,12,4,15,4,17,4,18,4,19,4
141+  AD5F 0F 04 11 04
141+  AD63 12 04 13 04
142+  AD67 00 06 01 06      defb 0,6,1,6,2,6,3,6,4,6,5,6,6,6,7,6,8,6,9,6,10,6,11,6
142+  AD6B 02 06 03 06
142+  AD6F 04 06 05 06
142+  AD73 06 06 07 06
142+  AD77 08 06 09 06
142+  AD7B 0A 06 0B 06
143+  AD7F 10 06 11 06      defb 16,6,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6
143+  AD83 12 06 13 06
143+  AD87 14 06 15 06
143+  AD8B 16 06 17 06
143+  AD8F 18 06 19 06
143+  AD93 1A 06 1B 06
144+  AD97 02 07 02 08      defb 2,7,2,8,2,9,2,10,2,11,2,12,2,13,2,14,2,15,2,16,2,17,2,18,2,19,2,20,2,21
144+  AD9B 02 09 02 0A
144+  AD9F 02 0B 02 0C
144+  ADA3 02 0D 02 0E
144+  ADA7 02 0F 02 10
144+  ADAB 02 11 02 12
144+  ADAF 02 13 02 14
144+  ADB3 02 15
145+  ADB5 19 07 19 08      defb 25,7,25,8,25,9,25,10,25,11,25,12,25,13,25,14,25,15,25,16,25,17,25,18,25,19,25,20,25,21
145+  ADB9 19 09 19 0A
145+  ADBD 19 0B 19 0C
145+  ADC1 19 0D 19 0E
145+  ADC5 19 0F 19 10
145+  ADC9 19 11 19 12
145+  ADCD 19 13 19 14
145+  ADD1 19 15
146+  ADD3 03 0B 04 0B      defb 3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,11,11
146+  ADD7 05 0B 06 0B
146+  ADDB 07 0B 08 0B
146+  ADDF 09 0B 0A 0B
146+  ADE3 0B 0B
147+  ADE5 0B 07 0B 08      defb 11,7,11,8,11,9,11,10
147+  ADE9 0B 09 0B 0A
148+  ADED 10 0D 10 0F      defb 16,13,16,15,16,16,16,17,16,18,16,19
148+  ADF1 10 10 10 11
148+  ADF5 10 12 10 13
149+  ADF9
# file closed: screen/titlescreen.asm
130   ADF9                  include "screen\lifescreen.asm"
# file opened: screen/lifescreen.asm
  1+  ADF9              ;
  2+  ADF9              ; Draws the life remaining screen
  3+  ADF9              ;
  4+  ADF9              lifescreen_draw:
  5+  ADF9 CD 4F AE         call lifescreen_init
  6+  ADFC
  7+  ADFC 3A 2E C5         ld a,(game_currentplayer)             ; get the current player
  8+  ADFF C6 30            add 48                                ; add 48 to get char
  9+  AE01 21 49 84         ld hl,string_lifescreen_player+10
 10+  AE04 77               ld (hl),a                             ; load this to the string we're about to show
 11+  AE05
 12+  AE05 21 3F 84         ld hl,string_lifescreen_player
 13+  AE08 CD 44 86         call string_print
 14+  AE0B
 15+  AE0B 3A 26 C6         ld a,(player+9)                       ; get the current player lives
 16+  AE0E C6 30            add 48                                ; add 48 to get the character
 17+  AE10 FE 31            cp 49
 18+  AE12 C2 25 AE         jp nz,lifescreen_draw0
 19+  AE15 21 59 84         ld hl,string_lifescreen_lastman
 20+  AE18
 21+  AE18 06 08            ld b,8
 22+  AE1A 3E 0A            ld a,10                                ; set red
 23+  AE1C 11 6C 58         ld de,22528+108                        ; attrs here
 24+  AE1F CD BA A9         call screen_setcolours
 25+  AE22
 26+  AE22 C3 2C AE         jp lifescreen_draw1
 27+  AE25              lifescreen_draw0:
 28+  AE25 21 4E 84         ld hl,string_lifescreen_lives+2       ; not last man, so use the normal view
 29+  AE28 77               ld (hl),a                             ; load this to the string we're about to show
 30+  AE29 21 4C 84         ld hl,string_lifescreen_lives
 31+  AE2C              lifescreen_draw1:
 32+  AE2C CD 44 86         call string_print
 33+  AE2F
 34+  AE2F 3E 86            ld a,134
 35+  AE31 11 0B 58         ld de, 22528+11     ; get the colour for the top text
 36+  AE34 06 0A            ld b,10
 37+  AE36 CD BA A9         call screen_setcolours
 38+  AE39 3A 31 C5         ld a,(game_control)
 39+  AE3C FE 00            cp 0
 40+  AE3E CA 46 AE         jp z,lifescreen_draw2
 41+  AE41 06 32            ld b,50
 42+  AE43 CD 64 81         call utilities_pauseforframes         ; pause for a second if joystick
 43+  AE46              lifescreen_draw2:
 44+  AE46 CD 98 B1         call sound_lifestart
 45+  AE49 3E 64            ld a,100                              ; wait for 200 frames
 46+  AE4B CD 25 81         call utilities_waitforkey_forframes   ; wait for keypress
 47+  AE4E
 48+  AE4E C9               ret
 49+  AE4F
 50+  AE4F              ;
 51+  AE4F              ; Initialises the screen
 52+  AE4F              ;
 53+  AE4F              lifescreen_init:
 54+  AE4F              ; We want a blue screen.
 55+  AE4F                  ;call $0D6B
 56+  AE4F 3E 0E            ld a,14             ; yellow ink (6) on blue paper (1),
 57+  AE51                                      ; bright (64).
 58+  AE51 CD 49 81         call utilities_clearscreen
 59+  AE54 32 8D 5C         ld (23693),a        ; set our screen colours.
 60+  AE57 3E 01            ld a,1              ; 1 is the code for blue.
 61+  AE59 D3 FE            out (254),a         ; write to port 254.
 62+  AE5B                  ;call 3503           ; ROM routine - clears screen, opens chan 2.
 63+  AE5B
 64+  AE5B C9               ret
# file closed: screen/lifescreen.asm
131   AE5C                  include "screen\gameover.asm"
# file opened: screen/gameover.asm
  1+  AE5C              ;
  2+  AE5C              ; Draws the game over screen
  3+  AE5C              ;
  4+  AE5C              gameover_draw:
  5+  AE5C 3E 00            ld a,0
  6+  AE5E 32 9A AF         ld (gameover_soundplayed),a
  7+  AE61 3E 01            ld a,1
  8+  AE63 32 2E C5         ld (game_currentplayer),a               ; do the first player first
  9+  AE66 CD 8E C6         call player_init_lifestart              ; get the player config
 10+  AE69 CD BF AE         call gameover_enterhighscores
 11+  AE6C
 12+  AE6C 3A 2D C5         ld a,(game_numberplayers)               ; check if we need to do player 2
 13+  AE6F FE 02            cp 2
 14+  AE71 C2 7F AE         jp nz,gameover_draw0
 15+  AE74 3E 02            ld a,2
 16+  AE76 32 2E C5         ld (game_currentplayer),a               ; do the second player
 17+  AE79 CD 8E C6         call player_init_lifestart              ; get the player config
 18+  AE7C CD BF AE         call gameover_enterhighscores
 19+  AE7F              gameover_draw0:
 20+  AE7F CD 8D AF         call gameover_init
 21+  AE82
 22+  AE82 21 64 84         ld hl,string_gameoverscreen_gameover
 23+  AE85 CD 44 86         call string_print
 24+  AE88
 25+  AE88 21 70 84         ld hl,string_gameoverscreen_copyright
 26+  AE8B CD 44 86         call string_print
 27+  AE8E
 28+  AE8E CD A2 AE         call gameover_commontext
 29+  AE91 CD 9B AF         call gameover_playsound
 30+  AE94 06 0B            ld b,11
 31+  AE96 3E 42            ld a,66
 32+  AE98 11 2B 58         ld de,22528+43                         ; attrs here
 33+  AE9B CD BA A9         call screen_setcolours
 34+  AE9E CD 10 81         call utilities_waitforkey   ; wait for keypress
 35+  AEA1
 36+  AEA1 C9               ret
 37+  AEA2
 38+  AEA2              ;
 39+  AEA2              ; Draws text shared by the game over and high score screens
 40+  AEA2              ;
 41+  AEA2              gameover_commontext:
 42+  AEA2 CD 7E A9         call screen_setuptext       ; show scores
 43+  AEA5 CD E3 CD         call scores_printscores     ; print the current scores
 44+  AEA8
 45+  AEA8 21 98 84         ld hl,string_gameover_credits
 46+  AEAB CD 44 86         call string_print
 47+  AEAE
 48+  AEAE 21 84 84         ld hl,string_gameoverscreen_bestscores
 49+  AEB1 CD 44 86         call string_print
 50+  AEB4
 51+  AEB4 06 20            ld b,32
 52+  AEB6 3E 45            ld a,69
 53+  AEB8 11 C0 5A         ld de,22528+704                         ; attrs here
 54+  AEBB CD BA A9         call screen_setcolours
 55+  AEBE
 56+  AEBE C9               ret
 57+  AEBF
 58+  AEBF              ;
 59+  AEBF              ; If required, enter highscore
 60+  AEBF              ;
 61+  AEBF              gameover_enterhighscores:
 62+  AEBF                  ; check if we need to enter initial
 63+  AEBF CD 54 CE         call scores_processhighscores
 64+  AEC2
 65+  AEC2 3A 52 CE         ld a,(scores_highscoretmp)
 66+  AEC5 FE 00            cp 0
 67+  AEC7 C8               ret z
 68+  AEC8 CD 23 AF         call gameover_enterhighscores_init
 69+  AECB CD 9B AF         call gameover_playsound
 70+  AECE                  ; Set the flash
 71+  AECE 3A 52 CE         ld a,(scores_highscoretmp)              ; scoretmp has the memory offset of the start of the number
 72+  AED1 1E 05            ld e,5
 73+  AED3 93               sub e                                   ; get the score position back to coords
 74+  AED4 11 00 00         ld de,0
 75+  AED7 5F               ld e,a                                  ; load into de
 76+  AED8 21 68 CD         ld hl,scores_table
 77+  AEDB 19               add hl,de                               ; get the memory location
 78+  AEDC 4E 23 46 2B      ld bc,(hl)                              ; get the coords
 79+  AEE0 CD 2C AA         call screen_getscreenattradress         ; get the memory location of the cell attr into de
 80+  AEE3 1A               ld a,(de)                               ; get the current attr
 81+  AEE4 F6 80            or 128                                  ; make it flash
 82+  AEE6 12               ld (de),a
 83+  AEE7 13               inc de
 84+  AEE8 12               ld (de),a
 85+  AEE9 13               inc de
 86+  AEEA 12               ld (de),a                               ; make all three flash
 87+  AEEB 3A 52 CE         ld a,(scores_highscoretmp)              ; get the score back again
 88+  AEEE 3D               dec a
 89+  AEEF 3D               dec a
 90+  AEF0 3D               dec a                                   ; get high score location back to position of name
 91+  AEF1 16 00            ld d,0
 92+  AEF3 5F               ld e,a
 93+  AEF4 21 68 CD         ld hl,scores_table
 94+  AEF7 19               add hl,de                               ; load memory into hl
 95+  AEF8 08               ex af,af'
 96+  AEF9 06 0F            ld b,15
 97+  AEFB CD 64 81         call utilities_pauseforframes           ; pause for a little bit
 98+  AEFE 06 03            ld b,3                                  ; collect three chars
 99+  AF00              gameover_enterhighscores2:
100+  AF00 C5               push bc
101+  AF01 E5               push hl
102+  AF02              gameover_enterhighscores3:
103+  AF02 CD 68 81         call utilities_readkey               ; get key into a
104+  AF05 FE 41            cp 65
105+  AF07 DA 02 AF         jp c,gameover_enterhighscores3
106+  AF0A FE 5B            cp 91
107+  AF0C D2 02 AF         jp nc,gameover_enterhighscores3      ; if not a letter, get another
108+  AF0F E1               pop hl
109+  AF10 77               ld (hl),a
110+  AF11 23               inc hl
111+  AF12 E5               push hl
112+  AF13 CD 11 B2         call sound_gemcollected
113+  AF16 CD 3F CE         call scores_showtable
114+  AF19 E1               pop hl
115+  AF1A 06 0F            ld b,15
116+  AF1C CD 64 81         call utilities_pauseforframes
117+  AF1F C1               pop bc
118+  AF20 10 DE            djnz gameover_enterhighscores2
119+  AF22 C9               ret
120+  AF23
121+  AF23              ;
122+  AF23              ; Displays the screen text for high score entry
123+  AF23              ;
124+  AF23              gameover_enterhighscores_init:
125+  AF23
126+  AF23 CD 8D AF         call gameover_init
127+  AF26 CD A2 AE         call gameover_commontext
128+  AF29
129+  AF29 21 A4 84         ld hl,string_highscore_congratulations
130+  AF2C CD 44 86         call string_print
131+  AF2F
132+  AF2F 3A 2E C5         ld a,(game_currentplayer)
133+  AF32 FE 01            cp 1
134+  AF34 21 B6 84         ld hl,string_highscore_player1
135+  AF37 CA 3D AF         jp z, gameover_enterhighscores_init1
136+  AF3A              gameover_enterhighscores_init0:
137+  AF3A 21 C1 84         ld hl,string_highscore_player2
138+  AF3D              gameover_enterhighscores_init1:
139+  AF3D CD 44 86         call string_print
140+  AF40 06 60            ld b,96
141+  AF42 3E 43            ld a,67
142+  AF44 11 A0 58         ld de,22528+160                         ; attrs here
143+  AF47 CD BA A9         call screen_setcolours
144+  AF4A
145+  AF4A 21 CC 84         ld hl,string_highscore_youhaveearned
146+  AF4D CD 44 86         call string_print
147+  AF50
148+  AF50 3A 52 CE         ld a,(scores_highscoretmp)
149+  AF53 FE 05            cp 5
150+  AF55 CA 63 AF         jp z, gameover_enterhighscores_init2    ; first place
151+  AF58 FE 11            cp 17
152+  AF5A CA 69 AF         jp z, gameover_enterhighscores_init3    ; 2nd place
153+  AF5D 21 08 85         ld hl,string_highscore_place3           ; 3rd place
154+  AF60 C3 6F AF         jp gameover_enterhighscores_init4
155+  AF63              gameover_enterhighscores_init2
156+  AF63 21 DE 84         ld hl,string_highscore_place1
157+  AF66 C3 6F AF         jp gameover_enterhighscores_init4
158+  AF69              gameover_enterhighscores_init3
159+  AF69 21 F3 84         ld hl,string_highscore_place2
160+  AF6C C3 6F AF         jp gameover_enterhighscores_init4
161+  AF6F              gameover_enterhighscores_init4
162+  AF6F CD 44 86         call string_print
163+  AF72
164+  AF72 06 60            ld b,96
165+  AF74 3E 42            ld a,66
166+  AF76 11 40 59         ld de,22528+320                         ; attrs here
167+  AF79 CD BA A9         call screen_setcolours
168+  AF7C
169+  AF7C 21 1D 85         ld hl,string_highscore_pleaseenter
170+  AF7F CD 44 86         call string_print
171+  AF82
172+  AF82 06 60            ld b,96
173+  AF84 3E 46            ld a,70
174+  AF86 11 E0 59         ld de,22528+480                         ; attrs here
175+  AF89 CD BA A9         call screen_setcolours
176+  AF8C C9               ret
177+  AF8D
178+  AF8D              ;
179+  AF8D              ; Initialises the screen
180+  AF8D              ;
181+  AF8D              gameover_init:
182+  AF8D              ; We want a black screen.
183+  AF8D 3E 47            ld a,71             ; white ink (7) on black paper (0),
184+  AF8F                                      ; bright (64).
185+  AF8F CD 49 81         call utilities_clearscreen
186+  AF92 32 8D 5C         ld (23693),a        ; set our screen colours.
187+  AF95 3E 00            ld a,0              ; 2 is the code for red.
188+  AF97 D3 FE            out (254),a         ; write to port 254.
189+  AF99 C9               ret
190+  AF9A
191+  AF9A              gameover_soundplayed:
192+  AF9A 00               defb 0
193+  AF9B
194+  AF9B              ;
195+  AF9B              ; Plays the sound if it hasn't already been played
196+  AF9B              ;
197+  AF9B              gameover_playsound:
198+  AF9B 3A 9A AF         ld a,(gameover_soundplayed)
199+  AF9E FE 01            cp 1
200+  AFA0 C8               ret z
201+  AFA1 CD C5 B1         call sound_gameover
202+  AFA4 3E 01            ld a,1
203+  AFA6 32 9A AF         ld (gameover_soundplayed),a
204+  AFA9 C9               ret
# file closed: screen/gameover.asm
132   AFAA                  include "screen\endlevel.asm"
# file opened: screen/endlevel.asm
  1+  AFAA              ;
  2+  AFAA              ; Draws the level transition screen
  3+  AFAA              ;
  4+  AFAA              endlevel_draw:
  5+  AFAA CD AB B0         call endlevel_init
  6+  AFAD CD 94 B0         call endlevel_commontext
  7+  AFB0
  8+  AFB0 21 A4 84         ld hl,string_highscore_congratulations
  9+  AFB3 CD 44 86         call string_print
 10+  AFB6
 11+  AFB6 3A 2E C5         ld a,(game_currentplayer)
 12+  AFB9 FE 01            cp 1
 13+  AFBB 21 B6 84         ld hl,string_highscore_player1
 14+  AFBE CA C4 AF         jp z, endlevel_init1
 15+  AFC1              endlevel_init0:
 16+  AFC1 21 C1 84         ld hl,string_highscore_player2
 17+  AFC4              endlevel_init1:
 18+  AFC4 CD 44 86         call string_print
 19+  AFC7
 20+  AFC7 21 3A 85         ld hl,string_endlevel_youhaveearned
 21+  AFCA CD 44 86         call string_print
 22+  AFCD
 23+  AFCD CD 33 B0         call endlevel_workoutbonus
 24+  AFD0 D5               push de
 25+  AFD1 08               ex af,af'                               ; store the a value for later
 26+  AFD2 CD 44 86         call string_print
 27+  AFD5 D1               pop de
 28+  AFD6 62 6B            ld hl,de                                ; get the points text into de
 29+  AFD8 CD 44 86         call string_print
 30+  AFDB
 31+  AFDB 21 A5 85         ld hl, string_endlevel_anothergo
 32+  AFDE CD 44 86         call string_print
 33+  AFE1
 34+  AFE1 06 20            ld b,32
 35+  AFE3 3E 23            ld a,35
 36+  AFE5 11 60 59         ld de,22528+352                         ; attrs here
 37+  AFE8 CD BA A9         call screen_setcolours
 38+  AFEB
 39+  AFEB 06 20            ld b,32
 40+  AFED 3E 25            ld a,37
 41+  AFEF 11 A0 59         ld de,22528+416                         ; attrs here
 42+  AFF2 CD BA A9         call screen_setcolours
 43+  AFF5
 44+  AFF5 06 20            ld b,32
 45+  AFF7 3E 23            ld a,35
 46+  AFF9 11 E0 59         ld de,22528+480                         ; attrs here
 47+  AFFC CD BA A9         call screen_setcolours
 48+  AFFF
 49+  AFFF 06 20            ld b,32
 50+  B001 3E 22            ld a,34
 51+  B003 11 40 5A         ld de,22528+576                         ; attrs here
 52+  B006 CD BA A9         call screen_setcolours
 53+  B009
 54+  B009 08               ex af,af'                               ; get back a value with bonus type
 55+  B00A 06 14            ld b,20
 56+  B00C CD 64 81         call utilities_pauseforframes
 57+  B00F
 58+  B00F 47               ld b,a                      ; put the bonus count in b
 59+  B010              endlevel_init2:
 60+  B010 C5               push bc
 61+  B011 06 01            ld b,1
 62+  B013 CD 8C CD         call scores_addthousands
 63+  B016 CD E2 B1         call sound_scoretick
 64+  B019 CD ED C6         call player_recordcurrentstate
 65+  B01C CD A3 CD         call scores_printscore     ; print the current scores
 66+  B01F 06 0A            ld b,10
 67+  B021 CD 64 81         call utilities_pauseforframes
 68+  B024 C1               pop bc
 69+  B025 10 E9            djnz endlevel_init2
 70+  B027
 71+  B027 CD D1 C5         call game_increasedifficulty ; move the difficulty up a level
 72+  B02A CD ED C6         call player_recordcurrentstate
 73+  B02D
 74+  B02D 3E 64            ld a,100                              ; wait for 200 frames
 75+  B02F CD 25 81         call utilities_waitforkey_forframes   ; wait for keypress
 76+  B032
 77+  B032 C9               ret
 78+  B033
 79+  B033              ;
 80+  B033              ; Works out the bonus
 81+  B033              ; Outputs:
 82+  B033              ; a = 15 (all seven)
 83+  B033              ; a = 10 (3 large or 4 small)
 84+  B033              ; a = 5 (1 large diamond)
 85+  B033              ; hl - pointer to bonus text
 86+  B033              ; de - pointer to points text
 87+  B033              ;
 88+  B033              endlevel_workoutbonus:
 89+  B033 21 EA B8         ld hl,level_diamonds+2     ; location of state of first diamond
 90+  B036 06 03            ld b,3                      ; number to check
 91+  B038 16 00            ld d,0                      ; zero diamond count
 92+  B03A              endlevel_workoutbonus0:
 93+  B03A 7E               ld a,(hl)                   ; get state
 94+  B03B FE 01            cp 1
 95+  B03D C2 41 B0         jp nz,endlevel_workoutbonus1 ; if not, move on
 96+  B040 14               inc d                       ; increment diamond count
 97+  B041              endlevel_workoutbonus1:
 98+  B041 23               inc hl
 99+  B042 23               inc hl
100+  B043 23               inc hl
101+  B044 23               inc hl
102+  B045 23               inc hl                      ; get to next state
103+  B046 10 F2            djnz endlevel_workoutbonus0
104+  B048
105+  B048 21 FA B8         ld hl,level_gems+2     ; location of state of first gem
106+  B04B 06 04            ld b,4                      ; number to check
107+  B04D 1E 00            ld e,0                      ; zero gem count
108+  B04F              endlevel_workoutbonus2:
109+  B04F 7E               ld a,(hl)                   ; get state
110+  B050 FE 01            cp 1
111+  B052 C2 56 B0         jp nz,endlevel_workoutbonus3 ; if not, move on
112+  B055 1C               inc e                       ; increment diamond count
113+  B056              endlevel_workoutbonus3:
114+  B056 23               inc hl
115+  B057 23               inc hl
116+  B058 23               inc hl
117+  B059 23               inc hl
118+  B05A 23               inc hl                     ; get to next state
119+  B05B 10 F2            djnz endlevel_workoutbonus2
120+  B05D
121+  B05D 7A               ld a,d
122+  B05E 83               add e
123+  B05F FE 07            cp 7                        ; check for max bonus
124+  B061 C2 6D B0         jp nz,endlevel_workoutbonus4 ;
125+  B064 3E 0F            ld a,15
126+  B066 21 6A 85         ld hl, string_endlevel_bonus3
127+  B069 11 96 85         ld de, string_endlevel_points3
128+  B06C C9               ret                         ; return with bonus of 15
129+  B06D              endlevel_workoutbonus4:
130+  B06D 7A               ld a,d                      ; check for for diamonds
131+  B06E FE 03            cp 3
132+  B070 C2 7C B0         jp nz,endlevel_workoutbonus5
133+  B073 3E 0A            ld a,10
134+  B075 21 5B 85         ld hl, string_endlevel_bonus2
135+  B078 11 87 85         ld de, string_endlevel_points2
136+  B07B C9               ret                         ; return with bonus of ten
137+  B07C              endlevel_workoutbonus5:
138+  B07C 7B               ld a,e                      ; check for four gems
139+  B07D FE 04            cp 4
140+  B07F C2 8B B0         jp nz,endlevel_workoutbonus6
141+  B082 3E 0A            ld a,10
142+  B084 21 5B 85         ld hl, string_endlevel_bonus2
143+  B087 11 87 85         ld de, string_endlevel_points2
144+  B08A C9               ret                         ; return with bonus of 10
145+  B08B              endlevel_workoutbonus6:
146+  B08B 3E 05            ld a,5                      ; otherwise, bonus is 5
147+  B08D 21 4C 85         ld hl, string_endlevel_bonus1
148+  B090 11 79 85         ld de, string_endlevel_points1
149+  B093 C9               ret
150+  B094
151+  B094              ;
152+  B094              ; Draws text shared by the game over and high score screens
153+  B094              ;
154+  B094              endlevel_commontext:
155+  B094 CD 7E A9         call screen_setuptext       ; show scores
156+  B097 CD E3 CD         call scores_printscores     ; print the current scores
157+  B09A
158+  B09A 21 84 84         ld hl,string_gameoverscreen_bestscores
159+  B09D CD 44 86         call string_print
160+  B0A0
161+  B0A0 06 20            ld b,32
162+  B0A2 3E 45            ld a,69
163+  B0A4 11 C0 5A         ld de,22528+704                         ; attrs here
164+  B0A7 CD BA A9         call screen_setcolours
165+  B0AA
166+  B0AA C9               ret
167+  B0AB
168+  B0AB              ;
169+  B0AB              ; Initialises the screen
170+  B0AB              ;
171+  B0AB              endlevel_init:
172+  B0AB              ; We want a green screen.
173+  B0AB 3E 21            ld a,33             ; white ink (7) on black paper (0),
174+  B0AD                                      ; bright (64).
175+  B0AD CD 49 81         call utilities_clearscreen
176+  B0B0 32 8D 5C         ld (23693),a        ; set our screen colours.
177+  B0B3 3E 00            ld a,0              ; 2 is the code for red.
178+  B0B5 D3 FE            out (254),a         ; write to port 254.
179+  B0B7 C9               ret
# file closed: screen/endlevel.asm
133   B0B8                  include "screen\options.asm"
# file opened: screen/options.asm
  1+  B0B8              ;
  2+  B0B8              ; Show the options screen
  3+  B0B8              ;
  4+  B0B8              options_show:
  5+  B0B8 CD 59 B1         call options_init
  6+  B0BB
  7+  B0BB 21 C0 85         ld hl,string_options_title
  8+  B0BE CD 44 86         call string_print
  9+  B0C1 21 CA 85         ld hl,string_options_1player
 10+  B0C4 CD 44 86         call string_print
 11+  B0C7 21 DA 85         ld hl,string_options_2player
 12+  B0CA CD 44 86         call string_print
 13+  B0CD 21 EA 85         ld hl,string_options_keyboard
 14+  B0D0 CD 44 86         call string_print
 15+  B0D3 21 FD 85         ld hl,string_options_joystick
 16+  B0D6 CD 44 86         call string_print
 17+  B0D9 21 0B 86         ld hl,string_options_start
 18+  B0DC CD 44 86         call string_print
 19+  B0DF 21 16 86         ld hl,string_options_vanity
 20+  B0E2 CD 44 86         call string_print
 21+  B0E5
 22+  B0E5 3A 2D C5         ld a,(game_numberplayers)
 23+  B0E8 FE 01            cp 1
 24+  B0EA C2 F3 B0         jp nz,options_show0
 25+  B0ED 11 C9 58         ld de,22528+201                         ; top row attrs here
 26+  B0F0 C3 F6 B0         jp options_show1
 27+  B0F3              options_show0:
 28+  B0F3 11 E9 58         ld de,22528+233                         ; top row attrs here
 29+  B0F6              options_show1:
 30+  B0F6 06 10            ld b,16
 31+  B0F8 3E C7            ld a,199
 32+  B0FA CD BA A9         call screen_setcolours                  ; highlight current player
 33+  B0FD
 34+  B0FD 3A 31 C5         ld a,(game_control)
 35+  B100 FE 00            cp 0
 36+  B102 C2 0B B1         jp nz,options_show6
 37+  B105 11 09 59         ld de,22528+265                         ; top row attrs here
 38+  B108 C3 0E B1         jp options_show7
 39+  B10B              options_show6:
 40+  B10B 11 29 59         ld de,22528+297                         ; top row attrs here
 41+  B10E              options_show7:
 42+  B10E 06 10            ld b,16
 43+  B110 3E C7            ld a,199
 44+  B112 CD BA A9         call screen_setcolours                  ; highlight current control
 45+  B115              options_show8:
 46+  B115 CD 68 81         call utilities_readkey
 47+  B118 FE 31            cp 49                                   ; was 1 pressed
 48+  B11A C2 25 B1         jp nz,options_show2
 49+  B11D 21 2D C5         ld hl,game_numberplayers
 50+  B120 36 01            ld (hl),1
 51+  B122 C3 53 B1         jp options_show9
 52+  B125              options_show2:
 53+  B125 FE 32            cp 50                                   ; was 2 pressed
 54+  B127 C2 32 B1         jp nz,options_show3
 55+  B12A 21 2D C5         ld hl,game_numberplayers
 56+  B12D 36 02            ld (hl),2
 57+  B12F C3 53 B1         jp options_show9
 58+  B132              options_show3:
 59+  B132 FE 33            cp 51                                   ; was 3 pressed
 60+  B134 C2 3F B1         jp nz,options_show4
 61+  B137 21 31 C5         ld hl,game_control
 62+  B13A 36 00            ld (hl),0
 63+  B13C C3 53 B1         jp options_show9
 64+  B13F              options_show4:
 65+  B13F FE 34            cp 52                                   ; was 4 pressed
 66+  B141 C2 4C B1         jp nz,options_show5
 67+  B144 21 31 C5         ld hl,game_control
 68+  B147 36 01            ld (hl),1
 69+  B149 C3 53 B1         jp options_show9
 70+  B14C              options_show5:
 71+  B14C FE 35            cp 53                                   ; was 5 pressed
 72+  B14E C8               ret z                                   ; exit if so
 73+  B14F C3 15 B1         jp options_show8                         ; otherwise, jump to top
 74+  B152 C9               ret
 75+  B153              options_show9:
 76+  B153 CD 11 B2         call sound_gemcollected
 77+  B156 C3 B8 B0         jp options_show
 78+  B159
 79+  B159              ;
 80+  B159              ; Initialise the options screen
 81+  B159              ;
 82+  B159              options_init:
 83+  B159 3E 47            ld a,71             ; white ink (7) on black paper (0),
 84+  B15B                                      ; bright (64).
 85+  B15B CD 49 81         call utilities_clearscreen
 86+  B15E 32 8D 5C         ld (23693),a        ; set our screen colours.
 87+  B161 3E 00            ld a,0              ; 2 is the code for red.
 88+  B163 D3 FE            out (254),a         ; write to port 254.
 89+  B165
 90+  B165 C9               ret
 91+  B166 C9               ret
# file closed: screen/options.asm
134   B167
135   B167                  include "sound\sound.asm"
# file opened: sound/sound.asm
  1+  B167
  2+  B167
  3+  B167              ;
  4+  B167              ; Plays a note
  5+  B167              ; Inputs:
  6+  B167              ; d - border
  7+  B167              ; e - pitch
  8+  B167              ; bc - duration
  9+  B167              sound_play:
 10+  B167 7B               ld a,e
 11+  B168 32 72 B1         ld (sound_play2+1),a
 12+  B16B 7A           	ld a,d
 13+  B16C              sound_play0:
 14+  B16C D3 FE            out (254),a
 15+  B16E 1D               dec e
 16+  B16F 20 04            jr nz,sound_play1
 17+  B171              sound_play2:
 18+  B171 1E 00            ld e,0
 19+  B173 EE 18            xor 24
 20+  B175              sound_play1:
 21+  B175 10 F5            djnz sound_play0
 22+  B177 0D               dec c
 23+  B178 20 F2            jr nz,sound_play0
 24+  B17A C9               ret
 25+  B17B
 26+  B17B              sound_gamestart:
 27+  B17B F3               di
 28+  B17C 06 03            ld b,3
 29+  B17E              sound_gamestart0:
 30+  B17E C5               push bc
 31+  B17F 1E 36            ld e,54
 32+  B181 01 4B 00         ld bc,75
 33+  B184 16 02            ld d,2
 34+  B186 CD 67 B1         call sound_play
 35+  B189 1E 4C            ld e,76
 36+  B18B 01 4B 00         ld bc,75
 37+  B18E 16 02            ld d,2
 38+  B190 CD 67 B1         call sound_play
 39+  B193 C1               pop bc
 40+  B194 10 E8            djnz sound_gamestart0
 41+  B196 FB               ei
 42+  B197 C9               ret
 43+  B198
 44+  B198              sound_lifestart:
 45+  B198 F3               di
 46+  B199 06 03            ld b,3
 47+  B19B              sound_lifestart0:
 48+  B19B C5               push bc
 49+  B19C 1E 2D            ld e,45
 50+  B19E 01 20 00         ld bc,32
 51+  B1A1 16 01            ld d,1
 52+  B1A3 CD 67 B1         call sound_play
 53+  B1A6 1E 41            ld e,65
 54+  B1A8 01 20 00         ld bc,32
 55+  B1AB 16 01            ld d,1
 56+  B1AD CD 67 B1         call sound_play
 57+  B1B0 1E 2D            ld e,45
 58+  B1B2 01 20 00         ld bc,32
 59+  B1B5 CD 67 B1         call sound_play
 60+  B1B8 1E 41            ld e,65
 61+  B1BA 01 20 00         ld bc,32
 62+  B1BD CD 67 B1         call sound_play
 63+  B1C0 C1               pop bc
 64+  B1C1 10 D8            djnz sound_lifestart0
 65+  B1C3 FB               ei
 66+  B1C4 C9               ret
 67+  B1C5
 68+  B1C5              sound_gameover:
 69+  B1C5 F3               di
 70+  B1C6 06 0A            ld b,10
 71+  B1C8 1E 28            ld e,40
 72+  B1CA              sound_gameover0:
 73+  B1CA C5               push bc
 74+  B1CB D5               push de
 75+  B1CC F5               push af
 76+  B1CD 01 20 00         ld bc,32
 77+  B1D0 16 00            ld d,0
 78+  B1D2 CD 67 B1         call sound_play
 79+  B1D5 F1               pop af
 80+  B1D6 D1               pop de
 81+  B1D7 3E 0A            ld a,10
 82+  B1D9 83               add e
 83+  B1DA 5F               ld e,a
 84+  B1DB C6 04            add 4
 85+  B1DD C1               pop bc
 86+  B1DE 10 EA            djnz sound_gameover0
 87+  B1E0 FB               ei
 88+  B1E1 C9               ret
 89+  B1E2
 90+  B1E2              sound_scoretick:
 91+  B1E2 F3               di
 92+  B1E3 1E 23            ld e,35
 93+  B1E5 01 18 00         ld bc,24
 94+  B1E8 16 00            ld d,0
 95+  B1EA CD 67 B1         call sound_play
 96+  B1ED FB               ei
 97+  B1EE C9               ret
 98+  B1EF
 99+  B1EF              sound_tankalarm:
100+  B1EF F3               di
101+  B1F0 1E 19            ld e,25
102+  B1F2 01 18 00         ld bc,24
103+  B1F5 16 00            ld d,0
104+  B1F7 CD 67 B1         call sound_play
105+  B1FA FB               ei
106+  B1FB C9               ret
107+  B1FC
108+  B1FC              sound_laser:
109+  B1FC 16 10        	ld d,16		            ;speaker = bit 4
110+  B1FE 1E 00        	ld e,0		            ;distance between speaker move counter
111+  B200 06 80        	ld b,128	            ;overall length counter
112+  B202              sound_laser0:
113+  B202 7A               ld a,d
114+  B203 E6 F8        	and 248		            ;keep border colour the same
115+  B205 D3 FE        	out (254),a	            ;move the speaker in or out depending on bit 4
116+  B207 2F           	cpl		                ;toggle, so we alternative between speaker in and out to make sound
117+  B208 57           	ld d,a		            ;store it
118+  B209 4B           	ld c,e		            ;now a pause
119+  B20A              sound_laser1:
120+  B20A 0D               dec c
121+  B20B 20 FD        	jr nz,sound_laser1
122+  B20D 1D           	dec e		            ;change to inc e to reverse the sound, or remove to make it a note
123+  B20E 10 F2        	djnz sound_laser0	;repeat B=255 times
124+  B210 C9           	ret
125+  B211
126+  B211              sound_gemcollected:
127+  B211 16 10        	ld d,16		            ;speaker = bit 4
128+  B213 1E 00        	ld e,0		            ;distance between speaker move counter
129+  B215 06 80        	ld b,128	            ;overall length counter
130+  B217              sound_gemcollected0:
131+  B217 7A               ld a,d
132+  B218 E6 F8        	and 248		            ;keep border colour the same
133+  B21A D3 FE        	out (254),a	            ;move the speaker in or out depending on bit 4
134+  B21C 2F           	cpl		                ;toggle, so we alternative between speaker in and out to make sound
135+  B21D 57           	ld d,a		            ;store it
136+  B21E 4B           	ld c,e		            ;now a pause
137+  B21F              sound_gemcollected1:
138+  B21F 0D               dec c
139+  B220 20 FD        	jr nz,sound_gemcollected1
140+  B222 1C           	inc e		            ;change to inc e to reverse the sound, or remove to make it a note
141+  B223 10 F2        	djnz sound_gemcollected0	;repeat B=255 times
142+  B225 C9           	ret
143+  B226
144+  B226              sound_pitchbend:
145+  B226 21 F4 01         ld hl,500 ; starting pitch.
146+  B229 06 FA            ld b,250 ; length of pitch bend.
147+  B22B              sound_pitchbend0:
148+  B22B C5                push bc
149+  B22C E5               push hl ; store pitch.
150+  B22D 11 01 00         ld de,1 ; very short duration.
151+  B230 CD B5 03         call 949 ; ROM beeper routine.
152+  B233 E1               pop hl ; restore pitch.
153+  B234 23               inc hl ; pitch going up.
154+  B235 C1               pop bc
155+  B236 10 F3            djnz sound_pitchbend0 ; repeat.
156+  B238 C9               ret
157+  B239
158+  B239              sound_pitchbenddown:
159+  B239 21 EE 02         ld hl,750 ; starting pitch.
160+  B23C 06 FA            ld b,250 ; length of pitch bend.
161+  B23E              sound_pitchbenddown0:
162+  B23E C5               push bc
163+  B23F E5               push hl ; store pitch.
164+  B240 11 01 00         ld de,1 ; very short duration.
165+  B243 CD B5 03         call 949 ; ROM beeper routine.
166+  B246 E1               pop hl ; restore pitch.
167+  B247 2B               dec hl ; pitch going down.
168+  B248 C1               pop bc
169+  B249 10 F3            djnz sound_pitchbenddown0 ; repeat.
170+  B24B C9               ret
171+  B24C
172+  B24C              sound_rockfell:
173+  B24C 08               ex af,af'
174+  B24D 1E 32            ld e,50 ; repeat 250 times.
175+  B24F 21 00 00         ld hl,0 ; start pointer in ROM.
176+  B252              sound_rockfell2
177+  B252 D5               push de
178+  B253 06 20            ld b,32 ; length of step.
179+  B255 C5           sound_rockfell0 push bc
180+  B256 7E               ld a,(hl) ; next "random" number.
181+  B257 23               inc hl ; pointer.
182+  B258 E6 F8            and 248 ; we want a black border.
183+  B25A D3 FE            out (254),a ; write to speaker.
184+  B25C 7B               ld a,e ; as e gets smaller...
185+  B25D 2F               cpl ; ...we increase the delay.
186+  B25E 3D           sound_rockfell1 dec a ; decrement loop counter.
187+  B25F 20 FD            jr nz,sound_rockfell1 ; delay loop.
188+  B261 C1               pop bc
189+  B262 10 F1            djnz sound_rockfell0 ; next step.
190+  B264 D1               pop de
191+  B265 7B               ld a,e
192+  B266 D6 18            sub 24 ; size of step.
193+  B268 FE 1E            cp 30 ; end of range.
194+  B26A CA 7B B2         jp z,sound_rockfell5
195+  B26D DA 7B B2         jp c, sound_rockfell5
196+  B270 5F               ld e,a
197+  B271 2F               cpl
198+  B272 06 28        sound_rockfell3 ld b,40 ; silent period.
199+  B274 10 FE        sound_rockfell4 djnz sound_rockfell4
200+  B276 3D               dec a
201+  B277 20 F9            jr nz,sound_rockfell3
202+  B279 18 D7            jr sound_rockfell2
203+  B27B              sound_rockfell5
204+  B27B 08               ex af,af'
205+  B27C C9               ret
206+  B27D
207+  B27D              sound_tankshoot:
208+  B27D 08               ex af,af'
209+  B27E 1E 32            ld e,50 ; repeat 250 times.
210+  B280 21 00 00         ld hl,0 ; start pointer in ROM.
211+  B283              sound_tankshoot2
212+  B283 D5               push de
213+  B284 06 10            ld b,16 ; length of step.
214+  B286 C5           sound_tankshoot0 push bc
215+  B287 7E               ld a,(hl) ; next "random" number.
216+  B288 23               inc hl ; pointer.
217+  B289 E6 F8            and 248 ; we want a black border.
218+  B28B D3 FE            out (254),a ; write to speaker.
219+  B28D 7B               ld a,e ; as e gets smaller...
220+  B28E 2F               cpl ; ...we increase the delay.
221+  B28F 3D           sound_tankshoot1 dec a ; decrement loop counter.
222+  B290 20 FD            jr nz,sound_tankshoot1 ; delay loop.
223+  B292 C1               pop bc
224+  B293 10 F1            djnz sound_tankshoot0 ; next step.
225+  B295 D1               pop de
226+  B296 7B               ld a,e
227+  B297 D6 18            sub 24 ; size of step.
228+  B299 FE 1E            cp 30 ; end of range.
229+  B29B CA AC B2         jp z,sound_tankshoot5
230+  B29E DA AC B2         jp c, sound_tankshoot5
231+  B2A1 5F               ld e,a
232+  B2A2 2F               cpl
233+  B2A3 06 28        sound_tankshoot3 ld b,40 ; silent period.
234+  B2A5 10 FE        sound_tankshoot4 djnz sound_tankshoot4
235+  B2A7 3D               dec a
236+  B2A8 20 F9            jr nz,sound_tankshoot3
237+  B2AA 18 D7            jr sound_tankshoot2
238+  B2AC              sound_tankshoot5
239+  B2AC 08               ex af,af'
240+  B2AD C9               ret
241+  B2AE
242+  B2AE              ; Call this every time you want to initialise a sound effect
243+  B2AE              ; A = Variable 1
244+  B2AE              ; B = Variable 2
245+  B2AE              ; C = Duration of overall sound effect
246+  B2AE              ; D = Duration of each step of the sound effect
247+  B2AE              ;
248+  B2AE              soundfx_a_init:
249+  B2AE 32 D5 B2         ld (soundfx_a_v2+1),a
250+  B2B1 78               ld a,b
251+  B2B2 32 DE B2         ld (soundfx_a_v3+1),a
252+  B2B5 79               ld a,c
253+  B2B6 32 C3 B2         ld (soundfx_a_main+1),a
254+  B2B9 7A               ld a,d
255+  B2BA 32 CA B2         ld (soundfx_a_v1+1),a
256+  B2BD AF               xor a
257+  B2BE 32 E7 B2         ld (soundfx_a_v4),a
258+  B2C1 C9               ret
259+  B2C2
260+  B2C2              ; Call this during your main loop
261+  B2C2              ; It will play one step of the sound effect each pass
262+  B2C2              ; until the complete sound effect has finished
263+  B2C2              ;
264+  B2C2              soundfx_a_main:
265+  B2C2 3E 00            ld a,0
266+  B2C4 3D               dec a
267+  B2C5 C8               ret z
268+  B2C6 32 C3 B2         ld (soundfx_a_main+1),a
269+  B2C9              soundfx_a_v1:
270+  B2C9 06 00            ld b,0
271+  B2CB 21 E7 B2         ld hl,soundfx_a_v4
272+  B2CE              soundfx_a_l1:
273+  B2CE 48               ld c,b
274+  B2CF 3E 08            ld a,%00001000
275+  B2D1 D3 FE            out (254),a
276+  B2D3 7E               ld a,(hl)
277+  B2D4              soundfx_a_v2:
278+  B2D4 EE 00            xor 0
279+  B2D6 47               ld b,a
280+  B2D7 10 FE            djnz $
281+  B2D9 AF               xor a
282+  B2DA D3 FE            out (254),a
283+  B2DC 7E               ld a,(hl)
284+  B2DD              soundfx_a_v3:
285+  B2DD EE 00            xor 0
286+  B2DF 47               ld b,a
287+  B2E0 10 FE            djnz $
288+  B2E2 35               dec (hl)
289+  B2E3 41               ld b,c
290+  B2E4 10 E8            djnz soundfx_a_l1
291+  B2E6 C9               ret
292+  B2E7
293+  B2E7              soundfx_a_v4:
294+  B2E7 00               defb 0
# file closed: sound/sound.asm
136   B2E8
137   B2E8                  include "leveldata\level.asm"
# file opened: leveldata/level.asm
  1+  B2E8              ; ###############################################################
  2+  B2E8              ; Data for level 1
  3+  B2E8              ; ###############################################################
  4+  B2E8              level_layout:
  5+  B2E8
  6+  B2E8                  ;defb 09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09,09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09
  7+  B2E8
  8+  B2E8 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,05,05,02,01,01,01,03,05,05,05,05,05,05,05,05,05,05,05,00,00
  8+  B2EC 05 05 05 05
  8+  B2F0 05 05 05 05
  8+  B2F4 05 05 02 01
  8+  B2F8 01 01 03 05
  8+  B2FC 05 05 05 05
  8+  B300 05 05 05 05
  8+  B304 05 05 00 00
  9+  B308 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,03,05,05,05,05,05,05,05,05,05,00,00
  9+  B30C 05 05 05 05
  9+  B310 05 05 05 05
  9+  B314 02 01 01 01
  9+  B318 01 01 01 01
  9+  B31C 03 05 05 05
  9+  B320 05 05 05 05
  9+  B324 05 05 00 00
 10+  B328 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,01,01,01,01,03,05,13,13,13,13,13,13,00,00
 10+  B32C 05 05 05 05
 10+  B330 05 05 02 01
 10+  B334 01 01 01 01
 10+  B338 01 01 01 01
 10+  B33C 01 01 03 05
 10+  B340 0D 0D 0D 0D
 10+  B344 0D 0D 00 00
 11+  B348 00 00 01 01      defb 00,00,01,01,01,01,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,03,05,05,05,05,05,05,00,00
 11+  B34C 01 01 00 01
 11+  B350 01 01 01 01
 11+  B354 01 01 01 01
 11+  B358 01 01 01 01
 11+  B35C 01 01 01 03
 11+  B360 05 05 05 05
 11+  B364 05 05 00 00
 12+  B368 00 00 01 01      defb 00,00,01,01,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,01,00,00
 12+  B36C 04 04 04 04
 12+  B370 04 04 01 01
 12+  B374 01 01 01 01
 12+  B378 01 01 01 01
 12+  B37C 01 01 01 01
 12+  B380 01 01 01 01
 12+  B384 00 01 00 00
 13+  B388 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,01,00,00
 13+  B38C 04 04 04 04
 13+  B390 04 04 04 04
 13+  B394 01 01 01 01
 13+  B398 01 01 01 01
 13+  B39C 01 01 01 01
 13+  B3A0 00 00 00 00
 13+  B3A4 00 01 00 00
 14+  B3A8 00 00 01 04      defb 00,00,01,04,04,01,01,01,01,01,04,04,04,04,01,01,01,01,01,01,01,00,00,00,00,01,01,01,01,01,00,00
 14+  B3AC 04 01 01 01
 14+  B3B0 01 01 04 04
 14+  B3B4 04 04 01 01
 14+  B3B8 01 01 01 01
 14+  B3BC 01 00 00 00
 14+  B3C0 00 01 01 01
 14+  B3C4 01 01 00 00
 15+  B3C8 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,01,04,04,04,04,04,04,04,04,00,00,00,00,04,04,04,04,04,04,04,01,00,00
 15+  B3CC 04 04 04 04
 15+  B3D0 04 01 04 04
 15+  B3D4 04 04 04 04
 15+  B3D8 04 04 00 00
 15+  B3DC 00 00 04 04
 15+  B3E0 04 04 04 04
 15+  B3E4 04 01 00 00
 16+  B3E8 00 00 01 01      defb 00,00,01,01,01,04,01,01,01,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 16+  B3EC 01 04 01 01
 16+  B3F0 01 01 04 04
 16+  B3F4 04 04 04 04
 16+  B3F8 04 04 00 04
 16+  B3FC 04 04 04 04
 16+  B400 04 04 04 04
 16+  B404 04 01 00 00
 17+  B408 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 17+  B40C 00 00 00 00
 17+  B410 00 04 04 04
 17+  B414 04 04 04 04
 17+  B418 04 04 00 04
 17+  B41C 04 04 04 04
 17+  B420 04 04 04 04
 17+  B424 04 01 00 00
 18+  B428 00 00 01 15      defb 00,00,01,21,21,21,21,21,21,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 18+  B42C 15 15 15 15
 18+  B430 15 01 04 04
 18+  B434 04 04 04 04
 18+  B438 04 04 00 04
 18+  B43C 04 04 04 04
 18+  B440 04 04 04 04
 18+  B444 04 01 00 00
 19+  B448 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,00,00,00,01,00,00
 19+  B44C 00 00 00 00
 19+  B450 00 01 04 04
 19+  B454 04 04 04 04
 19+  B458 04 04 00 04
 19+  B45C 04 04 04 04
 19+  B460 04 00 00 00
 19+  B464 00 01 00 00
 20+  B468 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 20+  B46C 00 00 00 00
 20+  B470 00 01 04 04
 20+  B474 04 04 04 04
 20+  B478 04 04 00 04
 20+  B47C 04 04 04 04
 20+  B480 04 00 04 04
 20+  B484 00 01 00 00
 21+  B488 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 21+  B48C 06 06 06 06
 21+  B490 06 01 04 04
 21+  B494 04 04 04 04
 21+  B498 04 04 00 04
 21+  B49C 04 04 04 04
 21+  B4A0 04 00 04 04
 21+  B4A4 00 01 00 00
 22+  B4A8 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,04,00,01,00,00
 22+  B4AC 1A 1A 1A 1A
 22+  B4B0 1A 01 04 00
 22+  B4B4 00 00 00 00
 22+  B4B8 00 00 00 00
 22+  B4BC 00 00 00 00
 22+  B4C0 00 00 04 04
 22+  B4C4 00 01 00 00
 23+  B4C8 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 23+  B4CC 1A 1A 1A 1A
 23+  B4D0 1A 01 04 00
 23+  B4D4 04 04 04 04
 23+  B4D8 04 04 00 04
 23+  B4DC 04 04 00 04
 23+  B4E0 04 04 04 04
 23+  B4E4 00 01 00 00
 24+  B4E8 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 24+  B4EC 1A 1A 1A 1A
 24+  B4F0 1A 01 04 00
 24+  B4F4 04 04 04 04
 24+  B4F8 04 04 00 04
 24+  B4FC 04 04 00 04
 24+  B500 04 04 04 04
 24+  B504 00 01 00 00
 25+  B508 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 25+  B50C 01 01 01 01
 25+  B510 01 01 04 00
 25+  B514 04 04 04 04
 25+  B518 04 04 00 04
 25+  B51C 04 04 00 04
 25+  B520 04 04 04 04
 25+  B524 00 01 00 00
 26+  B528 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,00,00,00,00,04,04,04,01,00,00
 26+  B52C 04 04 04 04
 26+  B530 04 04 04 00
 26+  B534 04 04 04 04
 26+  B538 04 04 00 04
 26+  B53C 04 04 00 00
 26+  B540 00 00 04 04
 26+  B544 04 01 00 00
 27+  B548 00 00 01 04      defb 00,00,01,04,04,04,00,00,00,00,00,00,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 27+  B54C 04 04 00 00
 27+  B550 00 00 00 00
 27+  B554 04 04 04 04
 27+  B558 04 04 00 04
 27+  B55C 04 04 04 04
 27+  B560 04 00 04 04
 27+  B564 04 01 00 00
 28+  B568 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 28+  B56C 04 04 00 04
 28+  B570 04 04 04 04
 28+  B574 04 04 04 04
 28+  B578 04 04 00 04
 28+  B57C 04 04 04 04
 28+  B580 04 00 04 04
 28+  B584 04 01 00 00
 29+  B588 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,04,00,04,04,04,01,00,00
 29+  B58C 04 04 00 04
 29+  B590 04 04 01 01
 29+  B594 01 01 01 01
 29+  B598 01 01 01 01
 29+  B59C 01 01 01 01
 29+  B5A0 04 00 04 04
 29+  B5A4 04 01 00 00
 30+  B5A8 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 30+  B5AC 04 04 00 04
 30+  B5B0 04 04 01 00
 30+  B5B4 00 00 00 00
 30+  B5B8 00 00 00 00
 30+  B5BC 00 00 00 01
 30+  B5C0 04 00 04 04
 30+  B5C4 04 01 00 00
 31+  B5C8 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 31+  B5CC 04 04 00 04
 31+  B5D0 04 04 01 00
 31+  B5D4 00 00 00 00
 31+  B5D8 00 00 00 00
 31+  B5DC 00 00 00 01
 31+  B5E0 04 00 04 04
 31+  B5E4 04 01 00 00
 32+  B5E8 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 32+  B5EC 04 04 00 04
 32+  B5F0 04 04 01 00
 32+  B5F4 00 00 00 00
 32+  B5F8 00 00 00 00
 32+  B5FC 00 00 00 01
 32+  B600 04 00 04 04
 32+  B604 04 01 00 00
 33+  B608 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,00,00,00,00,00,00,00,00,00,00,00,00,04,04,04,04,04,04,01,00,00
 33+  B60C 04 04 00 04
 33+  B610 04 04 04 00
 33+  B614 00 00 00 00
 33+  B618 00 00 00 00
 33+  B61C 00 00 00 04
 33+  B620 04 04 04 04
 33+  B624 04 01 00 00
 34+  B628 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,04,04,04,04,01,00,00
 34+  B62C 04 04 04 04
 34+  B630 04 04 01 00
 34+  B634 00 00 00 00
 34+  B638 00 00 00 00
 34+  B63C 00 00 00 01
 34+  B640 04 04 04 04
 34+  B644 04 01 00 00
 35+  B648 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,01,00,00,00,00,01,00,00,00,01,04,04,04,04,04,01,00,00
 35+  B64C 04 04 04 04
 35+  B650 04 04 01 00
 35+  B654 00 00 01 00
 35+  B658 00 00 00 01
 35+  B65C 00 00 00 01
 35+  B660 04 04 04 04
 35+  B664 04 01 00 00
 36+  B668 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00
 36+  B66C 01 01 01 01
 36+  B670 01 01 01 01
 36+  B674 01 01 01 01
 36+  B678 01 01 01 01
 36+  B67C 01 01 01 01
 36+  B680 01 01 01 01
 36+  B684 01 01 00 00
 37+  B688
 38+  B688              ; ###############################################################
 39+  B688              ; Object data: horiz, vert, state, memh, meml
 40+  B688              ; ###############################################################
 41+  B688              level_rocks:
 42+  B688 09 04 00 00      defb 9,4,0,0,0
 42+  B68C 00
 43+  B68D 0C 07 00 00      defb 12,7,0,0,0
 43+  B691 00
 44+  B692 10 07 00 00      defb 16,7,0,0,0
 44+  B696 00
 45+  B697 0B 08 00 00      defb 11,8,0,0,0
 45+  B69B 00
 46+  B69C 0A 0A 00 00      defb 10,10,0,0,0
 46+  B6A0 00
 47+  B6A1 0C 0A 00 00      defb 12,10,0,0,0
 47+  B6A5 00
 48+  B6A6 0D 09 00 00      defb 13,9,0,0,0
 48+  B6AA 00
 49+  B6AB 0E 08 00 00      defb 14,8,0,0,0
 49+  B6AF 00
 50+  B6B0 0F 0B 00 00      defb 15,11,0,0,0
 50+  B6B4 00
 51+  B6B5 0B 0C 00 00      defb 11,12,0,0,0
 51+  B6B9 00
 52+  B6BA 11 0C 00 00      defb 17,12,0,0,0
 52+  B6BE 00
 53+  B6BF 13 08 00 00      defb 19,8,0,0,0
 53+  B6C3 00
 54+  B6C4 16 09 00 00      defb 22,9,0,0,0
 54+  B6C8 00
 55+  B6C9 13 0A 00 00      defb 19,10,0,0,0
 55+  B6CD 00
 56+  B6CE 15 0A 00 00      defb 21,10,0,0,0
 56+  B6D2 00
 57+  B6D3 15 0C 00 00      defb 21,12,0,0,0
 57+  B6D7 00
 58+  B6D8 16 0C 00 00      defb 22,12,0,0,0
 58+  B6DC 00
 59+  B6DD 18 0A 00 00      defb 24,10,0,0,0
 59+  B6E1 00
 60+  B6E2 19 09 00 00      defb 25,9,0,0,0
 60+  B6E6 00
 61+  B6E7 1C 09 00 00      defb 28,9,0,0,0
 61+  B6EB 00
 62+  B6EC 1B 0C 00 00      defb 27,12,0,0,0
 62+  B6F0 00
 63+  B6F1 1A 0D 00 00      defb 26,13,0,0,0
 63+  B6F5 00
 64+  B6F6 19 0E 00 00      defb 25,14,0,0,0
 64+  B6FA 00
 65+  B6FB 19 10 00 00      defb 25,16,0,0,0
 65+  B6FF 00
 66+  B700 1A 11 00 00      defb 26,17,0,0,0
 66+  B704 00
 67+  B705 1B 11 00 00      defb 27,17,0,0,0
 67+  B709 00
 68+  B70A 1C 12 00 00      defb 28,18,0,0,0
 68+  B70E 00
 69+  B70F 1A 13 00 00      defb 26,19,0,0,0
 69+  B713 00
 70+  B714 1B 15 00 00      defb 27,21,0,0,0
 70+  B718 00
 71+  B719 1A 17 00 00      defb 26,23,0,0,0
 71+  B71D 00
 72+  B71E 1B 18 00 00      defb 27,24,0,0,0
 72+  B722 00
 73+  B723 19 18 00 00      defb 25,24,0,0,0
 73+  B727 00
 74+  B728 18 17 00 00      defb 24,23,0,0,0
 74+  B72C 00
 75+  B72D 13 14 00 00      defb 19,20,0,0,0
 75+  B731 00
 76+  B732 14 12 00 00      defb 20,18,0,0,0
 76+  B736 00
 77+  B737 14 10 00 00      defb 20,16,0,0,0
 77+  B73B 00
 78+  B73C 15 10 00 00      defb 21,16,0,0,0
 78+  B740 00
 79+  B741 16 12 00 00      defb 22,18,0,0,0
 79+  B745 00
 80+  B746 11 14 00 00      defb 17,20,0,0,0
 80+  B74A 00
 81+  B74B 0D 11 00 00      defb 13,17,0,0,0
 81+  B74F 00
 82+  B750 0C 13 00 00      defb 12,19,0,0,0
 82+  B754 00
 83+  B755 0B 13 00 00      defb 11,19,0,0,0
 83+  B759 00
 84+  B75A 0A 11 00 00      defb 10,17,0,0,0
 84+  B75E 00
 85+  B75F 05 12 00 00      defb 5,18,0,0,0
 85+  B763 00
 86+  B764 07 16 00 00      defb 7,22,0,0,0
 86+  B768 00
 87+  B769 09 16 00 00      defb 9,22,0,0,0
 87+  B76D 00
 88+  B76E 07 18 00 00      defb 7,24,0,0,0
 88+  B772 00
 89+  B773 05 18 00 00      defb 5,24,0,0,0
 89+  B777 00
 90+  B778 06 19 00 00      defb 6,25,0,0,0
 90+  B77C 00
 91+  B77D 08 19 00 00      defb 8,25,0,0,0
 91+  B781 00
 92+  B782 04 17 00 00      defb 4,23,0,0,0
 92+  B786 00
 93+  B787 FF               defb 255
 94+  B788
 95+  B788              level_rocks_alt:
 96+  B788 09 04 00 00      defb 9,4,0,0,0
 96+  B78C 00
 97+  B78D 0C 07 00 00      defb 12,7,0,0,0
 97+  B791 00
 98+  B792 0B 07 00 00      defb 11,7,0,0,0
 98+  B796 00
 99+  B797 0A 08 00 00      defb 10,8,0,0,0
 99+  B79B 00
100+  B79C 10 07 00 00      defb 16,7,0,0,0
100+  B7A0 00
101+  B7A1 0E 08 00 00      defb 14,8,0,0,0
101+  B7A5 00
102+  B7A6 0D 09 00 00      defb 13,9,0,0,0
102+  B7AA 00
103+  B7AB 0C 0A 00 00      defb 12,10,0,0,0
103+  B7AF 00
104+  B7B0 0A 0B 00 00      defb 10,11,0,0,0
104+  B7B4 00
105+  B7B5 0B 0C 00 00      defb 11,12,0,0,0
105+  B7B9 00
106+  B7BA 0F 0B 00 00      defb 15,11,0,0,0
106+  B7BE 00
107+  B7BF 11 0C 00 00      defb 17,12,0,0,0
107+  B7C3 00
108+  B7C4 15 0B 00 00      defb 21,11,0,0,0
108+  B7C8 00
109+  B7C9 16 0C 00 00      defb 22,12,0,0,0
109+  B7CD 00
110+  B7CE 19 09 00 00      defb 25,9,0,0,0
110+  B7D2 00
111+  B7D3 1C 09 00 00      defb 28,9,0,0,0
111+  B7D7 00
112+  B7D8 1B 0C 00 00      defb 27,12,0,0,0
112+  B7DC 00
113+  B7DD 1B 0E 00 00      defb 27,14,0,0,0
113+  B7E1 00
114+  B7E2 1A 0F 00 00      defb 26,15,0,0,0
114+  B7E6 00
115+  B7E7 1B 10 00 00      defb 27,16,0,0,0
115+  B7EB 00
116+  B7EC 1C 12 00 00      defb 28,18,0,0,0
116+  B7F0 00
117+  B7F1 1A 13 00 00      defb 26,19,0,0,0
117+  B7F5 00
118+  B7F6 1A 15 00 00      defb 26,21,0,0,0
118+  B7FA 00
119+  B7FB 1B 17 00 00      defb 27,23,0,0,0
119+  B7FF 00
120+  B800 1A 17 00 00      defb 26,23,0,0,0
120+  B804 00
121+  B805 19 18 00 00      defb 25,24,0,0,0
121+  B809 00
122+  B80A 18 17 00 00      defb 24,23,0,0,0
122+  B80E 00
123+  B80F 17 10 00 00      defb 23,16,0,0,0
123+  B813 00
124+  B814 15 10 00 00      defb 21,16,0,0,0
124+  B818 00
125+  B819 14 12 00 00      defb 20,18,0,0,0
125+  B81D 00
126+  B81E 13 14 00 00      defb 19,20,0,0,0
126+  B822 00
127+  B823 10 13 00 00      defb 16,19,0,0,0
127+  B827 00
128+  B828 0D 14 00 00      defb 13,20,0,0,0
128+  B82C 00
129+  B82D 0E 11 00 00      defb 14,17,0,0,0
129+  B831 00
130+  B832 0C 12 00 00      defb 12,18,0,0,0
130+  B836 00
131+  B837 0A 11 00 00      defb 10,17,0,0,0
131+  B83B 00
132+  B83C 05 12 00 00      defb 5,18,0,0,0
132+  B840 00
133+  B841 09 14 00 00      defb 9,20,0,0,0
133+  B845 00
134+  B846 08 15 00 00      defb 8,21,0,0,0
134+  B84A 00
135+  B84B 07 16 00 00      defb 7,22,0,0,0
135+  B84F 00
136+  B850 08 17 00 00      defb 8,23,0,0,0
136+  B854 00
137+  B855 07 18 00 00      defb 7,24,0,0,0
137+  B859 00
138+  B85A 08 1A 00 00      defb 8,26,0,0,0
138+  B85E 00
139+  B85F 06 19 00 00      defb 6,25,0,0,0
139+  B863 00
140+  B864 05 18 00 00      defb 5,24,0,0,0
140+  B868 00
141+  B869 04 17 00 00      defb 4,23,0,0,0
141+  B86D 00
142+  B86E FF               defb 255
143+  B86F
144+  B86F              level_missiles:
145+  B86F 0B 17 00 00      defb 11,23,0,0,0
145+  B873 00
146+  B874 0B 16 00 00      defb 11,22,0,0,0
146+  B878 00
147+  B879 0C 17 00 00      defb 12,23,0,0,0
147+  B87D 00
148+  B87E 0C 16 00 00      defb 12,22,0,0,0
148+  B882 00
149+  B883 0D 17 00 00      defb 13,23,0,0,0
149+  B887 00
150+  B888 0D 16 00 00      defb 13,22,0,0,0
150+  B88C 00
151+  B88D 0E 17 00 00      defb 14,23,0,0,0
151+  B891 00
152+  B892 0E 16 00 00      defb 14,22,0,0,0
152+  B896 00
153+  B897 0F 17 00 00      defb 15,23,0,0,0
153+  B89B 00
154+  B89C 0F 16 00 00      defb 15,22,0,0,0
154+  B8A0 00
155+  B8A1 10 17 00 00      defb 16,23,0,0,0
155+  B8A5 00
156+  B8A6 10 16 00 00      defb 16,22,0,0,0
156+  B8AA 00
157+  B8AB 11 17 00 00      defb 17,23,0,0,0
157+  B8AF 00
158+  B8B0 11 16 00 00      defb 17,22,0,0,0
158+  B8B4 00
159+  B8B5 12 17 00 00      defb 18,23,0,0,0
159+  B8B9 00
160+  B8BA 12 16 00 00      defb 18,22,0,0,0
160+  B8BE 00
161+  B8BF 13 17 00 00      defb 19,23,0,0,0
161+  B8C3 00
162+  B8C4 13 16 00 00      defb 19,22,0,0,0
162+  B8C8 00
163+  B8C9 14 17 00 00      defb 20,23,0,0,0
163+  B8CD 00
164+  B8CE 14 16 00 00      defb 20,22,0,0,0
164+  B8D2 00
165+  B8D3 15 17 00 00      defb 21,23,0,0,0
165+  B8D7 00
166+  B8D8 15 16 00 00      defb 21,22,0,0,0
166+  B8DC 00
167+  B8DD 16 17 00 00      defb 22,23,0,0,0
167+  B8E1 00
168+  B8E2 16 16 00 00      defb 22,22,0,0,0
168+  B8E6 00
169+  B8E7 FF               defb 255
170+  B8E8
171+  B8E8              ;
172+  B8E8              ; Diamonds: x,y,state,mem1+mem2
173+  B8E8              ;
174+  B8E8              level_diamonds:
175+  B8E8 0C 1B 00 00      defb 12,27,0,0,0
175+  B8EC 00
176+  B8ED 10 1B 00 00      defb 16,27,0,0,0
176+  B8F1 00
177+  B8F2 15 1B 00 00      defb 21,27,0,0,0
177+  B8F6 00
178+  B8F7 FF               defb 255
179+  B8F8
180+  B8F8              level_gems:
181+  B8F8 12 14 00 00      defb 18,20,0,0,0
181+  B8FC 00
182+  B8FD 06 18 00 00      defb 6,24,0,0,0
182+  B901 00
183+  B902 19 17 00 00      defb 25,23,0,0,0
183+  B906 00
184+  B907 1C 11 00 00      defb 28,17,0,0,0
184+  B90B 00
185+  B90C FF               defb 255
186+  B90D              ;
187+  B90D              ; Score area colours
188+  B90D              ;
189+  B90D              score_colours:
190+  B90D 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,67,67,67,67,67,67,67,67,66,71,71,71,71,71,71,71,71,71,71,71
190+  B911 47 47 47 47
190+  B915 47 47 47 42
190+  B919 43 43 43 43
190+  B91D 43 43 43 43
190+  B921 42 47 47 47
190+  B925 47 47 47 47
190+  B929 47 47 47 47
191+  B92D 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71
191+  B931 47 47 47 47
191+  B935 47 47 47 46
191+  B939 46 46 46 46
191+  B93D 46 46 46 46
191+  B941 46 47 47 47
191+  B945 47 47 47 47
191+  B949 47 47 47 47
192+  B94D
193+  B94D              high_score_colours:
194+  B94D 00 00 00 42      defb  0, 0, 0,66,66,66,71,71,71,71,71,71,67,67,67,71,71,71,71,71,71,70,70,70,71,71,71,71,71,71,0,0
194+  B951 42 42 47 47
194+  B955 47 47 47 47
194+  B959 43 43 43 47
194+  B95D 47 47 47 47
194+  B961 47 46 46 46
194+  B965 47 47 47 47
194+  B969 47 47 00 00
# file closed: leveldata/level.asm
138   B96D                  include "graphics\font.asm"
# file opened: graphics/font.asm
  1+  B96D              font:
  2+  B96D 00 00 00...  	defs 256
  3+  BA6D              	; end 1
  4+  BA6D 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; space
  4+  BA71 00 00 00 00
  5+  BA75 18 18 18 18  	defb	  24, 24, 24, 24, 24,  0, 24, 0 ;!
  5+  BA79 18 00 18 00
  6+  BA7D 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; "
  6+  BA81 00 00 00 00
  7+  BA85 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; #
  7+  BA89 00 00 00 00
  8+  BA8D 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; $
  8+  BA91 00 00 00 00
  9+  BA95 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; %
  9+  BA99 00 00 00 00
 10+  BA9D 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; &
 10+  BAA1 00 00 00 00
 11+  BAA5 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; '
 11+  BAA9 00 00 00 00
 12+  BAAD 0C 18 30 30  	defb	  12, 24, 48, 48, 48, 24, 12, 0; (
 12+  BAB1 30 18 0C 00
 13+  BAB5 30 18 0C 0C  	defb	  48, 24, 12, 12, 12, 24, 48,  0 ; )
 13+  BAB9 0C 18 30 00
 14+  BABD 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; *
 14+  BAC1 00 00 00 00
 15+  BAC5 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; +
 15+  BAC9 00 00 00 00
 16+  BACD 00 00 00 00  	defb	  0,  0,  0,  0,  0,  32, 96,  0 ; ,
 16+  BAD1 00 20 60 00
 17+  BAD5 00 00 00 3C  	defb	  0,  0,  0, 60,  0,  0,  0,  0 ; -
 17+  BAD9 00 00 00 00
 18+  BADD 00 00 00 00  	defb	  0,  0,  0,  0,  0,  96,96,  0 ; .
 18+  BAE1 00 60 60 00
 19+  BAE5 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; /
 19+  BAE9 00 00 00 00
 20+  BAED 1C 26 63 63  	defb	 28, 38, 99, 99, 99, 50, 28,  0 ; 0
 20+  BAF1 63 32 1C 00
 21+  BAF5 0C 1C 0C 0C  	defb	   12, 28, 12, 12, 12, 12, 63,0 ; 1
 21+  BAF9 0C 0C 3F 00
 22+  BAFD 3E 63 07 1E  	defb	  62, 99,  7, 30, 60, 96,127, 0 ; 2
 22+  BB01 3C 60 7F 00
 23+  BB05 3F 06 0C 1E  	defb	  63,  6, 12, 30,  3, 51, 30, 0 ; 3
 23+  BB09 03 33 1E 00
 24+  BB0D 0E 1E 36 66  	defb	  14, 30, 54,102,127,  6,  6, 0 ; 4
 24+  BB11 7F 06 06 00
 25+  BB15 7E 40 7E 03  	defb	 126, 64,126,  3,  3, 99, 62, 0 ; 5
 25+  BB19 03 63 3E 00
 26+  BB1D 1E 30 60 7E  	defb	 30, 48, 96,126, 99, 99, 62,  0 ; 6
 26+  BB21 63 63 3E 00
 27+  BB25 7F 63 06 0C  	defb	  127, 99,  6, 12, 24, 24, 24,0 ; 7
 27+  BB29 18 18 18 00
 28+  BB2D 3C 62 72 3C  	defb	  60, 98,114, 60, 79, 67,62,0   ; 8
 28+  BB31 4F 43 3E 00
 29+  BB35 3E 63 63 3F  	defb	  62, 99, 99, 63,  3,  6, 60, 0 ; 9
 29+  BB39 03 06 3C 00
 30+  BB3D 00 00 18 18  	defb	  0,  0, 24, 24,  0,  24,24,  0 ; :
 30+  BB41 00 18 18 00
 31+  BB45 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ;
 31+  BB49 00 00 00 00
 32+  BB4D 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; <
 32+  BB51 00 00 00 00
 33+  BB55 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; =
 33+  BB59 00 00 00 00
 34+  BB5D 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; >
 34+  BB61 00 00 00 00
 35+  BB65 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ?
 35+  BB69 00 00 00 00
 36+  BB6D              	; end 2
 37+  BB6D 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; @
 37+  BB71 00 00 00 00
 38+  BB75 1C 36 63 63  	defb	  28, 54, 99, 99,127, 99, 99, 0 ; A
 38+  BB79 7F 63 63 00
 39+  BB7D 7E 63 63 7E  	defb	  126, 99, 99,126, 99, 99,126,0 ; B
 39+  BB81 63 63 7E 00
 40+  BB85 1E 33 60 60  	defb	  30, 51, 96, 96, 96, 51, 30, 0 ; C
 40+  BB89 60 33 1E 00
 41+  BB8D 7C 66 63 63  	defb	  124,102, 99, 99, 99,102,124,0 ; D
 41+  BB91 63 66 7C 00
 42+  BB95 7F 60 60 7E  	defb	  127, 96, 96,126, 96, 96,127,0 ; E
 42+  BB99 60 60 7F 00
 43+  BB9D 7F 60 60 7E  	defb	  127, 96, 96,126, 96, 96, 96,0 ; F
 43+  BBA1 60 60 60 00
 44+  BBA5 1F 30 60 67  	defb	  31, 48, 96,103, 99, 51, 31, 0 ; G
 44+  BBA9 63 33 1F 00
 45+  BBAD 63 63 63 7F  	defb	  99, 99, 99,127, 99, 99, 99, 0 ; H
 45+  BBB1 63 63 63 00
 46+  BBB5 3F 0C 0C 0C  	defb	  63, 12, 12, 12, 12, 12, 63, 0 ; I
 46+  BBB9 0C 0C 3F 00
 47+  BBBD 03 03 03 03  	defb	  3,  3,  3,  3,  3, 99, 62,  0 ; J
 47+  BBC1 03 63 3E 00
 48+  BBC5 63 66 6C 78  	defb	  99,102,108,120,124,110,103, 0 ; K
 48+  BBC9 7C 6E 67 00
 49+  BBCD 30 30 30 30  	defb	  48, 48, 48, 48, 48, 48, 63, 0 ; L
 49+  BBD1 30 30 3F 00
 50+  BBD5 63 77 7F 7F  	defb	  99,119,127,127,107, 99, 99, 0 ; M
 50+  BBD9 6B 63 63 00
 51+  BBDD 63 73 7B 7F  	defb	  99,115,123,127,111,103, 99, 0 ; N
 51+  BBE1 6F 67 63 00
 52+  BBE5 3E 63 63 63  	defb	  62, 99, 99, 99, 99, 99, 62, 0 ; O
 52+  BBE9 63 63 3E 00
 53+  BBED 7E 61 61 61  	defb	  126, 97, 97, 97,126, 96, 96,0 ; P
 53+  BBF1 7E 60 60 00
 54+  BBF5 3E 63 63 63  	defb	  62, 99, 99, 99,111,102, 61, 0 ; Q
 54+  BBF9 6F 66 3D 00
 55+  BBFD 7E 63 63 67  	defb	  126, 99, 99,103,124,110,103,0 ; R
 55+  BC01 7C 6E 67 00
 56+  BC05 3C 66 60 3E  	defb	  60,102, 96, 62,  3, 99, 62, 0 ; S
 56+  BC09 03 63 3E 00
 57+  BC0D 7E 18 18 18  	defb	  126, 24, 24, 24, 24, 24, 24,0 ; T
 57+  BC11 18 18 18 00
 58+  BC15 63 63 63 63  	defb	  99, 99, 99, 99, 99, 99, 62, 0 ; U
 58+  BC19 63 63 3E 00
 59+  BC1D 63 63 63 77  	defb	  99, 99, 99,119, 62, 28,  8, 0 ; V
 59+  BC21 3E 1C 08 00
 60+  BC25 63 63 6B 7F  	defb	  99, 99,107,127,127, 54, 34, 0 ; W
 60+  BC29 7F 36 22 00
 61+  BC2D 63 77 3E 1C  	defb	  99,119, 62, 28, 62,119, 99, 0 ; X
 61+  BC31 3E 77 63 00
 62+  BC35 33 33 12 1E  	defb	  51, 51, 18, 30, 12, 12, 12, 0 ; Y
 62+  BC39 0C 0C 0C 00
 63+  BC3D 7F 07 0E 1C  	defb	  127,  7, 14, 28, 56,112,127,0 ; Z
 63+  BC41 38 70 7F 00
 64+  BC45 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; [
 64+  BC49 00 00 00 00
 65+  BC4D 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; \
 65+  BC51 00 00 00 00
 66+  BC55 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ]
 66+  BC59 00 00 00 00
 67+  BC5D 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ^
 67+  BC61 00 00 00 00
 68+  BC65 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; _
 68+  BC69 00 00 00 00
 69+  BC6D              	; end 3
 70+  BC6D 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; 
 70+  BC71 00 00 00 00
 71+  BC75 1C 36 63 63  	defb	  28, 54, 99, 99,127, 99, 99, 0 ; A
 71+  BC79 7F 63 63 00
 72+  BC7D 7E 63 63 7E  	defb	  126, 99, 99,126, 99, 99,126,0 ; B
 72+  BC81 63 63 7E 00
 73+  BC85 1E 33 60 60  	defb	  30, 51, 96, 96, 96, 51, 30, 0 ; C
 73+  BC89 60 33 1E 00
 74+  BC8D 7C 66 63 63  	defb	  124,102, 99, 99, 99,102,124,0 ; D
 74+  BC91 63 66 7C 00
 75+  BC95 7F 60 60 7E  	defb	  127, 96, 96,126, 96, 96,127,0 ; E
 75+  BC99 60 60 7F 00
 76+  BC9D 7F 60 60 7E  	defb	  127, 96, 96,126, 96, 96, 96,0 ; F
 76+  BCA1 60 60 60 00
 77+  BCA5 1F 30 60 67  	defb	  31, 48, 96,103, 99, 51, 31, 0 ; G
 77+  BCA9 63 33 1F 00
 78+  BCAD 63 63 63 7F  	defb	  99, 99, 99,127, 99, 99, 99, 0 ; H
 78+  BCB1 63 63 63 00
 79+  BCB5 3F 0C 0C 0C  	defb	  63, 12, 12, 12, 12, 12, 63, 0 ; I
 79+  BCB9 0C 0C 3F 00
 80+  BCBD 03 03 03 03  	defb	  3,  3,  3,  3,  3, 99, 62,  0 ; J
 80+  BCC1 03 63 3E 00
 81+  BCC5 63 66 6C 78  	defb	  99,102,108,120,124,110,103, 0 ; K
 81+  BCC9 7C 6E 67 00
 82+  BCCD 30 30 30 30  	defb	  48, 48, 48, 48, 48, 48, 63, 0 ; L
 82+  BCD1 30 30 3F 00
 83+  BCD5 63 77 7F 7F  	defb	  99,119,127,127,107, 99, 99, 0 ; M
 83+  BCD9 6B 63 63 00
 84+  BCDD 63 73 7B 7F  	defb	  99,115,123,127,111,103, 99, 0 ; N
 84+  BCE1 6F 67 63 00
 85+  BCE5 3E 63 63 63  	defb	  62, 99, 99, 99, 99, 99, 62, 0 ; O
 85+  BCE9 63 63 3E 00
 86+  BCED 7E 61 61 61  	defb	  126, 97, 97, 97,126, 96, 96,0 ; P
 86+  BCF1 7E 60 60 00
 87+  BCF5 3E 63 63 63  	defb	  62, 99, 99, 99,111,102, 61, 0 ; Q
 87+  BCF9 6F 66 3D 00
 88+  BCFD 7E 63 63 67  	defb	  126, 99, 99,103,124,110,103,0 ; R
 88+  BD01 7C 6E 67 00
 89+  BD05 3C 66 60 3E  	defb	  60,102, 96, 62,  3, 99, 62, 0 ; S
 89+  BD09 03 63 3E 00
 90+  BD0D 7E 18 18 18  	defb	  126, 24, 24, 24, 24, 24, 24,0 ; T
 90+  BD11 18 18 18 00
 91+  BD15 63 63 63 63  	defb	  99, 99, 99, 99, 99, 99, 62, 0 ; U
 91+  BD19 63 63 3E 00
 92+  BD1D 63 63 63 77  	defb	  99, 99, 99,119, 62, 28,  8, 0 ; V
 92+  BD21 3E 1C 08 00
 93+  BD25 63 63 6B 7F  	defb	  99, 99,107,127,127, 54, 34, 0 ; W
 93+  BD29 7F 36 22 00
 94+  BD2D 63 77 3E 1C  	defb	  99,119, 62, 28, 62,119, 99, 0 ; X
 94+  BD31 3E 77 63 00
 95+  BD35 33 33 12 1E  	defb	  51, 51, 18, 30, 12, 12, 12, 0 ; Y
 95+  BD39 0C 0C 0C 00
 96+  BD3D 7F 07 0E 1C  	defb	  127,  7, 14, 28, 56,112,127,0 ; Z
 96+  BD41 38 70 7F 00
 97+  BD45 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0
 97+  BD49 00 00 00 00
 98+  BD4D 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0
 98+  BD51 00 00 00 00
 99+  BD55 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0
 99+  BD59 00 00 00 00
100+  BD5D 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0
100+  BD61 00 00 00 00
101+  BD65 3C 42 99 A1  	defb	  60, 66,153,161,161,153, 66, 60 ; 	
101+  BD69 A1 99 42 3C
# file closed: graphics/font.asm
139   BD6D                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  BD6D              ; Tiles graphics.
  2+  BD6D              sprites:
  3+  BD6D 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  BD71 00 00 00 00
  4+  BD75 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  BD79 FF FF FF FF
  5+  BD7D 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  BD81 1F 3F 7F FF
  6+  BD85 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  BD89 F8 FC FE FF
  7+  BD8D 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  BD91 55 AA 55 AA
  8+  BD95 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 5, sky block
  8+  BD99 00 00 00 00
  9+  BD9D 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 6, slime block
  9+  BDA1 00 00 00 00
 10+  BDA5 00 00 00 00      defb    0  ,0  ,  0,  0,  0,  0,  0,  0   ; 7, for reuse
 10+  BDA9 00 00 00 00
 11+  BDAD 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52,  24    ; 8, diamond
 11+  BDB1 F1 72 34 18
 12+  BDB5 3C 7E FF 7F      defb    60,126,255,127,254,254,255,126    ; 9, rock
 12+  BDB9 FE FE FF 7E
 13+  BDBD 7E FF 7F 7F  	defb	126,255,127,127,254,255,126, 60    ; 10, rock 2
 13+  BDC1 FE FF 7E 3C
 14+  BDC5 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,255,255   ; 11, sky block, pixel trapdoor
 14+  BDC9 00 00 FF FF
 15+  BDCD 99 DB 7E 24  	defb    153,219,126, 36,255, 66, 36, 24   ; 12, missile
 15+  BDD1 FF 42 24 18
 16+  BDD5 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 13, sky block, tank background
 16+  BDD9 00 00 00 00
 17+  BDDD 00 00 00 00  	defb    0,  0,  0,  0,  0, 60, 90, 52     ; 14, gem
 17+  BDE1 00 3C 5A 34
 18+  BDE5 FD FE FD FE  	defb	253,254,253,254,253,254,253,254   ; 15, damaged mountain
 18+  BDE9 FD FE FD FE
 19+  BDED F4 F8 F4 F8  	defb	244,248,244,248,244,248,244,248   ; 16, damaged mountain 2
 19+  BDF1 F4 F8 F4 F8
 20+  BDF5 D0 E0 D0 E0  	defb	208,224,208,224,208,224,208,224   ; 17, damaged mountain 3
 20+  BDF9 D0 E0 D0 E0
 21+  BDFD 40 80 40 80  	defb	 64,128, 64,128, 64,128, 64,128   ; 18, damaged mountain 4
 21+  BE01 40 80 40 80
 22+  BE05 00 00 00 ED  	defb	0,  0,  0,237,237,  0,  0,  0	  ; 19, tank missile
 22+  BE09 ED 00 00 00
 23+  BE0D 99 DB 7E 24  	defb    153,219,126, 36,255,126, 60, 24   ; 20, missile active
 23+  BE11 FF 7E 3C 18
 24+  BE15 FF FF 00 00      defb	255,255,  0,  0,  0,  0,  0,  0	  ; 21, the pit 1
 24+  BE19 00 00 00 00
 25+  BE1D FC FC 00 00  	defb	252,252,  0,  0,  0,  0,  0,  0	  ; 22, the pit 2
 25+  BE21 00 00 00 00
 26+  BE25 F0 F0 00 00  	defb	240,240,  0,  0,  0,  0,  0,  0	  ; 23, the pit 3
 26+  BE29 00 00 00 00
 27+  BE2D C0 C0 00 00  	defb	192,192,  0,  0,  0,  0,  0,  0	  ; 24, the pit 4
 27+  BE31 00 00 00 00
 28+  BE35 00 00 00 00  	defb	0,0,  0,  0,  0,  0,  0,  0	  	  ; 25, the pit 5
 28+  BE39 00 00 00 00
 29+  BE3D FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 26, slime block, green on green
 29+  BE41 FF FF FF FF
 30+  BE45 00 00 00 66  	defb    0,  0,  0,102,  0,  0,  0,  0     ; 27, bullet
 30+  BE49 00 00 00 00
 31+  BE4D
 32+  BE4D
 33+  BE4D              sprite_attrs:
 34+  BE4D 46               defb    070 ; 0, space
 35+  BE4E 4D               defb    077 ; 1, cyan block
 36+  BE4F 4D               defb    077 ; 2, slope left
 37+  BE50 4D               defb    077 ; 3, slope right
 38+  BE51 46               defb    070 ; 4, dirt
 39+  BE52 4E               defb    078 ; 5, sky
 40+  BE53 66               defb    102 ; 6, slime
 41+  BE54 42               defb    066 ; 7, trapdoor
 42+  BE55 46               defb    070 ; 8, diamond
 43+  BE56 42               defb    066 ; 9, rock
 44+  BE57 42               defb    066 ; 10, rock 2
 45+  BE58 49           	defb    073 ; 11, sky, trapdoor
 46+  BE59 43           	defb    067 ; 12, missile
 47+  BE5A 4A               defb    074 ; 13, sky, red ink (tank)
 48+  BE5B 46               defb    070 ; 14, gem
 49+  BE5C 4D               defb    077 ; 15, damaged mountain
 50+  BE5D 4D               defb    077 ; 16, damaged mountain 2
 51+  BE5E 4D               defb    077 ; 17, damaged mountain 3
 52+  BE5F 4D               defb    077 ; 18, damaged mountain 4
 53+  BE60 00           	defb 	000 ; 19, tank missile (not used
 54+  BE61 43           	defb    067 ; 20, missile active
 55+  BE62 42           	defb	066	; 21, the pit 1
 56+  BE63 42           	defb	066	; 22, the pit 2
 57+  BE64 42           	defb	066	; 23, the pit 3
 58+  BE65 42           	defb	066	; 24, the pit 4
 59+  BE66 42           	defb	066	; 25, the pit 5
 60+  BE67 64           	defb    100 ; 26, slime, green on green
 61+  BE68 46           	defb 	070 ; 27, bullet
 62+  BE69
 63+  BE69
 64+  BE69              player_sprite:
 65+  BE69 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 0 up/down 1
 65+  BE6D 38 3D C3 80
 66+  BE71 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 1 left 1
 66+  BE75 3C 1C 16 32
 67+  BE79 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 2 right 1
 67+  BE7D 3C 38 68 4C
 68+  BE81 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 3 up/down 2
 68+  BE85 1C BC C3 01
 69+  BE89 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 60,100, 12; 4 left 2
 69+  BE8D 3C 3C 64 0C
 70+  BE91 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 60, 38, 48 ; 5 right 2
 70+  BE95 3C 3C 26 30
 71+  BE99 54 28 10 12  	defb	 84, 40, 16, 18, 30, 92,253, 95 ; 6 shoot up
 71+  BE9D 1E 5C FD 5F
 72+  BEA1 02 87 42 BF  	defb	 2,135, 66,191, 79,143, 25,  3  ; 7 shoot left
 72+  BEA5 4F 8F 19 03
 73+  BEA9 40 E1 42 FD  	defb	 64,225, 66,253,242,241,152,192 ; 8 shoot right
 73+  BEAD F2 F1 98 C0
 74+  BEB1 FA BF 3A 78  	defb	 250,191, 58,120, 72,  8, 20, 42 ; 9 shoot down
 74+  BEB5 48 08 14 2A
 75+  BEB9 92 BA 94 78  	defb 	 146,186,148,120, 56,120, 68,195 ; 10 crushed 1
 75+  BEBD 38 78 44 C3
 76+  BEC1 49 5D 29 1E  	defb	  73, 93, 41, 30, 28, 30, 34,195 ; 11 crushed 2
 76+  BEC5 1C 1E 22 C3
 77+  BEC9 72 57 72 67  	defb	114, 87,114,103,111, 69,225,155  ; 12 fight 1
 77+  BECD 6F 45 E1 9B
 78+  BED1 4E EA 4E E6  	defb	 78,234, 78,230,246,162,135,217  ; 13 fight 2
 78+  BED5 F6 A2 87 D9
 79+  BED9
 80+  BED9              ;
 81+  BED9              ; First 4 top half, next 4 bottom 1, next 4 bottom 2
 82+  BED9              ;
 83+  BED9              ship_sprite:
 84+  BED9 00 00 00 01  	defb	  0,  0,  0,  1,  3, 31,127,255
 84+  BEDD 03 1F 7F FF
 85+  BEE1 1F 01 7F FF  	defb	 31,  1,127,255,255,255,255,255
 85+  BEE5 FF FF FF FF
 86+  BEE9 F8 80 FE FF  	defb	248,128,254,255,255,255,255,255
 86+  BEED FF FF FF FF
 87+  BEF1 00 00 00 80  	defb	  0,  0,  0,128,192,248,254,255
 87+  BEF5 C0 F8 FE FF
 88+  BEF9 B3 B3 7F 1F  	defb	179,179,127, 31,  3,  3,  2,  7
 88+  BEFD 03 03 02 07
 89+  BF01 8F 8F FF FF  	defb	143,143,255,255,255, 15,  7,131
 89+  BF05 FF 0F 07 83
 90+  BF09 0F 0F FF FF  	defb	 15, 15,255,255,255, 16, 32,193
 90+  BF0D FF 10 20 C1
 91+  BF11 19 19 FE F8  	defb	 25, 25,254,248,192,192, 64,224
 91+  BF15 C0 C0 40 E0
 92+  BF19 98 98 7F 1F  	defb	152,152,127, 31,  3,  3,  2,  7
 92+  BF1D 03 03 02 07
 93+  BF21 F0 F0 FF FF  	defb	240,240,255,255,255,  8,  4,131
 93+  BF25 FF 08 04 83
 94+  BF29 F1 F1 FF FF  	defb	241,241,255,255,255,240,224,193
 94+  BF2D FF F0 E0 C1
 95+  BF31 CD CD FE F8  	defb	205,205,254,248,192,192, 64,224
 95+  BF35 C0 C0 40 E0
 96+  BF39
 97+  BF39              ;
 98+  BF39              ;  First 8 frames are tank, last frame is the gun barrel
 99+  BF39              ;
100+  BF39              tank_sprite:
101+  BF39 00 00 00 7F  	defb	  0,  0,  0,127,127,  0,  0,  0
101+  BF3D 7F 00 00 00
102+  BF41 01 03 FE FC  	defb	  1,  3,254,252,254,255,127, 64
102+  BF45 FE FF 7F 40
103+  BF49 FF FF 03 F9  	defb	255,255,  3,249,  3,255,255,  1
103+  BF4D 03 FF FF 01
104+  BF51 00 00 C0 E0  	defb	  0,  0,192,224,224,192,  0,  0
104+  BF55 E0 C0 00 00
105+  BF59 3F 7F E1 FB  	defb	 63,127,225,251,247,225,127, 63
105+  BF5D F7 E1 7F 3F
106+  BF61 FF FF 16 52  	defb	255,255, 22, 82, 84, 22,255,255
106+  BF65 54 16 FF FF
107+  BF69 FF FF A8 A9  	defb	255,255,168,169,155,168,255,255
107+  BF6D 9B A8 FF FF
108+  BF71 FC FE 8F AF  	defb	252,254,143,175,159,175,254,252
108+  BF75 9F AF FE FC
109+  BF79 00 00 00 1F  	defb	  0,  0,  0, 31, 31,  0,  0,  0 ; +64
109+  BF7D 1F 00 00 00
110+  BF81
111+  BF81              monster_sprite:
112+  BF81 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
112+  BF85 0B D0 16 68
113+  BF89 19 98 17 E8  	defb	 25,152, 23,232, 53,172,127,254
113+  BF8D 35 AC 7F FE
114+  BF91 FE 7F EC 37  	defb	254,127,236, 55,143,241,143,241
114+  BF95 8F F1 8F F1
115+  BF99 08 10 08 10  	defb	  8, 16,  8, 16, 24, 24,  0,  0		; frame 1
115+  BF9D 18 18 00 00
116+  BFA1 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
116+  BFA5 0B D0 16 68
117+  BFA9 19 98 17 E8  	defb	 25,152, 23,232,245,175,255,255
117+  BFAD F5 AF FF FF
118+  BFB1 BC 3D 0E 70  	defb	188, 61, 14,112, 15,240, 15,240
118+  BFB5 0F F0 0F F0
119+  BFB9 10 08 30 0C  	defb	 16,  8, 48, 12,  0,  0,  0,  0		; frame 2
119+  BFBD 00 00 00 00
120+  BFC1
121+  BFC1              robot_sprite:
122+  BFC1 0E 0A CE 3E  	defb	 14, 10,206, 62,206, 18, 34,102		; left 1
122+  BFC5 CE 12 22 66
123+  BFC9 0E 0A 4E FE  	defb	 14, 10, 78,254, 78, 18, 36,108		; 2
123+  BFCD 4E 12 24 6C
124+  BFD1 0E 0A 4E FE  	defb	 14, 10, 78,254, 78, 50, 99,  3		; 3
124+  BFD5 4E 32 63 03
125+  BFD9 0E 0A CE 3E  	defb	 14, 10,206, 62,206, 10,  9, 27		; 4
125+  BFDD CE 0A 09 1B
126+  BFE1 70 50 73 7C  	defb	112, 80,115,124,115, 72, 68,102		; right 1
126+  BFE5 73 48 44 66
127+  BFE9 70 50 72 7F  	defb	112, 80,114,127,114, 72, 36, 54		; 2
127+  BFED 72 48 24 36
128+  BFF1 70 50 72 7F  	defb	112, 80,114,127,114, 76,198,192		; 3
128+  BFF5 72 4C C6 C0
129+  BFF9 70 50 73 7C  	defb	112, 80,115,124,115, 80,144,216		; 4
129+  BFFD 73 50 90 D8
130+  C001 38 A9 BA 7C  	defb     56,169,186,124, 56, 42, 38, 96     ; dead 1
130+  C005 38 2A 26 60
131+  C009 1C 95 5D 3E  	defb	 28,149, 93, 62, 28, 84,100,  6		; dead 2
131+  C00D 1C 54 64 06
132+  C011
# file closed: graphics/graphics.asm
140   C011
141   C011                  include "game\control.asm"
# file opened: game/control.asm
  1+  C011              ;
  2+  C011              ; Check the preferred input method then move
  3+  C011              ;
  4+  C011              control_input:
  5+  C011 3A 28 C6         ld a,(player+11)    ; first, check if player is dying
  6+  C014 FE 04            cp 4                ; is the player falling
  7+  C016 CC EA C0         call z, control_fall
  8+  C019 FE 05            cp 5                ; is the player fighting
  9+  C01B CC D7 C0         call z, control_fight
 10+  C01E 3A 28 C6         ld a,(player+11)    ; first, check if player is dying
 11+  C021 FE 00            cp 0
 12+  C023 C0               ret nz               ; if so, can't move
 13+  C024 3A 22 C6         ld a,(player+5)      ; next, check if the player has pixels left to move
 14+  C027 FE 00            cp 0
 15+  C029 CA 30 C0         jp z, control_input0
 16+  C02C CD D2 C1         call control_automove
 17+  C02F C9               ret
 18+  C030              control_input0:
 19+  C030 3A 23 C6         ld a,(player+6)      ; next, check if the player is digging
 20+  C033 FE 00            cp 0
 21+  C035 CA 3C C0         jp z, control_input1
 22+  C038 CD 06 C1         call control_dig
 23+  C03B C9               ret
 24+  C03C              control_input1:
 25+  C03C 3A 31 C5         ld a,(game_control)
 26+  C03F FE 00            cp 0                ; is this keyboard
 27+  C041 C2 48 C0         jp nz,control_input2
 28+  C044 CD 4C C0         call control_keyboard
 29+  C047 C9               ret
 30+  C048              control_input2:
 31+  C048                  ; do joystick
 32+  C048 CD 97 C0         call control_joystick
 33+  C04B C9               ret
 34+  C04C
 35+  C04C              ;
 36+  C04C              ; Check the keyboard
 37+  C04C              ;
 38+  C04C              control_keyboard:
 39+  C04C 01 FE FB         ld bc,64510         ; port for keyboard row q-t.
 40+  C04F ED 78            in a,(c)            ; read keyboard.
 41+  C051 47               ld b,a              ; store result in b register.
 42+  C052 CB 18            rr b                ; check outermost key (q).
 43+  C054 D2 83 C0         jp nc,control_keyboard1
 44+  C057 01 FE FD         ld bc,65022         ; port for keyboard row a-f.
 45+  C05A ED 78            in a,(c)            ; read keyboard.
 46+  C05C 47               ld b,a              ; store result in b register.
 47+  C05D CB 18            rr b                ; check outermost key (a).
 48+  C05F D2 87 C0         jp nc,control_keyboard2
 49+  C062 01 FE DF         ld bc,57342         ; port for keyboard row y-p.
 50+  C065 ED 78            in a,(c)            ; read keyboard.
 51+  C067 47               ld b,a              ; store result in b register.
 52+  C068 CB 18            rr b                ; check outermost key (p).
 53+  C06A D2 8B C0         jp nc,control_keyboard3
 54+  C06D CB 18            rr b                ; check next key.
 55+  C06F D2 8F C0         jp nc,control_keyboard4
 56+  C072 01 FE 7F         ld bc,32766         ; port for keyboard row b-space.
 57+  C075 ED 78            in a,(c)            ; read keyboard.
 58+  C077 47               ld b,a              ; store result in b register.
 59+  C078 CB 18            rr b                ; check outermost key (space).
 60+  C07A D2 93 C0         jp nc,control_keyboard5
 61+  C07D 3E 00            ld a,0
 62+  C07F 32 9C D7         ld (bullet_enable),a ; if nothing has been pressed, reset the fire enabler
 63+  C082 C9               ret
 64+  C083              control_keyboard1:
 65+  C083 CD 19 C2         call control_pl_moveup         ; player up.
 66+  C086 C9               ret
 67+  C087              control_keyboard2:
 68+  C087 CD 46 C2         call control_pl_movedown       ; player down.
 69+  C08A C9               ret
 70+  C08B              control_keyboard3:
 71+  C08B CD A0 C2         call control_pl_moveright       ; player left.
 72+  C08E C9               ret
 73+  C08F              control_keyboard4:
 74+  C08F CD 72 C2         call control_pl_moveleft       ; player right.
 75+  C092 C9               ret
 76+  C093              control_keyboard5:
 77+  C093 CD CD C2         call control_pl_fire       ; player fire.
 78+  C096 C9               ret
 79+  C097
 80+  C097              ;
 81+  C097              ; Check the joystick
 82+  C097              ;
 83+  C097              control_joystick:
 84+  C097 01 1F 00         ld bc,31                        ; Kempston joystick port.
 85+  C09A ED 78            in a,(c)                        ; read input.
 86+  C09C E6 02            and 2                           ; check "left" bit.
 87+  C09E C2 CB C0         jp nz,control_joystick3       ; move left.
 88+  C0A1 ED 78            in a,(c)                        ; read input.
 89+  C0A3 E6 01            and 1                           ; test "right" bit.
 90+  C0A5 C2 CF C0         jp nz,control_joystick4       ; move right.
 91+  C0A8 ED 78            in a,(c)                        ; read input.
 92+  C0AA E6 08            and 8                           ; check "up" bit.
 93+  C0AC C2 C3 C0         jp nz,control_joystick1       ; move up.
 94+  C0AF ED 78            in a,(c)                        ; read input.
 95+  C0B1 E6 04            and 4                           ; check "down" bit.
 96+  C0B3 C2 C7 C0         jp nz,control_joystick2       ; move down.
 97+  C0B6 ED 78            in a,(c)                        ; read input.
 98+  C0B8 E6 10            and 16                          ; try the fire bit.
 99+  C0BA C2 D3 C0         jp nz,control_joystick5       ; fire pressed.
100+  C0BD 3E 00            ld a,0
101+  C0BF 32 9C D7         ld (bullet_enable),a ; if nothing has been pressed, reset the fire enabler
102+  C0C2 C9               ret
103+  C0C3              control_joystick1:
104+  C0C3 CD 19 C2         call control_pl_moveup         ; player up.
105+  C0C6 C9               ret
106+  C0C7              control_joystick2:
107+  C0C7 CD 46 C2         call control_pl_movedown       ; player down.
108+  C0CA C9               ret
109+  C0CB              control_joystick3:
110+  C0CB CD 72 C2         call control_pl_moveleft       ; player left.
111+  C0CE C9               ret
112+  C0CF              control_joystick4:
113+  C0CF CD A0 C2         call control_pl_moveright       ; player right.
114+  C0D2 C9               ret
115+  C0D3              control_joystick5:
116+  C0D3 CD CD C2         call control_pl_fire
117+  C0D6 C9               ret
118+  C0D7
119+  C0D7              ;
120+  C0D7              ; Fights the player - just flips the players anim frame
121+  C0D7              ;
122+  C0D7              control_fight:
123+  C0D7 3A 20 C6         ld a,(player+3)             ; load the frame
124+  C0DA FE 0C            cp 12                       ; flip between 12 and 13
125+  C0DC CA E4 C0         jp z,control_fight0
126+  C0DF 3E 0C            ld a,12
127+  C0E1 C3 E6 C0         jp control_fight1
128+  C0E4              control_fight0:
129+  C0E4 3E 0D            ld a,13
130+  C0E6              control_fight1:
131+  C0E6 32 20 C6         ld (player+3),a           ; save back
132+  C0E9 C9               ret
133+  C0EA
134+  C0EA              ;
135+  C0EA              ; Falls the player
136+  C0EA              ;
137+  C0EA              control_fall:
138+  C0EA ED 4B 1D C6      ld bc,(player)              ; get coords
139+  C0EE 0C               inc c
140+  C0EF ED 43 1D C6      ld (player),bc
141+  C0F3 3A 20 C6         ld a,(player+3)             ; load the frame
142+  C0F6 FE 03            cp 3                       ; flip between 3 and 0
143+  C0F8 C2 00 C1         jp nz, control_fall0
144+  C0FB 3E 00            ld a,0
145+  C0FD C3 02 C1         jp control_fall1
146+  C100              control_fall0:
147+  C100 3E 03            ld a,3
148+  C102              control_fall1:
149+  C102 32 20 C6         ld (player+3),a           ; save back
150+  C105 C9               ret
151+  C106
152+  C106              ;
153+  C106              ; Performs a dig if the counter has reset, otherwise, messes with the graphics
154+  C106              ;
155+  C106              control_dig:
156+  C106 ED 4B 1D C6      ld bc,(player)      ; load the current coords into bc
157+  C10A C5               push bc
158+  C10B 3A 1F C6         ld a,(player+2)     ; get the direction
159+  C10E FE 01            cp 1                ; left
160+  C110 CA 28 C1         jp z,control_dig0
161+  C113 FE 02            cp 2                ; right
162+  C115 CA 3D C1         jp z,control_dig1
163+  C118 FE 03            cp 3                ; down
164+  C11A CA 66 C1         jp z,control_dig5
165+  C11D FE 00            cp 0                ; up
166+  C11F CA 51 C1         jp z,control_dig4
167+  C122 21 23 C6         ld hl,player+6
168+  C125 36 00            ld (hl),0           ; turn off digging
169+  C127 C9               ret                 ; return
170+  C128              control_dig0:           ; going left
171+  C128 CD 36 AC         call sprites_scadd  ; get the current coord
172+  C12B 62 6B            ld hl,de
173+  C12D 2B               dec hl              ; move one left
174+  C12E C1               pop bc              ; get the coords back, subtract 8 from horiz, 8 from vert, store (will be coords of space above dug dirt)
175+  C12F 78               ld a,b
176+  C130 06 08            ld b,8
177+  C132 90               sub b
178+  C133 47               ld b,a
179+  C134 79               ld a,c
180+  C135 0E 08            ld c,8
181+  C137 91               sub c
182+  C138 4F               ld c,a
183+  C139 C5               push bc
184+  C13A C3 74 C1         jp control_dig2
185+  C13D              control_dig1:
186+  C13D CD 36 AC         call sprites_scadd  ; get the current coord
187+  C140 62 6B            ld hl,de
188+  C142 23               inc hl              ; move one right
189+  C143 C1               pop bc              ; get the coords back, add 8 to horiz, subtract 8 from vert store (will be coords of space above dug dirt)
190+  C144 3E 08            ld a,8
191+  C146 80               add a,b
192+  C147 47               ld b,a
193+  C148 79               ld a,c
194+  C149 0E 08            ld c,8
195+  C14B 91               sub c
196+  C14C 4F               ld c,a
197+  C14D C5               push bc
198+  C14E C3 74 C1         jp control_dig2
199+  C151              control_dig4:
200+  C151 3E 01            ld a,1
201+  C153 32 2E A7         ld (buffer_threelinerefresh),a  ; set the three line update flag, since we're digging up
202+  C156 CD 36 AC         call sprites_scadd  ; get the current coord
203+  C159 62 6B            ld hl,de
204+  C15B 11 20 00         ld de,32
205+  C15E ED 52            sbc hl,de             ; move one up
206+  C160 C1               pop bc              ; get the coords back, 1 from vert, store, then we'll sub 1 from c for each row later
207+  C161 0D               dec c
208+  C162 C5               push bc
209+  C163 C3 8C C1         jp control_dig6
210+  C166              control_dig5:
211+  C166 3E 02            ld a,2
212+  C168 32 2E A7         ld (buffer_threelinerefresh),a  ; set the three line update flag, since we're digging up
213+  C16B CD 36 AC         call sprites_scadd  ; get the current coord
214+  C16E 62 6B            ld hl,de
215+  C170 24               inc h              ; move one down
216+  C171                                     ; not bothered about working out bc here, since rock will never fall if digging down
217+  C171 C3 74 C1         jp control_dig2
218+  C174              ; Normal (not up) digging
219+  C174              control_dig2:
220+  C174 3A 25 C6         ld a,(player+8)     ; get the number of rows we need to overwrite
221+  C177 47               ld b,a              ; rows to copy over
222+  C178 E5               push hl             ; store the memory location of the first row for later
223+  C179              control_dig3:
224+  C179 CD BB C1         call control_getpixelrow
225+  C17C 77               ld (hl),a           ; load contents into row
226+  C17D 11 20 00         ld de,32
227+  C180 19               add hl,de           ; move to next row
228+  C181 10 F6            djnz control_dig3
229+  C183 E1               pop hl              ; get the original memory location back
230+  C184 11 20 00         ld de,32
231+  C187 ED 52            sbc hl,de           ; move to above row, ready for checking for rock
232+  C189 C3 A2 C1         jp control_dig10
233+  C18C              ; Special case for going up
234+  C18C              control_dig6:
235+  C18C 3A 25 C6         ld a,(player+8)     ; get the number of rows we need to overwrite
236+  C18F 47               ld b,a              ; rows to copy over
237+  C190              control_dig7:
238+  C190 CD BB C1         call control_getpixelrow
239+  C193              control_dig12:
240+  C193 77               ld (hl),a           ; load empty into row
241+  C194 11 20 00         ld de,32
242+  C197 ED 52            sbc hl,de           ; move up to next row
243+  C199 0D               dec c               ; decrease c to track rows
244+  C19A 10 F4            djnz control_dig7
245+  C19C 79               ld a,c
246+  C19D D6 07            sub 7
247+  C19F C1               pop bc
248+  C1A0 4F               ld c,a
249+  C1A1 C5               push bc             ; store the decreased c coord
250+  C1A2              control_dig10:
251+  C1A2 DD 21 24 C6      ld ix,player+7
252+  C1A6 DD 7E 00         ld a,(ix)     ; get the dig frame number
253+  C1A9 3D               dec a
254+  C1AA DD 77 00         ld (ix),a
255+  C1AD                  ; call the check for rocks above the removed dirt
256+  C1AD DD 21 23 C6      ld ix,player+6
257+  C1B1 DD 7E 00         ld a,(ix)     ; get the dig state
258+  C1B4 FE 00            cp 0
259+  C1B6 C1               pop bc
260+  C1B7 CC FE CB         call z, rocks_checkforfalling ; make the check if we're no longer digging
261+  C1BA C9               ret
262+  C1BB
263+  C1BB              ;
264+  C1BB              ; Gets a modified pixel row to overwrite dirt - if this is the last dig, overwrite with nothing, otherwise xor to flip the dirt
265+  C1BB              ; Inputs:
266+  C1BB              ; hl - memory of pixel row
267+  C1BB              ; Outputs:
268+  C1BB              ; a - modified row to write
269+  C1BB              ;
270+  C1BB              control_getpixelrow:
271+  C1BB 3A 24 C6         ld a,(player+7)     ; get the dig frame number
272+  C1BE FE 00            cp 0                ; is this the last dig
273+  C1C0 CA C7 C1         jp z,control_getpixelrow1
274+  C1C3 7E               ld a,(hl)           ; if not, xor with 255 to flip it
275+  C1C4 EE FF            xor 255
276+  C1C6 C9               ret
277+  C1C7              control_getpixelrow1:
278+  C1C7 DD 21 23 C6      ld ix,player+6
279+  C1CB DD 36 00 00      ld (ix),0           ; turn off digging
280+  C1CF 3E 00            ld a,0              ; if it is, load with empty
281+  C1D1 C9               ret
282+  C1D2
283+  C1D2              ;
284+  C1D2              ; Auto move the player until pixels is zero
285+  C1D2              ;
286+  C1D2              control_automove:
287+  C1D2 5F               ld e,a              ; store the number of pixels left to move in e
288+  C1D3 ED 4B 1D C6      ld bc,(player)      ; load the current coords into bc
289+  C1D7 21 1F C6         ld hl,player+2      ; get the direction
290+  C1DA 7E               ld a,(hl)
291+  C1DB FE 03            cp 3                ; down
292+  C1DD CA F0 C1         jp z,control_automove3  ; don't need to do anything
293+  C1E0 FE 00            cp 0                ; going up
294+  C1E2 CA FC C1         jp z,control_automove2
295+  C1E5 FE 01            cp 1                ; going left?
296+  C1E7 CA 08 C2         jp z,control_automove0
297+  C1EA 78               ld a,b
298+  C1EB 3C               inc a               ; if we're going right, increment a twice for two pixels
299+  C1EC 47               ld b,a
300+  C1ED C3 0B C2         jp control_automove1
301+  C1F0              control_automove3:
302+  C1F0 79               ld a,c
303+  C1F1 3C               inc a
304+  C1F2 3C               inc a               ; if we're going down, increment twice
305+  C1F3 4F               ld c,a
306+  C1F4 FE 90            cp 144
307+  C1F6 CC EC C2         call z, control_scroll_down
308+  C1F9 C3 0B C2         jp control_automove1
309+  C1FC              control_automove2:
310+  C1FC 79               ld a,c
311+  C1FD 3D               dec a
312+  C1FE 3D               dec a               ; if we're going up, decrement twice
313+  C1FF 4F               ld c,a
314+  C200 FE 60            cp 96
315+  C202 CC F9 C2         call z, control_scroll_up
316+  C205 C3 0B C2         jp control_automove1
317+  C208              control_automove0:
318+  C208 78               ld a,b
319+  C209 3D               dec a               ; if we're going left, decrement a twice
320+  C20A 47               ld b,a
321+  C20B              control_automove1:
322+  C20B ED 43 1D C6      ld (player),bc      ; and back to player
323+  C20F 7B               ld a,e              ; now get the pixel count back
324+  C210 3D               dec a               ; decrease by one
325+  C211 21 22 C6         ld hl,player+5
326+  C214 77               ld (hl),a           ; copy back
327+  C215 CD 2D C8         call player_justmoved
328+  C218 C9               ret
329+  C219
330+  C219              ;
331+  C219              ; Moves the player up
332+  C219              ;
333+  C219              control_pl_moveup:
334+  C219 C5               push bc
335+  C21A ED 4B 1D C6      ld bc,(player)          ; get the current coords, b horiz, c vert
336+  C21E 79               ld a,c                  ; load c into the acc
337+  C21F FE 18            cp 24
338+  C221 CA 3F C2         jp z,control_pl_moveup0 ; are we at the edge of the screen
339+  C224 FE 60            cp 96
340+  C226 CC F9 C2         call z, control_scroll_up
341+  C229 CD A0 C4         call movement_checkcanmove_up ; check we can move up, e will be 1 if we can
342+  C22C F5               push af
343+  C22D 7B               ld a,e                  ; put e in a
344+  C22E FE 00            cp 0
345+  C230 CA 3E C2         jp z,control_pl_moveup1 ; don't move if we can't
346+  C233 F1               pop af
347+  C234 D6 01            sub 1                   ; subtract 1
348+  C236                  ;sub 1                   ; subtract 1
349+  C236 4F               ld c,a                  ; load back to c
350+  C237 ED 43 1D C6      ld (player),bc          ; load back to player
351+  C23B C3 3F C2         jp control_pl_moveup0
352+  C23E              control_pl_moveup1:
353+  C23E F1               pop af                  ; restore af if needed
354+  C23F              control_pl_moveup0:
355+  C23F 3E 00            ld a,0
356+  C241 32 1F C6         ld (player+2),a        ; set direction to up
357+  C244 C1               pop bc
358+  C245 C9               ret
359+  C246              ;
360+  C246              ; Moves the player down
361+  C246              ;
362+  C246              control_pl_movedown:
363+  C246 C5               push bc
364+  C247 ED 4B 1D C6      ld bc,(player)          ; get the current coords, b horiz, c vert
365+  C24B 79               ld a,c                  ; load c into the acc
366+  C24C FE E0            cp 224
367+  C24E CA 6B C2         jp z,control_pl_movedown0 ; are we at the edge of the screen
368+  C251 FE 80            cp 128
369+  C253 CC EC C2         call z, control_scroll_down
370+  C256 CD 74 C4         call movement_checkcanmove_down ; check we can move down, e will be 1 if we can
371+  C259 F5               push af
372+  C25A 7B               ld a,e                  ; put e in a
373+  C25B FE 00            cp 0
374+  C25D CA 6A C2         jp z,control_pl_movedown1 ; don't move if we can't
375+  C260 F1               pop af
376+  C261 3C               inc a                   ; add 1
377+  C262                  ;inc a                   ; add 1
378+  C262 4F               ld c,a                  ; load back to c
379+  C263 ED 43 1D C6      ld (player),bc          ; load back to player
380+  C267 C3 6B C2         jp control_pl_movedown0
381+  C26A              control_pl_movedown1:
382+  C26A F1               pop af                  ; restore af if needed
383+  C26B              control_pl_movedown0:
384+  C26B 3E 03            ld a,3
385+  C26D 32 1F C6         ld (player+2),a        ; set direction to down
386+  C270 C1               pop bc
387+  C271 C9               ret
388+  C272              ;
389+  C272              ; Moves the player left
390+  C272              ;
391+  C272              control_pl_moveleft:
392+  C272 C5               push bc
393+  C273 ED 4B 1D C6      ld bc,(player)          ; get the current coords, b horiz, c vert
394+  C277 78               ld a,b                  ; load b into the acc
395+  C278 FE 10            cp 16
396+  C27A CA 99 C2         jp z,control_pl_moveleft0 ; are we at the edge of the screen
397+  C27D CD FF C4         call movement_checkcanmove_left ; check we can move down, e will be 1 if we can
398+  C280 F5               push af
399+  C281 7B               ld a,e                  ; put e in a
400+  C282 FE 00            cp 0
401+  C284 CA 98 C2         jp z,control_pl_moveleft1 ; don't move if we can't
402+  C287 21 22 C6         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
403+  C28A 3E 07            ld a,7
404+  C28C 77               ld (hl),a
405+  C28D F1               pop af
406+  C28E D6 01            sub 1                    ; subtract 1
407+  C290 47              ld b,a                  ; load back to c
408+  C291 ED 43 1D C6      ld (player),bc          ; load back to player
409+  C295 C3 99 C2         jp control_pl_moveleft0
410+  C298              control_pl_moveleft1:
411+  C298 F1               pop af
412+  C299              control_pl_moveleft0:
413+  C299 3E 01            ld a,1
414+  C29B 32 1F C6         ld (player+2),a        ; set direction to left
415+  C29E C1               pop bc
416+  C29F C9               ret
417+  C2A0              ;
418+  C2A0              ; Moves the player right
419+  C2A0              ;
420+  C2A0              control_pl_moveright:
421+  C2A0 C5               push bc
422+  C2A1 ED 4B 1D C6      ld bc,(player)          ; get the current coords, b horiz, c vert
423+  C2A5 78               ld a,b                  ; load b into the acc
424+  C2A6 FE F0            cp 240
425+  C2A8 CA C6 C2         jp z,control_pl_moveright0 ; are we at the edge of the screen
426+  C2AB CD D3 C4         call movement_checkcanmove_right ; check we can move down, e will be 1 if we can
427+  C2AE F5               push af
428+  C2AF 7B               ld a,e                  ; put e in a
429+  C2B0 FE 00            cp 0
430+  C2B2 CA C5 C2         jp z,control_pl_moveright1 ; don't move if we can't
431+  C2B5 21 22 C6         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
432+  C2B8 3E 07            ld a,7
433+  C2BA 77               ld (hl),a
434+  C2BB F1               pop af
435+  C2BC 3C               inc a                   ; add 1
436+  C2BD 47               ld b,a                  ; load back to b
437+  C2BE ED 43 1D C6      ld (player),bc          ; load back to player
438+  C2C2 C3 C6 C2         jp control_pl_moveright0
439+  C2C5              control_pl_moveright1:
440+  C2C5 F1               pop af                  ; restore af if needed
441+  C2C6              control_pl_moveright0:
442+  C2C6 3E 02            ld a,2
443+  C2C8 32 1F C6         ld (player+2),a        ; set direction to right
444+  C2CB C1               pop bc
445+  C2CC C9               ret
446+  C2CD
447+  C2CD              ;
448+  C2CD              ; Player fires
449+  C2CD              ;
450+  C2CD              control_pl_fire:
451+  C2CD 3A 9C D7         ld a,(bullet_enable)
452+  C2D0 FE 00            cp 0
453+  C2D2 C0               ret nz                      ; don't shoot if the bullet isn't enabled
454+  C2D3 3A 1F C6         ld a,(player+2)         ; get player direction
455+  C2D6 FE 00            cp 0
456+  C2D8 C8               ret z
457+  C2D9 FE 03            cp 3
458+  C2DB C8               ret z                   ; if up or down, don't fire
459+  C2DC 3A 9B D7         ld a,(bullet_state+3)       ; get the state
460+  C2DF FE 01            cp 1
461+  C2E1 C8               ret z                   ; if currently firing, don't fire
462+  C2E2 CD 9D D7         call bullet_init        ; initialise the bullet
463+  C2E5 CD B2 D7         call bullet_shoot       ; shoot the bullet
464+  C2E8 CD FC B1         call sound_laser
465+  C2EB C9               ret
466+  C2EC
467+  C2EC              ;
468+  C2EC              ; Scrolls the screen down
469+  C2EC              ;
470+  C2EC              control_scroll_down:
471+  C2EC F5               push af
472+  C2ED 3E 08            ld a,8
473+  C2EF 32 F7 A8         ld (screen_offset),a
474+  C2F2 F1               pop af
475+  C2F3 21 44 A7         ld hl,buffer_updateall
476+  C2F6 36 01            ld (hl),1         ; flag as screen needing update
477+  C2F8 C9               ret
478+  C2F9
479+  C2F9              ;
480+  C2F9              ; Scrolls the screen up
481+  C2F9              ;
482+  C2F9              control_scroll_up:
483+  C2F9 F5               push af
484+  C2FA 3E 00            ld a,0
485+  C2FC 32 F7 A8         ld (screen_offset),a
486+  C2FF F1               pop af
487+  C300 21 44 A7         ld hl,buffer_updateall
488+  C303 36 01            ld (hl),1         ; flag as screen needing update
489+  C305 C9               ret
490+  C306
491+  C306
492+  C306
493+  C306
# file closed: game/control.asm
142   C306                  include "game\movement.asm"
# file opened: game/movement.asm
  1+  C306              ;
  2+  C306              ; The number of frames to dig for
  3+  C306              ;
  4+  C306              movement_numberdigframes:
  5+  C306 0A               defb 10
  6+  C307
  7+  C307              ;
  8+  C307              ; Checks the contents of a cell are empty - ie, all pixel rows are zero
  9+  C307              ; Inputs:
 10+  C307              ; hl - memory location of top pixel row
 11+  C307              ; bc - screen coords, b horiz, c vert
 12+  C307              ; Outputs:
 13+  C307              ; e - 0 if not empty, 1 if empty
 14+  C307              ;
 15+  C307              movement_spaceisempty:
 16+  C307 C5               push bc
 17+  C308 E5               push hl
 18+  C309 CD 31 C3         call movement_spaceisgem        ; check if space is a gem
 19+  C30C E1               pop hl
 20+  C30D C1               pop bc
 21+  C30E 7B               ld a,e
 22+  C30F FE 01            cp 1
 23+  C311 C8               ret z                           ; if e is 1, space is a gem so can move here, return
 24+  C312 3E 08            ld a,8                          ; 8 rows to check
 25+  C314              movement_spaceisempty0:
 26+  C314 08               ex af,af'                       ; store the loop counter
 27+  C315 7E               ld a,(hl)                       ; get current pixel row
 28+  C316 FE 00            cp 0
 29+  C318 C2 2C C3         jp nz, movement_spaceisempty1    ; row is not empty, can't move here
 30+  C31B 79               ld a,c                          ; load the vertical coord
 31+  C31C 3C               inc a                           ; next row down
 32+  C31D 11 20 00         ld de,32
 33+  C320 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 34+  C321 4F               ld c,a                          ; copy vert coord back to c
 35+  C322 08               ex af,af'                       ; get loop counter back
 36+  C323 3D               dec a                           ; decrease loop counter
 37+  C324 C2 14 C3         jp nz, movement_spaceisempty0
 38+  C327 16 00            ld d,0
 39+  C329 1E 01            ld e,1                          ; got to end, so space is empty
 40+  C32B C9               ret
 41+  C32C              movement_spaceisempty1:
 42+  C32C 16 00            ld d,0
 43+  C32E 1E 00            ld e,0                          ; returning false, ie space not empty
 44+  C330 C9               ret
 45+  C331
 46+  C331              ;
 47+  C331              ; Check if a space contains a gem
 48+  C331              ; Inputs:
 49+  C331              ; bc - screen coords
 50+  C331              ; Outputs:
 51+  C331              ; e = 1 if gem
 52+  C331              movement_spaceisgem:
 53+  C331 CD 57 AA         call screen_getcharcoordsfromscreencoords   ; get the char coords we're checking into bc
 54+  C334 21 E8 B8         ld hl,level_diamonds           ; check diamonds first
 55+  C337              movement_spaceisgem0:
 56+  C337 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 57+  C33B 7B               ld a,e                          ; check for end of data
 58+  C33C FE FF            cp 255
 59+  C33E CA 59 C3         jp z,movement_spaceisgem1       ; if yes, done with diamonds
 60+  C341 23               inc hl
 61+  C342 23               inc hl                          ; move to state
 62+  C343 7E               ld a,(hl)
 63+  C344 23               inc hl
 64+  C345 23               inc hl
 65+  C346 23               inc hl                          ; get to next
 66+  C347 FE 01            cp 1                            ; check if collected
 67+  C349 CA 37 C3         jp z,movement_spaceisgem0       ; if yes, move to next diamond
 68+  C34C 7B               ld a,e                          ; load e again
 69+  C34D B9               cp c                            ; otherwise, compare c with e
 70+  C34E C2 37 C3         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 71+  C351 7A               ld a,d                          ; get d coord
 72+  C352 B8               cp b                            ; compare b with d
 73+  C353 C2 37 C3         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 74+  C356 1E 01            ld e,1                          ; otherwise, exit with e = 1
 75+  C358 C9               ret
 76+  C359              movement_spaceisgem1:
 77+  C359 21 F8 B8         ld hl,level_gems              ; check gems
 78+  C35C              movement_spaceisgem2:
 79+  C35C 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 80+  C360 7B               ld a,e                          ; check for end of data
 81+  C361 FE FF            cp 255
 82+  C363 CA 7E C3         jp z,movement_spaceisgem3       ; if yes, done with gems
 83+  C366 23               inc hl
 84+  C367 23               inc hl                          ; move to state
 85+  C368 7E               ld a,(hl)
 86+  C369 23               inc hl
 87+  C36A 23               inc hl
 88+  C36B 23               inc hl                          ; get to next
 89+  C36C FE 01            cp 1                            ; check if collected
 90+  C36E CA 5C C3         jp z,movement_spaceisgem2       ; if yes, move to next diamond
 91+  C371 7B               ld a,e                          ; load e again
 92+  C372 B9               cp c                            ; otherwise, compare c with e
 93+  C373 C2 5C C3         jp nz,movement_spaceisgem2      ; if different, move to next gem
 94+  C376 7A               ld a,d                          ; get d coord
 95+  C377 B8               cp b                            ; compare b with d
 96+  C378 C2 5C C3         jp nz,movement_spaceisgem2      ; if different, move to next gem
 97+  C37B 1E 01            ld e,1                          ; otherwise, exit with e = 1
 98+  C37D C9               ret
 99+  C37E              movement_spaceisgem3:
100+  C37E 1E 00            ld e,0                          ; nothing found, return e = 0
101+  C380 C9               ret
102+  C381
103+  C381              ;
104+  C381              ; Checks the line of a cell below is empty - ie, first pixel rows is zero
105+  C381              ; Inputs:
106+  C381              ; hl - memory location of top pixel row
107+  C381              ; bc - screen coords, b horiz, c vert
108+  C381              ; Outputs:
109+  C381              ; e - 0 if not empty, 1 if empty
110+  C381              ;
111+  C381              movement_linebelowisempty:
112+  C381 C5               push bc
113+  C382 E5               push hl
114+  C383 CD 31 C3         call movement_spaceisgem        ; check if space is a gem
115+  C386 E1               pop hl
116+  C387 C1               pop bc
117+  C388 7B               ld a,e
118+  C389 FE 01            cp 1
119+  C38B C8               ret z                           ; if e is 1, space is a gem so can move here, return
120+  C38C 7E               ld a,(hl)                       ; get current pixel row
121+  C38D FE 00            cp 0
122+  C38F C2 97 C3         jp nz, movement_linebelowisempty1    ; row is not empty, can't move here
123+  C392 16 00            ld d,0
124+  C394 1E 01            ld e,1                          ; got to end, so space is empty
125+  C396 C9               ret
126+  C397              movement_linebelowisempty1:
127+  C397 16 00            ld d,0
128+  C399 1E 00            ld e,0                          ; returning false, ie space not empty
129+  C39B C9               ret
130+  C39C
131+  C39C              ;
132+  C39C              ; Checks the line of a cell above is empty - ie, last pixel rows are zero
133+  C39C              ; Inputs:
134+  C39C              ; hl - memory location of top pixel row
135+  C39C              ; bc - screen coords, b horiz, c vert
136+  C39C              ; Outputs:
137+  C39C              ; e - 0 if not empty, 1 if empty
138+  C39C              ;
139+  C39C              movement_lineaboveisempty:
140+  C39C C5               push bc
141+  C39D E5               push hl
142+  C39E CD 31 C3         call movement_spaceisgem        ; check if space is a gem
143+  C3A1 E1               pop hl
144+  C3A2 C1               pop bc
145+  C3A3 7B               ld a,e
146+  C3A4 FE 01            cp 1
147+  C3A6 C8               ret z
148+  C3A7 7E               ld a,(hl)                       ; get current pixel row
149+  C3A8 FE 00            cp 0
150+  C3AA C2 B2 C3         jp nz, movement_lineaboveisempty1    ; row is not empty, can't move here
151+  C3AD 16 00            ld d,0
152+  C3AF 1E 01            ld e,1                          ; got to end, so space is empty
153+  C3B1 C9               ret
154+  C3B2              movement_lineaboveisempty1:
155+  C3B2 16 00            ld d,0
156+  C3B4 1E 00            ld e,0                          ; returning false, ie space not empty
157+  C3B6 C9               ret
158+  C3B7
159+  C3B7              ;
160+  C3B7              ; Checks the contents of a cell are diggable - ie, all pixel rows are dirt or empty
161+  C3B7              ; Inputs:
162+  C3B7              ; hl - memory location of top pixel row
163+  C3B7              ; bc - screen coords, b horiz, c vert
164+  C3B7              ; Outputs:
165+  C3B7              ; none - puts player into digging mode
166+  C3B7              ;
167+  C3B7              movement_spaceisdiggable:
168+  C3B7 3E 08            ld a,8                          ; 8 rows to check
169+  C3B9              movement_spaceisdiggable0:
170+  C3B9 08               ex af,af'                       ; store the loop counter
171+  C3BA 7E               ld a,(hl)                       ; get current pixel row
172+  C3BB FE 00            cp 0
173+  C3BD CA CD C3         jp z, movement_spaceisdiggable2  ; row is empty, can dig here
174+  C3C0 FE 55            cp 85
175+  C3C2 CA CD C3         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
176+  C3C5 FE AA            cp 170
177+  C3C7 CA CD C3         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
178+  C3CA C3 E7 C3         jp movement_spaceisdiggable1     ; otherwise, stop checking
179+  C3CD              movement_spaceisdiggable2:
180+  C3CD 79               ld a,c                          ; load the vertical coord
181+  C3CE 3C               inc a                           ; next row down
182+  C3CF 11 20 00         ld de,32
183+  C3D2 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
184+  C3D3 4F               ld c,a                          ; copy vert coord back to c
185+  C3D4 08               ex af,af'                       ; get loop counter back
186+  C3D5 3D               dec a                           ; decrease loop counter
187+  C3D6 C2 B9 C3         jp nz, movement_spaceisdiggable0
188+  C3D9 21 23 C6         ld hl,player+6
189+  C3DC 36 01            ld (hl),1                       ; set the player into digging mode
190+  C3DE 23               inc hl
191+  C3DF 3A 06 C3         ld a,(movement_numberdigframes)
192+  C3E2 77               ld (hl),a                       ; set the number of frame to dig for
193+  C3E3 23               inc hl
194+  C3E4 36 08            ld (hl),8                       ; set the number of pixels to dig
195+  C3E6 C9               ret
196+  C3E7              movement_spaceisdiggable1:
197+  C3E7 21 23 C6         ld hl,player+6
198+  C3EA 36 00            ld (hl),0                       ; set the player out of digging mode
199+  C3EC C9               ret
200+  C3ED
201+  C3ED              ;
202+  C3ED              ; Checks the contents of a cell below are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
203+  C3ED              ; Inputs:
204+  C3ED              ; hl - memory location of top pixel row
205+  C3ED              ; bc - screen coords, b horiz, c vert
206+  C3ED              ; Outputs:
207+  C3ED              ; none - puts player into digging mode
208+  C3ED              ;
209+  C3ED              movement_spacebelowisdiggable:
210+  C3ED 7E               ld a,(hl)                       ; get first pixel row
211+  C3EE FE 55            cp 85
212+  C3F0 CA FB C3         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
213+  C3F3 FE AA            cp 170
214+  C3F5 CA FB C3         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
215+  C3F8 C3 E7 C3         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
216+  C3FB              movement_spacebelowisdiggable3:
217+  C3FB 3E 08            ld a,8                          ; rows to check
218+  C3FD 1E 00            ld e,0                          ; count of rows to dig
219+  C3FF              movement_spacebelowisdiggable0:
220+  C3FF 08               ex af,af'                       ; store the loop counter
221+  C400 7E               ld a,(hl)                       ; get current pixel row
222+  C401 FE 55            cp 85
223+  C403 CA 0E C4         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
224+  C406 FE AA            cp 170
225+  C408 CA 0E C4         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
226+  C40B C3 1D C4         jp movement_spacebelowisdiggable5     ; don't count this row and stop counting
227+  C40E              movement_spacebelowisdiggable4:
228+  C40E 1C               inc e                           ; inc count of rows to dig
229+  C40F              movement_spacebelowisdiggable2:
230+  C40F 79               ld a,c                          ; load the vertical coord
231+  C410 3C               inc a                           ; next row down
232+  C411 D5               push de                         ; need e for later
233+  C412 11 20 00         ld de,32
234+  C415 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
235+  C416 4F               ld c,a                          ; copy vert coord back to c
236+  C417 D1               pop de                          ; get e back
237+  C418 08               ex af,af'                       ; get loop counter back
238+  C419 3D               dec a                           ; incease loop counter
239+  C41A C2 FF C3         jp nz, movement_spacebelowisdiggable0
240+  C41D              movement_spacebelowisdiggable5:
241+  C41D 21 23 C6         ld hl,player+6
242+  C420 36 01            ld (hl),1                       ; set the player into digging mode
243+  C422 23               inc hl
244+  C423 3A 06 C3         ld a,(movement_numberdigframes)
245+  C426 77               ld (hl),a                       ; set the number of frame to dig for
246+  C427 23               inc hl
247+  C428 73               ld (hl),e                       ; set the number of pixels to dig
248+  C429 C9               ret
249+  C42A              movement_spacebelowisdiggable1:
250+  C42A 21 23 C6         ld hl,player+6
251+  C42D 36 00            ld (hl),0                       ; set the player out of digging mode
252+  C42F C9               ret
253+  C430
254+  C430              ;
255+  C430              ; Checks the contents of a cell above are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
256+  C430              ; Inputs:
257+  C430              ; hl - memory location of top pixel row
258+  C430              ; bc - screen coords, b horiz, c vert
259+  C430              ; Outputs:
260+  C430              ; none - puts player into digging mode
261+  C430              ;
262+  C430              movement_spaceaboveisdiggable:
263+  C430 7E               ld a,(hl)                       ; get first pixel row
264+  C431 FE 55            cp 85
265+  C433 CA 3E C4         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
266+  C436 FE AA            cp 170
267+  C438 CA 3E C4         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
268+  C43B C3 E7 C3         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
269+  C43E              movement_spaceaboveisdiggable3:
270+  C43E 3E 08            ld a,8                          ; rows to check
271+  C440 1E 00            ld e,0                          ; count of rows to dig
272+  C442              movement_spaceaboveisdiggable0:
273+  C442 08               ex af,af'                       ; store the loop counter
274+  C443 7E               ld a,(hl)                       ; get current pixel row
275+  C444 FE 55            cp 85
276+  C446 CA 51 C4         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
277+  C449 FE AA            cp 170
278+  C44B CA 51 C4         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
279+  C44E C3 61 C4         jp movement_spaceaboveisdiggable5     ; don't count this row and stop counting
280+  C451              movement_spaceaboveisdiggable4:
281+  C451 1C               inc e                           ; inc count of rows to dig
282+  C452              movement_spaceaboveisdiggable2:
283+  C452 79               ld a,c                          ; load the vertical coord
284+  C453 3D               dec a                           ; next row up
285+  C454 D5               push de                         ; need e for later
286+  C455 11 20 00         ld de,32
287+  C458 ED 52            sbc hl,de                       ; otherwise, just go one up for hl, which means sub 32, because of course
288+  C45A 4F               ld c,a                          ; copy vert coord back to c
289+  C45B D1               pop de                          ; get e back
290+  C45C 08               ex af,af'                       ; get loop counter back
291+  C45D 3D               dec a                           ; incease loop counter
292+  C45E C2 42 C4         jp nz, movement_spaceaboveisdiggable0
293+  C461              movement_spaceaboveisdiggable5:
294+  C461 21 23 C6         ld hl,player+6
295+  C464 36 01            ld (hl),1                       ; set the player into digging mode
296+  C466 23               inc hl
297+  C467 3A 06 C3         ld a,(movement_numberdigframes)
298+  C46A 77               ld (hl),a                       ; set the number of frame to dig for
299+  C46B 23               inc hl
300+  C46C 73               ld (hl),e                       ; set the number of pixels to dig
301+  C46D C9               ret
302+  C46E              movement_spaceaboveisdiggable1:
303+  C46E 21 23 C6         ld hl,player+6
304+  C471 36 00            ld (hl),0                       ; set the player out of digging mode
305+  C473 C9               ret
306+  C474
307+  C474              ;
308+  C474              ; Checks if the player can move down
309+  C474              ; Inputs:
310+  C474              ; bc - player coords, b horiz, c vert
311+  C474              ; Outputs:
312+  C474              ; de - 1 can move
313+  C474              movement_checkcanmove_down:
314+  C474 F5               push af
315+  C475 C5               push bc
316+  C476 CD 36 AC         call sprites_scadd              ; get the memory location of cell into de
317+  C479 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
318+  C47B 24               inc h                       ; memory location of cell beneath now in hl
319+  C47C 3E 08            ld a,8                       ; look below
320+  C47E 81               add c
321+  C47F 4F               ld c,a
322+  C480 CD 81 C3         call movement_linebelowisempty       ; check space is empty
323+  C483 7B               ld a,e                          ; check space empty flag
324+  C484 FE 00            cp 0
325+  C486 CA 8F C4         jp z, movement_checkcanmove_down1 ; can't move
326+  C489 CD 2D C8         call player_justmoved
327+  C48C C1               pop bc
328+  C48D F1               pop af
329+  C48E C9               ret
330+  C48F              movement_checkcanmove_down1:
331+  C48F C1               pop bc
332+  C490 CD 36 AC         call sprites_scadd              ; get the memory location of cell into de
333+  C493 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
334+  C495 24               inc h
335+  C496 C5               push bc
336+  C497 CD ED C3         call movement_spacebelowisdiggable    ; can't move here, but can we dig
337+  C49A 11 00 00         ld de,0
338+  C49D C1               pop bc
339+  C49E F1               pop af
340+  C49F C9               ret
341+  C4A0
342+  C4A0              ;
343+  C4A0              ; Checks if the player can move up
344+  C4A0              ; Inputs:
345+  C4A0              ; bc - player coords, b horiz, c vert
346+  C4A0              ; Outputs:
347+  C4A0              ; de - 1 can move
348+  C4A0              movement_checkcanmove_up:
349+  C4A0 F5               push af
350+  C4A1 C5               push bc
351+  C4A2 CD 36 AC         call sprites_scadd              ; get the memory location of cell into de
352+  C4A5 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
353+  C4A7 11 20 00         ld de,32
354+  C4AA ED 52            sbc hl,de                       ; memory location of line above now in hl
355+  C4AC 0D               dec c                           ; look above
356+  C4AD CD 9C C3         call movement_lineaboveisempty       ; check space is empty
357+  C4B0 7B               ld a,e                          ; check space empty flag
358+  C4B1 FE 00            cp 0
359+  C4B3 CA BE C4         jp z, movement_checkcanmove_up1 ; can't move
360+  C4B6 1E 01            ld e,1
361+  C4B8 CD 2D C8         call player_justmoved
362+  C4BB C1               pop bc
363+  C4BC F1               pop af
364+  C4BD C9               ret
365+  C4BE              movement_checkcanmove_up1:
366+  C4BE C1               pop bc
367+  C4BF CD 36 AC         call sprites_scadd              ; get the memory location of cell into de
368+  C4C2 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
369+  C4C4 11 20 00         ld de,32
370+  C4C7 ED 52            sbc hl,de                       ; memory location of line above now in hl
371+  C4C9 C5               push bc
372+  C4CA CD 30 C4         call movement_spaceaboveisdiggable    ; can't move here, but can we dig
373+  C4CD 11 00 00         ld de,0
374+  C4D0 C1               pop bc
375+  C4D1 F1               pop af
376+  C4D2 C9               ret
377+  C4D3
378+  C4D3              ;
379+  C4D3              ; Checks if the player can move right
380+  C4D3              ; Inputs:
381+  C4D3              ; bc - player coords, b horiz, c vert
382+  C4D3              ; Outputs:
383+  C4D3              ; de - 1 can move
384+  C4D3              movement_checkcanmove_right:
385+  C4D3 F5               push af
386+  C4D4 C5               push bc
387+  C4D5 CD 36 AC         call sprites_scadd              ; get the memory location of cell into de
388+  C4D8 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
389+  C4DA 3E 08            ld a,8
390+  C4DC 80               add b                           ; move one cell right
391+  C4DD 47               ld b,a
392+  C4DE 23               inc hl                          ; memory location of cell to the right now in hl
393+  C4DF CD 07 C3         call movement_spaceisempty       ; check space is empty
394+  C4E2 7B               ld a,e                          ; check space empty flag
395+  C4E3 FE 00            cp 0
396+  C4E5 CA EE C4         jp z, movement_checkcanmove_right1 ; can't move
397+  C4E8 CD 2D C8         call player_justmoved
398+  C4EB C1               pop bc
399+  C4EC F1               pop af
400+  C4ED C9               ret
401+  C4EE              movement_checkcanmove_right1:
402+  C4EE C1               pop bc
403+  C4EF CD 36 AC         call sprites_scadd              ; get the memory location of cell into de
404+  C4F2 62 6B            ld hl,de
405+  C4F4 23               inc hl                          ; memory location of cell to the right now in hl
406+  C4F5 C5               push bc
407+  C4F6 CD B7 C3         call movement_spaceisdiggable    ; can't move here, but can we dig
408+  C4F9 11 00 00         ld de,0
409+  C4FC C1               pop bc
410+  C4FD F1               pop af
411+  C4FE C9               ret
412+  C4FF
413+  C4FF              ;
414+  C4FF              ; Checks if the player can move left
415+  C4FF              ; Inputs:
416+  C4FF              ; bc - player coords, b horiz, c vert
417+  C4FF              ; Outputs:
418+  C4FF              ; de - 1 can move
419+  C4FF              movement_checkcanmove_left:
420+  C4FF F5               push af
421+  C500 C5               push bc
422+  C501 CD 36 AC         call sprites_scadd              ; get the memory location of cell into de
423+  C504 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
424+  C506 78               ld a,b
425+  C507 06 08            ld b,8
426+  C509 90               sub b                           ; move one cell left
427+  C50A 47               ld b,a
428+  C50B 2B               dec hl                          ; memory location of cell to the right now in hl
429+  C50C CD 07 C3         call movement_spaceisempty       ; check space is empty
430+  C50F 7B               ld a,e                          ; check space empty flag
431+  C510 FE 00            cp 0
432+  C512 CA 1B C5         jp z, movement_checkcanmove_left1 ; can't move
433+  C515 CD 2D C8         call player_justmoved
434+  C518 C1               pop bc
435+  C519 F1               pop af
436+  C51A C9               ret
437+  C51B              movement_checkcanmove_left1:
438+  C51B C1               pop bc
439+  C51C CD 36 AC         call sprites_scadd              ; get the memory location of cell into de
440+  C51F 62 6B            ld hl,de
441+  C521 2B               dec hl                          ; memory location of cell to the right now in hl
442+  C522 C5               push bc
443+  C523 CD B7 C3         call movement_spaceisdiggable    ; can't move here, but can we dig
444+  C526 11 00 00         ld de,0
445+  C529 C1               pop bc
446+  C52A F1               pop af
447+  C52B C9               ret
# file closed: game/movement.asm
143   C52C                  include "game\game.asm"
# file opened: game/game.asm
  1+  C52C              ;
  2+  C52C              ; The current frame count, incremented each frame
  3+  C52C              ;
  4+  C52C              game_framenumber:
  5+  C52C 00               defb    0
  6+  C52D
  7+  C52D              ;
  8+  C52D              ; The number of players
  9+  C52D              ;
 10+  C52D              game_numberplayers:
 11+  C52D 01               defb 1
 12+  C52E
 13+  C52E              ;
 14+  C52E              ; The current player
 15+  C52E              ;
 16+  C52E              game_currentplayer:
 17+  C52E 01               defb 1
 18+  C52F
 19+  C52F              ;
 20+  C52F              ; The default number of lives
 21+  C52F              ;
 22+  C52F              game_numberlives:
 23+  C52F 04               defb 4
 24+  C530
 25+  C530              ;
 26+  C530              ; The current difficulty
 27+  C530              ;
 28+  C530              game_difficulty:
 29+  C530 01               defb 1
 30+  C531
 31+  C531              ;
 32+  C531              ; Control method: 0 for keyboard, 1 for kempston
 33+  C531              ;
 34+  C531              game_control:
 35+  C531 00               defb 0
 36+  C532
 37+  C532              ;
 38+  C532              ; The current rocks used
 39+  C532              ;
 40+  C532              game_current_rocks:
 41+  C532 00 00            defb 0,0
 42+  C534
 43+  C534
 44+  C534              game_tankdifficulty:
 45+  C534 46 41 3C 37      defb 70,65,60,55,50,45,40,35,30,25,20,12
 45+  C538 32 2D 28 23
 45+  C53C 1E 19 14 0C
 46+  C540              game_pitdifficulty:
 47+  C540 07 07 06 06      defb 7,7,6,6,5,5,5,5,4,4,3,3
 47+  C544 05 05 05 05
 47+  C548 04 04 03 03
 48+  C54C              game_robotdifficulty:
 49+  C54C 06 06 04 04      defb 6,6,4,4,3,3,2,2,0,0,0,0
 49+  C550 03 03 02 02
 49+  C554 00 00 00 00
 50+  C558              game_digdifficulty:
 51+  C558 14 14 0A 0A      defb 20,20,10,10,8,8,8,8,6,6,6,4
 51+  C55C 08 08 08 08
 51+  C560 06 06 06 04
 52+  C564              game_rockdifficulty:
 53+  C564 28 28 1E 1E      defb 40,40,30,30,26,26,26,26,26,26,26,26
 53+  C568 1A 1A 1A 1A
 53+  C56C 1A 1A 1A 1A
 54+  C570              game_missiledifficulty:
 55+  C570 28 28 23 23      defb 40,40,35,35,32,32,30,30,25,25,23,20
 55+  C574 20 20 1E 1E
 55+  C578 19 19 17 14
 56+  C57C              ;
 57+  C57C              ; Moves to the next player
 58+  C57C              ;
 59+  C57C              game_changeplayer:
 60+  C57C 3A 2D C5         ld a,(game_numberplayers)
 61+  C57F FE 01            cp 1
 62+  C581 C8               ret z                       ; if just one player, no need to change
 63+  C582 3A 2E C5         ld a,(game_currentplayer)   ; get current player
 64+  C585 3D               dec a                       ; otherwise decrease by one
 65+  C586 EE 01            xor 1                       ; xor with one to flip
 66+  C588 3C               inc a                       ; increment
 67+  C589 21 2E C5         ld hl,game_currentplayer
 68+  C58C 77               ld (hl),a                   ; store
 69+  C58D C9               ret
 70+  C58E
 71+  C58E              ;
 72+  C58E              ; Sets the number of players at the start of the game
 73+  C58E              ; Inputs:
 74+  C58E              ; a - number of players
 75+  C58E              game_setnumberofplayers:
 76+  C58E 21 2D C5         ld hl,game_numberplayers
 77+  C591 77               ld (hl),a
 78+  C592
 79+  C592              ;
 80+  C592              ; Starts a game
 81+  C592              ;
 82+  C592              game_init:
 83+  C592 3E 01            ld a,1
 84+  C594 32 2E C5         ld (game_currentplayer),a
 85+  C597 C9               ret
 86+  C598
 87+  C598              ;
 88+  C598              ; Sets the current rock layout. Odd gets 1, even gets 2
 89+  C598              ;
 90+  C598              game_setcurrentrocks:
 91+  C598 3A 30 C5         ld a,(game_difficulty)
 92+  C59B E6 01            and 1
 93+  C59D FE 00            cp 0
 94+  C59F CA AD C5         jp z,game_setcurrentrocks0
 95+  C5A2 11 88 B6         ld de,level_rocks
 96+  C5A5 21 32 C5         ld hl,game_current_rocks
 97+  C5A8 73 23 72 2B      ld (hl),de
 98+  C5AC C9               ret
 99+  C5AD              game_setcurrentrocks0:
100+  C5AD 11 88 B7         ld de,level_rocks_alt
101+  C5B0 21 32 C5         ld hl,game_current_rocks
102+  C5B3 73 23 72 2B      ld (hl),de
103+  C5B7 C9               ret
104+  C5B8
105+  C5B8              ;
106+  C5B8              ; Increment frame number by 1
107+  C5B8              ;
108+  C5B8              game_incrementframe:
109+  C5B8 3A 2C C5         ld a,(game_framenumber)
110+  C5BB FE FF            cp 255
111+  C5BD C2 C2 C5         jp nz,game_incrementframe0
112+  C5C0 3E 00            ld a,0
113+  C5C2              game_incrementframe0:
114+  C5C2 3C               inc a
115+  C5C3 32 2C C5         ld (game_framenumber),a
116+  C5C6 C9               ret
117+  C5C7
118+  C5C7              ;
119+  C5C7              ; Returns current frame
120+  C5C7              ; Outputs:
121+  C5C7              ; a - current frame
122+  C5C7              ;
123+  C5C7              game_getcurrentframe:
124+  C5C7 3A 2C C5         ld a,(game_framenumber)
125+  C5CA C9               ret
126+  C5CB
127+  C5CB              ;
128+  C5CB              ; Resets current frame
129+  C5CB              ;
130+  C5CB              game_resetcurrentframe:
131+  C5CB 21 2C C5         ld hl,game_framenumber
132+  C5CE 36 00            ld (hl),0
133+  C5D0 C9               ret
134+  C5D1
135+  C5D1              ;
136+  C5D1              ; Increases the current difficulty
137+  C5D1              ;
138+  C5D1              game_increasedifficulty:
139+  C5D1 3A 30 C5         ld a,(game_difficulty)
140+  C5D4 3C               inc a
141+  C5D5 32 30 C5         ld (game_difficulty),a
142+  C5D8
143+  C5D8              ;
144+  C5D8              ; Sets the various difficulties
145+  C5D8              ;
146+  C5D8              game_setdifficulty:
147+  C5D8 3A 30 C5         ld a,(game_difficulty)
148+  C5DB FE 0D            cp 13
149+  C5DD C2 E2 C5         jp nz,game_setdifficulty0
150+  C5E0 3E 0C            ld a,12                         ; limit difficulty to twelve
151+  C5E2              game_setdifficulty0:
152+  C5E2 11 00 00         ld de,0
153+  C5E5 5F               ld e,a                          ; keep the difficulty in de
154+  C5E6                  ; Set the tank difficulty
155+  C5E6 21 34 C5         ld hl,game_tankdifficulty
156+  C5E9 2B               dec hl
157+  C5EA 19               add hl,de                       ; add the difficulty
158+  C5EB 7E               ld a,(hl)                       ; get the value
159+  C5EC 32 E0 C9         ld (tank_speed),a               ; set the tank speed
160+  C5EF                  ; Set the pit difficulty
161+  C5EF 21 40 C5         ld hl,game_pitdifficulty
162+  C5F2 2B               dec hl
163+  C5F3 19               add hl,de                       ; add the difficulty
164+  C5F4 7E               ld a,(hl)                       ; get the value
165+  C5F5 32 B1 D1         ld (thepit_speed),a               ; set the pit speed
166+  C5F8                  ; Set the robot difficulty
167+  C5F8 21 4C C5         ld hl,game_robotdifficulty
168+  C5FB 2B               dec hl
169+  C5FC 19               add hl,de                       ; add the difficulty
170+  C5FD 7E               ld a,(hl)                       ; get the value
171+  C5FE 32 8E D3         ld (robots_robotspeed),a        ; set the robot speed
172+  C601                  ; Set the dig difficulty
173+  C601 21 58 C5         ld hl,game_digdifficulty
174+  C604 2B               dec hl
175+  C605 19               add hl,de                       ; add the difficulty
176+  C606 7E               ld a,(hl)                       ; get the value
177+  C607 32 06 C3         ld (movement_numberdigframes),a ; set the dig frames
178+  C60A                  ; Set the rock difficulty
179+  C60A 21 64 C5         ld hl,game_rockdifficulty
180+  C60D 2B               dec hl
181+  C60E 19               add hl,de                       ; add the difficulty
182+  C60F 7E               ld a,(hl)                       ; get the value
183+  C610 32 FB CB         ld (rocks_numberofframestowobble),a ; set the wobble frames
184+  C613                  ; Set the missile difficulty
185+  C613 21 70 C5         ld hl,game_missiledifficulty
186+  C616 2B               dec hl
187+  C617 19               add hl,de                       ; add the difficulty
188+  C618 7E               ld a,(hl)                       ; get the value
189+  C619 32 ED CF         ld (missiles_speed),a           ; set the missile difficulty
190+  C61C C9               ret
# file closed: game/game.asm
144   C61D                  include "game\player.asm"
# file opened: game/player.asm
  1+  C61D              ;
  2+  C61D              ;   Data for current player
  3+  C61D              ;
  4+  C61D              player:
  5+  C61D 00 00            defb    0,0                 ; horiz,vert (+0,+1)
  6+  C61F 02 00 01         defb    2,0,1               ; dir (0 up, 1 left, 2 right, 3 down), frame, frame transition count (+2,+3,+4)
  7+  C622 00               defb    0                   ; auto move remaining (+5)
  8+  C623 00 00 00         defb    0,0,0               ; is digging (0 no), digging count, pixels to di (+6,+7,+8)
  9+  C626 00               defb    0                   ; lives remaining (+9)
 10+  C627 00               defb    0                   ; died this life (+10)
 11+  C628 00 00            defb    0,0                 ; dying (+11), frames (+12)
 12+  C62A 00               defb    0                   ; can finish level, whether can finish level or not (+13)
 13+  C62B 00               defb    0                   ; difficulty (+14)
 14+  C62C
 15+  C62C              player_location:
 16+  C62C 00               defb 0                      ; 0 normal, 1 diamond cavern, 2 the pit
 17+  C62D
 18+  C62D              ;
 19+  C62D              ; Works out which part of the screen the player is in
 20+  C62D              ; Pit is between 3,9 and 8,9
 21+  C62D              ; Diamond cavern is between 11,22 and 22,28
 22+  C62D              ;
 23+  C62D              player_getlocation:
 24+  C62D ED 4B 1D C6      ld bc,(player)              ; get screen coords
 25+  C631 CD 57 AA         call screen_getcharcoordsfromscreencoords ; get char coords, c horiz
 26+  C634 78               ld a,b                      ; check for pit first
 27+  C635 FE 09            cp 9                        ; if not on this row, not in the pit
 28+  C637 C2 46 C6         jp nz,player_getlocation0
 29+  C63A 79               ld a,c                      ; check horizontal
 30+  C63B FE 09            cp 9
 31+  C63D D2 46 C6         jp nc, player_getlocation0  ; if more than 9, not in the pit
 32+  C640 21 2C C6         ld hl,player_location
 33+  C643 36 02            ld (hl),2                   ; load location with 2, the pit
 34+  C645 C9               ret                         ; done
 35+  C646              player_getlocation0:            ; check for diamond cavern
 36+  C646 78               ld a,b                      ; first check vertical
 37+  C647 FE 16            cp 22                       ; if above row 22, then not in cavern
 38+  C649 DA 5D C6         jp c,player_getlocation1
 39+  C64C 79               ld a,c                      ; get the horizontal next
 40+  C64D FE 0B            cp 11
 41+  C64F DA 5D C6         jp c,player_getlocation1    ; if less than 11 not in diamond cave
 42+  C652 FE 17            cp 23
 43+  C654 D2 5D C6         jp nc,player_getlocation1    ; if less than 11 not in diamond cave
 44+  C657 21 2C C6         ld hl,player_location
 45+  C65A 36 01            ld (hl),1                   ; load location with 1, the cavern
 46+  C65C C9               ret
 47+  C65D              player_getlocation1:
 48+  C65D 21 2C C6         ld hl,player_location
 49+  C660 36 00            ld (hl),0                   ; load location with 2, the pit
 50+  C662 C9               ret                         ; done
 51+  C663
 52+  C663
 53+  C663              ;
 54+  C663              ; Initializes a player at start of game
 55+  C663              ; Copy initial coords, copy lives, copy score
 56+  C663              ;
 57+  C663              player_init_gamestart:
 58+  C663 3E 01            ld a,1
 59+  C665 32 2E C5         ld (game_currentplayer),a
 60+  C668 3A 2F C5         ld a,(game_numberlives)
 61+  C66B 32 29 C7         ld (player1_lives),a
 62+  C66E 32 2A C7         ld (player2_lives),a                        ; set the initial number of lives at game start
 63+  C671
 64+  C671 21 2D C7         ld hl,player1_score+2
 65+  C674 06 06            ld b,6
 66+  C676              player_init_gamestart0:
 67+  C676 36 30            ld (hl),48
 68+  C678 23               inc hl
 69+  C679 10 FB            djnz player_init_gamestart0                 ; zero out player 1 score
 70+  C67B 21 36 C7         ld hl,player2_score+2
 71+  C67E 06 06            ld b,6
 72+  C680              player_init_gamestart1:
 73+  C680 36 30            ld (hl),48
 74+  C682 23               inc hl
 75+  C683 10 FB            djnz player_init_gamestart1                 ; zero out player 2 score
 76+  C685 3E 01            ld a,1
 77+  C687 32 3D C7         ld (player1_difficulty),a
 78+  C68A 32 3E C7         ld (player2_difficulty),a                   ; set player difficulties to zero
 79+  C68D C9               ret
 80+  C68E
 81+  C68E              ;
 82+  C68E              ; Initializes a player at start of a life
 83+  C68E              ; Copy initial coords, copy lives, copy score
 84+  C68E              ;
 85+  C68E              player_init_lifestart:
 86+  C68E 21 22 C6         ld hl,player+5
 87+  C691 06 09            ld b,9                      ; initialise 9 properties
 88+  C693              player_init_lifestart2:
 89+  C693 36 00            ld (hl),0
 90+  C695 23               inc hl
 91+  C696 10 FB            djnz player_init_lifestart2
 92+  C698
 93+  C698 21 1F C6         ld hl,player+2              ; initialise some properties
 94+  C69B 36 02            ld (hl),2
 95+  C69D 23               inc hl
 96+  C69E 36 00            ld (hl),0
 97+  C6A0 23               inc hl
 98+  C6A1 36 01            ld (hl),1
 99+  C6A3
100+  C6A3 ED 4B EB 80      ld bc,(init_coord)
101+  C6A7 ED 43 1D C6      ld (player),bc
102+  C6AB
103+  C6AB 3A 2E C5         ld a,(game_currentplayer)
104+  C6AE FE 01            cp 1
105+  C6B0 C2 BD C6         jp nz,player_init_lifestart4
106+  C6B3 01 26 C6         ld bc,player+9
107+  C6B6 3A 29 C7         ld a,(player1_lives)
108+  C6B9 02               ld (bc),a
109+  C6BA C3 C4 C6         jp player_init_lifestart3
110+  C6BD              player_init_lifestart4:
111+  C6BD 01 26 C6         ld bc,player+9
112+  C6C0 3A 2A C7         ld a,(player2_lives)
113+  C6C3 02               ld (bc),a
114+  C6C4              player_init_lifestart3:
115+  C6C4 CD B5 CF         call diamonds_init      ; initialise gems
116+  C6C7 01 06 00         ld bc,6
117+  C6CA 11 5E CD         ld de,scores_current+2
118+  C6CD 3A 2E C5         ld a,(game_currentplayer)
119+  C6D0 FE 01            cp 1
120+  C6D2 C2 E1 C6         jp nz,player_init_lifestart0
121+  C6D5 3A 3D C7         ld a,(player1_difficulty)       ; initialise player 1 difficulty
122+  C6D8 32 30 C5         ld (game_difficulty),a
123+  C6DB 21 2D C7         ld hl,player1_score+2           ; itialise player 1 scores
124+  C6DE C3 EA C6         jp player_init_lifestart1
125+  C6E1              player_init_lifestart0:
126+  C6E1 3A 3E C7         ld a,(player2_difficulty)       ; initialise player 2 difficulty
127+  C6E4 32 30 C5         ld (game_difficulty),a
128+  C6E7 21 36 C7         ld hl,player2_score+2           ; initialise player 2 scores
129+  C6EA              player_init_lifestart1:
130+  C6EA ED B0            ldir
131+  C6EC C9               ret
132+  C6ED
133+  C6ED
134+  C6ED              ;
135+  C6ED              ; Copies the current score and difficulty in the current player
136+  C6ED              ;
137+  C6ED              player_recordcurrentstate:
138+  C6ED 01 06 00         ld bc,6                  ; copy current score back to correct player
139+  C6F0 21 5E CD         ld hl,scores_current+2
140+  C6F3 3A 2E C5         ld a,(game_currentplayer)
141+  C6F6 FE 01            cp 1
142+  C6F8 C2 0D C7         jp nz,player_recordcurrentstate0
143+  C6FB 3A 30 C5         ld a,(game_difficulty)
144+  C6FE 32 3D C7         ld (player1_difficulty),a       ; store difficulty
145+  C701 11 2D C7         ld de,player1_score+2
146+  C704 3A 26 C6         ld a,(player+9)
147+  C707 32 29 C7         ld (player1_lives),a              ; record lives
148+  C70A C3 1C C7         jp player_recordcurrentstate1
149+  C70D              player_recordcurrentstate0:         ; do player 2
150+  C70D 3A 30 C5         ld a,(game_difficulty)
151+  C710 32 3E C7         ld (player2_difficulty),a       ; store difficulty
152+  C713 3A 26 C6         ld a,(player+9)
153+  C716 32 2A C7         ld (player2_lives),a              ; record lives
154+  C719 11 36 C7         ld de,player2_score+2
155+  C71C              player_recordcurrentstate1:
156+  C71C ED B0            ldir
157+  C71E C9               ret
158+  C71F
159+  C71F              ;
160+  C71F              ; Player just died, subtract a life
161+  C71F              ;
162+  C71F              player_died:
163+  C71F 01 26 C6         ld bc,player+9
164+  C722 0A               ld a,(bc)
165+  C723 3D               dec a
166+  C724 02               ld (bc),a
167+  C725 CD ED C6         call player_recordcurrentstate
168+  C728 C9               ret
169+  C729
170+  C729              ;
171+  C729              ; Player lives
172+  C729              ;
173+  C729              player1_lives:
174+  C729 03               defb 3
175+  C72A              player2_lives:
176+  C72A 03               defb 3
177+  C72B
178+  C72B              ;
179+  C72B              ; Player scores
180+  C72B              ;
181+  C72B              player1_score:
182+  C72B 04 01 30 30      defb 4,1,'000000',255
182+  C72F 30 30 30 30
182+  C733 FF
183+  C734              player2_score:
184+  C734 16 01 30 30      defb 22,1,'000000',255
184+  C738 30 30 30 30
184+  C73C FF
185+  C73D
186+  C73D              ;
187+  C73D              ; Player difficulties
188+  C73D              ;
189+  C73D              player1_difficulty:
190+  C73D 00               defb 0
191+  C73E              player2_difficulty:
192+  C73E 00               defb 0
193+  C73F
194+  C73F              ;
195+  C73F              ; Kills a player this life
196+  C73F              ;
197+  C73F              player_killplayer:
198+  C73F 21 27 C6         ld hl,player+10
199+  C742 36 01            ld (hl),1
200+  C744 C9               ret
201+  C745
202+  C745              ;
203+  C745              ; Crush a player this life
204+  C745              ;
205+  C745              player_crushplayer:
206+  C745 21 28 C6         ld hl,player+11             ; mark as crushed
207+  C748 36 01            ld (hl),1
208+  C74A C9               ret
209+  C74B
210+  C74B              player_tankkillplayer
211+  C74B 21 28 C6         ld hl,player+11             ; mark as tanked
212+  C74E 36 02            ld (hl),2
213+  C750 C9               ret
214+  C751
215+  C751              player_zonkplayer
216+  C751 21 28 C6         ld hl,player+11             ; mark as zonked (missile)
217+  C754 36 03            ld (hl),3
218+  C756 C9               ret
219+  C757
220+  C757              player_pitkillplayer
221+  C757 21 28 C6         ld hl,player+11             ; mark as pit killed
222+  C75A 36 04            ld (hl),4
223+  C75C C9               ret
224+  C75D
225+  C75D              player_robotkillplayer
226+  C75D 21 28 C6         ld hl,player+11             ; mark as robot killed
227+  C760 36 05            ld (hl),5
228+  C762 C9               ret
229+  C763
230+  C763              ;
231+  C763              ; Draws the player at the current position or deletes them
232+  C763              ;
233+  C763              player_drawplayer:
234+  C763 3A 1F C6         ld a,(player+2)             ; get the current direction
235+  C766 FE 03            cp 3
236+  C768 C2 6D C7         jp nz,player_drawplayer0
237+  C76B 3E 00            ld a,0                      ; if 3, then down, so set the direction to 0 since the sprite is the same as up
238+  C76D              player_drawplayer0:             ; DYING CHECKS
239+  C76D 5F               ld e,a                      ; store in e
240+  C76E 3A 28 C6         ld a,(player+11)             ; get the dying flag
241+  C771 FE 01            cp 1
242+  C773 CA AD C7         jp z,player_drawplayer3     ; if it's one, we're being crushed
243+  C776 FE 04            cp 4
244+  C778 CA F5 C7         jp z,player_drawplayer9     ; player is falling into the pit
245+  C77B FE 05            cp 5
246+  C77D CA 11 C8         jp z,player_drawplayer12    ; player has been killed by a robot
247+  C780              player_drawplayer4:             ; CHECK FOR DIGGING
248+  C780 3A 23 C6         ld a,(player+6)             ; get the dig flag
249+  C783 FE 01            cp 1
250+  C785 CA 96 C7         jp z,player_drawplayer1    ; get dig frame
251+  C788 3A 20 C6         ld a,(player+3)             ; this is normal movement so get the current frame
252+  C78B 83               add a,e
253+  C78C C3 9B C7         jp player_drawplayer2
254+  C78F              player_drawplayer6:             ; GETTING THE DIG FRAM
255+  C78F E6 01            and 1                       ; check for odd
256+  C791 C6 0A            add 10                      ; add 10, to get either 10 or 11
257+  C793 C3 9B C7         jp player_drawplayer2
258+  C796              player_drawplayer1:             ; GET THE NORMAL FRAME
259+  C796 3A 1F C6         ld a,(player+2)             ; digging, get the current direction again, because want all four
260+  C799 C6 06            add a,6                     ; add direction to 6 to get frame
261+  C79B              player_drawplayer2:             ; WORK OUT THE FRAME
262+  C79B 07               rlca
263+  C79C 07               rlca
264+  C79D 07               rlca                        ; multiply by eight
265+  C79E 6F               ld l,a
266+  C79F 26 00            ld h,0
267+  C7A1 11 69 BE         ld de,player_sprite
268+  C7A4 19               add hl,de                   ; load hl with the location of the player sprite data
269+  C7A5              player_drawplayer7:             ; DRAW THE PlAYER
270+  C7A5 ED 4B 1D C6      ld bc,(player)              ; load bc with the start coords
271+  C7A9 CD 29 AB         call sprites_drawsprite     ; call the routine to draw the sprite
272+  C7AC                  ;call player_storeupdatedlines ; log updated rows
273+  C7AC C9               ret
274+  C7AD              ;
275+  C7AD              ; CRUSHING
276+  C7AD              ;
277+  C7AD              player_drawplayer3:
278+  C7AD 21 29 C6         ld hl,player+12
279+  C7B0 7E               ld a,(hl)                  ; crushing, so get the current anim flag
280+  C7B1 FE 00            cp 0
281+  C7B3 C2 BC C7         jp nz,player_drawplayer5    ; if this isn't zero, then this isn't the first time round, so do the crush anim
282+  C7B6 3E 64            ld a,100
283+  C7B8 77               ld (hl),a                   ; otherwise, load up the anim frames
284+  C7B9 C3 80 C7         jp player_drawplayer4       ; and return to the main loop to remove the current frame
285+  C7BC              player_drawplayer5:
286+  C7BC 3D               dec a
287+  C7BD 77               ld (hl),a
288+  C7BE FE 00            cp 0
289+  C7C0 CC 3F C7         call z,player_killplayer     ; final animation, so kill the player
290+  C7C3 FE 0A            cp 10                         ; play the sound
291+  C7C5 CC 4C B2         call z, sound_rockfell
292+  C7C8 FE 14            cp 20                        ; check if we should move the rock
293+  C7CA C2 DE C7         jp nz,player_drawplayer8
294+  C7CD D9               exx
295+  C7CE F5               push af
296+  C7CF ED 4B FC CB      ld bc,(rocks_killerrock)    ; get the coords of the rock that killed us
297+  C7D3 21 B5 BD         ld hl,sprites+72
298+  C7D6 CD 29 AB         call sprites_drawsprite     ; draw a rock over current
299+  C7D9 F1               pop af
300+  C7DA D9               exx
301+  C7DB C3 8F C7         jp player_drawplayer6       ; continue drawing player
302+  C7DE              player_drawplayer8:
303+  C7DE FE 14            cp 20
304+  C7E0 D2 8F C7         jp nc,player_drawplayer6    ; if not in last 10 frames, draw as normal
305+  C7E3 ED 4B 1D C6      ld bc,(player)
306+  C7E7 CD 57 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
307+  C7EA 3E 42            ld a,66             ; load red
308+  C7EC CD AF AA         call screen_setattr
309+  C7EF 21 B5 BD         ld hl,sprites+72            ; otherwise, player is rock
310+  C7F2 C3 A5 C7         jp player_drawplayer7
311+  C7F5              ;
312+  C7F5              ; FALLING
313+  C7F5              ;
314+  C7F5              player_drawplayer9:             ; player is falling into the pit
315+  C7F5 21 29 C6         ld hl,player+12
316+  C7F8 7E               ld a,(hl)                   ; get the frames
317+  C7F9 FE 00            cp 0
318+  C7FB C2 04 C8         jp nz,player_drawplayer10    ; if this isn't zero, then this isn't the first time round, so do the crush anim
319+  C7FE 3E 50            ld a,80
320+  C800 77               ld (hl),a                   ; otherwise, load up the anim frames
321+  C801 C3 80 C7         jp player_drawplayer4       ; and return to the main loop to remove the current frame
322+  C804              player_drawplayer10:
323+  C804 3D               dec a
324+  C805 77               ld (hl),a
325+  C806 FE 00            cp 0
326+  C808 CC 3F C7         call z,player_killplayer     ; final frame, so kill the player
327+  C80B 3A 20 C6         ld a,(player+3)
328+  C80E C3 9B C7         jp player_drawplayer2
329+  C811              ;
330+  C811              ; ROBOT KILLED
331+  C811              ;
332+  C811              player_drawplayer12:
333+  C811 21 29 C6         ld hl,player+12
334+  C814 7E               ld a,(hl)                   ; get the frames
335+  C815 FE 00            cp 0
336+  C817 C2 20 C8         jp nz,player_drawplayer13    ; if this isn't zero, then this isn't the first time round, so do the crush anim
337+  C81A 3E C8            ld a,200
338+  C81C 77               ld (hl),a                   ; otherwise, load up the anim frames
339+  C81D C3 80 C7         jp player_drawplayer4       ; and return to the main loop to remove the current frame
340+  C820              player_drawplayer13:
341+  C820 3D               dec a
342+  C821 77               ld (hl),a
343+  C822 FE 00            cp 0
344+  C824 CC 3F C7         call z,player_killplayer     ; final frame, so kill the player
345+  C827 3A 20 C6         ld a,(player+3)
346+  C82A C3 9B C7         jp player_drawplayer2
347+  C82D
348+  C82D              ;
349+  C82D              ; Runs after the player just moved. Changes animation frame if required
350+  C82D              ;
351+  C82D              player_justmoved:
352+  C82D D9               exx
353+  C82E 3A 21 C6         ld a,(player+4)             ; get the transition count
354+  C831 FE 00            cp 0
355+  C833 CA 39 C8         jp z, player_justmoved2     ; if zero reset and change the frame
356+  C836 C3 53 C8         jp player_justmoved1       ; otherwise decrease and continue
357+  C839              player_justmoved2:
358+  C839                  ; reset and change frame in here
359+  C839 3E 01            ld a,1
360+  C83B 32 21 C6         ld (player+4),a            ; reset back to whatever
361+  C83E 3A 20 C6         ld a,(player+3)             ; load the frame
362+  C841 FE 03            cp 3                       ; flip between 3 and 0
363+  C843 C2 4B C8         jp nz, player_justmoved4
364+  C846 3E 00            ld a,0
365+  C848 C3 4D C8         jp player_justmoved5
366+  C84B              player_justmoved4:
367+  C84B 3E 03            ld a,3
368+  C84D              player_justmoved5:
369+  C84D 32 20 C6         ld (player+3),a           ; save back
370+  C850 C3 57 C8         jp player_justmoved3
371+  C853              player_justmoved1:
372+  C853                  ; decrease count
373+  C853 3D               dec a
374+  C854 32 21 C6         ld (player+4),a
375+  C857              player_justmoved3:
376+  C857 D9               exx;
377+  C858 C9               ret
378+  C859
379+  C859              ;
380+  C859              ; Called if the player has collected a diamond. Checks the current coord. If it is the start coord, then return complete
381+  C859              ; Outputs:
382+  C859              ; a - 1 for completed level
383+  C859              player_checkforexit:
384+  C859 ED 4B 1D C6      ld bc,(player)                 ; get player coords
385+  C85D ED 5B EB 80      ld de,(init_coord)             ; get start coords
386+  C861 78               ld a,b
387+  C862 BA               cp d                         ; compare horiz
388+  C863 C2 6E C8         jp nz,player_checkforexit1
389+  C866 79               ld a,c
390+  C867 BB               cp e                        ; compare vert
391+  C868 C2 6E C8         jp nz,player_checkforexit1
392+  C86B              player_checkforexit0:
393+  C86B 3E 01            ld a,1                       ; hasn't completed
394+  C86D C9               ret
395+  C86E              player_checkforexit1:
396+  C86E 3E 00            ld a,0                       ; has completed
397+  C870 C9               ret
# file closed: game/player.asm
145   C871                  include "game\ship.asm"
# file opened: game/ship.asm
  1+  C871              ;
  2+  C871              ; Ship initial position: vert,horiz
  3+  C871              ;
  4+  C871              ship_initpos:
  5+  C871 00 24            defb 0,36
  6+  C873              ship_initpos2:
  7+  C873 00 00            defb 0,0
  8+  C875              ship_frame:
  9+  C875 00               defb 0
 10+  C876              ;
 11+  C876              ; The current memory location
 12+  C876              ;
 13+  C876              ship_current_sprite:
 14+  C876 00 00            defb 0,0
 15+  C878
 16+  C878              ship_current_coords:
 17+  C878 00 00            defb 0,0
 18+  C87A
 19+  C87A              ship_soundpitch:
 20+  C87A 00               defb 0
 21+  C87B
 22+  C87B              ship_process:
 23+  C87B 3A 28 C6         ld a,(player+11)
 24+  C87E FE 02            cp 2                        ; has the player been killed by tank?
 25+  C880 C0               ret nz                      ; do nothing if not
 26+  C881 CD F9 C2         call control_scroll_up           ; make sure the screen is on the top screen
 27+  C884 CD 2D C9         call ship_takeoff           ; bye bye
 28+  C887 CD 3F C7         call player_killplayer      ; killed
 29+  C88A 06 32            ld b,50
 30+  C88C CD 64 81         call utilities_pauseforframes
 31+  C88F C9               ret
 32+  C890
 33+  C890              ship_sound:
 34+  C890 16 00            ld d,0
 35+  C892 3A 7A C8         ld a,(ship_soundpitch)
 36+  C895 1E 04            ld e,4
 37+  C897 93               sub e
 38+  C898 5F               ld e,a
 39+  C899 32 7A C8         ld (ship_soundpitch),a
 40+  C89C 01 10 00         ld bc,16
 41+  C89F F3               di
 42+  C8A0 CD 67 B1         call sound_play
 43+  C8A3 FB               ei
 44+  C8A4 C9               ret
 45+  C8A5
 46+  C8A5              ship_soundup:
 47+  C8A5 16 00            ld d,0
 48+  C8A7 3A 7A C8         ld a,(ship_soundpitch)
 49+  C8AA 1E 04            ld e,4
 50+  C8AC 83               add e
 51+  C8AD 5F               ld e,a
 52+  C8AE 32 7A C8         ld (ship_soundpitch),a
 53+  C8B1 01 10 00         ld bc,16
 54+  C8B4 F3               di
 55+  C8B5 CD 67 B1         call sound_play
 56+  C8B8 FB               ei
 57+  C8B9 C9               ret
 58+  C8BA
 59+  C8BA              ;
 60+  C8BA              ;   Draw and land the ship - first move the ship down, then across, drawing the player in the middle
 61+  C8BA              ;
 62+  C8BA              ship_land:
 63+  C8BA 3E 96            ld a,150
 64+  C8BC 32 7A C8         ld (ship_soundpitch),a
 65+  C8BF ED 4B 71 C8      ld bc,(ship_initpos)
 66+  C8C3 ED 43 73 C8      ld (ship_initpos2),bc        ; save the initial position for later use
 67+  C8C7 1E 00            ld e,0                      ; store a flag to track first time round
 68+  C8C9 06 09            ld b,9                      ; move down 8 pixels
 69+  C8CB              ship_land0:
 70+  C8CB C5               push bc
 71+  C8CC 7B               ld a,e
 72+  C8CD D5               push de                     ; store de for next time round
 73+  C8CE FE 01            cp 1                        ; check first time flag
 74+  C8D0 C2 E5 C8         jp nz,ship_land1             ; don't draw over previous one if first time
 75+  C8D3 CD 78 C9         call ship_draw_full         ; delete old one
 76+  C8D6 CD 5C C9         call ship_change_frame      ; increment the frame
 77+  C8D9 ED 4B 73 C8      ld bc,(ship_initpos2)       ; get the current coords
 78+  C8DD 81 C6 01         add c,1                     ; move down one pixels
 79+  C8E0 4F               ld c,a
 80+  C8E1 ED 43 73 C8      ld (ship_initpos2),bc
 81+  C8E5              ship_land1:
 82+  C8E5 CD 78 C9         call ship_draw_full         ; draw the ship
 83+  C8E8 D1               pop de
 84+  C8E9 7B               ld a,e
 85+  C8EA FE 00            cp 0
 86+  C8EC C2 EF C8         jp nz,ship_land4
 87+  C8EF                  ;call sound_pitchbend        ; play sound if first frame
 88+  C8EF              ship_land4:
 89+  C8EF D5               push de
 90+  C8F0 CD 71 C9         call ship_draw_screen
 91+  C8F3 CD 90 C8         call ship_sound
 92+  C8F6 D1               pop de
 93+  C8F7 1E 01            ld e,1
 94+  C8F9 C1               pop bc
 95+  C8FA 10 CF            djnz ship_land0             ; repeat for downward movement
 96+  C8FC                  ; done moving down
 97+  C8FC                  ; now move across
 98+  C8FC CD 63 C7         call player_drawplayer      ; draw player
 99+  C8FF CD 78 C9         call ship_draw_full         ; delete old one
100+  C902 1E 00            ld e,0                      ; store a flag to track first time round
101+  C904 06 14            ld b,20                      ; move back 20 pixels pixels
102+  C906              ship_land3:
103+  C906 C5               push bc
104+  C907 7B               ld a,e
105+  C908 D5               push de                     ; store de for next time round
106+  C909 FE 01            cp 1                        ; check first time flag
107+  C90B C2 20 C9         jp nz,ship_land2             ; don't draw over previous one if first time
108+  C90E CD 78 C9         call ship_draw_full         ; delete old one
109+  C911 CD 5C C9         call ship_change_frame      ; increment the frame
110+  C914 ED 4B 73 C8      ld bc,(ship_initpos2)       ; get the current coords
111+  C918 78               ld a,b
112+  C919 D6 01            sub 1                       ; move back one pixels
113+  C91B 47               ld b,a
114+  C91C ED 43 73 C8      ld (ship_initpos2),bc
115+  C920              ship_land2:
116+  C920 CD 78 C9         call ship_draw_full         ; draw the ship
117+  C923 CD 71 C9         call ship_draw_screen       ; draw the frame to screen by clearing the buffer
118+  C926 D1               pop de
119+  C927 1E 01            ld e,1                      ; set e to 1 to indicate >1 time
120+  C929 C1               pop bc
121+  C92A 10 DA            djnz ship_land3             ; repeat for vertical movement
122+  C92C C9               ret
123+  C92D
124+  C92D              ;
125+  C92D              ;   Take off the ship
126+  C92D              ;
127+  C92D              ship_takeoff:
128+  C92D                  ;call sound_pitchbenddown
129+  C92D 1E 01            ld e,1                      ; store a flag to track first time round
130+  C92F 06 08            ld b,8                      ; move up 8 pixels
131+  C931              ship_takeoff0:
132+  C931 C5               push bc
133+  C932 7B               ld a,e
134+  C933 D5               push de                     ; store de for next time round
135+  C934 FE 01            cp 1                        ; check first time flag
136+  C936 C2 4C C9         jp nz,ship_takeoff1             ; don't draw over previous one if first time
137+  C939 ED 4B 73 C8      ld bc,(ship_initpos2)       ; get the current coords
138+  C93D CD 78 C9         call ship_draw_full         ; delete old one
139+  C940 CD 5C C9         call ship_change_frame      ; increment the frame
140+  C943 ED 4B 73 C8      ld bc,(ship_initpos2)       ; get the current coords
141+  C947 0D               dec c                       ; move up one pixels
142+  C948 ED 43 73 C8      ld (ship_initpos2),bc
143+  C94C              ship_takeoff1:
144+  C94C CD 78 C9         call ship_draw_full         ; draw the ship
145+  C94F CD 71 C9         call ship_draw_screen
146+  C952 CD A5 C8         call ship_soundup
147+  C955 D1               pop de
148+  C956 1E 01            ld e,1
149+  C958 C1               pop bc
150+  C959 10 D6            djnz ship_takeoff0             ; repeat for upward movement
151+  C95B                  ; done moving up
152+  C95B C9               ret
153+  C95C
154+  C95C              ;
155+  C95C              ; Swap the animation frame between 0 and 32. This will be added to the memory location later
156+  C95C              ;
157+  C95C              ship_change_frame:
158+  C95C F5               push af
159+  C95D 3A 75 C8         ld a,(ship_frame)
160+  C960 FE 00            cp 0
161+  C962 CA 6A C9         jp z,ship_change_frame0
162+  C965 3E 00            ld a,0                      ; flip to 0
163+  C967 C3 6C C9         jp ship_change_frame1
164+  C96A              ship_change_frame0:
165+  C96A 3E 20            ld a,32                      ; flip to 32
166+  C96C              ship_change_frame1:
167+  C96C 32 75 C8         ld (ship_frame),a            ; save the frame
168+  C96F F1               pop af
169+  C970 C9               ret
170+  C971
171+  C971              ship_draw_screen:
172+  C971 76               halt
173+  C972 F3               di
174+  C973 CD 20 A8         call buffer_buffertoscreen  ; copy buffer to screen
175+  C976 FB               ei                          ; enable interupts
176+  C977 C9               ret
177+  C978
178+  C978              ship_draw_full:
179+  C978 21 D9 BE         ld hl,ship_sprite
180+  C97B ED 4B 73 C8      ld bc,(ship_initpos2)         ; load bc with the start coords
181+  C97F 22 76 C8         ld (ship_current_sprite),hl  ; put into memory
182+  C982 ED 43 78 C8      ld (ship_current_coords),bc  ; put into memory
183+  C986 CD A5 C9         call ship_draw
184+  C989 08               ex af,af'
185+  C98A 3A 75 C8         ld a,(ship_frame)            ; get the animation frame
186+  C98D 16 00            ld d,0
187+  C98F 5F               ld e,a
188+  C990 19               add hl,de
189+  C991 22 76 C8         ld (ship_current_sprite),hl  ; put into memory
190+  C994 08               ex af,af'
191+  C995 ED 4B 73 C8      ld bc,(ship_initpos2)         ; load bc with the start coords
192+  C999 81 C6 08         add c,8                      ; move one line down
193+  C99C 4F               ld c,a
194+  C99D ED 43 78 C8      ld (ship_current_coords),bc  ; put into memory
195+  C9A1 CD A5 C9         call ship_draw
196+  C9A4 C9               ret
197+  C9A5
198+  C9A5              ;
199+  C9A5              ; Draw the ship
200+  C9A5              ; Inputs:
201+  C9A5              ; None, all in memory
202+  C9A5              ;
203+  C9A5              ship_draw:
204+  C9A5 3E 04            ld a,4                              ; 4 pieces per half
205+  C9A7              ship_draw0:
206+  C9A7 F5               push af
207+  C9A8 2A 76 C8         ld hl,(ship_current_sprite)
208+  C9AB ED 4B 78 C8      ld bc,(ship_current_coords)         ; load bc with the start coords
209+  C9AF CD 29 AB         call sprites_drawsprite
210+  C9B2 2A 76 C8         ld hl,(ship_current_sprite)
211+  C9B5 ED 4B 78 C8      ld bc,(ship_current_coords)         ; load bc with the start coords
212+  C9B9 11 08 00         ld de,8
213+  C9BC 19               add hl,de
214+  C9BD 80 C6 08         add b,8
215+  C9C0 47               ld b,a
216+  C9C1 22 76 C8         ld (ship_current_sprite),hl         ; put into memory
217+  C9C4 ED 43 78 C8      ld (ship_current_coords),bc         ; put into memory
218+  C9C8 F1               pop af
219+  C9C9 3D               dec a
220+  C9CA FE 00            cp 0
221+  C9CC C2 A7 C9         jp nz,ship_draw0
222+  C9CF
223+  C9CF C9               ret
224+  C9D0
# file closed: game/ship.asm
146   C9D0                  include "game\tank.asm"
# file opened: game/tank.asm
  1+  C9D0              ;
  2+  C9D0              ; tank initial position: vert,horiz
  3+  C9D0              ;
  4+  C9D0              tank_initpos:
  5+  C9D0 10 D0            defb 16,208
  6+  C9D2              tank_initpos2:
  7+  C9D2 00 00            defb 0,0
  8+  C9D4              tank_frame:
  9+  C9D4 00               defb 0
 10+  C9D5              tank_anim:
 11+  C9D5 11               defb 17
 12+  C9D6
 13+  C9D6              ;
 14+  C9D6              ; The damage countdown
 15+  C9D6              ;
 16+  C9D6              tank_currentdamage:
 17+  C9D6 F0               defb 240
 18+  C9D7
 19+  C9D7              ;
 20+  C9D7              ; The damage coordinate
 21+  C9D7              ;
 22+  C9D7              tank_currentdamagecoord:
 23+  C9D7 16 02            defb 22,2
 24+  C9D9
 25+  C9D9              ;
 26+  C9D9              ; Controls when the tank shoots
 27+  C9D9              ;
 28+  C9D9              tank_count:
 29+  C9D9 00               defb 0
 30+  C9DA
 31+  C9DA              ;
 32+  C9DA              ; Holds the block number of the current damage sprite
 33+  C9DA              ;
 34+  C9DA              tank_damageframe:
 35+  C9DA 00               defb 0
 36+  C9DB
 37+  C9DB              ;
 38+  C9DB              ; The current memory location
 39+  C9DB              ;
 40+  C9DB              tank_current_sprite:
 41+  C9DB 00 00            defb 0,0
 42+  C9DD
 43+  C9DD              tank_current_coords:
 44+  C9DD 00 00            defb 0,0
 45+  C9DF
 46+  C9DF              ;
 47+  C9DF              ; Is the missile displayed - will be 19 if so, 0 if not
 48+  C9DF              ;
 49+  C9DF              tank_missile_displayed:
 50+  C9DF 00               defb 0
 51+  C9E0
 52+  C9E0              ;
 53+  C9E0              ; Speed that the tank fires
 54+  C9E0              ;
 55+  C9E0              tank_speed:
 56+  C9E0 00               defb 0
 57+  C9E1
 58+  C9E1              ;
 59+  C9E1              ; Initialise the tank
 60+  C9E1              ;
 61+  C9E1              tank_init:
 62+  C9E1 ED 4B D0 C9      ld bc,(tank_initpos)
 63+  C9E5 ED 43 D2 C9      ld (tank_initpos2),bc       ; save the initial position for later use
 64+  C9E9 21 D4 C9         ld hl,tank_frame
 65+  C9EC 36 00            ld (hl),0
 66+  C9EE 21 D5 C9         ld hl,tank_anim
 67+  C9F1 36 11            ld (hl),17
 68+  C9F3 21 DA C9         ld hl,tank_damageframe              ; reset tank
 69+  C9F6 36 00            ld (hl),0
 70+  C9F8 21 D9 C9         ld hl,tank_count
 71+  C9FB 36 00            ld (hl),0
 72+  C9FD 21 D6 C9         ld hl,tank_currentdamage
 73+  CA00 36 F0            ld (hl),240
 74+  CA02 21 D7 C9         ld hl,tank_currentdamagecoord
 75+  CA05 36 16            ld (hl),22
 76+  CA07 23               inc hl
 77+  CA08 36 02            ld (hl),2
 78+  CA0A 21 DF C9         ld hl,tank_missile_displayed
 79+  CA0D 36 00            ld (hl),0
 80+  CA0F
 81+  CA0F C9               ret
 82+  CA10
 83+  CA10              ;
 84+  CA10              ;   Draw and move the tank
 85+  CA10              ;   Start processing at frame 75
 86+  CA10              ;   Don't move if anim is zero
 87+  CA10              ;   Decrement frame if moved
 88+  CA10              ;
 89+  CA10              tank_process:
 90+  CA10 3A D5 C9         ld a,(tank_anim)
 91+  CA13 FE 00            cp 0
 92+  CA15 C2 1C CA         jp nz,tank_process0         ; fire the tank if we've already moved, or jump to movement
 93+  CA18 CD 35 CA         call tank_fire
 94+  CA1B C9               ret
 95+  CA1C              tank_process0:
 96+  CA1C CD C7 C5         call game_getcurrentframe   ; get the current frame number into a
 97+  CA1F FE 4B            cp 75
 98+  CA21 D8               ret c                       ; return if the frame number is below 75
 99+  CA22 CD 6F CB         call tank_move              ; move tank if not
100+  CA25 3A D5 C9         ld a,(tank_anim)
101+  CA28 3D               dec a
102+  CA29 32 D5 C9         ld (tank_anim),a            ; decrease the anim count
103+  CA2C FE 00            cp 0
104+  CA2E C0               ret nz
105+  CA2F 3E 01            ld a,1
106+  CA31 32 86 D3         ld (robots_spawntimer),a ; set the spawn speed low so that a robot spawns soon after the tank stops moving
107+  CA34 C9               ret
108+  CA35
109+  CA35              ;
110+  CA35              ; Fires the tank
111+  CA35              ;
112+  CA35              tank_fire:
113+  CA35 3A D9 C9         ld a,(tank_count)            ; if not, don't do anything
114+  CA38 3C               inc a                        ; increment
115+  CA39 ED 5B E0 C9      ld de,(tank_speed)
116+  CA3D BB               cp e                        ; have we reached the speed
117+  CA3E C2 43 CA         jp nz,tank_fire0
118+  CA41 3E 00            ld a,0                       ; reset if reached fifty
119+  CA43              tank_fire0:                      ; DEALING WITH A NEW BLOCK
120+  CA43 32 D9 C9         ld (tank_count),a            ; store tank count
121+  CA46 FE 00            cp 0
122+  CA48 CA 69 CA         jp z,tank_fire7              ; If this is zero, fire
123+  CA4B 3A DF C9         ld a,(tank_missile_displayed) ; is the missile displaying?
124+  CA4E FE 00            cp 0
125+  CA50 C8               ret z                       ; don't do anything if not
126+  CA51 CD 29 CB         call tank_missilegraphic     ; if not, overwrite the previous tank missile
127+  CA54 3E 00            ld a,0                       ; reset the flag
128+  CA56 32 DF C9         ld (tank_missile_displayed),a
129+  CA59 3E 02            ld a,2
130+  CA5B ED 4B D7 C9      ld bc,(tank_currentdamagecoord)
131+  CA5F 0C               inc c
132+  CA60 0C               inc c
133+  CA61 ED 43 58 AC      ld (origcoords),bc
134+  CA65 CD 45 A7         call buffer_marklineforupdate
135+  CA68 C9               ret                        ; only shoot if we're on 0
136+  CA69              tank_fire7:
137+  CA69 3A D6 C9         ld a,(tank_currentdamage)    ; get the damage countdown
138+  CA6C E6 07            and 7                       ; check if multiple of 8 - house keeping when moving onto a new block
139+  CA6E C2 A4 CA         jp nz,tank_fire1            ; not, so just do a normal frame
140+  CA71 ED 4B D7 C9      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
141+  CA75 79               ld a,c
142+  CA76 FE 0A            cp 10
143+  CA78 C2 7F CA         jp nz, tank_fire6
144+  CA7B CD 61 CB         call tank_killedbytank      ; we're through, so the player has died. Kill them.
145+  CA7E C9               ret                         ; return if we're through the mountain
146+  CA7F              tank_fire6:
147+  CA7F 3E 0F            ld a,15
148+  CA81 32 DA C9         ld (tank_damageframe),a     ; reset the damage frame
149+  CA84 21 6D BD         ld hl,sprites               ; location of the empty block
150+  CA87 CD 81 AA         call screen_showchar        ; show this character here
151+  CA8A ED 4B D7 C9      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
152+  CA8E 05               dec b                       ; look one above
153+  CA8F CD E5 AA         call screen_ischarempty     ; check if it is empty
154+  CA92 ED 4B D7 C9      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc again
155+  CA96 FE 01            cp 1
156+  CA98 C2 DB CA         jp nz,tank_fire2             ; block above isn't empty, so can't move on, copy down above blocks
157+  CA9B ED 4B D7 C9      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
158+  CA9F 0D               dec c
159+  CAA0 ED 43 D7 C9      ld (tank_currentdamagecoord),bc ; store the coord
160+  CAA4              tank_fire1:                         ; DEALING WITH NORMAL DAMAGE
161+  CAA4 ED 4B D7 C9      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
162+  CAA8 3A D6 C9         ld a,(tank_currentdamage)    ; get the damage countdown
163+  CAAB E6 07            and 7                       ; is it a multiple of 8? only want to do the first line check then
164+  CAAD C2 B8 CA         jp nz, tank_fire5
165+  CAB0 CD 15 AB         call screen_getcharfirstbyte    ; get the first byte to check if this is a slope
166+  CAB3 FE FF            cp 255                      ; if it's a full line, it will be 255 and not a slope
167+  CAB5 C2 F9 CA         jp nz,tank_fire3            ; if it's a slope, handle this differently
168+  CAB8              tank_fire5:
169+  CAB8 3A DA C9         ld a,(tank_damageframe)
170+  CABB CD A4 AA         call screen_getblock        ; get the block data into hl
171+  CABE CD 81 AA         call screen_showchar        ; show this character here
172+  CAC1 3A DA C9         ld a,(tank_damageframe)
173+  CAC4 3C               inc a
174+  CAC5 32 DA C9         ld (tank_damageframe),a     ; increment the damage block and store
175+  CAC8 3A D6 C9         ld a,(tank_currentdamage)    ; get the damage countdown
176+  CACB 3D               dec a
177+  CACC 3D               dec a
178+  CACD 32 D6 C9         ld (tank_currentdamage),a     ; decrease current damage by 2 and store
179+  CAD0 3A DF C9         ld a,(tank_missile_displayed) ; is the missile displaying?
180+  CAD3 FE 00            cp 0
181+  CAD5 CC 29 CB         call z, tank_missilegraphic
182+  CAD8 C3 02 CB         jp tank_fire4
183+  CADB              tank_fire2:                     ; DEALING WITH COPYING BLOCKS FROM ABOVE
184+  CADB 05               dec b
185+  CADC C5               push bc
186+  CADD CD FE AA         call screen_copyblockdown       ; copy the block down
187+  CAE0 ED 4B D7 C9      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
188+  CAE4 C1               pop bc                      ; get the coord we just checked back
189+  CAE5 78               ld a,b
190+  CAE6 FE 00            cp 0
191+  CAE8 CA A4 CA         jp z,tank_fire1             ; if we're at the top of the screen, don't check any more
192+  CAEB C5               push bc
193+  CAEC 05               dec b
194+  CAED CD E5 AA         call screen_ischarempty     ; check if it is empty
195+  CAF0 C1               pop bc
196+  CAF1 FE 01            cp 1                        ; if empty
197+  CAF3 C2 DB CA         jp nz, tank_fire2            ; copy another one down
198+  CAF6 C3 A4 CA         jp tank_fire1               ; otherwise, return to main thread
199+  CAF9              tank_fire3:                      ; dealing with slopes
200+  CAF9 3A D6 C9         ld a,(tank_currentdamage)    ; get the damage countdown
201+  CAFC 06 08            ld b,8
202+  CAFE 90               sub b                        ; special case for slopes
203+  CAFF 32 D6 C9         ld (tank_currentdamage),a    ; decrease the damage countdown by 8, so that next time, we get rid of this block without eroding it
204+  CB02              tank_fire4:                     ; TIDY UP
205+  CB02 ED 4B D7 C9      ld bc,(tank_currentdamagecoord)
206+  CB06 ED 43 58 AC      ld (origcoords),bc
207+  CB0A CD 45 A7         call buffer_marklineforupdate
208+  CB0D 3E 01            ld a,1
209+  CB0F CD 45 A7         call buffer_marklineforupdate
210+  CB12 3E 02            ld a,2
211+  CB14 CD 45 A7         call buffer_marklineforupdate
212+  CB17 ED 4B D7 C9      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
213+  CB1B 79               ld a,c
214+  CB1C FE 0D            cp 13
215+  CB1E DA 25 CB         jp c, tank_fire8                ; play alarm instead if getting close
216+  CB21 CD 7D B2         call sound_tankshoot
217+  CB24 C9               ret
218+  CB25              tank_fire8:
219+  CB25 CD EF B1         call sound_tankalarm
220+  CB28 C9               ret
221+  CB29
222+  CB29              ;
223+  CB29              ; Displays or hides the missile graphic, and changes the gun
224+  CB29              ;
225+  CB29              tank_missilegraphic:
226+  CB29 3A DF C9         ld a,(tank_missile_displayed)
227+  CB2C FE 00            cp 0
228+  CB2E C2 36 CB         jp nz,tank_missilegraphic0
229+  CB31 3E 13            ld a,19
230+  CB33 C3 38 CB         jp tank_missilegraphic1
231+  CB36              tank_missilegraphic0:
232+  CB36 3E 00            ld a,0
233+  CB38              tank_missilegraphic1:
234+  CB38 32 DF C9         ld (tank_missile_displayed),a ; store the flipped graphic
235+  CB3B ED 4B D7 C9      ld bc,(tank_currentdamagecoord)
236+  CB3F 0C               inc c
237+  CB40 0C               inc c                   ; print the graphic 2 spaces right
238+  CB41 CD A4 AA         call screen_getblock        ; get the block data into hl
239+  CB44 CD 81 AA         call screen_showchar        ; show this character here
240+  CB47 06 02            ld b,2
241+  CB49 0E 18            ld c,24                     ; set gunbarrel coords
242+  CB4B 11 00 00         ld de,0
243+  CB4E 21 39 BF         ld hl,tank_sprite           ; set hl to gunbarrel gfx, shooting is +64
244+  CB51 3A DF C9         ld a,(tank_missile_displayed)
245+  CB54 FE 00            cp 0
246+  CB56 CA 5C CB         jp z,tank_missilegraphic2
247+  CB59 11 40 00         ld de,64
248+  CB5C              tank_missilegraphic2:
249+  CB5C 19               add hl,de                   ; work out missile graphic
250+  CB5D CD 81 AA         call screen_showchar        ; show this character here
251+  CB60 C9               ret
252+  CB61
253+  CB61              ;
254+  CB61              ; Deal with the player being killed by the tank
255+  CB61              ;
256+  CB61              tank_killedbytank:
257+  CB61 ED 4B D7 C9      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
258+  CB65 21 6D BD         ld hl,sprites                   ; empty sprite
259+  CB68 CD 81 AA         call screen_showchar            ; hide the last piece of dirt
260+  CB6B CD 4B C7         call player_tankkillplayer
261+  CB6E C9               ret
262+  CB6F
263+  CB6F              tank_move:
264+  CB6F ED 4B D2 C9      ld bc,(tank_initpos2)
265+  CB73 C5               push bc
266+  CB74 3A D5 C9         ld a,(tank_anim)
267+  CB77 FE 11            cp 17                       ; check first time flag
268+  CB79 CA 8B CB         jp z,tank_move1             ; don't draw over previous one if first time
269+  CB7C CD 90 CB         call tank_draw_full         ; delete old one
270+  CB7F ED 4B D2 C9      ld bc,(tank_initpos2)       ; get the current coords
271+  CB83 78               ld a,b
272+  CB84 D6 01            sub 1                       ; move back one pixels
273+  CB86 47               ld b,a
274+  CB87 ED 43 D2 C9      ld (tank_initpos2),bc
275+  CB8B              tank_move1:
276+  CB8B CD 90 CB         call tank_draw_full         ; draw the tank
277+  CB8E C1               pop bc
278+  CB8F C9               ret
279+  CB90
280+  CB90              tank_draw_full:
281+  CB90 21 39 BF         ld hl,tank_sprite
282+  CB93 ED 4B D2 C9      ld bc,(tank_initpos2)         ; load bc with the start coords
283+  CB97 22 DB C9         ld (tank_current_sprite),hl  ; put into memory
284+  CB9A ED 43 DD C9      ld (tank_current_coords),bc  ; put into memory
285+  CB9E CD BD CB         call tank_draw
286+  CBA1 08               ex af,af'
287+  CBA2 3A D4 C9         ld a,(tank_frame)            ; get the animation frame
288+  CBA5 16 00            ld d,0
289+  CBA7 5F               ld e,a
290+  CBA8 19               add hl,de
291+  CBA9 22 DB C9         ld (tank_current_sprite),hl  ; put into memory
292+  CBAC 08               ex af,af'
293+  CBAD ED 4B D2 C9      ld bc,(tank_initpos2)         ; load bc with the start coords
294+  CBB1 81 C6 08         add c,8                      ; move one line down
295+  CBB4 4F               ld c,a
296+  CBB5 ED 43 DD C9      ld (tank_current_coords),bc  ; put into memory
297+  CBB9 CD BD CB         call tank_draw
298+  CBBC C9               ret
299+  CBBD
300+  CBBD              ;
301+  CBBD              ; Draw the tank
302+  CBBD              ; Inputs:
303+  CBBD              ; None, all in memory
304+  CBBD              ;
305+  CBBD              tank_draw:
306+  CBBD 3E 04            ld a,4                              ; 4 pieces per half
307+  CBBF              tank_draw0:
308+  CBBF F5               push af
309+  CBC0 2A DB C9         ld hl,(tank_current_sprite)
310+  CBC3 ED 4B DD C9      ld bc,(tank_current_coords)         ; load bc with the start coords
311+  CBC7 CD 29 AB         call sprites_drawsprite
312+  CBCA 2A DB C9         ld hl,(tank_current_sprite)
313+  CBCD ED 4B DD C9      ld bc,(tank_current_coords)         ; load bc with the start coords
314+  CBD1 11 08 00         ld de,8
315+  CBD4 19               add hl,de
316+  CBD5 80 C6 08         add b,8
317+  CBD8 47               ld b,a
318+  CBD9 22 DB C9         ld (tank_current_sprite),hl         ; put into memory
319+  CBDC ED 43 DD C9      ld (tank_current_coords),bc         ; put into memory
320+  CBE0 F1               pop af
321+  CBE1 3D               dec a
322+  CBE2 FE 00            cp 0
323+  CBE4 C2 BF CB         jp nz,tank_draw0
324+  CBE7
325+  CBE7 C9               ret
326+  CBE8
# file closed: game/tank.asm
147   CBE8                  include "game\rocks.asm"
# file opened: game/rocks.asm
  1+  CBE8              ;
  2+  CBE8              ; A structure of falling rocks
  3+  CBE8              ; Assume we'll never have more than 4 falling at any one time
  4+  CBE8              ; (1,2 - 16 bit memory location for rock graphic),state (0 fell, 1 falling, 2 wobbling), countdown
  5+  CBE8              ;
  6+  CBE8              rocks_falling:
  7+  CBE8 00 00 00 00      defb 0,0,0,0
  8+  CBEC 00 00 00 00      defb 0,0,0,0
  9+  CBF0 00 00 00 00      defb 0,0,0,0
 10+  CBF4 00 00 00 00      defb 0,0,0,0
 11+  CBF8
 12+  CBF8              rocks_tmp:
 13+  CBF8 00               defb 0
 14+  CBF9
 15+  CBF9              rocks_tmp2:
 16+  CBF9 00 00            defb 0,0
 17+  CBFB
 18+  CBFB              ;
 19+  CBFB              ; The number of frames to wobble for
 20+  CBFB              ; Must always be 10 more than the number of frames a player digs
 21+  CBFB              ;
 22+  CBFB              rocks_numberofframestowobble:
 23+  CBFB 14               defb 20
 24+  CBFC
 25+  CBFC              ;
 26+  CBFC              ; Coords of the rock that killed us
 27+  CBFC              ;
 28+  CBFC              rocks_killerrock:
 29+  CBFC 00 00            defb 0,0
 30+  CBFE
 31+  CBFE              ;
 32+  CBFE              ; Checks for a rock that needs to start falling. Takes a memory location of the first line at the bottom of the space.
 33+  CBFE              ; Checks to see if the pixel row in that location is a rock bottom. If it is, mark this rock as ready to fall.
 34+  CBFE              ; If the pixel row is not the rock bottom, stop checking.
 35+  CBFE              ; Inputs:
 36+  CBFE              ; hl- memory location
 37+  CBFE              ;
 38+  CBFE              rocks_checkforfalling:
 39+  CBFE 7E               ld a,(hl)           ; get the pixel row in this memory location
 40+  CBFF FE 7E            cp 126              ; check against the bottom pixel row of the rock graphic
 41+  CC01 C2 07 CC         jp nz,rocks_checkforfalling2 ; not a rock, stop
 42+  CC04 CD 08 CC         call rocks_addrocktofalling ; mark the rock as falling
 43+  CC07              rocks_checkforfalling2:
 44+  CC07 C9               ret
 45+  CC08
 46+  CC08              ;
 47+  CC08              ; Adds the rock to the structure that tracks falling rocks
 48+  CC08              ; Inputs:
 49+  CC08              ; hl - memory location of falling rock graphic
 50+  CC08              ; bc - coords of rock, c vert
 51+  CC08              rocks_addrocktofalling:
 52+  CC08 C5               push bc             ; store the coords
 53+  CC09 11 E8 CB         ld de,rocks_falling
 54+  CC0C 06 04            ld b,4              ; number of possible falling rocks
 55+  CC0E              rocks_addrocktofalling0:
 56+  CC0E 13               inc de
 57+  CC0F                  ;inc de
 58+  CC0F 13               inc de              ; move three along to get the state
 59+  CC10 1A               ld a,(de)           ; load the state
 60+  CC11 FE 00            cp 0                ; check if this is not falling
 61+  CC13 C2 2A CC         jp nz,rocks_addrocktofalling1 ; continue the loop if not 0
 62+  CC16 13               inc de              ; move to frame
 63+  CC17 3A FB CB         ld a,(rocks_numberofframestowobble) ; load the number of frames to wobble
 64+  CC1A 12               ld (de),a
 65+  CC1B 1B               dec de              ; move de back to state
 66+  CC1C 3E 02            ld a,2
 67+  CC1E 12               ld (de),a           ; set the state to wobbling
 68+  CC1F 1B               dec de              ; move back coords
 69+  CC20 C1               pop bc              ; get back coords
 70+  CC21 78               ld a,b
 71+  CC22 12               ld (de),a           ; store the vertical
 72+  CC23 1B               dec de
 73+  CC24 79               ld a,c
 74+  CC25 12               ld (de),a           ; store the horizontal
 75+  CC26 C5               push bc
 76+  CC27 C3 2E CC         jp rocks_addrocktofalling2 ; done
 77+  CC2A              rocks_addrocktofalling1:
 78+  CC2A 13               inc de
 79+  CC2B 13               inc de              ; move memory along to next rock
 80+  CC2C 10 E0            djnz rocks_addrocktofalling0 ; try the next rock
 81+  CC2E              rocks_addrocktofalling2: ; done, return
 82+  CC2E C1               pop bc              ; to tidy up
 83+  CC2F C9               ret
 84+  CC30
 85+  CC30              ;
 86+  CC30              ; Processes any falling rocks
 87+  CC30              ;
 88+  CC30              rocks_processrocks:
 89+  CC30 DD 21 E8 CB      ld ix,rocks_falling
 90+  CC34 06 04            ld b,4              ; the number of rocks to check
 91+  CC36              rocks_processrocks0:
 92+  CC36 C5               push bc             ; store loop count
 93+  CC37 DD 4E 00 DD      ld bc,(ix)          ; load the coords for this rock into bc
 93+  CC3B 46 01
 94+  CC3D DD 23            inc ix
 95+  CC3F DD 23            inc ix              ; move to the state
 96+  CC41 DD 7E 00         ld a,(ix)           ; load the state into a
 97+  CC44 FE 00            cp 0
 98+  CC46 CA 67 CC         jp z,rocks_processrocks3 ; if not falling, check next
 99+  CC49 FE 02            cp 2
100+  CC4B C2 5B CC         jp nz, rocks_processrocks2
101+  CC4E                  ; we're wobbling
102+  CC4E DD 23            inc ix              ; get frame number for wobble
103+  CC50 DD 7E 00         ld a,(ix)           ; get wobble frame into a
104+  CC53 CD 2A CD         call rocks_wobble
105+  CC56 DD 23            inc ix              ; increment for next
106+  CC58 C3 6B CC         jp rocks_processrocks1  ; do next rock
107+  CC5B              rocks_processrocks2:
108+  CC5B                  ; we're falling
109+  CC5B C5               push bc
110+  CC5C CD 6F CC         call rocks_fall
111+  CC5F C1               pop bc
112+  CC60 DD 23            inc ix
113+  CC62 DD 23            inc ix              ; inc ix to get to next
114+  CC64 C3 6B CC         jp rocks_processrocks1
115+  CC67              rocks_processrocks3:
116+  CC67 DD 23            inc ix
117+  CC69 DD 23            inc ix
118+  CC6B              rocks_processrocks1:
119+  CC6B C1               pop bc              ; get loop count back
120+  CC6C 10 C8            djnz rocks_processrocks0
121+  CC6E C9               ret
122+  CC6F
123+  CC6F              ;
124+  CC6F              ; Falls a rock one pixel, checks the next square down to see if it is empty, if not, stop falling
125+  CC6F              ; bc - coord of current rock graphic on screen
126+  CC6F              ; ix - memory location of current rock in rock list, currently at the 3rd position (rock state)
127+  CC6F              ;
128+  CC6F              rocks_fall:
129+  CC6F DD 2B            dec ix
130+  CC71 DD 2B            dec ix              ; decrease ix back to coords
131+  CC73 ED 43 F9 CB      ld (rocks_tmp2),bc  ; store original coords
132+  CC77 3E 03            ld a,3              ; move this number of pixels
133+  CC79              rocks_fall1:
134+  CC79 32 F8 CB         ld (rocks_tmp),a    ; store loop counter
135+  CC7C DD 4E 00 DD      ld bc,(ix)          ; get current coords
135+  CC80 46 01
136+  CC82 CD 36 AC         call sprites_scadd  ; get the memory of the coords into de
137+  CC85 14               inc d               ; add 256 to get next row
138+  CC86 1A               ld a,(de)           ; get the contents of the next row
139+  CC87 FE 00            cp 0
140+  CC89 C2 E9 CC         jp nz,rocks_fall3    ; move the rock if the row is empty
141+  CC8C 0C               inc c               ; increment the vertical
142+  CC8D DD 71 00 DD      ld (ix),bc          ; store the new coords
142+  CC91 70 01
143+  CC93 79               ld a,c              ; get the vertical coord into a
144+  CC94 E6 07            and 7               ; divisible by 8?
145+  CC96 FE 00            cp 0
146+  CC98 C2 B5 CC         jp nz,rocks_fall4   ; if not, carry on
147+  CC9B CD 57 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
148+  CC9E 3E 42            ld a,66             ; load red
149+  CCA0 CD AF AA         call screen_setattr
150+  CCA3 DD 4E 00 DD      ld bc,(ix)
150+  CCA7 46 01
151+  CCA9 79               ld a,c              ; get vertical
152+  CCAA D6 08            sub 8               ; look up one square
153+  CCAC 4F               ld c,a              ; put a back in c
154+  CCAD CD 57 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
155+  CCB0 3E 46            ld a,70             ; load yellow
156+  CCB2 CD AF AA         call screen_setattr
157+  CCB5              rocks_fall4:
158+  CCB5 3A F8 CB         ld a,(rocks_tmp)    ; get the loop counter
159+  CCB8 3D               dec a
160+  CCB9 FE 00            cp 0
161+  CCBB C2 79 CC         jp nz,rocks_fall1   ; do another pixel if needed
162+  CCBE              rocks_fall2:
163+  CCBE 3E 09            ld a,9              ; rock graphic
164+  CCC0 ED 4B F9 CB      ld bc,(rocks_tmp2)  ; get the original coords
165+  CCC4 CD A4 AA         call screen_getblock     ; get the memory into hl
166+  CCC7 CD 29 AB         call sprites_drawsprite  ; draw the sprite - over the top of the current one
167+  CCCA 3E 09            ld a,9
168+  CCCC DD 4E 00 DD      ld bc,(ix)          ; get the new coords
168+  CCD0 46 01
169+  CCD2 CD A4 AA         call screen_getblock     ; get the memory into hl
170+  CCD5 CD 29 AB         call sprites_drawsprite  ; draw the sprite - over the top of the current one
171+  CCD8 DD 4E 00 DD      ld bc,(ix)          ; get the coords again
171+  CCDC 46 01
172+  CCDE CD 0F CD         call rocks_checkforplayer ; check to see if we hit a player
173+  CCE1 DD 23            inc ix
174+  CCE3 DD 23            inc ix                  ; get ix back to state
175+  CCE5 CD FF CC         call rocks_makesound
176+  CCE8 C9               ret
177+  CCE9              rocks_fall3:
178+  CCE9 3E 00            ld a,0              ; set the state to fell
179+  CCEB DD 77 02         ld (ix+2),a           ; store the falling state
180+  CCEE DD 4E 00 DD      ld bc,(ix)          ; get the coords
180+  CCF2 46 01
181+  CCF4 CD 57 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
182+  CCF7 3E 42            ld a,66             ; load magenta
183+  CCF9 CD AF AA         call screen_setattr
184+  CCFC C3 BE CC         jp rocks_fall2      ; rejoin main loop
185+  CCFF
186+  CCFF              ;
187+  CCFF              ; Makes the rock sound if we're no longer falling, and if we didn't hit a player
188+  CCFF              ;
189+  CCFF              rocks_makesound:
190+  CCFF DD 7E 00         ld a,(ix)           ; get the state
191+  CD02 FE 00            cp 0
192+  CD04 C0               ret nz              ; if we haven't fallen, don't do anything
193+  CD05 21 28 C6         ld hl,player+11
194+  CD08 7E               ld a,(hl)
195+  CD09 FE 01            cp 1
196+  CD0B C4 4C B2         call nz, sound_rockfell ; only make sound if didn't kill player
197+  CD0E C9               ret
198+  CD0F
199+  CD0F              ;
200+  CD0F              ; Checks to see if the rock is hitting a player
201+  CD0F              ; Inputs:
202+  CD0F              ; bc - coords of rock we're checking
203+  CD0F              rocks_checkforplayer:
204+  CD0F ED 5B 1D C6      ld de,(player)       ; get the player coords
205+  CD13 7B               ld a,e               ; get the vert coord first
206+  CD14 91               sub c                ; subtract the rock vertical coord from players
207+  CD15 FE 08            cp 8                 ; the rock will only hit a player if the player is directly underneath, so this must be 8
208+  CD17 C0               ret nz               ; if not, hasn't hit
209+  CD18 7A               ld a,d               ; get the player horiz coord
210+  CD19 90               sub b                ; subtract rock coord
211+  CD1A C6 07            add 7                ; add max distance
212+  CD1C FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
213+  CD1E DA 22 CD         jp c,rocks_checkforplayer0
214+  CD21 C9               ret
215+  CD22              rocks_checkforplayer0:
216+  CD22 ED 43 FC CB      ld (rocks_killerrock),bc; store the coords of the killer rock
217+  CD26 CD 45 C7         call player_crushplayer ; if so, jump out
218+  CD29 C9               ret
219+  CD2A
220+  CD2A              ;
221+  CD2A              ; Wobbles a rocks
222+  CD2A              ; Inputs:
223+  CD2A              ; bc - coord of current rock graphic on screen
224+  CD2A              ; ix - memory location of current rock in rock list, currently at the 4th position (wobble count)
225+  CD2A              ; a - wobble frame
226+  CD2A              rocks_wobble:
227+  CD2A DD 7E 00         ld a,(ix)           ; get the wobble count, which we'll use as frame toggle
228+  CD2D E6 01            and 1               ; is it odd or even, gets 1 or 0
229+  CD2F 1E 09            ld e,9              ; this is the rock frame
230+  CD31 83               add a,e             ; add the frame toggle
231+  CD32 C5               push bc
232+  CD33 CD A4 AA         call screen_getblock     ; get the memory into hl
233+  CD36 CD 29 AB         call sprites_drawsprite  ; draw the sprite - over the top of the current one
234+  CD39 DD 7E 00         ld a,(ix)           ; get the frame toggle again
235+  CD3C 3D               dec a               ; decrease
236+  CD3D DD 77 00         ld (ix),a           ; store
237+  CD40 E6 01            and 1
238+  CD42 1E 09            ld e,9              ; this is the rock frame
239+  CD44 83               add a,e             ; add the frame toggle
240+  CD45 CD A4 AA         call screen_getblock     ; get the memory into hl
241+  CD48 C1               pop bc
242+  CD49 CD 29 AB         call sprites_drawsprite  ; draw the sprite again with the new frame - next time it will do the opposite
243+  CD4C DD 7E 00         ld a,(ix)           ; get the wobble count back
244+  CD4F FE 00            cp 0
245+  CD51 C0               ret nz              ; if we're not at zero, return
246+  CD52 DD 2B            dec ix              ; otherwise look to state location
247+  CD54 3E 01            ld a,1              ; set the state to falling
248+  CD56 DD 77 00         ld (ix),a           ; store the falling state
249+  CD59 DD 23            inc ix              ; set ix back to location of wobble count, and we're done
250+  CD5B C9               ret
251+  CD5C
# file closed: game/rocks.asm
148   CD5C                  include "game\scores.asm"
# file opened: game/scores.asm
  1+  CD5C              ;
  2+  CD5C              ; The score of the current player
  3+  CD5C              ;
  4+  CD5C              scores_current:
  5+  CD5C 04 01 30 30      defb 4,1,'000000',255       ;+2
  5+  CD60 30 30 30 30
  5+  CD64 FF
  6+  CD65
  7+  CD65              scores_defaultname:
  8+  CD65 2D 2D 2D         defb '---'
  9+  CD68
 10+  CD68              ;
 11+  CD68              ; The current high score table
 12+  CD68              ;
 13+  CD68              scores_table:
 14+  CD68 03 17 47 41      defb 03,23,'GAM000000',255         ;+0, +2, +5
 14+  CD6C 4D 30 30 30
 14+  CD70 30 30 30 FF
 15+  CD74 0C 17 47 41      defb 12,23,'GAM000000',255        ;+12, +14, +17
 15+  CD78 4D 30 30 30
 15+  CD7C 30 30 30 FF
 16+  CD80 15 17 47 41      defb 21,23,'GAM000000',255        ;+24, +26, +29
 16+  CD84 4D 30 30 30
 16+  CD88 30 30 30 FF
 17+  CD8C
 18+  CD8C              ;
 19+  CD8C              ; Add thousands to the score
 20+  CD8C              ; Inputs:
 21+  CD8C              ; b - number to add
 22+  CD8C              ;
 23+  CD8C              scores_addthousands:
 24+  CD8C 21 60 CD         ld hl,scores_current+4
 25+  CD8F CD F0 CD         call scores_update
 26+  CD92 C9               ret
 27+  CD93
 28+  CD93              ;
 29+  CD93              ; Add hundreds to the score
 30+  CD93              ; Inputs:
 31+  CD93              ; b - number to add
 32+  CD93              ;
 33+  CD93              scores_addhundreds:
 34+  CD93 21 61 CD         ld hl,scores_current+5
 35+  CD96 CD F0 CD         call scores_update
 36+  CD99 C9               ret
 37+  CD9A
 38+  CD9A              ;
 39+  CD9A              ; Temporary area for printing scores
 40+  CD9A              ;
 41+  CD9A              scores_printscore_tmp:
 42+  CD9A 00 00 00 00      defb 0,0,0,0,0,0,0,0,255
 42+  CD9E 00 00 00 00
 42+  CDA2 FF
 43+  CDA3
 44+  CDA3              ;
 45+  CDA3              ; Prints the score to screen
 46+  CDA3              ;
 47+  CDA3              scores_printscore:
 48+  CDA3 3A 2E C5         ld a,(game_currentplayer)   ; get current player
 49+  CDA6 21 5C CD         ld hl,scores_current
 50+  CDA9 FE 01            cp 1
 51+  CDAB C2 B3 CD         jp nz, score_printscore0    ; if not player 1
 52+  CDAE 36 04            ld (hl),4       ; set position for player 1
 53+  CDB0 C3 B5 CD         jp score_printscore1
 54+  CDB3              score_printscore0:
 55+  CDB3 36 16            ld (hl),22       ; set position for player 2
 56+  CDB5              score_printscore1:
 57+  CDB5 CD B9 CD         call score_printscoreformatted
 58+  CDB8 C9               ret
 59+  CDB9
 60+  CDB9              ;
 61+  CDB9              ; Formats a score and prints to the top screen
 62+  CDB9              ; Inputs:
 63+  CDB9              ; hl - where is the score
 64+  CDB9              score_printscoreformatted:
 65+  CDB9 01 08 00         ld bc,8
 66+  CDBC 11 9A CD         ld de,scores_printscore_tmp
 67+  CDBF ED B0            ldir                        ; copy to temp
 68+  CDC1 21 9A CD         ld hl,scores_printscore_tmp
 69+  CDC4 E5 DD E1         ld ix,hl
 70+  CDC7 DD 7E 02         ld a,(ix+2)
 71+  CDCA FE 30            cp 48                   ; is it a leading zero?
 72+  CDCC C2 DF CD         jp nz,score_printscore2
 73+  CDCF DD 36 02 20      ld (ix+2),32              ; load it with a space
 74+  CDD3 DD 7E 03         ld a,(ix+3)
 75+  CDD6 FE 30            cp 48                   ; is it a leading zero?
 76+  CDD8 C2 DF CD         jp nz,score_printscore2
 77+  CDDB DD 36 03 20      ld (ix+3),32              ; load it with a space
 78+  CDDF              score_printscore2:
 79+  CDDF CD 44 86         call string_print
 80+  CDE2 C9               ret
 81+  CDE3
 82+  CDE3              ;
 83+  CDE3              ; Prints both scores to screen
 84+  CDE3              ;
 85+  CDE3              scores_printscores:
 86+  CDE3 21 2B C7         ld hl,player1_score
 87+  CDE6 CD B9 CD         call score_printscoreformatted
 88+  CDE9 21 34 C7         ld hl,player2_score
 89+  CDEC CD B9 CD         call score_printscoreformatted
 90+  CDEF C9               ret
 91+  CDF0
 92+  CDF0              ;
 93+  CDF0              ; Updates the current score.
 94+  CDF0              ; Inputs:
 95+  CDF0              ; hl - memory location of the score column
 96+  CDF0              ; b - number to add
 97+  CDF0              ;
 98+  CDF0              scores_update:
 99+  CDF0 7E               ld a,(hl)           ; current value of digit.
100+  CDF1 80               add a,b             ; add points to this digit.
101+  CDF2 77               ld (hl),a           ; place new digit back in string.
102+  CDF3 FE 3A            cp 58               ; more than ASCII value '9'?
103+  CDF5 D8               ret c               ; no - relax.
104+  CDF6 D6 0A            sub 10              ; subtract 10.
105+  CDF8 77               ld (hl),a           ; put new character back in string.
106+  CDF9              scores_update0:
107+  CDF9 2B               dec hl              ; previous character in string.
108+  CDFA 34               inc (hl)            ; up this by one.
109+  CDFB 7E               ld a,(hl)           ; what's the new value?
110+  CDFC FE 3A            cp 58               ; gone past ASCII nine?
111+  CDFE D8               ret c               ; no, scoring done.
112+  CDFF D6 0A            sub 10              ; down by ten.
113+  CE01 77               ld (hl),a           ; put it back
114+  CE02 C3 F9 CD         jp scores_update0   ; go round again.
115+  CE05
116+  CE05
117+  CE05              ;
118+  CE05              ; Temporary area to store score
119+  CE05              ;
120+  CE05              scores_showtable_tmp:
121+  CE05 00 00 00 00      defb 0,0,0,0,0,0,0,0,0,0,0,255
121+  CE09 00 00 00 00
121+  CE0D 00 00 00 FF
122+  CE11
123+  CE11              ;
124+  CE11              ; Processes a score
125+  CE11              ; Inputs:
126+  CE11              ; hl - location on table
127+  CE11              ;
128+  CE11              scores_showtable_process:
129+  CE11 01 0B 00         ld bc,11                     ; copy this many
130+  CE14 11 05 CE         ld de,scores_showtable_tmp
131+  CE17 ED B0            ldir
132+  CE19 DD 21 05 CE      ld ix,scores_showtable_tmp   ; decide whether to show five or six numbers
133+  CE1D DD 7E 05         ld a,(ix+5)
134+  CE20 FE 30            cp 48                        ; is this a zero?
135+  CE22 C2 38 CE         jp nz,scores_showtable_process0 ; if not, show the whole thing
136+  CE25 01 05 00         ld bc,5                      ; copy this many
137+  CE28 DD E5 E1         ld hl,ix
138+  CE2B 11 06 00         ld de,6
139+  CE2E 19               add hl,de                    ; move to second digit
140+  CE2F 54 5D            ld de,hl
141+  CE31 1B               dec de
142+  CE32 ED B0            ldir
143+  CE34 DD 36 0A 20      ld (ix+10),32                ; stick a space at the end
144+  CE38              scores_showtable_process0:
145+  CE38 21 05 CE         ld hl,scores_showtable_tmp
146+  CE3B CD 44 86         call string_print
147+  CE3E C9               ret
148+  CE3F
149+  CE3F              ;
150+  CE3F              ; Displays the high score table at the bottom of the screen
151+  CE3F              ;
152+  CE3F              scores_showtable:
153+  CE3F 21 68 CD         ld hl, scores_table
154+  CE42 CD 11 CE         call scores_showtable_process
155+  CE45 21 74 CD         ld hl, scores_table+12
156+  CE48 CD 11 CE         call scores_showtable_process
157+  CE4B 21 80 CD         ld hl, scores_table+24
158+  CE4E CD 11 CE         call scores_showtable_process
159+  CE51 C9               ret
160+  CE52
161+  CE52              ;
162+  CE52              ; Place to store the current position we're checking
163+  CE52              ;
164+  CE52              scores_highscoretmp:
165+  CE52 00               defb 0
166+  CE53
167+  CE53              ;
168+  CE53              ; Place to store the equal indicator
169+  CE53              ;
170+  CE53              scores_highscoretmp2:
171+  CE53 00               defb 0
172+  CE54
173+  CE54              ;
174+  CE54              ; Updates the highscore table. Start at bottom score. Work way from left. Compare each digit. If current is higher than one we're checking,
175+  CE54              ; copy checking one down (or erase) then copy current over that one. Then move up one and do the same
176+  CE54              ;
177+  CE54              scores_processhighscores:
178+  CE54 21 52 CE         ld hl,scores_highscoretmp
179+  CE57 36 00            ld (hl),0  ; load up the tracking byte with 0 (ie, not on the table)
180+  CE59 3E 1D            ld a,29
181+  CE5B              scores_processhighscores3:
182+  CE5B 21 68 CD         ld hl,scores_table          ; position of first score column
183+  CE5E 5F               ld e,a
184+  CE5F 16 00            ld d,0
185+  CE61 19               add hl,de
186+  CE62 08               ex af,af'                   ; store a for later
187+  CE63 11 5E CD         ld de,scores_current+2      ; position of current score column
188+  CE66 3E 01            ld a,1
189+  CE68 32 53 CE         ld (scores_highscoretmp2),a ; set the equal indicator to 1 - this will be set to zero if a different number is found
190+  CE6B 06 06            ld b,6                      ; times to loop
191+  CE6D              scores_processhighscores0:
192+  CE6D 7E               ld a,(hl)
193+  CE6E 4F               ld c,a                      ; get first score column
194+  CE6F 1A               ld a,(de)                   ; get first current column
195+  CE70 B9               cp c                        ; compare current with first
196+  CE71 DA 96 CE         jp c,scores_processhighscores4  ; if c is bigger, then this is not a higher score, so end
197+  CE74 CA 7F CE         jp z,scores_processhighscores5  ; if c is equal, then don't clear the equality flag
198+  CE77 3E 00            ld a,0                      ; this must be bigger, so no need to check further
199+  CE79 32 53 CE         ld (scores_highscoretmp2),a ; zero the equality indicator
200+  CE7C C3 83 CE         jp scores_processhighscores6
201+  CE7F              scores_processhighscores5:
202+  CE7F 23               inc hl
203+  CE80 13               inc de                      ; move to next column
204+  CE81 10 EA            djnz scores_processhighscores0 ; loop
205+  CE83              scores_processhighscores6:
206+  CE83 3A 53 CE         ld a,(scores_highscoretmp2)   ; get the equality indicator
207+  CE86 FE 01            cp 1
208+  CE88 CA 96 CE         jp z,scores_processhighscores4 ; if it is equal, not a highscore
209+  CE8B B7               or a                            ; clear the carry flag
210+  CE8C 08               ex af,af'                     ; still here, so must be bigger
211+  CE8D 32 52 CE         ld (scores_highscoretmp),a  ; store the position indicator in the tracking byte
212+  CE90 0E 0C            ld c,12
213+  CE92 91               sub c
214+  CE93 D2 5B CE         jp nc,scores_processhighscores3 ; if the place we're looking is less than zero, we've gone to far, so continue, otherwise go again
215+  CE96              scores_processhighscores4
216+  CE96 CD 9A CE         call scores_updatehighscores
217+  CE99 C9               ret
218+  CE9A
219+  CE9A              ;
220+  CE9A              ; Update score table
221+  CE9A              ;
222+  CE9A              scores_updatehighscores:
223+  CE9A 3A 52 CE         ld a,(scores_highscoretmp)  ; get the place we want to overwrite
224+  CE9D FE 00            cp 0
225+  CE9F C8               ret z                       ; if this is 0, didn't get a high score
226+  CEA0 FE 1D            cp 29                       ; check against 29... if it's equal, we don't want to copy the current score down one
227+  CEA2 CA D5 CE         jp z, scores_updatehighscores3
228+  CEA5                                              ; copy old score over one below, if not first
229+  CEA5 21 68 CD         ld hl,scores_table
230+  CEA8 11 11 00         ld de,17                    ; start at second score, because this is the first one we'd ever need to copy...
231+  CEAB 19               add hl,de                   ; position of first column
232+  CEAC 2B               dec hl
233+  CEAD 2B               dec hl
234+  CEAE 2B               dec hl
235+  CEAF E5               push hl
236+  CEB0 11 0C 00         ld de,12
237+  CEB3 19               add hl,de                   ; get position of next score
238+  CEB4 54 5D            ld de,hl
239+  CEB6 E1               pop hl                      ; get hl back
240+  CEB7 01 09 00         ld bc,9
241+  CEBA ED B0            ldir
242+  CEBC FE 11            cp 17                       ; see if we're copying into the second place slot (17 memory offset). If so, stop copying back the scores
243+  CEBE CA D5 CE         jp z,scores_updatehighscores3
244+  CEC1 21 68 CD         ld hl,scores_table
245+  CEC4 11 02 00         ld de,2                    ; ... otherwise, copy back the first score
246+  CEC7 19               add hl,de                   ; position of first column
247+  CEC8 E5               push hl
248+  CEC9 11 0C 00         ld de,12
249+  CECC 19               add hl,de                   ; get position of next score
250+  CECD 54 5D            ld de,hl
251+  CECF E1               pop hl                      ; get hl back
252+  CED0 01 09 00         ld bc,9
253+  CED3 ED B0            ldir
254+  CED5              scores_updatehighscores3:
255+  CED5 06 06            ld b,6                      ; now overwrite
256+  CED7 21 68 CD         ld hl,scores_table
257+  CEDA 16 00            ld d,0
258+  CEDC 5F               ld e,a
259+  CEDD 19               add hl,de                   ; position of first column
260+  CEDE 08               ex af,af'
261+  CEDF 11 5E CD         ld de,scores_current+2      ; position of current score column
262+  CEE2              scores_updatehighscores2:
263+  CEE2 1A               ld a,(de)
264+  CEE3 77               ld (hl),a
265+  CEE4 23               inc hl
266+  CEE5 13               inc de
267+  CEE6 10 FA            djnz scores_updatehighscores2
268+  CEE8 11 09 00         ld de,9
269+  CEEB ED 52            sbc hl,de
270+  CEED 54 5D            ld de,hl                    ; get back to start of entry
271+  CEEF 21 65 CD         ld hl,scores_defaultname    ; still need to overwrite the name
272+  CEF2 01 03 00         ld bc,3                      ; 3 chars to copy
273+  CEF5 ED B0            ldir
274+  CEF7 C9               ret
# file closed: game/scores.asm
149   CEF8                  include "game\diamonds.asm"
# file opened: game/diamonds.asm
  1+  CEF8              diamonds_tmp:
  2+  CEF8 00               defb 0
  3+  CEF9
  4+  CEF9              diamonds_tmp2:
  5+  CEF9 00               defb 0
  6+  CEFA
  7+  CEFA              ;
  8+  CEFA              ; Holds the number of thousands for the current gem type
  9+  CEFA              ;
 10+  CEFA              diamonds_score:
 11+  CEFA 00               defb 0
 12+  CEFB
 13+  CEFB              ;
 14+  CEFB              ; Changes the attribute of gem and diamond cells based on the frame count
 15+  CEFB              ; Inputs:
 16+  CEFB              ; hl - memory location of gem type
 17+  CEFB              diamonds_twinkle_type:
 18+  CEFB CD C7 C5         call game_getcurrentframe       ; get current frame number
 19+  CEFE E6 07            and 7                           ; want a number from 0-7
 20+  CF00 C6 40            add 64                          ; add to 60 to get attr colour
 21+  CF02 32 F9 CE         ld (diamonds_tmp2),a             ; store the colour
 22+  CF05              diamonds_twinkle_type0:
 23+  CF05 4E 23 46 2B      ld bc,(hl)                      ; get coords into bc
 24+  CF09 79               ld a,c                          ; load c into a
 25+  CF0A FE FF            cp 255                          ; is this the end?
 26+  CF0C CA 34 CF         jp z,diamonds_twinkle_type1           ; step out if so
 27+  CF0F 23               inc hl
 28+  CF10 23               inc hl
 29+  CF11 7E               ld a,(hl)                       ; check the state, don't process if collected
 30+  CF12 FE 01            cp 1
 31+  CF14 CA 35 CF         jp z,diamonds_twinkle_type2           ; step out if so
 32+  CF17 CD 75 CF         call diamonds_checkforplayer    ; check to see if we've collided with player
 33+  CF1A DC 3C CF         call c,diamonds_collect     ; we collided
 34+  CF1D 23               inc hl
 35+  CF1E E5               push hl
 36+  CF1F E5 DD E1         ld ix,hl
 37+  CF22 DD 4E FD DD      ld bc,(ix-3)                    ; get coords again
 37+  CF26 46 FE
 38+  CF28 3A F9 CE         ld a,(diamonds_tmp2)
 39+  CF2B CD AF AA         call screen_setattr
 40+  CF2E E1               pop hl
 41+  CF2F 23               inc hl
 42+  CF30 23               inc hl                          ; move to next diamond
 43+  CF31 C3 05 CF         jp diamonds_twinkle_type0
 44+  CF34              diamonds_twinkle_type1:
 45+  CF34 C9               ret
 46+  CF35              diamonds_twinkle_type2:
 47+  CF35 23               inc hl                          ; do stuff the we would have done anyway to get to next gem
 48+  CF36 23               inc hl
 49+  CF37 23               inc hl
 50+  CF38 08               ex af,af'
 51+  CF39 C3 05 CF         jp diamonds_twinkle_type0       ; rejoin main loop
 52+  CF3C
 53+  CF3C              ;
 54+  CF3C              ; Collect the diamond we collided with
 55+  CF3C              ; Inputs:
 56+  CF3C              ; hl - memory location of current diamond, currently on state
 57+  CF3C              ; Output:
 58+  CF3C              ; a - 70 - for yellow on black
 59+  CF3C              diamonds_collect:
 60+  CF3C 36 01            ld (hl),1                       ; collected
 61+  CF3E E5               push hl
 62+  CF3F 2B               dec hl
 63+  CF40 2B               dec hl
 64+  CF41 4E 23 46 2B      ld bc,(hl)                      ; get the coords
 65+  CF45 CD 67 AA         call screen_getscreencoordsfromcharcoords ; get the screen coords into bc
 66+  CF48 ED 5B F8 CE      ld de,(diamonds_tmp)            ; tmp stores the offset for this type of gem
 67+  CF4C 16 00            ld d,0
 68+  CF4E 21 6D BD         ld hl,sprites
 69+  CF51 19               add hl,de
 70+  CF52 CD 29 AB         call sprites_drawsprite     ; call the routine to draw the sprite
 71+  CF55 E1               pop hl
 72+  CF56 3E 46            ld a,70                     ; pass this back to overwrite the attr
 73+  CF58 32 F9 CE         ld (diamonds_tmp2),a
 74+  CF5B D9               exx
 75+  CF5C 3A FA CE         ld a,(diamonds_score)
 76+  CF5F 47               ld b,a
 77+  CF60 CD 8C CD         call scores_addthousands
 78+  CF63 3A F8 CE         ld a,(diamonds_tmp)
 79+  CF66 FE 40            cp 64                       ; check the gem type offset, if its 64 this is a diamond, so mark the level as completable
 80+  CF68 C2 70 CF         jp nz,diamonds_collect0
 81+  CF6B 21 2A C6         ld hl,player+13
 82+  CF6E 36 01            ld (hl),1                   ; mark the player as able to complete the level
 83+  CF70              diamonds_collect0:
 84+  CF70 CD 11 B2         call sound_gemcollected
 85+  CF73 D9               exx
 86+  CF74 C9               ret
 87+  CF75
 88+  CF75              ;
 89+  CF75              ; Checks to see if the gem is hitting a player
 90+  CF75              ; Inputs:
 91+  CF75              ; bc - coords of diamond we're checking
 92+  CF75              diamonds_checkforplayer:
 93+  CF75 78               ld a,b               ; multiply b by 8
 94+  CF76 07               rlca
 95+  CF77 07               rlca
 96+  CF78 07               rlca
 97+  CF79 47               ld b,a
 98+  CF7A ED 5B 1D C6      ld de,(player)       ; get the player coords
 99+  CF7E 7B               ld a,e               ; get the vert coord first
100+  CF7F 90               sub b                ; subtract the diamond vertical coord from players
101+  CF80 C6 04            add 4                ; add the max distance
102+  CF82 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
103+  CF84 D0               ret nc               ; if not, hasn't hit
104+  CF85 79               ld a,c               ; multiply c by 8
105+  CF86 07               rlca
106+  CF87 07               rlca
107+  CF88 07               rlca
108+  CF89 4F               ld c,a
109+  CF8A 7A               ld a,d               ; get the player horiz coord
110+  CF8B 91               sub c                ; subtract rock coord
111+  CF8C C6 04            add 4                ; add max distance
112+  CF8E FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
113+  CF90 D0               ret nc
114+  CF91 3E 00            ld a,0
115+  CF93 C9               ret
116+  CF94
117+  CF94
118+  CF94              ;
119+  CF94              ; Initialise diamonds and gems
120+  CF94              ;
121+  CF94              diamonds_twinkle
122+  CF94 21 FA CE         ld hl,diamonds_score
123+  CF97 36 02            ld (hl),2         ; store the score we'll add
124+  CF99 21 F8 CE         ld hl,diamonds_tmp
125+  CF9C 36 40            ld (hl),64         ; store the location the diamond sprite
126+  CF9E 21 E8 B8         ld hl, level_diamonds
127+  CFA1 CD FB CE         call diamonds_twinkle_type
128+  CFA4 21 FA CE         ld hl,diamonds_score
129+  CFA7 36 01            ld (hl),1         ; store the score we'll add
130+  CFA9 21 F8 CE         ld hl,diamonds_tmp
131+  CFAC 36 70            ld (hl),112         ; store the location the gem sprite
132+  CFAE 21 F8 B8         ld hl, level_gems
133+  CFB1 CD FB CE         call diamonds_twinkle_type
134+  CFB4 C9               ret
135+  CFB5
136+  CFB5              ;
137+  CFB5              ; Initialise diamonds and gems
138+  CFB5              ;
139+  CFB5              diamonds_init:
140+  CFB5 21 E8 B8         ld hl, level_diamonds
141+  CFB8 CD C2 CF         call diamonds_init_type
142+  CFBB 21 F8 B8         ld hl, level_gems
143+  CFBE CD C2 CF         call diamonds_init_type
144+  CFC1 C9               ret
145+  CFC2
146+  CFC2              ;
147+  CFC2              ; Initialise diamonds or gems, get memory addresses
148+  CFC2              ; Inputs:
149+  CFC2              ; hl - memory location
150+  CFC2              diamonds_init_type:
151+  CFC2 4E               ld c,(hl)                      ; get coords into c
152+  CFC3 79               ld a,c                          ; load c into add
153+  CFC4 FE FF            cp 255                          ; is this the end?
154+  CFC6 CA DD CF         jp z,diamonds_init_type1             ; step out if so
155+  CFC9 23               inc hl
156+  CFCA 46               ld b,(hl)                       ; get coords into b
157+  CFCB E5               push hl
158+  CFCC CD 18 AA         call screen_getcellattroffset ; get memory of attr for this diamond into de
159+  CFCF E1               pop hl
160+  CFD0 23               inc hl                          ; move to state
161+  CFD1 36 00            ld (hl),0
162+  CFD3 23               inc hl                          ; move to memory
163+  CFD4 73 23 72 2B      ld (hl),de                      ; store the memory location
164+  CFD8 23               inc hl                          ; move to next diamond
165+  CFD9 23               inc hl
166+  CFDA C3 C2 CF         jp diamonds_init_type
167+  CFDD              diamonds_init_type1:
168+  CFDD C9               ret
# file closed: game/diamonds.asm
150   CFDE                  include "game\missiles.asm"
# file opened: game/missiles.asm
  1+  CFDE              ;
  2+  CFDE              ; Controls when missiles fall
  3+  CFDE              ;
  4+  CFDE              missiles_count:
  5+  CFDE 00               defb 0
  6+  CFDF
  7+  CFDF              ;
  8+  CFDF              ; A structure of falling missiles
  9+  CFDF              ; Assume we'll never have more than 4 falling at any one time
 10+  CFDF              ; (1,2 - 16 bit memory location for missile graphic),state (0 fell, 1 falling)
 11+  CFDF              ;
 12+  CFDF              missiles_falling:
 13+  CFDF 00 00 00         defb 0,0,0
 14+  CFE2 00 00 00         defb 0,0,0
 15+  CFE5 00 00 00         defb 0,0,0
 16+  CFE8 00 00 00         defb 0,0,0
 17+  CFEB
 18+  CFEB              ;
 19+  CFEB              ; The coords of the missile that killed us
 20+  CFEB              ;
 21+  CFEB              missiles_killermissile:
 22+  CFEB 00 00            defb 0,0
 23+  CFED
 24+  CFED              ;
 25+  CFED              ; The speed of the missiles
 26+  CFED              ;
 27+  CFED              missiles_speed:
 28+  CFED 00               defb 0
 29+  CFEE
 30+  CFEE              ;
 31+  CFEE              ; Zeroes the state of each missile
 32+  CFEE              ;
 33+  CFEE              missiles_init:
 34+  CFEE 06 0C            ld b,12
 35+  CFF0 DD 21 6F B8      ld ix,level_missiles
 36+  CFF4              missiles_init0:
 37+  CFF4 DD 36 02 00      ld (ix+2),0               ; set the state to zero
 38+  CFF8 11 05 00         ld de,5
 39+  CFFB DD 19            add ix,de
 40+  CFFD DD 36 02 00      ld (ix+2),0
 41+  D001 DD 19            add ix,de
 42+  D003 10 EF            djnz missiles_init0
 43+  D005 06 04            ld b,4                  ; reset four falling missiles
 44+  D007 21 DF CF         ld hl,missiles_falling
 45+  D00A              missiles_init1:
 46+  D00A 36 00            ld (hl),0
 47+  D00C 23               inc hl
 48+  D00D 36 00            ld (hl),0
 49+  D00F 23               inc hl
 50+  D010 36 00            ld (hl),0
 51+  D012 23               inc hl
 52+  D013 10 F5            djnz missiles_init1
 53+  D015 C9               ret
 54+  D016
 55+  D016              ;
 56+  D016              ; Runs each frame and checks if a missile can fall, then selects one at random and adds to the falling missiles
 57+  D016              ; Processes any already falling missiles
 58+  D016              ;
 59+  D016              missiles_process:
 60+  D016 3A 28 C6         ld a,(player+11)                        ; check if the player was hit by a missile previously
 61+  D019 FE 03            cp 3
 62+  D01B C2 22 D0         jp nz,missiles_process3                 ; if not, continue
 63+  D01E CD 62 D1         call missiles_zonkplayer
 64+  D021 C9               ret
 65+  D022              missiles_process3:
 66+  D022 3A 2C C6         ld a,(player_location)
 67+  D025 FE 01            cp 1
 68+  D027 C2 98 D0         jp nz, missiles_process0                ; if not 1 we're not in the cavern so no need to make any more fall
 69+  D02A 21 2A C6         ld hl,player+13
 70+  D02D 7E               ld a,(hl)                               ; check if player has collected a diamond
 71+  D02E FE 01            cp 1
 72+  D030 C2 98 D0         jp nz, missiles_process0                ; don't activate if not
 73+  D033 21 DE CF         ld hl,missiles_count
 74+  D036 7E               ld a,(hl)                   ; get the missiles count
 75+  D037 3C               inc a
 76+  D038 ED 5B ED CF      ld de,(missiles_speed)
 77+  D03C BB               cp e                                   ; have we reached the count yet
 78+  D03D CA 44 D0         jp z,missiles_process2                 ; if not, don't activate a new one
 79+  D040 77               ld (hl),a                               ; store the updated count, and continue without activating
 80+  D041 C3 98 D0         jp missiles_process0
 81+  D044              missiles_process2:
 82+  D044 36 00            ld (hl),0                               ; zero the counter
 83+  D046 1E 0C            ld e,12
 84+  D048 CD B8 81         call utilities_randomupper              ; get random number from 0 to 11
 85+  D04B 11 0A 00         ld de,10
 86+  D04E CD 03 81         call utilities_multiply                 ; multiple random number by 10
 87+  D051 54 5D            ld de,hl                                ; this is the offset for the random missile
 88+  D053 DD 21 6F B8      ld ix,level_missiles                   ; load the location of the missile definitions
 89+  D057 DD 19            add ix,de                               ; get to location of missile
 90+  D059 DD 7E 02         ld a,(ix+2)
 91+  D05C FE 00            cp 0
 92+  D05E CA 6E D0         jp z,missiles_process1                  ; if this missile isn't active, activate it
 93+  D061 11 05 00         ld de,5                                 ; otherwise, check the missile above
 94+  D064 DD 19            add ix,de
 95+  D066 DD 7E 02         ld a,(ix+2)
 96+  D069 FE 00            cp 0
 97+  D06B C2 98 D0         jp nz,missiles_process0                 ; if this is active as well, the player got lucky
 98+  D06E              missiles_process1:                          ; activate a missile
 99+  D06E DD 36 02 01      ld (ix+2),1                               ; mark this missile as active
100+  D072 DD 4E 00 DD      ld bc,(ix)                              ; get char coords from the missile
100+  D076 46 01
101+  D078 78               ld a,b
102+  D079 ED 5B F7 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows
103+  D07D 93               sub e
104+  D07E CD 67 AA         call screen_getscreencoordsfromcharcoords ; get screen coords into bc
105+  D081 C5               push bc
106+  D082 3E 0C            ld a,12                                 ; inactive missile sprite
107+  D084 CD A4 AA         call screen_getblock
108+  D087 CD 29 AB         call sprites_drawsprite                 ; draw the sprite over the old one
109+  D08A C1               pop bc
110+  D08B C5               push bc
111+  D08C 3E 14            ld a,20                                 ; active missile sprite
112+  D08E CD A4 AA         call screen_getblock
113+  D091 CD 29 AB         call sprites_drawsprite                 ; draw the sprite over the old one
114+  D094 C1               pop bc
115+  D095 CD 26 D1         call missiles_addmissiletofalling
116+  D098              missiles_process0:
117+  D098 CD 9C D0         call missiles_fall
118+  D09B C9               ret
119+  D09C
120+  D09C              ;
121+  D09C              ; Processes falling missiles
122+  D09C              ;
123+  D09C              missiles_fall:
124+  D09C 06 04            ld b,4              ; number of possible falling missiles
125+  D09E DD 21 DF CF      ld ix,missiles_falling
126+  D0A2              missiles_fall0:
127+  D0A2 C5               push bc
128+  D0A3 DD 7E 02         ld a,(ix+2)
129+  D0A6 FE 00            cp 0
130+  D0A8 CA 05 D1         jp z,missiles_fall1 ; not falling move to next
131+  D0AB FE 01            cp 1                ; is this ready to fall
132+  D0AD CA B3 D0         jp z, missiles_fall3
133+  D0B0 C3 1F D1         jp missiles_fall4   ; if not, decrease the countdown
134+  D0B3              missiles_fall3:
135+  D0B3 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
135+  D0B7 46 01
136+  D0B9 CD 36 AC         call sprites_scadd  ; get the memory of the coords into de
137+  D0BC 14               inc d               ; add 256 to get next row
138+  D0BD 1A               ld a,(de)           ; get the contents of the next row
139+  D0BE FE 00            cp 0
140+  D0C0 C2 18 D1         jp nz,missiles_fall2 ; if this is not empty, stop this missile falling
141+  D0C3 3E 14            ld a,20                                 ; active missile sprite
142+  D0C5 CD A4 AA         call screen_getblock
143+  D0C8 CD 29 AB         call sprites_drawsprite                 ; draw the sprite over the old one
144+  D0CB DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
144+  D0CF 46 01
145+  D0D1 0C               inc c               ; move down one pixel
146+  D0D2 DD 71 00 DD      ld (ix),bc          ; store the new coords
146+  D0D6 70 01
147+  D0D8 3E 14            ld a,20                                 ; active missile sprite
148+  D0DA CD A4 AA         call screen_getblock
149+  D0DD CD 29 AB         call sprites_drawsprite                 ; draw the sprite
150+  D0E0 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
150+  D0E4 46 01
151+  D0E6 79               ld a,c              ; get the vertical coord into a
152+  D0E7 E6 07            and 7               ; divisible by 8?
153+  D0E9 FE 00            cp 0
154+  D0EB C2 05 D1         jp nz,missiles_fall1   ; if not, carry on
155+  D0EE CD 57 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
156+  D0F1 3E 43            ld a,67             ; load magenta
157+  D0F3 CD AF AA         call screen_setattr
158+  D0F6 DD 4E 00 DD      ld bc,(ix)
158+  D0FA 46 01
159+  D0FC CD 57 AA         call screen_getcharcoordsfromscreencoords ; get the attr address into de
160+  D0FF 05               dec b               ; look one square above
161+  D100 3E 46            ld a,70             ; load yellow
162+  D102 CD AF AA         call screen_setattr
163+  D105              missiles_fall1:         ; hl at state
164+  D105 DD 4E 00 DD      ld bc,(ix)          ; get coords back
164+  D109 46 01
165+  D10B CD 47 D1         call missiles_checkforplayer ; check for player
166+  D10E DD 23            inc ix
167+  D110 DD 23            inc ix
168+  D112 DD 23            inc ix              ; get to next missile
169+  D114 C1               pop bc
170+  D115 10 8B            djnz missiles_fall0
171+  D117 C9               ret
172+  D118              missiles_fall2:
173+  D118 DD 36 02 00      ld (ix+2),0
174+  D11C C3 05 D1         jp missiles_fall1   ; rejoin the loop
175+  D11F              missiles_fall4:
176+  D11F 3D               dec a               ; decrease the countdown
177+  D120 DD 77 02         ld (ix+2),a         ; store back
178+  D123 C3 05 D1         jp missiles_fall1   ; do next missile
179+  D126
180+  D126              ;
181+  D126              ; Adds the missile to the structure that tracks falling missile
182+  D126              ; Inputs:
183+  D126              ; bc - coords of missile, c vert
184+  D126              missiles_addmissiletofalling:
185+  D126 C5               push bc             ; store the coords
186+  D127 11 DF CF         ld de,missiles_falling
187+  D12A 06 04            ld b,4              ; number of possible falling missiles
188+  D12C              missiles_addmissiletofalling0:
189+  D12C 13               inc de
190+  D12D 13               inc de              ; move three along to get the state
191+  D12E 1A               ld a,(de)           ; load the state
192+  D12F FE 00            cp 0                ; check if this is not falling
193+  D131 C2 42 D1         jp nz,missiles_addmissiletofalling1 ; continue the loop if not 0
194+  D134 3E 19            ld a,25
195+  D136 12               ld (de),a           ; set the state to pre-falling
196+  D137 1B               dec de              ; move back coords
197+  D138 C1               pop bc              ; get back coords
198+  D139 78               ld a,b
199+  D13A 12               ld (de),a           ; store the vertical
200+  D13B 1B               dec de
201+  D13C 79               ld a,c
202+  D13D 12               ld (de),a           ; store the horizontal
203+  D13E C5               push bc
204+  D13F C3 45 D1         jp missiles_addmissiletofalling2 ; done
205+  D142              missiles_addmissiletofalling1:
206+  D142 13               inc de              ; move memory along to next rock
207+  D143 10 E7            djnz missiles_addmissiletofalling0 ; try the next missile
208+  D145              missiles_addmissiletofalling2: ; done, return
209+  D145 C1               pop bc              ; to tidy up
210+  D146 C9               ret
211+  D147
212+  D147              ;
213+  D147              ; Checks to see if the missile is hitting a player
214+  D147              ; Inputs:
215+  D147              ; bc - coords of missile we're checking
216+  D147              missiles_checkforplayer:
217+  D147 ED 5B 1D C6      ld de,(player)       ; get the player coords
218+  D14B 7B               ld a,e               ; get the vert coord first
219+  D14C 91               sub c                ; subtract the missile vertical coord from players
220+  D14D FE 08            cp 8                 ; the missile will only hit a player if the player is directly underneath, so this must be 8
221+  D14F C0               ret nz               ; if not, hasn't hit
222+  D150 7A               ld a,d               ; get the player horiz coord
223+  D151 90               sub b                ; subtract missile coord
224+  D152 C6 07            add 7                ; add max distance
225+  D154 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
226+  D156 DA 5A D1         jp c,missiles_checkforplayer0
227+  D159 C9               ret
228+  D15A              missiles_checkforplayer0:
229+  D15A ED 43 EB CF      ld (missiles_killermissile),bc; store the coords of the killer missile
230+  D15E CD 51 C7         call player_zonkplayer ; if so, jump out
231+  D161 C9               ret
232+  D162
233+  D162              ;
234+  D162              ; Player has been hit, so draw text over them and mark as dead
235+  D162              ;
236+  D162              missiles_zonkplayer:
237+  D162 CD 3F C7         call player_killplayer      ; mark as dead
238+  D165 ED 4B 1D C6      ld bc,(player)              ; get player coords
239+  D169 CD 57 AA         call screen_getcharcoordsfromscreencoords
240+  D16C 0D               dec c
241+  D16D 0D               dec c
242+  D16E 04               inc b
243+  D16F C5               push bc
244+  D170 3E 42            ld a,66
245+  D172 CD AF AA         call screen_setattr
246+  D175 0C               inc c
247+  D176 CD AF AA         call screen_setattr
248+  D179 0C               inc c
249+  D17A CD AF AA         call screen_setattr
250+  D17D 0C               inc c
251+  D17E CD AF AA         call screen_setattr
252+  D181 0C               inc c
253+  D182 CD AF AA         call screen_setattr
254+  D185 0C               inc c
255+  D186 CD AF AA         call screen_setattr
256+  D189 C1               pop bc
257+  D18A ED 5B F7 A8      ld de,(screen_offset)
258+  D18E 78               ld a,b
259+  D18F 93               sub e
260+  D190 47               ld b,a                      ; subtract the offset
261+  D191 04               inc b
262+  D192 04               inc b                       ; add two for the score rows
263+  D193 ED 43 B7 85      ld (string_zonk),bc         ; set coords of string
264+  D197 21 B7 85         ld hl,string_zonk
265+  D19A CD 44 86         call string_print
266+  D19D 06 14            ld b,20
267+  D19F CD 64 81         call utilities_pauseforframes ; pause
268+  D1A2 C9               ret
269+  D1A3
# file closed: game/missiles.asm
151   D1A3                  include "game\thepit.asm"
# file opened: game/thepit.asm
  1+  D1A3              ;
  2+  D1A3              ; Timer for deciding how fast the trap withdraws
  3+  D1A3              ;
  4+  D1A3              thepit_timer:
  5+  D1A3 00               defb 0
  6+  D1A4
  7+  D1A4              ;
  8+  D1A4              ; Ticks for the trap state. Will count to 3 then reset
  9+  D1A4              ;
 10+  D1A4              thepit_trapcount:
 11+  D1A4 00               defb 0
 12+  D1A5
 13+  D1A5              ;
 14+  D1A5              ; The horizontal coordinate of the current pit trap
 15+  D1A5              ;
 16+  D1A5              thepit_trapcoord:
 17+  D1A5 08               defb 8
 18+  D1A6
 19+  D1A6              ;
 20+  D1A6              ; Initialises the pit
 21+  D1A6              ;
 22+  D1A6              thepit_init:
 23+  D1A6 21 A5 D1         ld hl,thepit_trapcoord
 24+  D1A9 36 08            ld (hl),8
 25+  D1AB 21 A4 D1         ld hl,thepit_trapcount
 26+  D1AE 36 00            ld (hl),0
 27+  D1B0 C9               ret
 28+  D1B1              ;
 29+  D1B1              ; The speed the pit will withdraw
 30+  D1B1              ;
 31+  D1B1              thepit_speed:
 32+  D1B1 00               defb 0
 33+  D1B2
 34+  D1B2              ;
 35+  D1B2              ; Performs per frame processing on the pit room
 36+  D1B2              ;
 37+  D1B2              thepit_process:
 38+  D1B2 3A 2C C6         ld a,(player_location)
 39+  D1B5 FE 02            cp 2                            ; if two, the player is in the pit, so process the trap
 40+  D1B7 C2 21 D2         jp nz,thepit_process0
 41+  D1BA ED 4B 1D C6      ld bc,(player)                  ; get the player's coords to check if about to fall
 42+  D1BE 3E 08            ld a,8
 43+  D1C0 81               add a,c
 44+  D1C1 4F               ld c,a                          ; look at the square underneath
 45+  D1C2 CD 57 AA         call screen_getcharcoordsfromscreencoords ; get the cell coords
 46+  D1C5 CD E5 AA         call screen_ischarempty
 47+  D1C8 FE 01            cp 1                            ; check if this is 1=empty
 48+  D1CA CA 22 D2         jp z,thepit_process2
 49+  D1CD 3A A3 D1         ld a,(thepit_timer)             ; get the timer
 50+  D1D0 3C               inc a
 51+  D1D1 32 A3 D1         ld (thepit_timer),a             ; store
 52+  D1D4 ED 5B B1 D1      ld de,(thepit_speed)            ; get the speed
 53+  D1D8 BB               cp e                           ; have we reached the trigger?
 54+  D1D9 C2 21 D2         jp nz, thepit_process0          ; no need to do anything
 55+  D1DC 3E 00            ld a,0
 56+  D1DE 32 A3 D1         ld (thepit_timer),a             ; zero the timer and process
 57+  D1E1 3A A4 D1         ld a,(thepit_trapcount)         ; get the current count
 58+  D1E4 3C               inc a
 59+  D1E5 32 A4 D1         ld (thepit_trapcount),a         ; reset the trap count
 60+  D1E8 FE 04            cp 4                            ; do we need to begin another character?
 61+  D1EA C2 09 D2         jp nz,thepit_process1           ; if not, draw as normal
 62+  D1ED 3E 00            ld a,0
 63+  D1EF 32 A4 D1         ld (thepit_trapcount),a         ; reset the trap count
 64+  D1F2 3A A5 D1         ld a,(thepit_trapcoord)         ; get the trap horiz coord
 65+  D1F5 FE 02            cp 2
 66+  D1F7 CA 21 D2         jp z,thepit_process0
 67+  D1FA 4F               ld c,a
 68+  D1FB 06 0A            ld b,10
 69+  D1FD 3E 46            ld a,70
 70+  D1FF CD AF AA         call screen_setattr             ; set the attr of the empty square to yellow on black
 71+  D202 3A A5 D1         ld a,(thepit_trapcoord)         ; get the trap horiz coord
 72+  D205 3D               dec a
 73+  D206 32 A5 D1         ld (thepit_trapcoord),a         ; store the reduced coord
 74+  D209
 75+  D209              thepit_process1:                    ; draw the trapdoor in current position
 76+  D209 3A A5 D1         ld a,(thepit_trapcoord)
 77+  D20C FE 02            cp 2
 78+  D20E CA 21 D2         jp z, thepit_process0           ; don't process outside of the pit
 79+  D211 4F               ld c,a
 80+  D212 06 0A            ld b,10                         ; vertical coord will always be the same
 81+  D214 3A A4 D1         ld a,(thepit_trapcount)         ; get the trap count
 82+  D217 5F               ld e,a                          ; store in e
 83+  D218 3E 16            ld a,22                         ; 21 is full trapdoor
 84+  D21A 83               add a,e
 85+  D21B CD A4 AA         call screen_getblock
 86+  D21E CD 81 AA         call screen_showchar            ; show the char
 87+  D221
 88+  D221              thepit_process0:
 89+  D221 C9               ret
 90+  D222              thepit_process2:
 91+  D222 CD 57 C7         call player_pitkillplayer
 92+  D225 C9               ret
 93+  D226
# file closed: game/thepit.asm
152   D226                  include "game\monster.asm"
# file opened: game/monster.asm
  1+  D226
  2+  D226              ;
  3+  D226              ; Where the monster currently is
  4+  D226              ;
  5+  D226              monster_currentcoords:
  6+  D226 00 00            defb 0,0
  7+  D228
  8+  D228              ;
  9+  D228              ; The start coords of the monster
 10+  D228              ;
 11+  D228              monster_initcoords:
 12+  D228 70 1B            defb 112,27
 13+  D22A
 14+  D22A              ;
 15+  D22A              ; Store the memory location of the current jump position
 16+  D22A              ;
 17+  D22A              monster_jumppos:
 18+  D22A 00 00            defb 0,0
 19+  D22C
 20+  D22C              ;
 21+  D22C              ; The jump table for the monster.
 22+  D22C              ;
 23+  D22C              monster_jumptable:
 24+  D22C FF 03 02 02      defb 255,3,2,2,2,2,2,2,2,2,1,1,1,1,1,255
 24+  D230 02 02 02 02
 24+  D234 02 02 01 01
 24+  D238 01 01 01 FF
 25+  D23C
 26+  D23C              ;
 27+  D23C              ; The vertical direction: 0 up, 1 down
 28+  D23C              ;
 29+  D23C              monster_jumpdirectionvert:
 30+  D23C 00               defb 0
 31+  D23D
 32+  D23D              ;
 33+  D23D              ; The horiz direction: 0 right, 1 left
 34+  D23D              ;
 35+  D23D              monster_jumpdirectionhoriz:
 36+  D23D 00               defb 0
 37+  D23E
 38+  D23E              ;
 39+  D23E              ; Frame offset, 0 or 32
 40+  D23E              ;
 41+  D23E              monster_frameoffset:
 42+  D23E 00               defb 0
 43+  D23F
 44+  D23F              ;
 45+  D23F              ; Monster tick
 46+  D23F              ;
 47+  D23F              monster_tick:
 48+  D23F 00               defb 0
 49+  D240
 50+  D240              ;
 51+  D240              ; The colour of the monster
 52+  D240              ;
 53+  D240              monster_colour:
 54+  D240 06               defb 6
 55+  D241
 56+  D241              ;
 57+  D241              ; Initialises the pit monster
 58+  D241              ;
 59+  D241              monster_init:
 60+  D241 ED 4B 28 D2      ld bc,(monster_initcoords)              ; load the initial coords
 61+  D245 ED 43 26 D2      ld (monster_currentcoords),bc           ; save in current coords
 62+  D249 21 2D D2         ld hl,monster_jumptable+1
 63+  D24C 22 2A D2         ld (monster_jumppos),hl                 ; store the initial position in the jump table
 64+  D24F 3E 00            ld a,0
 65+  D251 32 3C D2         ld (monster_jumpdirectionvert),a        ; going up
 66+  D254 32 3E D2         ld (monster_frameoffset),a
 67+  D257 32 3F D2         ld (monster_tick),a
 68+  D25A CD E4 D2         call monster_draw                       ; the monster
 69+  D25D C9               ret
 70+  D25E
 71+  D25E              ;
 72+  D25E              ; Animate the monster
 73+  D25E              ;
 74+  D25E              monster_process:
 75+  D25E 3A 3F D2         ld a,(monster_tick)                     ; check if we should draw this frame
 76+  D261 FE 01            cp 1
 77+  D263 CA 6B D2         jp z,monster_process6
 78+  D266 3C               inc a
 79+  D267 32 3F D2         ld (monster_tick),a                     ; increase the tick and continue
 80+  D26A C9               ret
 81+  D26B              monster_process6:
 82+  D26B 3E 00            ld a,0
 83+  D26D 32 3F D2         ld (monster_tick),a                     ; zero the tick
 84+  D270 CD E4 D2         call monster_draw                       ; overwrite the old sprite
 85+  D273 3A 3E D2         ld a,(monster_frameoffset)              ; get the anim frame offset
 86+  D276 EE 20            xor 32                                  ; flip between 0 and 32
 87+  D278 32 3E D2         ld (monster_frameoffset),a              ; store
 88+  D27B ED 4B 26 D2      ld bc,(monster_currentcoords)           ; get the current coords
 89+  D27F 2A 2A D2         ld hl,(monster_jumppos)                 ; get the position in the jump table
 90+  D282 56               ld d,(hl)                               ; get the jump modifier
 91+  D283 3A 3C D2         ld a,(monster_jumpdirectionvert)        ; get the vertical direction
 92+  D286 FE 00            cp 0                                    ; if 0, going up, so dec vert
 93+  D288 C2 91 D2         jp nz,monster_process0
 94+  D28B 79               ld a,c
 95+  D28C 92               sub d
 96+  D28D 23               inc hl                                  ; move forward a jump pos
 97+  D28E C3 94 D2         jp monster_process1
 98+  D291              monster_process0:
 99+  D291 79               ld a,c                                   ; going down so inc c
100+  D292 82               add a,d
101+  D293 2B               dec hl                                  ; move back a jump pos
102+  D294              monster_process1:
103+  D294 4F               ld c,a                                  ; get the vertical coord back
104+  D295 7E               ld a,(hl)                               ; check the next jump pos
105+  D296 FE FF            cp 255                                  ; if 255 reverse
106+  D298 CA A1 D2         jp z,monster_process3
107+  D29B 22 2A D2         ld (monster_jumppos),hl                 ; store the new pos
108+  D29E C3 B3 D2         jp monster_process2                     ; keep going
109+  D2A1              monster_process3:
110+  D2A1 3A 3C D2         ld a,(monster_jumpdirectionvert)        ; get the direction
111+  D2A4 EE 01            xor 1                                   ; flip it
112+  D2A6 32 3C D2         ld (monster_jumpdirectionvert),a        ; store it
113+  D2A9 FE 01            cp 1
114+  D2AB CA B3 D2         jp z,monster_process2
115+  D2AE D9               exx
116+  D2AF CD F7 D2         call monster_colourchange
117+  D2B2 D9               exx
118+  D2B3              monster_process2:
119+  D2B3 3A 3D D2         ld a,(monster_jumpdirectionhoriz)       ; get the horiz direction
120+  D2B6 FE 00            cp 0                                    ; is it right?
121+  D2B8 C2 CD D2         jp nz,monster_process4
122+  D2BB 04               inc b                                   ; 1 pixel right
123+  D2BC 78               ld a,b
124+  D2BD FE 38            cp 56                                   ; reached the edge of the pit?
125+  D2BF C2 DC D2         jp nz,monster_process5
126+  D2C2 3A 3D D2         ld a,(monster_jumpdirectionhoriz)
127+  D2C5 EE 01            xor 1
128+  D2C7 32 3D D2         ld (monster_jumpdirectionhoriz),a       ; flip direction
129+  D2CA C3 DC D2         jp monster_process5
130+  D2CD              monster_process4:
131+  D2CD 05               dec b                                   ; 1 pixel left
132+  D2CE 78               ld a,b
133+  D2CF FE 18            cp 24                                   ; reached the edge of the pit?
134+  D2D1 C2 DC D2         jp nz,monster_process5
135+  D2D4 3A 3D D2         ld a,(monster_jumpdirectionhoriz)
136+  D2D7 EE 01            xor 1
137+  D2D9 32 3D D2         ld (monster_jumpdirectionhoriz),a       ; flip direction
138+  D2DC              monster_process5:
139+  D2DC ED 43 26 D2      ld (monster_currentcoords),bc           ; store the new vertical coords
140+  D2E0 CD E4 D2         call monster_draw                       ; finally, draw the monster
141+  D2E3 C9               ret
142+  D2E4
143+  D2E4              ;
144+  D2E4              ; Draw the monster at the current location
145+  D2E4              ;
146+  D2E4              monster_draw:
147+  D2E4 ED 4B 26 D2      ld bc,(monster_currentcoords)
148+  D2E8 3A 3E D2         ld a,(monster_frameoffset)
149+  D2EB 11 00 00         ld de,0
150+  D2EE 5F               ld e,a
151+  D2EF 21 81 BF         ld hl,monster_sprite                    ; load the first frame
152+  D2F2 19               add hl,de
153+  D2F3 CD 87 AB         call sprites_draw2by2sprite
154+  D2F6 C9               ret
155+  D2F7
156+  D2F7              ;
157+  D2F7              ; Changes the monster colour whenever it reaches the bottom of its jump
158+  D2F7              ;
159+  D2F7              monster_colourchange:
160+  D2F7 3A 40 D2         ld a,(monster_colour)
161+  D2FA 3C               inc a
162+  D2FB FE 07            cp 7
163+  D2FD C2 02 D3         jp nz, monster_colourchange0
164+  D300 3E 01            ld a,1
165+  D302              monster_colourchange0:
166+  D302 32 40 D2         ld (monster_colour),a                   ; save the monster colour
167+  D305 3A F7 A8         ld a,(screen_offset)
168+  D308 FE 00            cp 0
169+  D30A CA 37 D3         jp z,monster_colourchange1
170+  D30D 3A 40 D2         ld a,(monster_colour)                   ; get the monster colour
171+  D310 06 06            ld b,6
172+  D312 0E 40            ld c,64
173+  D314 81               add c                                   ; want this with black background, so add 64
174+  D315 11 A3 58         ld de,22528+163                         ; attrs here
175+  D318 CD BA A9         call screen_setcolours
176+  D31B 3A 40 D2         ld a,(monster_colour)                   ; get the monster colour
177+  D31E 06 06            ld b,6
178+  D320 0E 40            ld c,64
179+  D322 81               add c                                   ; want this with black background, so add 64
180+  D323 11 C3 58         ld de,22528+195                         ; attrs here
181+  D326 CD BA A9         call screen_setcolours
182+  D329 3A 40 D2         ld a,(monster_colour)                   ; get the monster colour
183+  D32C F6 60            or 96
184+  D32E 06 06            ld b,6
185+  D330 11 E3 58         ld de,22528+227                         ; attrs here
186+  D333 CD BA A9         call screen_setcolours
187+  D336 C9               ret
188+  D337              monster_colourchange1:
189+  D337 3A 40 D2         ld a,(monster_colour)                   ; get the monster colour
190+  D33A 06 06            ld b,6
191+  D33C 0E 40            ld c,64
192+  D33E 81               add c                                   ; want this with black background, so add 64
193+  D33F 11 A3 59         ld de,22528+419                         ; attrs here
194+  D342 CD BA A9         call screen_setcolours
195+  D345 3A 40 D2         ld a,(monster_colour)                   ; get the monster colour
196+  D348 06 06            ld b,6
197+  D34A 0E 40            ld c,64
198+  D34C 81               add c                                   ; want this with black background, so add 64
199+  D34D 11 C3 59         ld de,22528+451                         ; attrs here
200+  D350 CD BA A9         call screen_setcolours
201+  D353 3A 40 D2         ld a,(monster_colour)                   ; get the monster colour
202+  D356 F6 60            or 96
203+  D358 06 06            ld b,6
204+  D35A 11 E3 59         ld de,22528+483                         ; attrs here
205+  D35D CD BA A9         call screen_setcolours
206+  D360 C9               ret
# file closed: game/monster.asm
153   D361                  include "game\robots.asm"
# file opened: game/robots.asm
  1+  D361
  2+  D361              ;
  3+  D361              ; Array of robot states
  4+  D361              ; x,y,state (0 inactive, 1 active), direction (0 left, 1 right), anim offset, automove frames remaining, move direction (0 left, 1 right, 3 up, 4 down)
  5+  D361              robots_robots:
  6+  D361 00 00 00 00      defb 0,0,0,0,0,0,0
  6+  D365 00 00 00
  7+  D368 00 00 00 00      defb 0,0,0,0,0,0,0
  7+  D36C 00 00 00
  8+  D36F 00 00 00 00      defb 0,0,0,0,0,0,0
  8+  D373 00 00 00
  9+  D376 00 00 00 00      defb 0,0,0,0,0,0,0
  9+  D37A 00 00 00
 10+  D37D 00 00 00 00      defb 0,0,0,0,0,0,0
 10+  D381 00 00 00
 11+  D384
 12+  D384              robots_initcoords:
 13+  D384 18 E8            defb 24,232
 14+  D386
 15+  D386              ;
 16+  D386              ; When this reaches zero, spawn a new robot
 17+  D386              ;
 18+  D386              robots_spawntimer:
 19+  D386 FA               defb 250
 20+  D387
 21+  D387              ;
 22+  D387              ; When this reaches max, change the anim frame
 23+  D387              ;
 24+  D387              robots_animtimer:
 25+  D387 00               defb 0
 26+  D388
 27+  D388              ;
 28+  D388              ; When this reaches max, change move the robot
 29+  D388              ;
 30+  D388              robots_movetimer:
 31+  D388 00               defb 0
 32+  D389
 33+  D389
 34+  D389              ;
 35+  D389              ; The number of robots active
 36+  D389              ;
 37+  D389              robots_numberactive:
 38+  D389 00               defb 0
 39+  D38A
 40+  D38A              ;
 41+  D38A              ; Tracks which directions a robot can move
 42+  D38A              ; up,down,left,right
 43+  D38A              robots_canmovedirections:
 44+  D38A 00 00 00 00      defb 0,0,0,0
 45+  D38E
 46+  D38E              ;
 47+  D38E              ; The current robot speed
 48+  D38E              ;
 49+  D38E              robots_robotspeed:
 50+  D38E 02               defb 2
 51+  D38F
 52+  D38F              ;
 53+  D38F              ; The current robot spawn speed
 54+  D38F              ;
 55+  D38F              robots_robotspawnspeed:
 56+  D38F 04               defb 4
 57+  D390
 58+  D390              ;
 59+  D390              ; The current max robots
 60+  D390              ;
 61+  D390              robots_robotsmax:
 62+  D390 03               defb 3
 63+  D391
 64+  D391              ;
 65+  D391              ; Initialises the robots
 66+  D391              ;
 67+  D391              robots_init:
 68+  D391 06 23            ld b,35
 69+  D393 DD 21 61 D3      ld ix,robots_robots
 70+  D397              robots_init0:
 71+  D397 DD 36 00 00      ld (ix),0                       ; reset robot states back to zero
 72+  D39B DD 23            inc ix
 73+  D39D 10 F8            djnz robots_init0
 74+  D39F 3E 00            ld a,0
 75+  D3A1 32 89 D3         ld (robots_numberactive),a
 76+  D3A4 3E FA            ld a,250
 77+  D3A6 32 86 D3         ld (robots_spawntimer),a
 78+  D3A9                  ; Self writing code
 79+  D3A9                  ; Robot speed
 80+  D3A9 3A 8E D3         ld a,(robots_robotspeed)
 81+  D3AC 32 65 D4         ld (robots_process7+1),a
 82+  D3AF 3C               inc a
 83+  D3B0 32 95 D4         ld (robots_process6+1),a
 84+  D3B3                  ; Robots max
 85+  D3B3 3A 90 D3         ld a,(robots_robotsmax)
 86+  D3B6 32 CF D3         ld (robots_spawn+1),a
 87+  D3B9 32 26 D4         ld (robots_process8+1),a
 88+  D3BC 32 53 D4         ld (robots_process0+1),a
 89+  D3BF 3E 04            ld a,4
 90+  D3C1 32 8F D3         ld (robots_robotspawnspeed),a
 91+  D3C4 3A 8F D3         ld a,(robots_robotspawnspeed)
 92+  D3C7 32 37 D4         ld (robots_process10+1),a
 93+  D3CA CD 8A D7         call robots_zeromovecounters
 94+  D3CD C9               ret
 95+  D3CE
 96+  D3CE              ;
 97+  D3CE              ; Spawns a new robot
 98+  D3CE              ; Inputs:
 99+  D3CE              ; ix - pointer to start of robot array entry
100+  D3CE              ;
101+  D3CE              robots_spawn:
102+  D3CE 06 03            ld b,3                      ;(SELF WRITING CODE)
103+  D3D0 DD 21 61 D3      ld ix,robots_robots
104+  D3D4              robots_spawn0:
105+  D3D4 DD 7E 02         ld a,(ix+2)                 ; get the state
106+  D3D7 FE 00            cp 0
107+  D3D9 C2 05 D4         jp nz,robots_spawn1         ; if already active, move on
108+  D3DC ED 4B 84 D3      ld bc,(robots_initcoords)
109+  D3E0 DD 71 00 DD      ld (ix),bc
109+  D3E4 70 01
110+  D3E6 DD 36 02 01      ld (ix+2),1
111+  D3EA DD 36 03 00      ld (ix+3),0
112+  D3EE DD 36 04 00      ld (ix+4),0
113+  D3F2 DD 36 05 00      ld (ix+5),0
114+  D3F6 DD 36 06 00      ld (ix+6),0
115+  D3FA 3A 89 D3         ld a,(robots_numberactive)
116+  D3FD 3C               inc a
117+  D3FE 32 89 D3         ld (robots_numberactive),a  ; increase the number active
118+  D401 CD 1B D7         call robots_draw            ; draw initial frame
119+  D404 C9               ret
120+  D405              robots_spawn1:
121+  D405 11 07 00         ld de,7
122+  D408 DD 19            add ix,de
123+  D40A 10 C8            djnz robots_spawn0
124+  D40C C9               ret
125+  D40D              ;
126+  D40D              ; Kills robot
127+  D40D              ; Inputs:
128+  D40D              ; ix - pointer to start of robot array entry
129+  D40D              ;
130+  D40D              robots_kill:
131+  D40D 3A 89 D3         ld a,(robots_numberactive)
132+  D410 3D               dec a
133+  D411 32 89 D3         ld (robots_numberactive),a
134+  D414 DD 36 02 00      ld (ix+2),0                     ; set to inactive
135+  D418 C5               push bc
136+  D419 E5               push hl
137+  D41A 06 01            ld b,1
138+  D41C CD 93 CD         call scores_addhundreds
139+  D41F E1               pop hl
140+  D420 C1               pop bc
141+  D421 C9               ret
142+  D422
143+  D422              ;
144+  D422              ; Processes the robots
145+  D422              ;
146+  D422              robots_process:
147+  D422 3A 89 D3         ld a,(robots_numberactive)              ; first, check if we need to spawn a new robot
148+  D425              robots_process8:
149+  D425 FE 03            cp 3                                    ; 3 is the maximum
150+  D427 CA 52 D4         jp z,robots_process0                    ; if already three, nothing to do
151+  D42A 3A 8F D3         ld a,(robots_robotspawnspeed)                ; now check the spawn speed timer
152+  D42D 3D               dec a
153+  D42E 32 8F D3         ld (robots_robotspawnspeed),a           ; store the spawn speed timer
154+  D431 FE 00            cp 0
155+  D433 C2 52 D4         jp nz,robots_process0                   ; if it hasn't reached zero yet, just move
156+  D436              robots_process10:
157+  D436 3E 04            ld a,4                                  ; SELF WRITING CODE
158+  D438 32 8F D3         ld (robots_robotspawnspeed),a                ; reset the spawn speed timer
159+  D43B 3A 86 D3         ld a,(robots_spawntimer)                ; now check the spawn timer
160+  D43E FE 00            cp 0
161+  D440 C2 4E D4         jp nz,robots_process1                   ; if it hasn't reached zero yet, just decrease
162+  D443 3E FA            ld a,250
163+  D445 32 86 D3         ld (robots_spawntimer),a                ; reset the spawn timer
164+  D448 CD CE D3         call robots_spawn                       ; spawn a robot
165+  D44B C3 52 D4         jp robots_process0                      ; carry on
166+  D44E              robots_process1:
167+  D44E 3D               dec a
168+  D44F 32 86 D3         ld (robots_spawntimer),a                ; decrease the spawn timer and store
169+  D452              robots_process0:
170+  D452 06 03            ld b,3                                  ; max number of robots (SELF WRITING CODE)
171+  D454 DD 21 61 D3      ld ix, robots_robots                    ; point ix at the robot array
172+  D458              robots_process2:
173+  D458 C5               push bc
174+  D459 DD 7E 02         ld a,(ix+2)                             ; check the state
175+  D45C FE 00            cp 0
176+  D45E CA 7A D4         jp z,robots_process3                    ; if not active, move on
177+  D461 3A 88 D3         ld a,(robots_movetimer)
178+  D464              robots_process7:                            ; self writing code - the number in the comparison will be ovewritten
179+  D464 FE 04            cp 4
180+  D466 C2 7A D4         jp nz,robots_process3                   ; can we move this frame
181+  D469 CD 1B D7         call robots_draw                        ; draw over existing
182+  D46C CD 9F D4         call robots_move                        ; move the
183+  D46F DD 7E 02         ld a,(ix+2)                             ; get the state again
184+  D472 FE 00            cp 0
185+  D474 CA 7A D4         jp z,robots_process3                    ; move to next if this robot has become inactive
186+  D477 CD 1B D7         call robots_draw                        ; draw the new robot
187+  D47A              robots_process3:
188+  D47A C1               pop bc
189+  D47B 11 07 00         ld de,7
190+  D47E DD 19            add ix,de
191+  D480 10 D6            djnz robots_process2
192+  D482 3A 87 D3         ld a,(robots_animtimer)
193+  D485 3C               inc a
194+  D486 FE 08            cp 8
195+  D488 C2 8D D4         jp nz,robots_process4
196+  D48B 3E 00            ld a,0                                  ; reset if we reached max
197+  D48D              robots_process4:
198+  D48D 32 87 D3         ld (robots_animtimer),a
199+  D490 3A 88 D3         ld a,(robots_movetimer)                 ; increment the robot move timer
200+  D493 3C               inc a
201+  D494              robots_process6:                            ; self writing code - the number in the comparison will be ovewritten
202+  D494 FE 05            cp 5                                    ; there is another reference to this number above
203+  D496 C2 9B D4         jp nz,robots_process5
204+  D499 3E 00            ld a,0
205+  D49B              robots_process5:
206+  D49B 32 88 D3         ld (robots_movetimer),a
207+  D49E
208+  D49E C9               ret
209+  D49F
210+  D49F
211+  D49F              ;
212+  D49F              ; Moves a robot
213+  D49F              ; Inputs:
214+  D49F              ; ix - points to first byte of robot in array
215+  D49F              robots_move:
216+  D49F DD 7E 02         ld a,(ix+2)                             ; get the state
217+  D4A2 FE 02            cp 2
218+  D4A4 CA D5 D4         jp z,robots_move4                       ; don't move if shot, just change the anim
219+  D4A7 3A 87 D3         ld a,(robots_animtimer)                 ; get the anim timer
220+  D4AA FE 07            cp 7                                    ; compare with 8
221+  D4AC C2 BF D4         jp nz,robots_move1                       ; if even, don't increment frame
222+  D4AF DD 7E 04         ld a,(ix+4)                             ; get the anim frame
223+  D4B2 06 08            ld b,8
224+  D4B4 80               add a,b                                 ; add to anim frame
225+  D4B5 FE 20            cp 32
226+  D4B7 C2 BC D4         jp nz,robots_move0                      ; if not 32, then just store
227+  D4BA 3E 00            ld a,0                                  ; otherwise, reset
228+  D4BC              robots_move0:
229+  D4BC DD 77 04         ld (ix+4),a                             ; store
230+  D4BF              robots_move1:
231+  D4BF DD 7E 05         ld a,(ix+5)
232+  D4C2 FE 00            cp 0                                    ; are we automoving
233+  D4C4 CA CD D4         jp z,robots_move2                       ; if not, keep directions
234+  D4C7 CD E9 D4         call robots_automove
235+  D4CA C3 D1 D4         jp robots_move3
236+  D4CD              robots_move2:
237+  D4CD CD 26 D5         call robots_checkdirectionsandmove
238+  D4D0 C9               ret
239+  D4D1              robots_move3:
240+  D4D1 CD 64 D7         call robots_checkforplayer              ; check to see if we collided with a player
241+  D4D4 C9               ret
242+  D4D5              robots_move4:
243+  D4D5 DD 7E 04         ld a,(ix+4)
244+  D4D8 FE 48            cp 72
245+  D4DA C2 E3 D4         jp nz,robots_move5
246+  D4DD 3E 40            ld a,64
247+  D4DF DD 77 04         ld (ix+4),a
248+  D4E2 C9               ret
249+  D4E3              robots_move5:
250+  D4E3 3E 48            ld a,72
251+  D4E5 DD 77 04         ld (ix+4),a
252+  D4E8 C9               ret
253+  D4E9
254+  D4E9
255+  D4E9              ;
256+  D4E9              ; Processes automove
257+  D4E9              ; Inputs:
258+  D4E9              ; ix - points to the current robot
259+  D4E9              ; a - number of frames left to move
260+  D4E9              robots_automove:
261+  D4E9 3D               dec a
262+  D4EA DD 77 05         ld (ix+5),a                         ; store the decreased frames
263+  D4ED DD 4E 00 DD      ld bc,(ix)                          ; get coords
263+  D4F1 46 01
264+  D4F3 DD 7E 06         ld a,(ix+6)                         ; get the direction
265+  D4F6 FE 00            cp 0                                ; left
266+  D4F8 CA 09 D5         jp z,robots_automove1
267+  D4FB FE 02            cp 2                                ; up
268+  D4FD CA 0D D5         jp z,robots_automove3
269+  D500 FE 03            cp 3                                ; down
270+  D502 CA 14 D5         jp z,robots_automove4
271+  D505 04               inc b                               ; right
272+  D506 C3 1B D5         jp robots_automove2
273+  D509              robots_automove1:
274+  D509 05               dec b
275+  D50A C3 1B D5         jp robots_automove2
276+  D50D              robots_automove3:
277+  D50D 0D               dec c
278+  D50E 0D               dec c
279+  D50F 0D               dec c
280+  D510 0D               dec c
281+  D511 C3 1B D5         jp robots_automove2
282+  D514              robots_automove4:
283+  D514 0C               inc c
284+  D515 0C               inc c
285+  D516 0C               inc c
286+  D517 0C               inc c
287+  D518 C3 1B D5         jp robots_automove2
288+  D51B              robots_automove2:
289+  D51B DD 71 00 DD      ld (ix),bc
289+  D51F 70 01
290+  D521 C9               ret
291+  D522
292+  D522              ;
293+  D522              ; Holds how many times moved in current direction
294+  D522              ;
295+  D522              robots_alreadymoved:
296+  D522 00 00 00 00      defb 0,0,0,0
297+  D526
298+  D526              ;
299+  D526              ; Checks if a robot can move in all directions, then picks one and moves there.
300+  D526              ; This looks complicated, but really what it does is:
301+  D526              ; 1) Look at the current direction
302+  D526              ; 2) Randomly determine which orthoganal direction check first
303+  D526              ; 3) If orthogonal can't be moved, keep going in direction we're going
304+  D526              ; 4) Otherwise, back the way we came
305+  D526              ; Inputs:
306+  D526              ; ix - points to the current robot
307+  D526              ;
308+  D526              robots_checkdirectionsandmove:
309+  D526 DD 7E 06         ld a,(ix+6)                 ; get the direction
310+  D529 FE 00            cp 0                        ; left
311+  D52B C2 61 D5         jp nz,robots_checkdirectionsandmove0
312+  D52E                  ;LEFT
313+  D52E                  ; check how many times we've moved left
314+  D52E 21 22 D5         ld hl,robots_alreadymoved+0
315+  D531 7E               ld a,(hl)                               ; check how many times we've moved in this direction
316+  D532 FE 02            cp 2                                    ; if less than two, try to go in this direction
317+  D534 D2 3D D5         jp nc,robots_checkdirectionsandmove11
318+  D537                  ; check left
319+  D537 CD 8C D6         call robots_checkleftandmove
320+  D53A FE 01            cp 1
321+  D53C C8               ret z                       ; if we moved, don't check again
322+  D53D              robots_checkdirectionsandmove11:
323+  D53D                  ; random check
324+  D53D CD C7 C5         call game_getcurrentframe
325+  D540 E6 01            and 1                       ; odd or even
326+  D542 CA 4E D5         jp z,robots_checkdirectionsandmove3
327+  D545 CD F6 D5         call robots_checkupthendown ; prefer up over down
328+  D548 FE 01            cp 1
329+  D54A C8               ret z
330+  D54B C3 54 D5         jp robots_checkdirectionsandmove4
331+  D54E              robots_checkdirectionsandmove3:
332+  D54E CD EC D5         call robots_checkdownthenup ; prefer down over up
333+  D551 FE 01            cp 1
334+  D553 C8               ret z
335+  D554              robots_checkdirectionsandmove4:
336+  D554                  ; check left
337+  D554 CD 8C D6         call robots_checkleftandmove
338+  D557 FE 01            cp 1
339+  D559 C8               ret z                       ; if we moved, don't check again
340+  D55A                  ; check right
341+  D55A CD D1 D6         call robots_checkrightandmove
342+  D55D FE 01            cp 1
343+  D55F C8               ret z                       ; if we moved, don't check again
344+  D560                  ; if we're here and haven't moved...
345+  D560 C9               ret
346+  D561              robots_checkdirectionsandmove0
347+  D561                  ; RIGHT
348+  D561 FE 01            cp 1                        ; right
349+  D563 C2 99 D5         jp nz,robots_checkdirectionsandmove1
350+  D566                  ; ALREADY MOVING RIGHT
351+  D566                  ; check how many times we've moved right
352+  D566 21 23 D5         ld hl,robots_alreadymoved+1
353+  D569 7E               ld a,(hl)                               ; check how many times we've moved in this direction
354+  D56A FE 02            cp 2                                    ; if less than two, try to go in this direction
355+  D56C D2 75 D5         jp nc,robots_checkdirectionsandmove12
356+  D56F                  ; check left
357+  D56F CD D1 D6         call robots_checkrightandmove
358+  D572 FE 01            cp 1
359+  D574 C8               ret z                       ; if we moved, don't check again
360+  D575              robots_checkdirectionsandmove12:
361+  D575                  ; random check
362+  D575 CD C7 C5         call game_getcurrentframe
363+  D578 E6 01            and 1                       ; odd or even
364+  D57A CA 86 D5         jp z,robots_checkdirectionsandmove5
365+  D57D CD EC D5         call robots_checkdownthenup ; prefer down over up
366+  D580 FE 01            cp 1
367+  D582 C8               ret z
368+  D583 C3 8C D5         jp robots_checkdirectionsandmove6
369+  D586              robots_checkdirectionsandmove5:
370+  D586 CD F6 D5         call robots_checkupthendown ; prefer down over up
371+  D589 FE 01            cp 1
372+  D58B C8               ret z
373+  D58C              robots_checkdirectionsandmove6:
374+  D58C                  ; check right
375+  D58C CD D1 D6         call robots_checkrightandmove
376+  D58F FE 01            cp 1
377+  D591 C8               ret z                       ; if we moved, don't check again
378+  D592                  ; check left
379+  D592 CD 8C D6         call robots_checkleftandmove
380+  D595 FE 01            cp 1
381+  D597 C8               ret z                       ; if we moved, don't check again
382+  D598                  ; if we're here and haven't moved...
383+  D598 C9               ret
384+  D599              robots_checkdirectionsandmove1
385+  D599                  ; UP
386+  D599 FE 02            cp 2                        ; up
387+  D59B C2 C2 D5         jp nz,robots_checkdirectionsandmove2
388+  D59E                  ; ALREADY MOVING UP
389+  D59E                  ; random check
390+  D59E CD C7 C5         call game_getcurrentframe
391+  D5A1 E6 01            and 1                       ; odd or even
392+  D5A3 CA AF D5         jp z,robots_checkdirectionsandmove7
393+  D5A6 CD 0C D6         call robots_checkleftthenright ; prefer left over right
394+  D5A9 FE 01            cp 1
395+  D5AB C8               ret z
396+  D5AC C3 B5 D5         jp robots_checkdirectionsandmove8
397+  D5AF              robots_checkdirectionsandmove7:
398+  D5AF CD 02 D6         call robots_checkrightthenleft ; prefer right over left
399+  D5B2 FE 01            cp 1
400+  D5B4 C8               ret z
401+  D5B5              robots_checkdirectionsandmove8:
402+  D5B5                  ; check up
403+  D5B5 CD 18 D6         call robots_checkupandmove
404+  D5B8 FE 01            cp 1
405+  D5BA C8               ret z                       ; if we moved, don't check again
406+  D5BB                  ; check down
407+  D5BB CD 54 D6         call robots_checkdownandmove
408+  D5BE FE 01            cp 1
409+  D5C0 C8               ret z                       ; if we moved, don't check again
410+  D5C1                  ; if we're here and haven't moved...
411+  D5C1 C9               ret
412+  D5C2              robots_checkdirectionsandmove2
413+  D5C2                  ; DOWN
414+  D5C2                  ; random check
415+  D5C2 CD D1 81         call utilities_randomfromram
416+  D5C5 E6 01            and 1                       ; odd or even
417+  D5C7 CA D3 D5         jp z,robots_checkdirectionsandmove9
418+  D5CA CD 02 D6         call robots_checkrightthenleft ; prefer right over left
419+  D5CD FE 01            cp 1
420+  D5CF C8               ret z
421+  D5D0 C3 D9 D5         jp robots_checkdirectionsandmove10
422+  D5D3              robots_checkdirectionsandmove9:
423+  D5D3 CD 0C D6         call robots_checkleftthenright ; prefer left over right
424+  D5D6 FE 01            cp 1
425+  D5D8 C8               ret z
426+  D5D9              robots_checkdirectionsandmove10:
427+  D5D9                  ; check down
428+  D5D9 CD 54 D6         call robots_checkdownandmove
429+  D5DC FE 01            cp 1
430+  D5DE C8               ret z                       ; if we moved, don't check again
431+  D5DF                  ; check right first
432+  D5DF CD D1 D6         call robots_checkrightandmove
433+  D5E2 FE 01            cp 1
434+  D5E4 C8               ret z                       ; if we moved, don't check again
435+  D5E5                  ; check up
436+  D5E5 CD 18 D6         call robots_checkupandmove
437+  D5E8 FE 01            cp 1
438+  D5EA C8               ret z                       ; if we moved, don't check again
439+  D5EB                  ; if we're here and haven't moved...
440+  D5EB C9               ret
441+  D5EC
442+  D5EC              ;
443+  D5EC              ; Different orders of checking directions, for pseudo random motion
444+  D5EC              ;
445+  D5EC              robots_checkdownthenup:
446+  D5EC                  ; check down
447+  D5EC CD 54 D6         call robots_checkdownandmove
448+  D5EF FE 01            cp 1
449+  D5F1 C8               ret z                       ; if we moved, don't check again
450+  D5F2                  ; check up
451+  D5F2 CD 18 D6         call robots_checkupandmove
452+  D5F5 C9               ret
453+  D5F6
454+  D5F6              robots_checkupthendown:
455+  D5F6                  ; check up
456+  D5F6 CD 18 D6         call robots_checkupandmove
457+  D5F9 FE 01            cp 1
458+  D5FB C8               ret z
459+  D5FC                  ; check down
460+  D5FC CD 54 D6         call robots_checkdownandmove
461+  D5FF FE 01            cp 1
462+  D601 C9               ret
463+  D602              robots_checkrightthenleft:
464+  D602                  ; check right
465+  D602 CD D1 D6         call robots_checkrightandmove
466+  D605 FE 01            cp 1
467+  D607 C8               ret z                       ; if we moved, don't check again
468+  D608                  ; check left
469+  D608 CD 8C D6         call robots_checkleftandmove
470+  D60B C9               ret
471+  D60C
472+  D60C              robots_checkleftthenright:
473+  D60C                  ; check left
474+  D60C CD 8C D6         call robots_checkleftandmove
475+  D60F FE 01            cp 1
476+  D611 C8               ret z
477+  D612                  ; check right
478+  D612 CD D1 D6         call robots_checkrightandmove
479+  D615 FE 01            cp 1
480+  D617 C9               ret
481+  D618
482+  D618              ;
483+  D618              ; Checks up for movement
484+  D618              ; Outputs:
485+  D618              ; a - 1 if have moved
486+  D618              robots_checkupandmove:
487+  D618                  ; check above
488+  D618 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
488+  D61C 46 01
489+  D61E 79               ld a,c
490+  D61F FE 28            cp 40
491+  D621 D8               ret c
492+  D622 CD 36 AC         call sprites_scadd              ; get the memory location of cell into de
493+  D625 62 6B            ld hl,de                        ; look at cell directly above (subtract 256)
494+  D627 25               dec h
495+  D628 79               ld a,c
496+  D629 0E 08            ld c,8
497+  D62B 91               sub c
498+  D62C 4F               ld c,a
499+  D62D CD 07 C3         call movement_spaceisempty       ; check space is empty
500+  D630 7B               ld a,e                          ; check space empty flag
501+  D631 FE 00            cp 0
502+  D633 CA 51 D6         jp z,robots_checkupandmove0    ; can't move here so return
503+  D636 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
503+  D63A 46 01
504+  D63C 0D               dec c                       ; move up
505+  D63D 0D               dec c
506+  D63E 0D               dec c
507+  D63F 0D               dec c
508+  D640 DD 71 00 DD      ld (ix),bc
508+  D644 70 01
509+  D646 DD 36 06 02      ld (ix+6),2
510+  D64A DD 36 05 01      ld (ix+5),1                 ; set the auto move frames
511+  D64E 3E 01            ld a,1
512+  D650 C9               ret
513+  D651              robots_checkupandmove0:
514+  D651 3E 00            ld a,0
515+  D653 C9               ret
516+  D654
517+  D654              ;
518+  D654              ; Checks down for movement
519+  D654              ; Outputs:
520+  D654              ; a - 1 if have moved
521+  D654              robots_checkdownandmove:
522+  D654                  ; check below
523+  D654 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
523+  D658 46 01
524+  D65A CD 36 AC         call sprites_scadd              ; get the memory location of cell into de
525+  D65D 62 6B            ld hl,de                        ; look at cell directly above (add 256)
526+  D65F 24               inc h
527+  D660 79               ld a,c
528+  D661 0E 08            ld c,8
529+  D663 81               add c
530+  D664 4F               ld c,a
531+  D665 CD 07 C3         call movement_spaceisempty       ; check space is empty
532+  D668 7B               ld a,e                          ; check space empty flag
533+  D669 FE 00            cp 0
534+  D66B CA 89 D6         jp z,robots_checkdownandmove0    ; can't move here so return
535+  D66E DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
535+  D672 46 01
536+  D674 0C               inc c                       ; move up
537+  D675 0C               inc c
538+  D676 0C               inc c
539+  D677 0C               inc c
540+  D678 DD 71 00 DD      ld (ix),bc
540+  D67C 70 01
541+  D67E DD 36 06 03      ld (ix+6),3
542+  D682 DD 36 05 01      ld (ix+5),1                 ; set the auto move frames
543+  D686 3E 01            ld a,1
544+  D688 C9               ret
545+  D689              robots_checkdownandmove0:
546+  D689 3E 00            ld a,0
547+  D68B C9               ret
548+  D68C
549+  D68C              ;
550+  D68C              ; Checks left for movement
551+  D68C              ; Outputs:
552+  D68C              ; a - 1 if have moved
553+  D68C              robots_checkleftandmove:
554+  D68C                  ; check below
555+  D68C DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
555+  D690 46 01
556+  D692 CD 36 AC         call sprites_scadd              ; get the memory location of cell into de
557+  D695 62 6B            ld hl,de                        ; look at cell directly to the left (sub 1)
558+  D697 78               ld a,b
559+  D698 06 08            ld b,8
560+  D69A 90               sub b                           ; move one cell left
561+  D69B 47               ld b,a
562+  D69C 2B               dec hl                          ; memory location of cell to the right now in hl
563+  D69D CD 07 C3         call movement_spaceisempty       ; check space is empty
564+  D6A0 7B               ld a,e                          ; check space empty flag
565+  D6A1 FE 00            cp 0
566+  D6A3 CA CE D6         jp z,robots_checkleftandmove0    ; if zero can't move
567+  D6A6 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
567+  D6AA 46 01
568+  D6AC 05               dec b
569+  D6AD DD 71 00 DD      ld (ix),bc
569+  D6B1 70 01
570+  D6B3 DD 36 06 00      ld (ix+6),0
571+  D6B7 DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
572+  D6BB DD 36 03 00      ld (ix+3),0                 ; set to left
573+  D6BF 21 22 D5         ld hl,robots_alreadymoved+0 ; increment the already moved flag
574+  D6C2 7E               ld a,(hl)
575+  D6C3 3C               inc a
576+  D6C4 CD 8A D7         call robots_zeromovecounters ; zero the move counters
577+  D6C7 21 22 D5         ld hl,robots_alreadymoved+0 ; increment the already moved flag
578+  D6CA 77               ld (hl),a                   ; store the incremented counter
579+  D6CB 3E 01            ld a,1
580+  D6CD C9               ret
581+  D6CE              robots_checkleftandmove0:
582+  D6CE 3E 00            ld a,0
583+  D6D0 C9               ret
584+  D6D1
585+  D6D1              ;
586+  D6D1              ; Checks right for movement
587+  D6D1              ; Outputs:
588+  D6D1              ; a - 1 if have moved
589+  D6D1              robots_checkrightandmove:
590+  D6D1                  ; check below
591+  D6D1 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
591+  D6D5 46 01
592+  D6D7 78               ld a,b
593+  D6D8 FE E8            cp 232
594+  D6DA CA 18 D7         jp z,robots_checkrightandmove0  ; can't move if at edge
595+  D6DD CD 36 AC         call sprites_scadd              ; get the memory location of cell into de
596+  D6E0 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
597+  D6E2 3E 08            ld a,8
598+  D6E4 80               add b                           ; move one cell right
599+  D6E5 47               ld b,a
600+  D6E6 23               inc hl                          ; memory location of cell to the right now in hl
601+  D6E7 CD 07 C3         call movement_spaceisempty       ; check space is empty
602+  D6EA 7B               ld a,e                          ; check space empty flag
603+  D6EB FE 00            cp 0
604+  D6ED CA 18 D7         jp z,robots_checkrightandmove0    ; if zero can't move
605+  D6F0 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
605+  D6F4 46 01
606+  D6F6 04               inc b
607+  D6F7 DD 71 00 DD      ld (ix),bc
607+  D6FB 70 01
608+  D6FD DD 36 06 01      ld (ix+6),1
609+  D701 DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
610+  D705 DD 36 03 01      ld (ix+3),1                 ; set to right
611+  D709 21 23 D5         ld hl,robots_alreadymoved+1 ; increment the already moved flag
612+  D70C 7E               ld a,(hl)
613+  D70D 3C               inc a
614+  D70E CD 8A D7         call robots_zeromovecounters ; zero the move counters
615+  D711 21 22 D5         ld hl,robots_alreadymoved+0 ; increment the already moved flag
616+  D714 77               ld (hl),a                   ; store the incremented counter
617+  D715 3E 01            ld a,1
618+  D717 C9               ret
619+  D718              robots_checkrightandmove0:
620+  D718 3E 00            ld a,0
621+  D71A C9               ret
622+  D71B
623+  D71B              ;
624+  D71B              ; Draws a robot
625+  D71B              ; Inputs:
626+  D71B              ; ix - points to first byte of robot in array
627+  D71B              robots_draw:
628+  D71B DD 4E 00 DD      ld bc,(ix)
628+  D71F 46 01
629+  D721 21 C1 BF         ld hl,robot_sprite                      ; set to the robot sprite
630+  D724 DD 7E 02         ld a,(ix+2)                             ; get the state
631+  D727 FE 02            cp 2                                    ; is this dying
632+  D729 CA 44 D7         jp z,robots_draw1
633+  D72C              robots_draw3:
634+  D72C DD 7E 03         ld a,(ix+3)                             ; get the direction
635+  D72F FE 00            cp 0
636+  D731 CA 38 D7         jp z,robots_draw0                       ; if left, nothing to do
637+  D734 11 20 00         ld de,32
638+  D737 19               add hl,de                               ; add four frames to sprite
639+  D738              robots_draw0:
640+  D738 DD 7E 04         ld a,(ix+4)                             ; get the anim frame
641+  D73B 11 00 00         ld de,0
642+  D73E 5F               ld e,a
643+  D73F 19               add hl,de                               ; add to base
644+  D740 CD 29 AB         call sprites_drawsprite
645+  D743 C9               ret
646+  D744              ;
647+  D744              ; Dying
648+  D744              ;
649+  D744              robots_draw1:
650+  D744 DD 7E 05         ld a,(ix+5)                             ; get anim frames
651+  D747 FE 00            cp 0                                    ; if zero this is the first time around
652+  D749 C2 54 D7         jp nz,robots_draw2
653+  D74C 3E 18            ld a,24
654+  D74E DD 77 05         ld (ix+5),a                             ; load up the anim frames
655+  D751 C3 2C D7         jp robots_draw3                         ; return to main loop to draw as normal
656+  D754              robots_draw2:
657+  D754 3D               dec a
658+  D755 DD 77 05         ld (ix+5),a
659+  D758 FE 00            cp 0                                    ; have we reached the end yet
660+  D75A C2 60 D7         jp nz, robots_draw4
661+  D75D CD 0D D4         call robots_kill
662+  D760              robots_draw4:
663+  D760 C3 38 D7         jp robots_draw0
664+  D763 C9               ret
665+  D764
666+  D764              ;
667+  D764              ; Checks to see if the robot is hitting a player
668+  D764              ; Inputs:
669+  D764              ; ix - memory location of robot we're checking
670+  D764              robots_checkforplayer:
671+  D764 3A 28 C6         ld a,(player+11)     ; get player state
672+  D767 FE 00            cp 0
673+  D769 C0               ret nz               ; if already dying, don't kill again
674+  D76A DD 4E 00 DD      ld bc,(ix)           ; get coords
674+  D76E 46 01
675+  D770 ED 5B 1D C6      ld de,(player)       ; get the player coords
676+  D774 7B               ld a,e               ; get the vert coord first
677+  D775 91               sub c                ; subtract the diamond vertical coord from players
678+  D776 C6 08            add 8                ; add the max distance
679+  D778 FE 11            cp 17                ; compare to max*2+1? if carry flag set, they've hit
680+  D77A D0               ret nc               ; if not, hasn't hit
681+  D77B 7A               ld a,d               ; get the player horiz coord
682+  D77C 90               sub b                ; subtract rock coord
683+  D77D C6 08            add 8                ; add max distance
684+  D77F FE 11            cp 17                ; compare to max*2+1? if carry flag set, they've hit
685+  D781 D0               ret nc
686+  D782 DD 36 02 00      ld (ix+2),0          ; mark as inactive
687+  D786 CD 5D C7         call player_robotkillplayer ; mark the player as killed
688+  D789 C9               ret
689+  D78A
690+  D78A              ;
691+  D78A              ; Zeroes the already moved counter
692+  D78A              ;
693+  D78A              robots_zeromovecounters:
694+  D78A 06 04            ld b,4
695+  D78C 21 22 D5         ld hl,robots_alreadymoved
696+  D78F 08               ex af,af'
697+  D790 3E 00            ld a,0
698+  D792              robots_zeromovecounters0:
699+  D792 77               ld (hl),a
700+  D793 23               inc hl
701+  D794 10 FC            djnz robots_zeromovecounters0
702+  D796 08               ex af,af'
703+  D797 C9               ret
704+  D798
# file closed: game/robots.asm
154   D798                  include "game\bullet.asm"
# file opened: game/bullet.asm
  1+  D798              ;
  2+  D798              ; Current state: x & y coords (screen), direction (0 left, 1 right), state
  3+  D798              ;
  4+  D798              bullet_state:
  5+  D798 00 00 00 00      defb 0,0,0,0
  6+  D79C
  7+  D79C              ;
  8+  D79C              ; Measures if bullet can be fired. Disabled if fire held down
  9+  D79C              ;
 10+  D79C              bullet_enable:
 11+  D79C 00               defb 0
 12+  D79D
 13+  D79D              ;
 14+  D79D              ; Initialise a the bullet
 15+  D79D              ;
 16+  D79D              bullet_init:
 17+  D79D DD 21 98 D7      ld ix,bullet_state
 18+  D7A1 DD 36 00 00      ld (ix),0
 19+  D7A5 DD 36 01 00      ld (ix+1),0
 20+  D7A9 DD 36 02 00      ld (ix+2),0
 21+  D7AD DD 36 03 00      ld (ix+3),0
 22+  D7B1 C9               ret
 23+  D7B2
 24+  D7B2              ;
 25+  D7B2              ; Shoots the bullet
 26+  D7B2              ;
 27+  D7B2              bullet_shoot:
 28+  D7B2 3E 01            ld a,1
 29+  D7B4 32 9C D7         ld (bullet_enable),a        ; disable the bullet until fire is release
 30+  D7B7 DD 21 98 D7      ld ix,bullet_state
 31+  D7BB ED 4B 1D C6      ld bc,(player)              ; get the player coords
 32+  D7BF 3A 1F C6         ld a,(player+2)             ; get the player direction
 33+  D7C2 FE 01            cp 1                        ; going left?
 34+  D7C4 CA D2 D7         jp z,bullet_shoot0
 35+  D7C7 3E 08            ld a,8
 36+  D7C9 80               add a,b                     ; going right so add eight to start coords
 37+  D7CA 47               ld b,a
 38+  D7CB DD 36 02 01      ld (ix+2),1                 ; set right
 39+  D7CF C3 DB D7         jp bullet_shoot1
 40+  D7D2              bullet_shoot0:
 41+  D7D2 78               ld a,b
 42+  D7D3 06 08            ld b,8
 43+  D7D5 90               sub b
 44+  D7D6 47               ld b,a                      ; going left so subtract eight to start coords
 45+  D7D7 DD 36 02 00      ld (ix+2),0                 ; set right
 46+  D7DB              bullet_shoot1:
 47+  D7DB DD 71 00 DD      ld (ix),bc        ; store coords
 47+  D7DF 70 01
 48+  D7E1 DD 36 03 01      ld (ix+3),1       ; set state to 1
 49+  D7E5 CD 3B D8         call bullet_draw ; draw the initial frame
 50+  D7E8 C9               ret
 51+  D7E9
 52+  D7E9              ;
 53+  D7E9              ; Performs bullet processing
 54+  D7E9              ;
 55+  D7E9              bullet_process:
 56+  D7E9 3A 9B D7         ld a,(bullet_state+3)       ; get the state
 57+  D7EC FE 00            cp 0
 58+  D7EE C8               ret z                       ; don't draw if this has become inactive
 59+  D7EF CD 3B D8         call bullet_draw            ; delete current frame
 60+  D7F2 CD FF D7         call bullet_move            ; move the bullet
 61+  D7F5 3A 9B D7         ld a,(bullet_state+3)       ; get the state
 62+  D7F8 FE 00            cp 0
 63+  D7FA C8               ret z                       ; don't draw if this has become inactive
 64+  D7FB CD 3B D8         call bullet_draw            ; draw new frame
 65+  D7FE C9               ret
 66+  D7FF
 67+  D7FF              ;
 68+  D7FF              ; Moves the bullet, checking for collisions
 69+  D7FF              ;
 70+  D7FF              bullet_move:
 71+  D7FF DD 21 98 D7      ld ix,bullet_state
 72+  D803 DD 4E 00 DD      ld bc,(ix)
 72+  D807 46 01
 73+  D809 DD 7E 02         ld a,(ix+2)                 ; get the direction
 74+  D80C FE 00            cp 0                        ; going left?
 75+  D80E CA 18 D8         jp z,bullet_move0
 76+  D811 3E 08            ld a,8
 77+  D813 80               add b
 78+  D814 47               ld b,a                      ; add 8 since going right
 79+  D815 C3 1D D8         jp bullet_move1
 80+  D818              bullet_move0:
 81+  D818 78               ld a,b
 82+  D819 06 08            ld b,8
 83+  D81B 90               sub b
 84+  D81C 47               ld b,a                      ; subtract 8 since going left
 85+  D81D              bullet_move1:
 86+  D81D DD 71 00 DD      ld (ix),bc                  ; store new coords
 86+  D821 70 01
 87+  D823 C5               push bc
 88+  D824 CD 48 D8         call bullets_checkforrobot
 89+  D827 C1               pop bc
 90+  D828 FE 01            cp 1                        ; if we hit a robot, keep moving
 91+  D82A C8               ret z
 92+  D82B CD 36 AC         call sprites_scadd          ; get memory loc of this block into de
 93+  D82E 21 60 00         ld hl,96
 94+  D831 19               add hl,de
 95+  D832 7E               ld a,(hl)                   ; get the content
 96+  D833 FE 00            cp 0
 97+  D835 C8               ret z                       ; if empty, continue
 98+  D836 DD 36 03 00      ld (ix+3),0                 ; otherwise, mark bullet as inactive
 99+  D83A C9               ret
100+  D83B
101+  D83B              ;
102+  D83B              ; Draw the bullet
103+  D83B              ;
104+  D83B              bullet_draw:
105+  D83B ED 4B 98 D7      ld bc,(bullet_state)        ; get coords
106+  D83F 3E 1B            ld a,27
107+  D841 CD A4 AA         call screen_getblock        ; get the block address
108+  D844 CD 29 AB         call sprites_drawsprite     ; draw the sprite
109+  D847 C9               ret
110+  D848
111+  D848              ;
112+  D848              ; Checks to see if the robot is hitting a bullet
113+  D848              ; Outputs:
114+  D848              ; a = 0 if not robot hit
115+  D848              ; a = 1 if robot not hit
116+  D848              bullets_checkforrobot:
117+  D848 3E 00            ld a,0
118+  D84A 32 9E D8         ld (bullets_tmp),a
119+  D84D 3A 90 D3         ld a,(robots_robotsmax) ; robots to check
120+  D850 47               ld b,a
121+  D851 FD 21 61 D3      ld iy,robots_robots   ; start of robot array
122+  D855              bullets_checkforrobot0:
123+  D855 C5               push bc
124+  D856 FD 7E 02         ld a,(iy+2)             ; get the state
125+  D859 FE 01            cp 1
126+  D85B C2 92 D8         jp nz,bullets_checkforrobot1 ; if not active, don't check
127+  D85E FD 5E 00 FD      ld de,(iy)              ; get robot coords
127+  D862 56 01
128+  D864 7A               ld a,d
129+  D865 E6 F8            and 248                 ; get nearest multiple of 8
130+  D867 57               ld d,a
131+  D868 ED 4B 98 D7      ld bc,(bullet_state)    ; get bullet coords
132+  D86C 7A               ld a,d               ; get the robot horiz coord
133+  D86D 90               sub b                ; subtract robot coord
134+  D86E FE 00            cp 0                ; should be the same
135+  D870 CA 7C D8         jp z,bullets_checkforrobot2 ; if not, might have hit, so check the next char along... if matched, check vert
136+  D873 3E 08            ld a,8
137+  D875 82               add a,d
138+  D876 90               sub b                ; check again for the next char along
139+  D877 FE 00            cp 0
140+  D879 C2 92 D8         jp nz,bullets_checkforrobot1 ; if not, haven't hit
141+  D87C              bullets_checkforrobot2:
142+  D87C 7B               ld a,e               ; get the vert coord
143+  D87D 91               sub c                ; subtract the bullet vertical coord from robots
144+  D87E C6 04            add 4                ; add the max distance
145+  D880 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
146+  D882 D2 92 D8         jp nc,bullets_checkforrobot1   ; if not, hasn't hit
147+  D885 FD 36 02 02      ld (iy+2),2             ; mark the robot as killed
148+  D889 FD 36 05 00      ld (iy+5),0             ; mark the anim frames as zero
149+  D88D 3E 01            ld a,1
150+  D88F 32 9E D8         ld (bullets_tmp),a      ; hit the flag to say we killed a robot
151+  D892              bullets_checkforrobot1:
152+  D892 11 07 00         ld de,7
153+  D895 FD 19            add iy,de              ; move to next robot
154+  D897 C1               pop bc
155+  D898 10 BB            djnz bullets_checkforrobot0
156+  D89A 3A 9E D8         ld a,(bullets_tmp)
157+  D89D C9               ret
158+  D89E
159+  D89E              bullets_tmp:
160+  D89E 00               defb 0
161+  D89F
# file closed: game/bullet.asm
155   D89F
156   D89F              ;===========================================================================
157   D89F              ; Stack.
158   D89F              ;===========================================================================
159   D89F
160   D89F              ; Stack: this area is reserved for the stack
161   D89F              STACK_SIZE: equ 100    ; in words
162   D89F
163   D89F              ; Reserve stack space
164   D89F 00 00            defw 0  ; WPMEM, 2
165   D8A1              stack_bottom:
166   D8A1 00 00 00...      defs    STACK_SIZE*2, 0
167   D969              stack_top:
168   D969 00 00            defw 0  ; WPMEM, 2
169   D96B
170   D96B                     SAVESNA "./dist/ThePit.sna", main
# file closed: main.asm
