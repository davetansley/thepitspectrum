# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;===========================================================================
  6   8000              ; Persistent watchpoint.
  7   8000              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
  8   8000              ; If you do so the program will hit a breakpoint when it tries to
  9   8000              ; write to the first byte of the 3rd line.
 10   8000              ; When program breaks in the fill_memory sub routine please hover over hl
 11   8000              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 12   8000              ;===========================================================================
 13   8000
 14   8000              ; WPMEMx 0x5840, 1, w
 15   8000
 16   8000
 17   8000              ;===========================================================================
 18   8000              ; main routine - the code execution starts here.
 19   8000              ; Sets up the new interrupt routine, the memory
 20   8000              ; banks and jumps to the start loop.
 21   8000              ;===========================================================================
 22   8000              main:
 23   8000 21 DA B7         ld hl,font
 24   8003 22 36 5C         ld (23606),hl
 25   8006 CD 5E B0         call options_show
 26   8009
 27   8009                  ; Draw the title screen
 28   8009              main_titlescreen:
 29   8009 CD 2E AC         call titlescreen_show
 30   800C CD E7 C3         call game_init
 31   800F CD B8 C4         call player_init_gamestart
 32   8012
 33   8012              main_lifestart:
 34   8012
 35   8012 CD DE C4         call player_init_lifestart
 36   8015 CD ED C3         call game_setcurrentrocks   ; set the current rocks based on the level
 37   8018 CD 2D C4         call game_setdifficulty     ; set the current difficulty
 38   801B
 39   801B CD C3 AD         call lifescreen_draw        ; show the lives remaining screen
 40   801E
 41   801E CD C9 80         call init_start
 42   8021 CD F8 A8         call screen_draw
 43   8024 CD 47 A8         call buffer_allbuffertoscreen
 44   8027
 45   8027 CD E4 CD         call missiles_init
 46   802A CD DF C6         call ship_land              ; land the ship
 47   802D CD F3 C7         call tank_init
 48   8030 CD AB CD         call diamonds_init
 49   8033 CD 9C CF         call thepit_init
 50   8036 CD 38 D0         call monster_init
 51   8039 CD 87 D1         call robots_init
 52   803C CD 17 D5         call bullet_init
 53   803F
 54   803F              mloop:
 55   803F                  ;halt
 56   803F CD 86 80         call main_loop_processing
 57   8042
 58   8042                  ;
 59   8042                  ; Check if the player died
 60   8042                  ;
 61   8042 21 7C C4         ld hl,player+10
 62   8045 7E               ld a,(hl)                   ; check if the player died this frame
 63   8046 FE 01            cp 1
 64   8048 C2 72 80         jp nz,mloop0
 65   804B CD 6F C5         call player_died        ; do end of life housekeeping
 66   804E 06 28            ld b,40
 67   8050 CD 64 81         call utilities_pauseforframes
 68   8053
 69   8053 21 7B C4         ld hl,player+9        ; check lives remaining
 70   8056 7E               ld a,(hl)
 71   8057 FE 00            cp 0
 72   8059 C2 6C 80         jp nz,mloop1         ; haven't finished, so keep going
 73   805C
 74   805C 3A 82 C3         ld a,(game_numberplayers) ; get the number of players
 75   805F FE 01            cp 1
 76   8061 CA BA 80         jp z,main_gameover   ; if just one player, then this is game over
 77   8064
 78   8064 3A 83 C3         ld a,(game_currentplayer) ; get the current player
 79   8067 FE 02            cp 2                    ; if we're here, we have no lives, and if the current player is 2, then we're done
 80   8069 CA BA 80         jp z,main_gameover            ; if it's  two game over
 81   806C
 82   806C              mloop1:
 83   806C CD D1 C3         call game_changeplayer ; change player if needed
 84   806F C3 12 80         jp main_lifestart    ; otherwise, start a new life
 85   8072              mloop0:
 86   8072                  ;
 87   8072                  ; Check if the player completed the level
 88   8072                  ;
 89   8072 21 7F C4         ld hl,player+13
 90   8075 7E               ld a,(hl)
 91   8076 FE 01            cp 1
 92   8078 C2 3F 80         jp nz,mloop
 93   807B CD A9 C6         call player_checkforexit
 94   807E FE 01            cp 1                        ; look at return, if 1, level has been completed
 95   8080 CA C0 80         jp z,main_endlevel          ; jump to level transition screen
 96   8083 C3 3F 80         jp mloop                ; start the loop again
 97   8086
 98   8086
 99   8086              main_loop_processing:
100   8086
101   8086 CD 06 A8         call buffer_buffertoscreen  ; copy buffer to screen
102   8089 CD 6B A7         call buffer_clearlist       ; zero the updated lines list
103   808C CD 82 C4         call player_getlocation     ; figure out where the player is
104   808F CD B3 C5         call player_drawplayer      ; delete player
105   8092 CD 7E BE         call control_input          ; check input
106   8095 CD B3 C5         call player_drawplayer      ; draw player
107   8098 CD 22 C8         call tank_process           ; prcoess the tank
108   809B CD CA C6         call ship_process           ; proces the ship
109   809E CD 29 CA         call rocks_processrocks     ; process falling rocks
110   80A1 CD A8 CF         call thepit_process         ; process the pit trap
111   80A4 CD 0C CE         call missiles_process       ; process missiles
112   80A7 CD 55 D0         call monster_process        ; process monster
113   80AA CD 0A D2         call robots_process         ; process robots
114   80AD CD 5E D5         call bullet_process         ; process the bullet
115   80B0 CD 8A CD         call diamonds_twinkle       ; make the diamonds twinkle
116   80B3 CD 9C CB         call scores_printscore      ; update the score on screen
117   80B6 CD 0D C4         call game_incrementframe    ; increment the game frame
118   80B9
119   80B9 C9               ret
120   80BA
121   80BA              main_gameover:
122   80BA CD 23 AE         call gameover_draw          ; show the game over screen
123   80BD C3 09 80         jp main_titlescreen         ; go back to title
124   80C0
125   80C0              main_endlevel:
126   80C0 CD 3D C5         call player_recordcurrentstate
127   80C3 CD 53 AF         call endlevel_draw          ; show the end level screen
128   80C6 C3 12 80         jp main_lifestart           ; start a new life
129   80C9
130   80C9
131   80C9              ;===========================================================================
132   80C9              ; Include modules
133   80C9              ;===========================================================================
134   80C9                  include "init.asm"
# file opened: init.asm
  1+  80C9              ;
  2+  80C9              ; Set up at start up
  3+  80C9              ;
  4+  80C9              init_start:
  5+  80C9              ; We want a black screen.
  6+  80C9
  7+  80C9 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  80CB                                      ; bright (64).
  9+  80CB CD 49 81         call utilities_clearscreen
 10+  80CE 32 8D 5C         ld (23693),a        ; set our screen colours.
 11+  80D1 AF               xor a               ; quick way to load accumulator with zero.
 12+  80D2 CD 9B 22         call 8859           ; set permanent border colours.
 13+  80D5
 14+  80D5 21 DD A8         ld hl,screen_offset ; reset some temp variables
 15+  80D8 36 00            ld (hl),0
 16+  80DA 21 DE A8         ld hl,screen_tmp
 17+  80DD 36 00            ld (hl),0
 18+  80DF 21 13 A7         ld hl,buffer_tmp
 19+  80E2 36 00            ld (hl),0
 20+  80E4 23               inc hl
 21+  80E5 36 00            ld (hl),0
 22+  80E7
 23+  80E7 CD 20 C4         call game_resetcurrentframe ; reset current frame
 24+  80EA
 25+  80EA C9               ret
 26+  80EB
 27+  80EB              ;
 28+  80EB              ;   Start coord
 29+  80EB              ;   vert c, horiz b
 30+  80EB              init_coord:
 31+  80EB 18 30            defb 24,48
 32+  80ED
 33+  80ED              ;
 34+  80ED              ; Number of lives to start
 35+  80ED              ;
 36+  80ED              init_lives:
 37+  80ED 03               defb 3
 38+  80EE
 39+  80EE              ;
 40+  80EE              ; Score to start
 41+  80EE              ;
 42+  80EE              init_score:
 43+  80EE 30 30 30 30      defb '000000'
 43+  80F2 30 30
# file closed: init.asm
135   80F4                  include "utilities.asm"
# file opened: utilities.asm
  1+  80F4              ; ##########################################################################
  2+  80F4              ; Print a character
  3+  80F4              ; Inputs:
  4+  80F4              ; b - x coord
  5+  80F4              ; c - y coord
  6+  80F4              ; d - character
  7+  80F4              ; e - colour
  8+  80F4              ; ##########################################################################
  9+  80F4              utilities_print_char:
 10+  80F4 7B               ld a,e
 11+  80F5 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  80F8 3E 16            ld a,22
 13+  80FA D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  80FB 78               ld a,b              ; Gets the X co-ordinate
 15+  80FC 3D               dec a
 16+  80FD D7               rst 16
 17+  80FE 79               ld a,c              ; and the Y co-ordinate
 18+  80FF D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  8100 7A               ld a,d              ; ASCII code for udg.
 20+  8101 D7               rst 16              ; draw block.
 21+  8102 C9               ret
 22+  8103
 23+  8103
 24+  8103              ;Inputs:
 25+  8103              ;     DE and A are factors
 26+  8103              ;Outputs:
 27+  8103              ;     A is not changed
 28+  8103              ;     B is 0
 29+  8103              ;     C is not changed
 30+  8103              ;     DE is not changed
 31+  8103              ;     HL is the product
 32+  8103              ;Time:
 33+  8103              ;     342+6x
 34+  8103              ;
 35+  8103              utilities_multiply:
 36+  8103 06 08            ld b,8          ;7           7
 37+  8105 21 00 00         ld hl,0         ;10         10
 38+  8108 29               add hl,hl     ;11*8       88
 39+  8109 07               rlca          ;4*8        32
 40+  810A 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  810C 19                   add hl,de   ;--         --
 42+  810D 10 F9            djnz $-5      ;13*7+8     99
 43+  810F C9               ret             ;10         10
 44+  8110
 45+  8110              utilities_waitforkey:
 46+  8110 21 08 5C         ld hl,23560         ; LAST K system variable.
 47+  8113 36 00            ld (hl),0           ; put null value there.
 48+  8115              utilities_waitforkey0:
 49+  8115 7E               ld a,(hl)           ; new value of LAST K.
 50+  8116 FE 00            cp 0                ; is it still zero?
 51+  8118 20 0A            jr nz,utilities_waitforkey1           ; yes, so no key pressed.
 52+  811A 01 1F 00         ld bc,31                        ; Kempston joystick port.
 53+  811D ED 78            in a,(c)                        ; read input.
 54+  811F E6 10            and 16
 55+  8121 CA 15 81         jp z,utilities_waitforkey0
 56+  8124              utilities_waitforkey1:
 57+  8124 C9               ret                 ; key was pressed.
 58+  8125
 59+  8125              ;
 60+  8125              ; Waits number of frames for keypress. If got, returns 1, if not 0
 61+  8125              ; Inputs:
 62+  8125              ; a - number of frames to waits
 63+  8125              ; Ouputs:
 64+  8125              ; e - 0 not pressed, 1 pressed
 65+  8125              utilities_waitforkey_forframes:
 66+  8125 21 08 5C         ld hl,23560         ; LAST K system variable.
 67+  8128 36 00            ld (hl),0           ; put null value there.
 68+  812A 47               ld b,a              ; number of frames to wait
 69+  812B              utilities_waitforkey_forframes0:
 70+  812B 7E               ld a,(hl)           ; new value of LAST K.
 71+  812C FE 00            cp 0                ; is it still zero?
 72+  812E 28 03            jr z,utilities_waitforkey_forframes1           ; yes, so no key pressed.
 73+  8130 1E 01            ld e,1              ; set the pressed flag
 74+  8132 C9               ret                 ; key was pressed.
 75+  8133              utilities_waitforkey_forframes1:
 76+  8133 C5               push bc
 77+  8134 01 1F 00         ld bc,31                        ; Kempston joystick port.
 78+  8137 ED 78            in a,(c)                        ; read input.
 79+  8139 C1               pop bc
 80+  813A E6 10            and 16
 81+  813C CA 42 81         jp z,utilities_waitforkey_forframes2
 82+  813F 1E 01            ld e,1              ; set the pressed flag
 83+  8141 C9               ret                 ; key was pressed.
 84+  8142              utilities_waitforkey_forframes2:
 85+  8142 76               halt                ; wait for frame
 86+  8143 76               halt                ; wait for frame
 87+  8144 10 E5            djnz utilities_waitforkey_forframes0 ; loop again
 88+  8146 1E 00            ld e,0              ; nothing pressed in time
 89+  8148 C9               ret
 90+  8149
 91+  8149              ;
 92+  8149              ; Clears the screen
 93+  8149              ; Inputs:
 94+  8149              ; a - attribute colour
 95+  8149              utilities_clearscreen:
 96+  8149 76               halt
 97+  814A 21 00 58         ld hl,22528         ; attr
 98+  814D 11 01 58         ld de,22529         ; attr+1
 99+  8150 01 FF 02         ld bc,767
100+  8153 77               ld (hl),a
101+  8154 ED B0            ldir
102+  8156
103+  8156 21 00 40         ld hl, 16384        ;pixels
104+  8159 11 01 40         ld de, 16385        ;pixels + 1
105+  815C 01 FF 17         ld bc, 6143         ;pixels area length - 1
106+  815F 36 00            ld (hl), 0          ;set first byte to '0'
107+  8161 ED B0            ldir                ;copy bytes
108+  8163
109+  8163 C9               ret
110+  8164
111+  8164              ;
112+  8164              ; Wait for a number of frames
113+  8164              ; Inputs:
114+  8164              ; b - number of frames
115+  8164              utilities_pauseforframes:
116+  8164 76               halt
117+  8165 10 FD            djnz utilities_pauseforframes
118+  8167 C9               ret
119+  8168
120+  8168              utilities_readkey:
121+  8168 21 88 81         LD HL,utilties_keymap              ; Point HL at the keyboard list
122+  816B 16 08            LD D,8                                  ; This is the number of ports (rows) to check
123+  816D 0E FE            LD C,$FE                            ; C is always FEh for reading keyboard ports
124+  816F              utilities_readkey_0:
125+  816F 46               LD B,(HL)                               ; Get the keyboard port address from table
126+  8170 23               INC HL                                  ; Increment to list of keys
127+  8171 ED 78            IN A,(C)                                ; Read the row of keys in
128+  8173 E6 1F            AND $1F                                     ; We are only interested in the first five bits
129+  8175 1E 05            LD E,5                                  ; This is the number of keys in the row
130+  8177              utilities_readkey_1:
131+  8177 CB 3F            SRL A                                   ; Shift A right; bit 0 sets carry bit
132+  8179 30 0B            JR NC,utilities_readkey_2   ; If the bit is 0, we've found our key
133+  817B 23               INC HL                                  ; Go to next table address
134+  817C 1D               DEC E                                   ; Decrement key loop counter
135+  817D 20 F8            JR NZ,utilities_readkey_1   ; Loop around until this row finished
136+  817F 15               DEC D                                   ; Decrement row loop counter
137+  8180 20 ED            JR NZ,utilities_readkey_0   ; Loop around until we are done
138+  8182 A7               AND A                                   ; Clear A (no key found)
139+  8183 C3 68 81         jp utilities_readkey
140+  8186              utilities_readkey_2:
141+  8186 7E               LD A,(HL)                               ; We've found a key at this point; fetch the character code!
142+  8187 C9               RET
143+  8188
144+  8188              utilties_keymap:
145+  8188 FE 23 5A 58      defb $FE,"#","Z","X","C","V"
145+  818C 43 56
146+  818E FD 41 53 44      defb $FD,"A","S","D","F","G"
146+  8192 46 47
147+  8194 FB 51 57 45      defb $FB,"Q","W","E","R","T"
147+  8198 52 54
148+  819A F7 31 32 33      defb $F7,"1","2","3","4","5"
148+  819E 34 35
149+  81A0 EF 30 39 38      defb $EF,"0","9","8","7","6"
149+  81A4 37 36
150+  81A6 DF 50 4F 49      defb $DF,"P","O","I","U","Y"
150+  81AA 55 59
151+  81AC BF 23 4C 4B      defb $BF,"#","L","K","J","H"
151+  81B0 4A 48
152+  81B2 7F 20 23 4D      defb $7F," ","#","M","N","B"
152+  81B6 4E 42
153+  81B8
154+  81B8
155+  81B8              ;
156+  81B8              ; Generates a randomish number in the range 0 to e
157+  81B8              ; Inputs:
158+  81B8              ; e - upper value
159+  81B8              ; Outputs:
160+  81B8              ; a - random number
161+  81B8              utilities_randomupper
162+  81B8 3A 81 C3         ld a,(game_framenumber)
163+  81BB 6F               ld l,a
164+  81BC 26 00            ld h,0
165+  81BE 16 00            ld d,0
166+  81C0 42 4B            ld bc,de
167+  81C2              utilities_randomupper0:
168+  81C2 B7               or a
169+  81C3 ED 42            sbc hl,bc
170+  81C5 F2 C2 81         jp p,utilities_randomupper0
171+  81C8 09               add hl,bc
172+  81C9 01 00 00         ld bc,0
173+  81CC 09               add hl,bc
174+  81CD 7D               ld a,l
175+  81CE C9               ret
176+  81CF
# file closed: utilities.asm
136   81CF                  include "strings.asm"
# file opened: strings.asm
  1+  81CF              string_score1:
  2+  81CF 04 00 53 43      defb 4,0,'SCORE1',255
  2+  81D3 4F 52 45 31
  2+  81D7 FF
  3+  81D8              string_scorenumbers1:
  4+  81D8 04 01 30 30      defb 4,1,'000000',255
  4+  81DC 30 30 30 30
  4+  81E0 FF
  5+  81E1              string_company:
  6+  81E1 0C 00 43 45      defb 12,0,'CENTURI',255
  6+  81E5 4E 54 55 52
  6+  81E9 49 FF
  7+  81EB              string_player1:
  8+  81EB 0C 01 50 4C      defb 12,1,'PLAYER 1',255
  8+  81EF 41 59 45 52
  8+  81F3 20 31 FF
  9+  81F6              string_player2:
 10+  81F6 0C 01 50 4C      defb 12,1,'PLAYER 2',255
 10+  81FA 41 59 45 52
 10+  81FE 20 32 FF
 11+  8201              string_score2:
 12+  8201 16 00 53 43      defb 22,0,'SCORE2',255
 12+  8205 4F 52 45 32
 12+  8209 FF
 13+  820A              string_scorenumbers2:
 14+  820A 16 01 30 30      defb 22,1,'000000',255
 14+  820E 30 30 30 30
 14+  8212 FF
 15+  8213              string_titlescreen_copyright:
 16+  8213 06 15 7F 31      defb 6,21, 127,'1982  CENTURI INC',255
 16+  8217 39 38 32 20
 16+  821B 20 43 45 4E
 16+  821F 54 55 52 49
 16+  8223 20 49 4E 43
 16+  8227 FF
 17+  8228
 18+  8228
 19+  8228              string_alttitlescreen_1:
 20+  8228 0C 00 43 52      defb 12,0,'CREDITS 1',255
 20+  822C 45 44 49 54
 20+  8230 53 20 31 FF
 21+  8234              string_alttitlescreen_2:
 22+  8234 00 02 20 20      defb 0,2,'           THE OBJECT',254
 22+  8238 20 20 20 20
 22+  823C 20 20 20 20
 22+  8240 20 54 48 45
 22+  8244 20 4F 42 4A
 22+  8248 45 43 54 FE
 23+  824C 00 03 20 20      defb 0,3,'          OF THIS GAME',254
 23+  8250 20 20 20 20
 23+  8254 20 20 20 20
 23+  8258 4F 46 20 54
 23+  825C 48 49 53 20
 23+  8260 47 41 4D 45
 23+  8264 FE
 24+  8265 00 04 20 20      defb 0,4,'         IS TO DIG DOWN',254
 24+  8269 20 20 20 20
 24+  826D 20 20 20 49
 24+  8271 53 20 54 4F
 24+  8275 20 44 49 47
 24+  8279 20 44 4F 57
 24+  827D 4E FE
 25+  827F 00 05 20 20      defb 0,5,'        TO THE BOTTOM PIT',254
 25+  8283 20 20 20 20
 25+  8287 20 20 54 4F
 25+  828B 20 54 48 45
 25+  828F 20 42 4F 54
 25+  8293 54 4F 4D 20
 25+  8297 50 49 54 FE
 26+  829B 00 06 20 20      defb 0,6,'               AND',254
 26+  829F 20 20 20 20
 26+  82A3 20 20 20 20
 26+  82A7 20 20 20 20
 26+  82AB 20 41 4E 44
 26+  82AF FE
 27+  82B0 00 07 20 20      defb 0,7,'        COLLECT AT LEAST',254
 27+  82B4 20 20 20 20
 27+  82B8 20 20 43 4F
 27+  82BC 4C 4C 45 43
 27+  82C0 54 20 41 54
 27+  82C4 20 4C 45 41
 27+  82C8 53 54 FE
 28+  82CB 00 08 20 20      defb 0,8,'         ONE LARGE JEWEL',254
 28+  82CF 20 20 20 20
 28+  82D3 20 20 20 4F
 28+  82D7 4E 45 20 4C
 28+  82DB 41 52 47 45
 28+  82DF 20 4A 45 57
 28+  82E3 45 4C FE
 29+  82E6 00 09 20 20      defb 0,9,'              THEN',254
 29+  82EA 20 20 20 20
 29+  82EE 20 20 20 20
 29+  82F2 20 20 20 20
 29+  82F6 54 48 45 4E
 29+  82FA FE
 30+  82FB 00 0A 20 20      defb 0,10,'         RETURN TO SHIP',254
 30+  82FF 20 20 20 20
 30+  8303 20 20 20 52
 30+  8307 45 54 55 52
 30+  830B 4E 20 54 4F
 30+  830F 20 53 48 49
 30+  8313 50 FE
 31+  8315 00 0B 20 20      defb 0,11,'         THRU UPPER PIT',255
 31+  8319 20 20 20 20
 31+  831D 20 20 20 54
 31+  8321 48 52 55 20
 31+  8325 55 50 50 45
 31+  8329 52 20 50 49
 31+  832D 54 FF
 32+  832F              string_alttitlescreen_3:
 33+  832F 00 0D 20 20      defb 0,13,'    SINGLE BONUS  5000 POINTS',254
 33+  8333 20 20 53 49
 33+  8337 4E 47 4C 45
 33+  833B 20 42 4F 4E
 33+  833F 55 53 20 20
 33+  8343 35 30 30 30
 33+  8347 20 50 4F 49
 33+  834B 4E 54 53 FE
 34+  834F 00 0E 20 20      defb 0,14,'      COLLECT 1 LARGE JEWEL',254
 34+  8353 20 20 20 20
 34+  8357 43 4F 4C 4C
 34+  835B 45 43 54 20
 34+  835F 31 20 4C 41
 34+  8363 52 47 45 20
 34+  8367 4A 45 57 45
 34+  836B 4C FE
 35+  836D 00 0F 20 20      defb 0,15,'       AND RETURN TO SHIP',254
 35+  8371 20 20 20 20
 35+  8375 20 41 4E 44
 35+  8379 20 52 45 54
 35+  837D 55 52 4E 20
 35+  8381 54 4F 20 53
 35+  8385 48 49 50 FE
 36+  8389 00 11 20 20      defb 0,17,'    DOUBLE BONUS  10000 POINTS',254
 36+  838D 20 20 44 4F
 36+  8391 55 42 4C 45
 36+  8395 20 42 4F 4E
 36+  8399 55 53 20 20
 36+  839D 31 30 30 30
 36+  83A1 30 20 50 4F
 36+  83A5 49 4E 54 53
 36+  83A9 FE
 37+  83AA 00 12 20 20      defb 0,18,'    COLLECT ALL 3 LARGE JEWELS',254
 37+  83AE 20 20 43 4F
 37+  83B2 4C 4C 45 43
 37+  83B6 54 20 41 4C
 37+  83BA 4C 20 33 20
 37+  83BE 4C 41 52 47
 37+  83C2 45 20 4A 45
 37+  83C6 57 45 4C 53
 37+  83CA FE
 38+  83CB 00 13 20 20      defb 0,19,'       OR   ALL 4 SMALL JEWELS',254
 38+  83CF 20 20 20 20
 38+  83D3 20 4F 52 20
 38+  83D7 20 20 41 4C
 38+  83DB 4C 20 34 20
 38+  83DF 53 4D 41 4C
 38+  83E3 4C 20 4A 45
 38+  83E7 57 45 4C 53
 38+  83EB FE
 39+  83EC 00 15 20 20      defb 0,21,'    TRIPLE BONUS  15000 POINTS',254
 39+  83F0 20 20 54 52
 39+  83F4 49 50 4C 45
 39+  83F8 20 42 4F 4E
 39+  83FC 55 53 20 20
 39+  8400 31 35 30 30
 39+  8404 30 20 50 4F
 39+  8408 49 4E 54 53
 39+  840C FE
 40+  840D 00 16 20 20      defb 0,22,'       COLLECT ALL 7 JEWELS',255
 40+  8411 20 20 20 20
 40+  8415 20 43 4F 4C
 40+  8419 4C 45 43 54
 40+  841D 20 41 4C 4C
 40+  8421 20 37 20 4A
 40+  8425 45 57 45 4C
 40+  8429 53 FF
 41+  842B
 42+  842B              string_lifescreen_player:
 43+  842B 0B 00 20 50      defb 11,0,' PLAYER 1 ',255
 43+  842F 4C 41 59 45
 43+  8433 52 20 31 20
 43+  8437 FF
 44+  8438              string_lifescreen_lives:
 45+  8438 0B 03 30 20      defb 11,3,48,' MEN LEFT',255
 45+  843C 4D 45 4E 20
 45+  8440 4C 45 46 54
 45+  8444 FF
 46+  8445              string_lifescreen_lastman:
 47+  8445 0C 03 4C 41      defb 12,3,'LAST MAN',255
 47+  8449 53 54 20 4D
 47+  844D 41 4E FF
 48+  8450
 49+  8450              string_gameoverscreen_gameover:
 50+  8450 0B 06 47 41      defb 11,6,'GAME OVER',255
 50+  8454 4D 45 20 4F
 50+  8458 56 45 52 FF
 51+  845C              string_gameoverscreen_copyright:
 52+  845C 07 12 7F 31      defb 7,18,127,'1982 CENTURI INC',255
 52+  8460 39 38 32 20
 52+  8464 43 45 4E 54
 52+  8468 55 52 49 20
 52+  846C 49 4E 43 FF
 53+  8470              string_gameoverscreen_bestscores:
 54+  8470 07 16 42 45      defb 7,22,'BEST SCORES TODAY',255
 54+  8474 53 54 20 53
 54+  8478 43 4F 52 45
 54+  847C 53 20 54 4F
 54+  8480 44 41 59 FF
 55+  8484              string_gameover_credits:
 56+  8484 0C 01 43 52      defb 12,1,'CREDITS 0',255
 56+  8488 45 44 49 54
 56+  848C 53 20 30 FF
 57+  8490
 58+  8490              string_highscore_congratulations:
 59+  8490 08 05 43 4F      defb 8,5,'CONGRATULATIONS',255
 59+  8494 4E 47 52 41
 59+  8498 54 55 4C 41
 59+  849C 54 49 4F 4E
 59+  84A0 53 FF
 60+  84A2              string_highscore_player1:
 61+  84A2 0C 07 50 4C      defb 12,7,'PLAYER 1',255
 61+  84A6 41 59 45 52
 61+  84AA 20 31 FF
 62+  84AD              string_highscore_player2:
 63+  84AD 0C 07 50 4C      defb 12,7,'PLAYER 2',255
 63+  84B1 41 59 45 52
 63+  84B5 20 32 FF
 64+  84B8              string_highscore_youhaveearned:
 65+  84B8 08 0A 59 4F      defb 8,10,'YOU HAVE EARNED',255
 65+  84BC 55 20 48 41
 65+  84C0 56 45 20 45
 65+  84C4 41 52 4E 45
 65+  84C8 44 FF
 66+  84CA              string_highscore_place1:
 67+  84CA 06 0C 54 48      defb 6,12,'THE GREATEST SCORE',255
 67+  84CE 45 20 47 52
 67+  84D2 45 41 54 45
 67+  84D6 53 54 20 53
 67+  84DA 43 4F 52 45
 67+  84DE FF
 68+  84DF              string_highscore_place2:
 69+  84DF 06 0C 54 48      defb 6,12,'THE 2ND BEST SCORE',255
 69+  84E3 45 20 32 4E
 69+  84E7 44 20 42 45
 69+  84EB 53 54 20 53
 69+  84EF 43 4F 52 45
 69+  84F3 FF
 70+  84F4              string_highscore_place3:
 71+  84F4 06 0C 54 48      defb 6,12,'THE 3RD BEST SCORE',255
 71+  84F8 45 20 33 52
 71+  84FC 44 20 42 45
 71+  8500 53 54 20 53
 71+  8504 43 4F 52 45
 71+  8508 FF
 72+  8509              string_highscore_pleaseenter
 73+  8509 03 0F 52 45      defb 3,15,'RECORD YOUR INITIALS BELOW',255
 73+  850D 43 4F 52 44
 73+  8511 20 59 4F 55
 73+  8515 52 20 49 4E
 73+  8519 49 54 49 41
 73+  851D 4C 53 20 42
 73+  8521 45 4C 4F 57
 73+  8525 FF
 74+  8526
 75+  8526              string_endlevel_youhaveearned:
 76+  8526 08 0B 59 4F      defb 8,11,'YOU HAVE EARNED',255
 76+  852A 55 20 48 41
 76+  852E 56 45 20 45
 76+  8532 41 52 4E 45
 76+  8536 44 FF
 77+  8538              string_endlevel_bonus1:
 78+  8538 09 0D 53 49      defb 9,13,'SINGLE BONUS',255
 78+  853C 4E 47 4C 45
 78+  8540 20 42 4F 4E
 78+  8544 55 53 FF
 79+  8547              string_endlevel_bonus2:
 80+  8547 09 0D 44 4F      defb 9,13,'DOUBLE BONUS',255
 80+  854B 55 42 4C 45
 80+  854F 20 42 4F 4E
 80+  8553 55 53 FF
 81+  8556              string_endlevel_bonus3:
 82+  8556 09 0D 54 52      defb 9,13,'TRIPLE BONUS',255
 82+  855A 49 50 4C 45
 82+  855E 20 42 4F 4E
 82+  8562 55 53 FF
 83+  8565              string_endlevel_points1:
 84+  8565 0A 0F 35 30      defb 10,15,'5000 POINTS',255
 84+  8569 30 30 20 50
 84+  856D 4F 49 4E 54
 84+  8571 53 FF
 85+  8573              string_endlevel_points2:
 86+  8573 09 0F 31 30      defb 9,15,'10000 POINTS',255
 86+  8577 30 30 30 20
 86+  857B 50 4F 49 4E
 86+  857F 54 53 FF
 87+  8582              string_endlevel_points3:
 88+  8582 09 0F 31 35      defb 9,15,'15000 POINTS',255
 88+  8586 30 30 30 20
 88+  858A 50 4F 49 4E
 88+  858E 54 53 FF
 89+  8591              string_endlevel_anothergo:
 90+  8591 08 12 48 41      defb 8,18,'HAVE ANOTHER GO',255
 90+  8595 56 45 20 41
 90+  8599 4E 4F 54 48
 90+  859D 45 52 20 47
 90+  85A1 4F FF
 91+  85A3
 92+  85A3              string_zonk:
 93+  85A3 00 00 5A 4F      defb 0,0,'ZONK!!',255
 93+  85A7 4E 4B 21 21
 93+  85AB FF
 94+  85AC
 95+  85AC
 96+  85AC              string_options_title:
 97+  85AC 0D 03 54 48      defb 13,3,'THE PIT',255
 97+  85B0 45 20 50 49
 97+  85B4 54 FF
 98+  85B6              string_options_1player:
 99+  85B6 0A 06 31 2E      defb 10,6,'1. ONE PLAYER',255
 99+  85BA 20 4F 4E 45
 99+  85BE 20 50 4C 41
 99+  85C2 59 45 52 FF
100+  85C6              string_options_2player:
101+  85C6 0A 07 32 2E      defb 10,7,'2. TWO PLAYER',255
101+  85CA 20 54 57 4F
101+  85CE 20 50 4C 41
101+  85D2 59 45 52 FF
102+  85D6              string_options_keyboard:
103+  85D6 0A 08 33 2E      defb 10,8,'3. KEYBOARD',255
103+  85DA 20 4B 45 59
103+  85DE 42 4F 41 52
103+  85E2 44 FF
104+  85E4              string_options_joystick:
105+  85E4 0A 09 34 2E      defb 10,9,'4. KEMPSTON',255
105+  85E8 20 4B 45 4D
105+  85EC 50 53 54 4F
105+  85F0 4E FF
106+  85F2              string_options_start:
107+  85F2 0A 0A 35 2E      defb 10,10,'5. START',255
107+  85F6 20 53 54 41
107+  85FA 52 54 FF
108+  85FD              string_options_vanity:
109+  85FD 08 16 53 70      defb 8,22,'Spectrum Conversion',254
109+  8601 65 63 74 72
109+  8605 75 6D 20 43
109+  8609 6F 6E 76 65
109+  860D 72 73 69 6F
109+  8611 6E FE
110+  8613 07 17 62 79      defb 7,23,'by Dave Tansley, 2020',255
110+  8617 20 44 61 76
110+  861B 65 20 54 61
110+  861F 6E 73 6C 65
110+  8623 79 2C 20 32
110+  8627 30 32 30 FF
111+  862B
112+  862B              ;
113+  862B              ; Prints specified string
114+  862B              ; Inputs:
115+  862B              ; de: pointer to string
116+  862B              ; bc: length of string
117+  862B              ;
118+  862B              ; Print String Data
119+  862B              ; First two bytes of string contain X and Y char position, then the string
120+  862B              ; Individual strings are terminated with 0xFE
121+  862B              ; End of data is terminated with 0xFF
122+  862B              ; HL: Address of string
123+  862B              ;
124+  862B 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
125+  862C 23                                   INC HL                          ; Increase HL to the next memory location
126+  862D 56                                   LD D,(HL)                       ; Fetch the Y coordinate
127+  862E 23                                   INC HL                          ; Increase HL to the next memory location
128+  862F CD 42 86                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
129+  8632 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
130+  8633 23                                   INC HL                          ; Increase HL to the next character
131+  8634 FE FE                                CP 0xFE                         ; Compare with 0xFE
132+  8636 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
133+  8638 D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
134+  8639 E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
135+  863A CD 52 86                             CALL Print_Char                 ; Print the character
136+  863D E1                                   POP HL                          ; Retrieve HL back off the stack
137+  863E 1C                                   INC E                           ; Go to the next screen address
138+  863F 18 F1                                JR string_print_0               ; Loop back to print next character
139+  8641 C9                                   RET
140+  8642
141+  8642              ; Get screen address
142+  8642              ; D = Y character position
143+  8642              ; E = X character position
144+  8642              ; Returns address in DE
145+  8642              ;
146+  8642 7A           string_getcharaddress:       LD A,D
147+  8643 E6 07                                AND %00000111
148+  8645 1F                                   RRA
149+  8646 1F                                   RRA
150+  8647 1F                                   RRA
151+  8648 1F                                   RRA
152+  8649 B3                                   OR E
153+  864A 5F                                   LD E,A
154+  864B 7A                                   LD A,D
155+  864C E6 18                                AND %00011000
156+  864E F6 40                                OR %01000000
157+  8650 57                                   LD D,A
158+  8651 C9                                   RET                             ; Returns screen address in DE
159+  8652
160+  8652              ; Print a single character out
161+  8652              ; A:  Character to print
162+  8652              ; DE: Screen address to print character at
163+  8652              ;
164+  8652 2A 36 5C     Print_Char:             LD HL,(23606)                    ; Address of character set table in ROM
165+  8655 06 00                                LD B,0                          ; Set BC to A
166+  8657 4F                                   LD C,A
167+  8658 E6 FF                                AND 0xFF                        ; Clear the carry bit
168+  865A CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
169+  865C CB 10                                RL B
170+  865E CB 11                                RL C
171+  8660 CB 10                                RL B
172+  8662 CB 11                                RL C
173+  8664 CB 10                                RL B
174+  8666 09                                   ADD HL,BC                       ; Get the character address in HL
175+  8667 0E 08                                LD C,8                          ; Loop counter
176+  8669 D5                                   PUSH DE
177+  866A 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
178+  866B 12                                   LD (DE),A                       ; Stick A onto the screen
179+  866C 14                                   INC D                           ; Goto next line on screen
180+  866D 23                                   INC HL                           ; Goto next byte of character
181+  866E 0D                                   DEC C                           ; Decrease the loop counter
182+  866F 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
183+  8671 D1                                   POP DE
184+  8672 C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
137   8673                  include "screen\buffer.asm"
# file opened: screen/buffer.asm
  1+  8673              buffer_buffer:
  2+  8673 00 00 00...      defs 7424                   ; area reserved for screen
  3+  A373
  4+  A373              buffer_attr_buffer:
  5+  A373 00 00 00...      defs 928                    ; attrs buffer area
  6+  A713
  7+  A713              buffer_tmp:
  8+  A713 00 00            defb 0,0                    ; temp area
  9+  A715
 10+  A715              ;
 11+  A715              ; This list stores lines to be updated by the buffer.
 12+  A715              ; This is done by half line. Lines are encded with.
 13+  A715              ; 00hlllll
 14+  A715              ; Where h is the half of the screen (0 or 1), lllll is the line number
 15+  A715              buffer_updatedlines:
 16+  A715 FF FF FF...      defs 21,255
 17+  A72A
 18+  A72A              buffer_updateall:
 19+  A72A 00               defb 0
 20+  A72B
 21+  A72B              ;
 22+  A72B              ; Stores a line number in the update list
 23+  A72B              ; Inputs:
 24+  A72B              ; a - row number
 25+  A72B              buffer_marklineforupdate:
 26+  A72B FE 15            cp 21
 27+  A72D D0               ret nc                          ; dont store lines that we shouldn't draw
 28+  A72E 5F               ld e,a                          ; store in e
 29+  A72F ED 4B 26 AC      ld bc,(origcoords)              ; this should hold the coords of what was drawn
 30+  A733 79               ld a,c                          ; get the horiz coord
 31+  A734 FE 0F            cp 15
 32+  A736 CA 4D A7         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 33+  A739 FE 10            cp 16                           ; if this is 15 or less, the first half of screen
 34+  A73B CA 4D A7         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 35+  A73E DA 49 A7         jp c,buffer_marklineforupdate4  ; if first half, nothing to do
 36+  A741 78               ld a,b                          ; get the vertical
 37+  A742 3E 20            ld a,32                         ; set the 6th bit by adding 32
 38+  A744 83               add a,e
 39+  A745 5F               ld e,a                          ; store this value
 40+  A746 C3 54 A7         jp buffer_marklineforupdate2
 41+  A749              buffer_marklineforupdate4:
 42+  A749 78               ld a,b
 43+  A74A C3 54 A7         jp buffer_marklineforupdate2    ; just get the vertical
 44+  A74D              buffer_marklineforupdate3:          ; special case for 15,16 - need to render both halves, since might be between
 45+  A74D CD 58 A7         call buffer_storelineforupdate  ; call store update for e
 46+  A750 3E 20            ld a,32
 47+  A752 83               add a,e
 48+  A753 5F               ld e,a
 49+  A754              buffer_marklineforupdate2:
 50+  A754 CD 58 A7         call buffer_storelineforupdate  ; call store update for e
 51+  A757 C9               ret
 52+  A758
 53+  A758
 54+  A758              ;
 55+  A758              ; Stores the calculated line and half if needed
 56+  A758              ; Inputs:
 57+  A758              ; e - half/row
 58+  A758              ;
 59+  A758              buffer_storelineforupdate:
 60+  A758 06 15            ld b,21
 61+  A75A 21 15 A7         ld hl,buffer_updatedlines
 62+  A75D              buffer_storelineforupdate0:
 63+  A75D 7E               ld a,(hl)                       ; get the line stored in updated lines
 64+  A75E BB               cp e                            ; is this the same as the row number passed in?
 65+  A75F C8               ret z                           ; if so, don't need to do anything
 66+  A760 FE FF            cp 255                          ; is this 255, ie the end of the buffer
 67+  A762 C2 67 A7         jp nz,buffer_storelineforupdate1 ; if not, move to next
 68+  A765 73               ld (hl),e
 69+  A766 C9               ret
 70+  A767              buffer_storelineforupdate1:
 71+  A767 23               inc hl
 72+  A768 10 F3            djnz buffer_storelineforupdate0
 73+  A76A C9               ret
 74+  A76B
 75+  A76B              ;
 76+  A76B              ; Zeroes the updated lines list
 77+  A76B              ;
 78+  A76B              buffer_clearlist:
 79+  A76B 06 15            ld b,21
 80+  A76D 21 15 A7         ld hl,buffer_updatedlines
 81+  A770              buffer_clearlist0:
 82+  A770 36 FF            ld (hl),255
 83+  A772 23               inc hl
 84+  A773 10 FB            djnz buffer_clearlist0
 85+  A775 C9               ret
 86+  A776
 87+  A776              ;
 88+  A776              ; Which half are we displaying? 0 left 1 right
 89+  A776              ;
 90+  A776              buffer_bufferhalf:
 91+  A776 00               defb 0
 92+  A777
 93+  A777              ;
 94+  A777              ; Copies the buffer to the screen. Use stack.
 95+  A777              ; Inputs:
 96+  A777              ; hl - half/line number to display - 0 is first half, 0 is first line
 97+  A777              ;
 98+  A777              buffer_bufferlinetoscreen:
 99+  A777 7C               ld a,h
100+  A778 32 76 A7         ld (buffer_bufferhalf),a        ; store the half
101+  A77B 7D               ld a,l
102+  A77C 4F               ld c,a                          ; store a
103+  A77D ED 5B DD A8      ld de,(screen_offset)          ; load the screen offset, this is in rows, want it *256
104+  A781 83               add a,e                       ; add the row number
105+  A782 11 00 01         ld de,256
106+  A785 CD 03 81         call utilities_multiply
107+  A788 54 5D            ld de,hl
108+  A78A 21 73 86         ld hl,buffer_buffer
109+  A78D 19               add hl,de                   ; add the offset
110+  A78E 79               ld a,c                      ; get original row back
111+  A78F ED 73 02 A8      ld (buffer_bufferlinetoscreen3+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
112+  A793 D9               exx
113+  A794 0E 00            ld c,0                      ; zero horizontal
114+  A796 47               ld b,a                      ; load the row number into vertical coord
115+  A797 04               inc b
116+  A798 04               inc b                       ; move forward 2 to allow for scores
117+  A799 CD D5 A9         call screen_getcelladdress  ; get the memory into de
118+  A79C 21 10 00         ld hl,16                    ; offset by 16 chars to get to the centre, since populating stack from right
119+  A79F 19               add hl,de
120+  A7A0 3A 76 A7         ld a,(buffer_bufferhalf)    ; get the half
121+  A7A3 FE 01            cp 1
122+  A7A5 CA D2 A7         jp z,buffer_bufferlinetoscreen4
123+  A7A8              buffer_bufferlinetoscreen0:     ; PROCESS THE LEFT HALF
124+  A7A8 D9               exx                         ; hl is now buffer
125+  A7A9 23               inc hl
126+  A7AA 23               inc hl                      ; move hl forward 2 to skip first two blocks
127+  A7AB F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
128+  A7AC F1               pop af
129+  A7AD C1               pop bc
130+  A7AE D1               pop de
131+  A7AF DD E1            pop ix
132+  A7B1 D9               exx                         ; hl is now screen
133+  A7B2 08               ex af,af'
134+  A7B3 F1               pop af
135+  A7B4 C1               pop bc
136+  A7B5 D1               pop de
137+  A7B6 F9               ld sp,hl                    ; sp pointing at screen
138+  A7B7 D5               push de
139+  A7B8 C5               push bc
140+  A7B9 F5               push af
141+  A7BA 08               ex af,af'
142+  A7BB D9               exx                         ; hl is now buffer
143+  A7BC DD E5            push ix
144+  A7BE D5               push de
145+  A7BF C5               push bc
146+  A7C0 F5               push af
147+  A7C1 11 1E 00         ld de,30                    ; add thirty to get to next line
148+  A7C4 19               add hl,de
149+  A7C5 F9               ld sp,hl                    ; sp pointing at buffer
150+  A7C6 D9               exx                         ; hl is now screen
151+  A7C7 08               ex af,af'
152+  A7C8 24               inc h
153+  A7C9 7C               ld a,h
154+  A7CA E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
155+  A7CC C2 A8 A7         jp nz,buffer_bufferlinetoscreen0 ; next line in cell
156+  A7CF              buffer_bufferlinetoscreen1:
157+  A7CF C3 01 A8         jp buffer_bufferlinetoscreen3
158+  A7D2              buffer_bufferlinetoscreen4:     ; PROCESS THE RIGHT HALF
159+  A7D2 D9               exx                         ; hl is buffer
160+  A7D3 11 10 00         ld de,16
161+  A7D6 19               add hl,de                   ; move halfway across
162+  A7D7 D9               exx                         ; hl is screen
163+  A7D8 11 0E 00         ld de,14
164+  A7DB 19               add hl,de
165+  A7DC              buffer_bufferlinetoscreen2:
166+  A7DC D9               exx                         ; hl is now buffer
167+  A7DD F9               ld sp,hl                    ; do first fourteen for right hand side, sp pointing at buffer
168+  A7DE F1               pop af
169+  A7DF C1               pop bc
170+  A7E0 D1               pop de
171+  A7E1 DD E1            pop ix
172+  A7E3 D9               exx                         ; hl is now screen
173+  A7E4 08               ex af,af'
174+  A7E5 F1               pop af
175+  A7E6 C1               pop bc
176+  A7E7 D1               pop de
177+  A7E8 F9               ld sp,hl                    ; sp pointing at screen
178+  A7E9 D5               push de
179+  A7EA C5               push bc
180+  A7EB F5               push af
181+  A7EC 08               ex af,af'
182+  A7ED D9               exx                         ; hl is now buffer
183+  A7EE DD E5            push ix
184+  A7F0 D5               push de
185+  A7F1 C5               push bc
186+  A7F2 F5               push af
187+  A7F3 11 20 00         ld de,32                    ; add thirty two to get to next line
188+  A7F6 19               add hl,de
189+  A7F7 F9               ld sp,hl                    ; sp pointing at buffer
190+  A7F8 D9               exx                         ; hl is now screen
191+  A7F9 08               ex af,af'
192+  A7FA 24               inc h
193+  A7FB 7C               ld a,h
194+  A7FC E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
195+  A7FE C2 DC A7         jp nz,buffer_bufferlinetoscreen2 ; next line in cell
196+  A801              buffer_bufferlinetoscreen3:
197+  A801 31 00 00         ld sp,0
198+  A804 D9               exx
199+  A805 C9               ret
200+  A806
201+  A806              ;
202+  A806              ; Copies the buffer to the screen for updated lines. Use stack.
203+  A806              ; Inputs: none
204+  A806              ;
205+  A806              buffer_buffertoscreen:
206+  A806 3A 2A A7         ld a,(buffer_updateall)      ; get the all update flag
207+  A809 FE 00            cp 0
208+  A80B CA 17 A8         jp z,buffer_buffertoscreen2  ; if not set, draw only updated
209+  A80E CD 47 A8         call buffer_allbuffertoscreen ; otherwise, draw whole screen
210+  A811 21 2A A7         ld hl,buffer_updateall
211+  A814 36 00            ld (hl),0                    ; reset flag
212+  A816 C9               ret
213+  A817              buffer_buffertoscreen2:
214+  A817 06 15            ld b,21
215+  A819 FD 21 15 A7      ld iy,buffer_updatedlines    ; the location of the updated lines
216+  A81D              buffer_buffertoscreen0:
217+  A81D FD 7E 00         ld a,(iy)
218+  A820 FE FF            cp 255
219+  A822 CA 46 A8         jp z,buffer_buffertoscreen1                       ; if this is 255, then we're at the end of the updated list
220+  A825 6F               ld l,a
221+  A826 26 00            ld h,0
222+  A828 E6 20            and 32                      ; and with 32 to see if 6th bit is set
223+  A82A FE 20            cp 32                       ; if so, second half of screen
224+  A82C C2 37 A8         jp nz,buffer_buffertoscreen3
225+  A82F 26 01            ld h,1                      ; store half in h
226+  A831 FD 7E 00         ld a,(iy)
227+  A834 D6 20            sub 32                      ; remove 32
228+  A836 6F               ld l,a                      ; stor in line number
229+  A837              buffer_buffertoscreen3:
230+  A837 C5               push bc
231+  A838 FD E5            push iy
232+  A83A F3               di
233+  A83B CD 77 A7         call buffer_bufferlinetoscreen      ; hl has h=half (0 or 1), l=line
234+  A83E FB               ei
235+  A83F FD E1            pop iy
236+  A841 C1               pop bc
237+  A842 FD 23            inc iy
238+  A844 10 D7            djnz buffer_buffertoscreen0
239+  A846              buffer_buffertoscreen1:
240+  A846                  ;call buffer_buffertoattrsfast
241+  A846 C9               ret
242+  A847
243+  A847              ;
244+  A847              ; Copies the buffer to the screen. Use stack.
245+  A847              ; Inputs: none
246+  A847              ;
247+  A847              buffer_allbuffertoscreen:
248+  A847 06 15            ld b,21
249+  A849 3E 00            ld a,0
250+  A84B              buffer_allbuffertoscreen0:
251+  A84B C5               push bc
252+  A84C F5               push af
253+  A84D F3               di
254+  A84E 26 00            ld h,0
255+  A850 6F               ld l,a
256+  A851 CD 77 A7         call buffer_bufferlinetoscreen
257+  A854 FB               ei
258+  A855 F1               pop af
259+  A856 F5               push af
260+  A857 F3               di
261+  A858 26 01            ld h,1
262+  A85A 6F               ld l,a
263+  A85B CD 77 A7         call buffer_bufferlinetoscreen
264+  A85E FB               ei
265+  A85F F1               pop af
266+  A860 C1               pop bc
267+  A861 3C               inc a
268+  A862 10 E7            djnz buffer_allbuffertoscreen0
269+  A864 F3               di
270+  A865 CD 6A A8         call buffer_buffertoattrsfast
271+  A868 FB               ei
272+  A869 C9               ret
273+  A86A
274+  A86A              ;
275+  A86A              ; Copies the attrs buffer to screen with the stack
276+  A86A              ;
277+  A86A              buffer_buffertoattrsfast:
278+  A86A ED 73 D9 A8      ld (buffer_buffertoattrsfast1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
279+  A86E 3A DD A8         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
280+  A871 11 20 00         ld de,32
281+  A874 CD 03 81         call utilities_multiply
282+  A877 54 5D            ld de,hl
283+  A879 21 73 A3         ld hl,buffer_attr_buffer
284+  A87C 19               add hl,de                       ; add the offset, start of attr buffer now in hl
285+  A87D D9               exx
286+  A87E 21 50 58         ld hl,22528+80                  ; start of attr memory + 2 lines for score + 16 to start at right side
287+  A881 FD 21 13 A7      ld iy,buffer_tmp
288+  A885 FD 36 00 15      ld (iy),21              ; number of times to loop
289+  A889              buffer_buffertoattrsfast0:
290+  A889 D9               exx                         ; hl is now buffer
291+  A88A 23               inc hl
292+  A88B 23               inc hl                      ; move hl forward 2 to skip first two blocks
293+  A88C F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
294+  A88D F1               pop af
295+  A88E C1               pop bc
296+  A88F D1               pop de
297+  A890 DD E1            pop ix
298+  A892 D9               exx                         ; hl is now screen
299+  A893 08               ex af,af'
300+  A894 F1               pop af
301+  A895 C1               pop bc
302+  A896 D1               pop de
303+  A897 F9               ld sp,hl                    ; sp pointing at screen
304+  A898 D5               push de
305+  A899 C5               push bc
306+  A89A F5               push af
307+  A89B 08               ex af,af'
308+  A89C D9               exx                         ; hl is now buffer
309+  A89D DD E5            push ix
310+  A89F D5               push de
311+  A8A0 C5               push bc
312+  A8A1 F5               push af
313+  A8A2 1E 0E            ld e,14                    ; do another fourteen for right hand side
314+  A8A4 16 00            ld d,0
315+  A8A6 19               add hl,de
316+  A8A7 F9               ld sp,hl                    ; sp pointing at buffer
317+  A8A8 F1               pop af
318+  A8A9 C1               pop bc
319+  A8AA D1               pop de
320+  A8AB DD E1            pop ix
321+  A8AD D9               exx                         ; hl is now screen
322+  A8AE 08               ex af,af'
323+  A8AF 1E 0E            ld e,14
324+  A8B1 16 00            ld d,0
325+  A8B3 19               add hl,de
326+  A8B4 F1               pop af
327+  A8B5 C1               pop bc
328+  A8B6 D1               pop de
329+  A8B7 F9               ld sp,hl                    ; sp pointing at screen
330+  A8B8 D5               push de
331+  A8B9 C5               push bc
332+  A8BA F5               push af
333+  A8BB 08               ex af,af'
334+  A8BC D9               exx                         ; hl is now buffer
335+  A8BD DD E5            push ix
336+  A8BF D5               push de
337+  A8C0 C5               push bc
338+  A8C1 F5               push af
339+  A8C2 1E 10            ld e,16
340+  A8C4 16 00            ld d,0
341+  A8C6 19               add hl,de
342+  A8C7 D9               exx                         ; hl is now screen
343+  A8C8 11 12 00         ld de,18
344+  A8CB 19               add hl,de
345+  A8CC FD 7E 00         ld a,(iy)
346+  A8CF 3D               dec a
347+  A8D0 FE 00            cp 0
348+  A8D2 FD 77 00         ld (iy),a
349+  A8D5 C2 89 A8         jp nz,buffer_buffertoattrsfast0 ; do another row
350+  A8D8              buffer_buffertoattrsfast1:
351+  A8D8 31 00 00         ld sp,0
352+  A8DB D9               exx
353+  A8DC C9               ret
# file closed: screen/buffer.asm
138   A8DD                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  A8DD              screen_offset:
  2+  A8DD 00               defb 0                      ; offset from top of screen in lines
  3+  A8DE
  4+  A8DE              screen_tmp:
  5+  A8DE 00 00            defb 0,0                      ; temporary memory
  6+  A8E0
  7+  A8E0              screen_setscorecolours:
  8+  A8E0 21 7A B7         ld hl,score_colours
  9+  A8E3 11 00 58         ld de,22528                     ; attrs here
 10+  A8E6 01 40 00         ld bc,64
 11+  A8E9 ED B0            ldir
 12+  A8EB C9               ret
 13+  A8EC
 14+  A8EC              screen_sethighscorecolours:
 15+  A8EC 21 BA B7         ld hl,high_score_colours
 16+  A8EF 11 E0 5A         ld de,22528+736                 ; attrs here
 17+  A8F2 01 20 00         ld bc,32
 18+  A8F5 ED B0            ldir
 19+  A8F7 C9               ret
 20+  A8F8
 21+  A8F8              ; Draw the screen
 22+  A8F8              ; Inputs:
 23+  A8F8              ; none
 24+  A8F8              ; Notes:
 25+  A8F8              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
 26+  A8F8              screen_draw:
 27+  A8F8                  ;call clear_screen
 28+  A8F8 0E 00            ld c,0                      ; horiz
 29+  A8FA 06 00            ld b,0                      ; vert, 0 at top
 30+  A8FC DD 21 55 B1      ld ix,level_layout               ; point ix at level data
 31+  A900 FD 21 73 A3      ld iy,buffer_attr_buffer    ; point iy at attr data
 32+  A904              screen_draw0:
 33+  A904 DD 7E 00         ld a,(ix)                   ; load the block number
 34+  A907 C5               push bc                     ; store bc, contains loop count
 35+  A908 CD C3 AA         call screen_getattr         ; get the memory location for this cell's attr into hl
 36+  A90B 7E               ld a,(hl)                   ; get the attr value at the address
 37+  A90C FD 77 00         ld (iy),a                   ; load the attr into memory
 38+  A90F DD 7E 00         ld a,(ix)                   ; load the block number
 39+  A912 CD 8A AA         call screen_getblock        ; get the block data into hl
 40+  A915 CD 67 AA         call screen_showchar        ; show this character here
 41+  A918 C1               pop bc                      ; get the loop counter back
 42+  A919 DD 23            inc ix                      ; increment level location
 43+  A91B FD 23            inc iy                      ; increment attr location
 44+  A91D 0C               inc c                       ; increment horiz
 45+  A91E 79               ld a,c
 46+  A91F FE 20            cp 32                       ; check if horiz has reach edge of screen
 47+  A921 C2 04 A9         jp nz,screen_draw0          ; if not, loop
 48+  A924 0E 00            ld c,0                      ; if so, reset horiz
 49+  A926 04               inc b                       ; increment vertical
 50+  A927 78               ld a,b
 51+  A928 FE 1D            cp 29                       ; check if at bottom
 52+  A92A C2 04 A9         jp nz,screen_draw0          ; if not, loop
 53+  A92D 21 DE A8         ld hl, screen_tmp
 54+  A930 36 09            ld (hl),9                   ; load the block number into memory
 55+  A932 DD 2A 87 C3      ld ix,(game_current_rocks)  ; current rock memory
 56+  A936 CD A5 A9         call screen_initobjects     ; draw rocks
 57+  A939 21 DE A8         ld hl, screen_tmp
 58+  A93C 36 0C            ld (hl),12                  ; load the block number into memory
 59+  A93E DD 21 DC B6      ld ix,level_missiles       ; missile memory
 60+  A942 CD A5 A9         call screen_initobjects     ; draw missiles
 61+  A945 21 DE A8         ld hl, screen_tmp
 62+  A948 36 08            ld (hl),08                  ; load the block number into memory
 63+  A94A DD 21 55 B7      ld ix,level_diamonds       ; diamond memory
 64+  A94E CD A5 A9         call screen_initobjects     ; draw diamonds
 65+  A951 21 DE A8         ld hl, screen_tmp
 66+  A954 36 0E            ld (hl),14                  ; load the block number into memory
 67+  A956 DD 21 65 B7      ld ix,level_gems           ; gems memory
 68+  A95A CD A5 A9         call screen_initobjects     ; draw gems
 69+  A95D CD 64 A9         call screen_setuptext       ; draws text on the screen
 70+  A960 CD DC CB         call scores_printscores     ; print the current scores
 71+  A963 C9               ret
 72+  A964
 73+  A964              ;
 74+  A964              ; Sets up text on the screen
 75+  A964              ;
 76+  A964              screen_setuptext:
 77+  A964 CD 38 CC         call scores_showtable
 78+  A967 CD EC A8         call screen_sethighscorecolours
 79+  A96A 21 CF 81         ld hl, string_score1
 80+  A96D CD 2B 86         call string_print
 81+  A970 21 D8 81         ld hl, string_scorenumbers1
 82+  A973 CD 2B 86         call string_print
 83+  A976 21 E1 81         ld hl, string_company
 84+  A979 CD 2B 86         call string_print
 85+  A97C 21 01 82         ld hl, string_score2
 86+  A97F CD 2B 86         call string_print
 87+  A982 21 0A 82         ld hl, string_scorenumbers2
 88+  A985 CD 2B 86         call string_print
 89+  A988 3A 83 C3         ld a,(game_currentplayer)
 90+  A98B FE 01            cp 1
 91+  A98D C2 96 A9         jp nz,screen_setuptext0
 92+  A990 21 EB 81         ld hl, string_player1
 93+  A993 C3 99 A9         jp screen_setuptext1
 94+  A996              screen_setuptext0:
 95+  A996 21 F6 81         ld hl, string_player2
 96+  A999              screen_setuptext1:
 97+  A999 CD 2B 86         call string_print
 98+  A99C CD E0 A8         call screen_setscorecolours
 99+  A99F C9               ret
100+  A9A0
101+  A9A0              ;
102+  A9A0              ; Sets a line of colours
103+  A9A0              ; Inputs:
104+  A9A0              ; a - colour to set
105+  A9A0              ; b - number to set
106+  A9A0              ; de - start memory location
107+  A9A0              ;
108+  A9A0              screen_setcolours:
109+  A9A0 12               ld (de),a
110+  A9A1 13               inc de
111+  A9A2 10 FC            djnz screen_setcolours
112+  A9A4 C9               ret
113+  A9A5
114+  A9A5              ;
115+  A9A5              ; Draw initial object positions
116+  A9A5              ; Inputs:
117+  A9A5              ; ix - memory location of objects
118+  A9A5              ; a - graphic
119+  A9A5              screen_initobjects:
120+  A9A5 DD 4E 00         ld c,(ix)                   ; get the horiz coord
121+  A9A8 79               ld a,c
122+  A9A9 FE FF            cp 255
123+  A9AB CA D4 A9         jp z,screen_initobjects2
124+  A9AE DD 23            inc ix                      ; move to next
125+  A9B0 DD 46 00         ld b,(ix)                   ; get the vert coord
126+  A9B3 DD 23            inc ix
127+  A9B5 CD E6 A9         call screen_getcellattradress ; get the memory address of b,c attr into de
128+  A9B8 D5               push de
129+  A9B9 3A DE A8         ld a,(screen_tmp)                  ; get the block number back
130+  A9BC CD C3 AA         call screen_getattr         ; get the memory location for this cell's attr into hl
131+  A9BF D1               pop de
132+  A9C0 7E               ld a,(hl)                   ; get the attr value at the address
133+  A9C1 12               ld (de),a                   ; load the attr into memory
134+  A9C2 3A DE A8         ld a,(screen_tmp)                  ; get the block number back
135+  A9C5 CD 8A AA         call screen_getblock        ; get the block data into hl
136+  A9C8 CD 67 AA         call screen_showchar        ; show this character here
137+  A9CB
138+  A9CB              screen_initobjects1:
139+  A9CB DD 23            inc ix                      ; move past state
140+  A9CD DD 23            inc ix
141+  A9CF DD 23            inc ix                      ; move past mem
142+  A9D1 C3 A5 A9         jp screen_initobjects
143+  A9D4              screen_initobjects2:
144+  A9D4 C9               ret
145+  A9D5
146+  A9D5
147+  A9D5              ;
148+  A9D5              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
149+  A9D5              ; Inputs:
150+  A9D5              ; bc: coords
151+  A9D5              ; Outputs:
152+  A9D5              ; de: memory location
153+  A9D5              ;
154+  A9D5              screen_getcelladdress:
155+  A9D5 78               ld a,b      ; vertical position.
156+  A9D6 E6 18            and 24      ; which segment, 0, 1 or 2?
157+  A9D8 C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
158+  A9DA 57               ld d,a      ; this is our high byte.
159+  A9DB 78               ld a,b      ; what was that vertical position again?
160+  A9DC E6 07            and 7       ; which row within segment?
161+  A9DE 0F               rrca        ; multiply row by 32.
162+  A9DF 0F               rrca
163+  A9E0 0F               rrca
164+  A9E1 5F               ld e,a      ; low byte.
165+  A9E2 79               ld a,c      ; add on y coordinate.
166+  A9E3 83               add a,e     ; mix with low byte.
167+  A9E4 5F               ld e,a      ; address of screen position in de.
168+  A9E5 C9               ret
169+  A9E6
170+  A9E6              ;
171+  A9E6              ; Calculate buffer address of attribute for character at (b, c).
172+  A9E6              ; Inputs:
173+  A9E6              ; bc: coords
174+  A9E6              ; Outputs:
175+  A9E6              ; de: memory location
176+  A9E6              ;
177+  A9E6              screen_getcellattradress:
178+  A9E6 11 73 A3         ld de,buffer_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
179+  A9E9 69               ld l,c      ; x position.
180+  A9EA 26 00            ld h,0      ; 0 h
181+  A9EC 19               add hl,de
182+  A9ED 54 5D            ld de,hl    ; horiz done
183+  A9EF 78               ld a,b      ; do vert
184+  A9F0 D5               push de
185+  A9F1 C5               push bc
186+  A9F2 11 20 00         ld de,32
187+  A9F5 CD 03 81         call utilities_multiply
188+  A9F8 C1               pop bc
189+  A9F9 D1               pop de
190+  A9FA 19               add hl,de
191+  A9FB 54 5D            ld de,hl    ; vert done
192+  A9FD C9               ret
193+  A9FE
194+  A9FE              ;
195+  A9FE              ; Calculate buffer address offset of attribute for character at (b, c).
196+  A9FE              ; Inputs:
197+  A9FE              ; bc: coords
198+  A9FE              ; Outputs:
199+  A9FE              ; de: memory location
200+  A9FE              ;
201+  A9FE              screen_getcellattroffset:
202+  A9FE 69               ld l,c      ; x position.
203+  A9FF 26 00            ld h,0      ; 0 h
204+  AA01 54 5D            ld de,hl    ; horiz done
205+  AA03 78               ld a,b      ; do vert
206+  AA04 D5               push de
207+  AA05 C5               push bc
208+  AA06 11 20 00         ld de,32
209+  AA09 CD 03 81         call utilities_multiply
210+  AA0C C1               pop bc
211+  AA0D D1               pop de
212+  AA0E 19               add hl,de
213+  AA0F 54 5D            ld de,hl    ; vert done
214+  AA11 C9               ret
215+  AA12
216+  AA12              ;
217+  AA12              ; Calculate buffer address of attribute for character at (b, c).
218+  AA12              ; Inputs:
219+  AA12              ; bc: coords
220+  AA12              ; Outputs:
221+  AA12              ; de: memory location
222+  AA12              ;
223+  AA12              screen_getscreenattradress:
224+  AA12 11 00 58         ld de,22528 ; memory is at base + horiz (c) + vert*32 (b)
225+  AA15 69               ld l,c      ; x position.
226+  AA16 26 00            ld h,0      ; 0 h
227+  AA18 19               add hl,de
228+  AA19 54 5D            ld de,hl    ; horiz done
229+  AA1B 78               ld a,b      ; do vert
230+  AA1C D5               push de
231+  AA1D C5               push bc
232+  AA1E 11 20 00         ld de,32
233+  AA21 CD 03 81         call utilities_multiply
234+  AA24 C1               pop bc
235+  AA25 D1               pop de
236+  AA26 19               add hl,de
237+  AA27 54 5D            ld de,hl    ; vert done
238+  AA29 C9               ret
239+  AA2A
240+  AA2A              ;
241+  AA2A              ; Gets the attr memory location for a screen coord
242+  AA2A              ; Will overwrite bc
243+  AA2A              ; Inputs:
244+  AA2A              ; bc - screen coords
245+  AA2A              ; Outputs:
246+  AA2A              ; de - memory location
247+  AA2A              ; bc - character coords
248+  AA2A              ;
249+  AA2A              screen_getattraddressfromscreencoords:
250+  AA2A 78               ld a,b                          ; get the player block coords of current block
251+  AA2B E6 F8            and 248                         ; find closest multiple of eight
252+  AA2D 0F               rrca
253+  AA2E 0F               rrca
254+  AA2F 0F               rrca                ; divide by 8
255+  AA30 47               ld b,a
256+  AA31 79               ld a,c
257+  AA32 48               ld c,b                         ; swap b and c
258+  AA33 E6 F8            and 248
259+  AA35 0F               rrca
260+  AA36 0F               rrca
261+  AA37 0F               rrca                ; divide by 8
262+  AA38 47               ld b,a
263+  AA39 CD E6 A9         call screen_getcellattradress   ; work out memory location of current block attributes, memory in de
264+  AA3C C9               ret
265+  AA3D
266+  AA3D
267+  AA3D              ; Gets the nearest cell coords for a screen coord
268+  AA3D              ; Will overwrite bc
269+  AA3D              ; Inputs:
270+  AA3D              ; bc - screen coords
271+  AA3D              ; Outputs:
272+  AA3D              ; bc - character coords
273+  AA3D              ;
274+  AA3D              screen_getcharcoordsfromscreencoords:
275+  AA3D 78               ld a,b                          ; get the player block coords of current block
276+  AA3E E6 F8            and 248                         ; find closest multiple of eight
277+  AA40 0F               rrca
278+  AA41 0F               rrca
279+  AA42 0F               rrca                ; divide by 8
280+  AA43 47               ld b,a
281+  AA44 79               ld a,c
282+  AA45 48               ld c,b                         ; swap b and c
283+  AA46 E6 F8            and 248
284+  AA48 0F               rrca
285+  AA49 0F               rrca
286+  AA4A 0F               rrca                ; divide by 8
287+  AA4B 47               ld b,a
288+  AA4C C9               ret
289+  AA4D
290+  AA4D              ; Gets the screen coords for a cell coord
291+  AA4D              ; Will overwrite bc
292+  AA4D              ; Inputs:
293+  AA4D              ; bc - char coords
294+  AA4D              ; Outputs:
295+  AA4D              ; bc - screen coords
296+  AA4D              ;
297+  AA4D              screen_getscreencoordsfromcharcoords:
298+  AA4D 78               ld a,b                          ; get the player block coords of current block
299+  AA4E 07               rlca
300+  AA4F 07               rlca
301+  AA50 07               rlca                ; multiply by 8
302+  AA51 47               ld b,a
303+  AA52 79               ld a,c
304+  AA53 48               ld c,b                         ; swap b and c
305+  AA54 07               rlca
306+  AA55 07               rlca
307+  AA56 07               rlca                ; divide by 8
308+  AA57 47               ld b,a
309+  AA58 C9               ret
310+  AA59
311+  AA59              ;
312+  AA59              ; Get buffer address for a character at b,c - b vert
313+  AA59              ; Buffer memory is stored as sequential block
314+  AA59              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
315+  AA59              ; Inputs:
316+  AA59              ; bc - coords
317+  AA59              ; Outputs:
318+  AA59              ; de - memory location of first byte
319+  AA59              screen_getbufferaddress:
320+  AA59 21 73 86         ld hl, buffer_buffer    ; first get screen buffer start
321+  AA5C 50               ld d,b                  ; then work out vertical offset
322+  AA5D 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
323+  AA5F 19               add hl,de               ; add to base
324+  AA60 59               ld e,c                  ; then add horizontal offset (c)
325+  AA61 16 00            ld d,0
326+  AA63 19               add hl,de               ; add to base
327+  AA64 54 5D            ld de,hl
328+  AA66 C9               ret
329+  AA67
330+  AA67              ;
331+  AA67              ; Display character hl at (b, c) to buffer.
332+  AA67              ; Stored sequentially
333+  AA67              ; Inputs:
334+  AA67              ; hl: block address
335+  AA67              ; bc: coords
336+  AA67              ;
337+  AA67              screen_showchar:
338+  AA67 ED 43 26 AC      ld (origcoords),bc   ; store char coords
339+  AA6B 3E 00            ld a,0
340+  AA6D E5               push hl
341+  AA6E CD 59 AA         call screen_getbufferaddress ; get the current screen buffer pointer
342+  AA71 E1               pop hl
343+  AA72 06 08            ld b,8              ; number of pixels high.
344+  AA74              screen_showchar0:
345+  AA74 7E               ld a,(hl)           ; source graphic.
346+  AA75 12               ld (de),a           ; transfer to screen.
347+  AA76 23               inc hl              ; next piece of data.
348+  AA77 E5               push hl             ; store hl
349+  AA78 62 6B            ld hl,de            ; put de in hl
350+  AA7A 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
351+  AA7C 16 00            ld d,0
352+  AA7E 19               add hl,de              ; add de to hl
353+  AA7F 54 5D            ld de,hl            ; load back to de
354+  AA81 E1               pop hl              ; restore hl
355+  AA82
356+  AA82 10 F0            djnz screen_showchar0 ; repeat
357+  AA84 2E 01            ld l,1
358+  AA86 CD D7 AB         call sprites_marklinesforupdatechar
359+  AA89
360+  AA89 C9               ret
361+  AA8A
362+  AA8A
363+  AA8A              ;
364+  AA8A              ; Get cell graphic.
365+  AA8A              ; Inputs:
366+  AA8A              ; a: block
367+  AA8A              ; Outputs:
368+  AA8A              ; hl: memory
369+  AA8A              ;
370+  AA8A              screen_getblock:
371+  AA8A 07               rlca                        ; multiply block number by eight.
372+  AA8B 07               rlca
373+  AA8C 07               rlca
374+  AA8D 5F               ld e,a                      ; displacement to graphic address.
375+  AA8E 16 00            ld d,0                      ; no high byte.
376+  AA90 21 DA BB         ld hl,sprites               ; address of character blocks.
377+  AA93 19               add hl,de                   ; point to block.
378+  AA94 C9               ret
379+  AA95
380+  AA95              ;
381+  AA95              ; Set a the attr of a coord
382+  AA95              ; Inputs:
383+  AA95              ; bc - char coords
384+  AA95              ; a - attr
385+  AA95              ;
386+  AA95              screen_setattr:
387+  AA95 DD E5            push ix
388+  AA97 C5               push bc
389+  AA98 08               ex af, af'
390+  AA99 CD FE A9         call screen_getcellattroffset   ; get offset into de
391+  AA9C 21 73 A3         ld hl,buffer_attr_buffer
392+  AA9F 19               add hl,de                       ; get the memory location
393+  AAA0 08               ex af, af'                      ; get attr back
394+  AAA1 77               ld (hl),a                         ; set the attr
395+  AAA2 08               ex af, af'                      ; get attr back
396+  AAA3 ED 5B DD A8      ld de,(screen_offset)           ; get the offset
397+  AAA7 78               ld a,b                          ; get the vertical
398+  AAA8 93               sub e                           ; subtract the offset
399+  AAA9 DA BF AA         jp c,screen_setattr0            ; if less than zero, don't update the attr on screen
400+  AAAC FE 15            cp 21
401+  AAAE D2 BF AA         jp nc,screen_setattr0           ; if more than 21, don't update the attr on screen
402+  AAB1 47               ld b,a                          ; put the coord back in b
403+  AAB2 CD 12 AA         call screen_getscreenattradress ; screen attr address in de
404+  AAB5 21 40 00         ld hl,64                        ; attr memory + two rows for scores
405+  AAB8 19               add hl,de
406+  AAB9 08               ex af, af'                      ; get attr back
407+  AABA 77               ld (hl),a
408+  AABB C1               pop bc
409+  AABC DD E1            pop ix
410+  AABE C9               ret
411+  AABF              screen_setattr0:
412+  AABF C1               pop bc
413+  AAC0 DD E1            pop ix
414+  AAC2 C9               ret
415+  AAC3
416+  AAC3              ;
417+  AAC3              ; Get cell attribute.
418+  AAC3              ; Inputs:
419+  AAC3              ; a: block
420+  AAC3              ; Outputs:
421+  AAC3              ; hl: memory
422+  AAC3              ;
423+  AAC3              screen_getattr:
424+  AAC3 5F               ld e,a                      ; displacement to attribute address.
425+  AAC4 16 00            ld d,0                      ; no high byte.
426+  AAC6 21 BA BC         ld hl,sprite_attrs          ; address of block attributes.
427+  AAC9 19               add hl,de                   ; point to attribute.
428+  AACA C9               ret
429+  AACB
430+  AACB              ;
431+  AACB              ; Checks whether a character block has anything in it
432+  AACB              ; Inputs:
433+  AACB              ; bc - char coords
434+  AACB              ; Outputs:
435+  AACB              ; a - 1, empty
436+  AACB              screen_ischarempty:
437+  AACB CD 59 AA         call screen_getbufferaddress ; get the current screen buffer pointer
438+  AACE 06 08            ld b,8                      ; check 8 rows
439+  AAD0              screen_ischarempty2:
440+  AAD0 1A               ld a,(de)                   ; check line
441+  AAD1 FE 00            cp 0
442+  AAD3 C2 E1 AA         jp nz,screen_ischarempty1   ; if not zero, jump out with false
443+  AAD6 21 20 00         ld hl,32
444+  AAD9 19               add hl,de
445+  AADA 54 5D            ld de,hl                    ; move to next row
446+  AADC 10 F2            djnz screen_ischarempty2
447+  AADE              screen_ischarempty0:
448+  AADE 3E 01            ld a,1
449+  AAE0 C9               ret
450+  AAE1              screen_ischarempty1:
451+  AAE1 3E 00            ld a,0
452+  AAE3 C9               ret
453+  AAE4
454+  AAE4              ;
455+  AAE4              ; Copies a block from one place to another directly underneath, leaves the original empty
456+  AAE4              ; Inputs:
457+  AAE4              ; bc - coords of block to copy from
458+  AAE4              screen_copyblockdown
459+  AAE4 CD 59 AA         call screen_getbufferaddress ; get the current screen buffer pointer for source
460+  AAE7 06 08            ld b,8                      ; copy 8 rows
461+  AAE9              screen_copyblock0:
462+  AAE9 1A               ld a,(de)                    ; get what we're copying
463+  AAEA 08               ex af,af'
464+  AAEB 3E 00            ld a,0
465+  AAED 12               ld (de),a                    ; replace with empty
466+  AAEE 08               ex af,af'
467+  AAEF 14               inc d                        ; add 256 to get to the next row
468+  AAF0 12               ld (de),a                    ; copy to the next row
469+  AAF1 15               dec d
470+  AAF2 21 20 00         ld hl,32
471+  AAF5 19               add hl,de                       ; return back to source, next row down
472+  AAF6 54 5D            ld de,hl
473+  AAF8 10 EF            djnz screen_copyblock0
474+  AAFA C9               ret
475+  AAFB
476+  AAFB              ;
477+  AAFB              ; Returns the first byte of a character. Useful for figuring out what's there
478+  AAFB              ; Inputs:
479+  AAFB              ; bc - coords
480+  AAFB              ; Outputs:
481+  AAFB              ; a - first byte
482+  AAFB              ;
483+  AAFB              screen_getcharfirstbyte:
484+  AAFB CD 59 AA         call screen_getbufferaddress ; get the current screen buffer pointer for source
485+  AAFE 1A               ld a,(de)
486+  AAFF C9               ret
487+  AB00
# file closed: screen/screen.asm
139   AB00                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  AB00              ;
  2+  AB00              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  AB00              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  AB00              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  AB00              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  AB00              ; routine takes care of all the shifting itself. This means that sprite
  7+  AB00              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  AB00              ; space they would require in pre-shifted form.
  9+  AB00              ; Inputs:
 10+  AB00              ; hl - sprite data
 11+  AB00              ; bc - screen coords
 12+  AB00              ;
 13+  AB00              sprites_drawsprite7:
 14+  AB00 EE 07            xor 7               ; complement last 3 bits.
 15+  AB02 3C               inc a               ; add one for luck!
 16+  AB03              sprites_drawsprite3:
 17+  AB03 CB 11            rl c                ; ...into middle byte...
 18+  AB05 CB 12            rl d                ; ...and finally into left character cell.
 19+  AB07 3D               dec a               ; count shifts we've done.
 20+  AB08 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  AB0A                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  AB0A 79               ld a,c              ; left edge of image is currently in e.
 23+  AB0B 4A               ld c,d              ; put right edge there instead.
 24+  AB0C 57               ld d,a              ; and the left edge back into c.
 25+  AB0D 18 29            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  AB0F              sprites_drawsprite:
 27+  AB0F ED 43 26 AC      ld (origcoords),bc  ; store coords
 28+  AB13 ED 43 28 AC      ld (dispx),bc       ; store coords in dispx for now.
 29+  AB17 E5               push hl
 30+  AB18 CD 04 AC         call sprites_scadd  ; calculate screen address.
 31+  AB1B E1               pop hl
 32+  AB1C 3E 08            ld a,8              ; height of sprite in pixels.
 33+  AB1E              sprites_drawsprite1:
 34+  AB1E 08               ex af,af'           ; store loop counter.
 35+  AB1F D5               push de             ; store screen address.
 36+  AB20 4E               ld c,(hl)           ; first sprite graphic.
 37+  AB21 23               inc hl              ; increment poiinter to sprite data.
 38+  AB22 22 2A AC         ld (sprtmp),hl      ; store it for later.
 39+  AB25 16 00            ld d,0              ; blank right byte for now.
 40+  AB27 78               ld a,b              ; b holds y position.
 41+  AB28 E6 07            and 7               ; how are we straddling character cells?
 42+  AB2A 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 43+  AB2C FE 05            cp 5                ; 5 or more right shifts needed?
 44+  AB2E 30 D0            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 45+  AB30 A7               and a               ; oops, carry flag is set so clear it.
 46+  AB31              sprites_drawsprite2:
 47+  AB31 CB 19            rr c                ; rotate left byte right...
 48+  AB33 CB 1A            rr d                ; ...into right byte.
 49+  AB35 3D               dec a               ; one less shift to do.
 50+  AB36 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 51+  AB38              sprites_drawsprite0:
 52+  AB38 E1               pop hl              ; pop screen address from stack.
 53+  AB39 7E               ld a,(hl)           ; what's there already.
 54+  AB3A A9               xor c               ; merge in image data.
 55+  AB3B 77               ld (hl),a           ; place onto screen.
 56+  AB3C 23               inc hl
 57+  AB3D 7E               ld a,(hl)           ; what's already there.
 58+  AB3E AA               xor d               ; right edge of sprite image data.
 59+  AB3F 77               ld (hl),a           ; plonk it on screen.
 60+  AB40 3A 28 AC         ld a,(dispx)        ; vertical coordinate.
 61+  AB43 3C               inc a               ; next line down.
 62+  AB44 32 28 AC         ld (dispx),a        ; store new position.
 63+  AB47 2B               dec hl
 64+  AB48 11 20 00         ld de,32            ; add 32 to get to the next row
 65+  AB4B 19               add hl,de           ; add 32
 66+  AB4C              sprites_drawsprite6:
 67+  AB4C EB               ex de,hl            ; screen address in de.
 68+  AB4D 2A 2A AC         ld hl,(sprtmp)      ; restore graphic address.
 69+  AB50 08               ex af,af'           ; restore loop counter.
 70+  AB51 3D               dec a               ; decrement it.
 71+  AB52 C2 1E AB         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 72+  AB55 2E 02            ld l,2
 73+  AB57 CD C6 AB         call sprites_marklinesforupdatescreen
 74+  AB5A C9               ret                 ; job done.
 75+  AB5B
 76+  AB5B              ; Inputs:
 77+  AB5B              ; hl - sprite data
 78+  AB5B              ; bc - screen coords
 79+  AB5B              ;
 80+  AB5B              sprites_draw2by2sprite7
 81+  AB5B EE 07            xor 7               ; complement last 3 bits.
 82+  AB5D 3C               inc a               ; add one for luck!
 83+  AB5E              sprites_draw2by2sprite3
 84+  AB5E CB 12            rl d                ; rotate left...
 85+  AB60 CB 11            rl c                ; ...into middle byte...
 86+  AB62 CB 13            rl e                ; ...and finally into left character cell.
 87+  AB64 3D               dec a               ; count shifts we've done.
 88+  AB65 20 F7            jr nz,sprites_draw2by2sprite3 ; return until all shifts complete.
 89+  AB67                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 90+  AB67 7B               ld a,e              ; left edge of image is currently in e.
 91+  AB68 5A               ld e,d              ; put right edge there instead.
 92+  AB69 51               ld d,c              ; middle bit goes in d.
 93+  AB6A 4F               ld c,a              ; and the left edge back into c.
 94+  AB6B 18 31            jr sprites_draw2by2sprite0 ; we've done the switch so transfer to screen.
 95+  AB6D              sprites_draw2by2sprite
 96+  AB6D ED 43 26 AC      ld (origcoords),bc  ; store coords
 97+  AB71 ED 43 28 AC      ld (dispx),bc       ; store coords in dispx for now.
 98+  AB75 79               ld a,c
 99+  AB76 32 2C AC         ld (sprtmp0),a         ; store vertical.
100+  AB79 E5               push hl
101+  AB7A CD 04 AC         call sprites_scadd          ; calculate screen address.
102+  AB7D E1               pop hl
103+  AB7E 3E 10            ld a,16             ; height of sprite in pixels.
104+  AB80              sprites_draw2by2sprite1
105+  AB80 08               ex af,af'           ; store loop counter.
106+  AB81 D5               push de             ; store screen address.
107+  AB82 4E               ld c,(hl)           ; first sprite graphic.
108+  AB83 23               inc hl              ; increment poiinter to sprite data.
109+  AB84 56               ld d,(hl)           ; next bit of sprite image.
110+  AB85 23               inc hl              ; point to next row of sprite data.
111+  AB86 22 2A AC         ld (sprtmp),hl        ; store in tmp0 for later.
112+  AB89 1E 00            ld e,0              ; blank right byte for now.
113+  AB8B 78               ld a,b              ; b holds y position.
114+  AB8C E6 07            and 7               ; how are we straddling character cells?
115+  AB8E 28 0E            jr z,sprites_draw2by2sprite0 ; we're not straddling them, don't bother shifting.
116+  AB90 FE 05            cp 5                ; 5 or more right shifts needed?
117+  AB92 30 C7            jr nc,sprites_draw2by2sprite7 ; yes, shift from left as it's quicker.
118+  AB94 A7               and a               ; oops, carry flag is set so clear it.
119+  AB95              sprites_draw2by2sprite2
120+  AB95 CB 19            rr c                ; rotate left byte right...
121+  AB97 CB 1A            rr d                ; ...through middle byte...
122+  AB99 CB 1B            rr e                ; ...into right byte.
123+  AB9B 3D               dec a               ; one less shift to do.
124+  AB9C 20 F7            jr nz,sprites_draw2by2sprite2 ; return until all shifts complete.
125+  AB9E              sprites_draw2by2sprite0
126+  AB9E E1               pop hl              ; pop screen address from stack.
127+  AB9F 7E               ld a,(hl)           ; what's there already.
128+  ABA0 A9               xor c               ; merge in image data.
129+  ABA1 77               ld (hl),a           ; place onto screen.
130+  ABA2 23               inc hl               ; next character cell to right please.
131+  ABA3 7E               ld a,(hl)           ; what's there already.
132+  ABA4 AA               xor d               ; merge with middle bit of image.
133+  ABA5 77               ld (hl),a           ; put back onto screen.
134+  ABA6 23               inc hl              ; next bit of screen area.
135+  ABA7 7E               ld a,(hl)           ; what's already there.
136+  ABA8 AB               xor e               ; right edge of sprite image data.
137+  ABA9 77               ld (hl),a           ; plonk it on screen.
138+  ABAA 3A 2C AC         ld a,(sprtmp0)         ; temporary vertical coordinate.
139+  ABAD 3C               inc a               ; next line down.
140+  ABAE 32 2C AC         ld (sprtmp0),a         ; store new position.
141+  ABB1 2B               dec hl
142+  ABB2 2B               dec hl
143+  ABB3 11 20 00         ld de,32            ; add 32 to get to the next row
144+  ABB6 19               add hl,de           ; add 32
145+  ABB7              sprites_draw2by2sprite6
146+  ABB7 EB               ex de,hl            ; screen address in de.
147+  ABB8 2A 2A AC         ld hl,(sprtmp)        ; restore graphic address.
148+  ABBB 08               ex af,af'           ; restore loop counter.
149+  ABBC 3D               dec a               ; decrement it.
150+  ABBD C2 80 AB         jp nz,sprites_draw2by2sprite1 ; not reached bottom of sprite yet to repeat.
151+  ABC0 2E 03            ld l,3
152+  ABC2 CD C6 AB         call sprites_marklinesforupdatescreen
153+  ABC5 C9               ret                 ; job done.
154+  ABC6
155+  ABC6              ;
156+  ABC6              ; Marks lines for update with screen coords
157+  ABC6              ; Inputs:
158+  ABC6              ; l - number to update
159+  ABC6              ;
160+  ABC6              sprites_marklinesforupdatescreen:
161+  ABC6 F5               push af
162+  ABC7 ED 4B 26 AC      ld bc,(origcoords)
163+  ABCB CD 3D AA         call screen_getcharcoordsfromscreencoords
164+  ABCE ED 43 26 AC      ld (origcoords),bc
165+  ABD2 CD E1 AB         call sprites_marklinesforupdate
166+  ABD5 F1               pop af
167+  ABD6 C9               ret
168+  ABD7
169+  ABD7              ;
170+  ABD7              ; Marks lines for update with char coords
171+  ABD7              ; Inputs:
172+  ABD7              ; l - number to update
173+  ABD7              ;
174+  ABD7              sprites_marklinesforupdatechar:
175+  ABD7 F5               push af
176+  ABD8 ED 43 26 AC      ld (origcoords),bc
177+  ABDC CD E1 AB         call sprites_marklinesforupdate
178+  ABDF F1               pop af
179+  ABE0 C9               ret
180+  ABE1
181+  ABE1              ;
182+  ABE1              ; Marks lines for update
183+  ABE1              ; Inputs:
184+  ABE1              ; l - number to update
185+  ABE1              ;
186+  ABE1              sprites_marklinesforupdate:
187+  ABE1 ED 4B 26 AC      ld bc,(origcoords)
188+  ABE5 ED 5B DD A8      ld de,(screen_offset)          ; load the screen offset, this is in rows
189+  ABE9 78               ld a,b
190+  ABEA 93               sub e
191+  ABEB 47               ld b,a
192+  ABEC 7D               ld a,l                          ; get loop counter
193+  ABED              sprites_marklinesforupdate0:
194+  ABED C5               push bc
195+  ABEE 08               ex af,af'                     ; store loop counter
196+  ABEF 78               ld a,b
197+  ABF0 CD 2B A7         call buffer_marklineforupdate ; mark this line for update
198+  ABF3 ED 4B 26 AC      ld bc,(origcoords)            ; move the coords for the next line
199+  ABF7 04               inc b
200+  ABF8 ED 43 26 AC      ld (origcoords),bc
201+  ABFC C1               pop bc
202+  ABFD 04               inc b
203+  ABFE 08               ex af,af'                     ; restore loop counter
204+  ABFF 3D               dec a
205+  AC00 C2 ED AB         jp nz,sprites_marklinesforupdate0
206+  AC03 C9               ret
207+  AC04
208+  AC04              ;
209+  AC04              ; This routine returns a buffer address for (c, b) in de (c vert).
210+  AC04              ; For example: 0,0 will be at memory offset 0
211+  AC04              ; 1,0 (1 down) will be at memory offset 1
212+  AC04              ; 0,7 will be at memory offset 0
213+  AC04              ; 9,1 will be at memory offset 8+1
214+  AC04              ; 8,0 will be at memory offset 256
215+  AC04              ; 9,0 will be at memory offset 257
216+  AC04              ; Outputs:
217+  AC04              ; de - coords
218+  AC04              ;
219+  AC04              sprites_scadd:
220+  AC04 79               ld a,c               ; calculate vertical offset
221+  AC05 E6 F8            and 248             ;  to get nearest multiple of 8
222+  AC07 0F               rrca
223+  AC08 0F               rrca
224+  AC09 0F               rrca                ; divide by 8
225+  AC0A 67               ld h,a
226+  AC0B 78               ld a,b               ; calculate horizontal offset
227+  AC0C E6 F8            and 248             ;  to get nearest multiple of 8
228+  AC0E 0F               rrca
229+  AC0F 0F               rrca
230+  AC10 0F               rrca                ; divide by 8
231+  AC11 6F               ld l,a
232+  AC12 C5               push bc             ; store the screen coords
233+  AC13 44 4D            ld bc,hl            ; load bc with the character coords
234+  AC15 CD 59 AA         call screen_getbufferaddress
235+  AC18 C1               pop bc              ; get back screen coords, de is now memory of character
236+  AC19 79               ld a,c              ; now add the vertical within the cell
237+  AC1A E6 07            and 7
238+  AC1C 0F               rrca                ; multiply by 32.
239+  AC1D 0F               rrca
240+  AC1E 0F               rrca
241+  AC1F 6F               ld l,a
242+  AC20 26 00            ld h,0
243+  AC22 19               add hl,de
244+  AC23 54 5D            ld de,hl
245+  AC25 C9               ret
246+  AC26
247+  AC26 00 00        origcoords   defb 0,0           ; general-use coordinates.
248+  AC28
249+  AC28 00           dispx   defb 0           ; general-use coordinates.
250+  AC29 00           dispy   defb 0
251+  AC2A 00 00        sprtmp  defb 0,0           ; sprite temporary address.
252+  AC2C 00 00        sprtmp0  defb 0,0           ; sprite temporary address.
253+  AC2E
# file closed: screen/sprites.asm
140   AC2E                  include "screen\titlescreen.asm"
# file opened: screen/titlescreen.asm
  1+  AC2E              ;
  2+  AC2E              ; Draws the title screen
  3+  AC2E              ;
  4+  AC2E              titlescreen_show:
  5+  AC2E CD DB AC         call titlescreen_preinit
  6+  AC31 06 3C            ld b,60
  7+  AC33 CD 64 81         call utilities_pauseforframes         ; pause for a second
  8+  AC36              titlescreen_show2:
  9+  AC36 CD C8 AC         call titlescreen_init
 10+  AC39 CD 71 AC         call titlescreen_drawtitle
 11+  AC3C 3A 86 C3         ld a,(game_control)
 12+  AC3F FE 00            cp 0
 13+  AC41 CA 49 AC         jp z,titlescreen_show1
 14+  AC44 06 32            ld b,50
 15+  AC46 CD 64 81         call utilities_pauseforframes         ; pause for a second
 16+  AC49              titlescreen_show1:
 17+  AC49 3E FA            ld a,250                              ; wait for 200 frames
 18+  AC4B CD 25 81         call utilities_waitforkey_forframes   ; wait for keypress
 19+  AC4E 7B               ld a,e
 20+  AC4F FE 01            cp 1                                  ; was anything pressed?
 21+  AC51 C8               ret z                                 ; end titlescreen if so
 22+  AC52
 23+  AC52 CD E8 AC         call titlescreen_alt_init             ; otherwise, draw alt screen
 24+  AC55 CD 8D AC         call titlescreen_alt_drawtitle
 25+  AC58 3A 86 C3         ld a,(game_control)
 26+  AC5B FE 00            cp 0
 27+  AC5D CA 65 AC         jp z,titlescreen_show0
 28+  AC60 06 32            ld b,50
 29+  AC62 CD 64 81         call utilities_pauseforframes         ; pause for a second if joystick
 30+  AC65              titlescreen_show0:
 31+  AC65 3E FA            ld a,250                              ; wait for 200 frames
 32+  AC67 CD 25 81         call utilities_waitforkey_forframes   ; wait for keypress
 33+  AC6A 7B               ld a,e
 34+  AC6B FE 01            cp 1                                  ; was anything pressed?
 35+  AC6D C2 36 AC         jp nz,titlescreen_show2               ; start again if not
 36+  AC70 C9               ret
 37+  AC71
 38+  AC71              ;
 39+  AC71              ; Draws the iconic logo
 40+  AC71              ;
 41+  AC71              titlescreen_drawtitle:
 42+  AC71 06 67            ld b,103              ; number of points
 43+  AC73 DD 21 F5 AC      ld ix,titlescreen_logo_data
 44+  AC77              titlescreen_drawtitle0:
 45+  AC77 C5               push bc
 46+  AC78 DD 4E 00         ld c,(ix)                   ; got horiz
 47+  AC7B DD 23            inc ix
 48+  AC7D DD 46 00         ld b,(ix)                   ; got vert
 49+  AC80 DD 23            inc ix
 50+  AC82 CD 12 AA         call screen_getscreenattradress ; memory in de
 51+  AC85 13               inc de                      ; slide one to the right, since I'm too lazy to change the data
 52+  AC86 3E 13            ld a,19
 53+  AC88 12               ld (de),a
 54+  AC89 C1               pop bc
 55+  AC8A 10 EB            djnz titlescreen_drawtitle0 ; loop if we're not at the end
 56+  AC8C C9               ret
 57+  AC8D
 58+  AC8D              ;
 59+  AC8D              ; Draws the alternate title screen
 60+  AC8D              ;
 61+  AC8D              titlescreen_alt_drawtitle:
 62+  AC8D 21 28 82         ld hl,string_alttitlescreen_1
 63+  AC90 CD 2B 86         call string_print
 64+  AC93 21 34 82         ld hl,string_alttitlescreen_2
 65+  AC96 CD 2B 86         call string_print
 66+  AC99 21 2F 83         ld hl,string_alttitlescreen_3
 67+  AC9C CD 2B 86         call string_print
 68+  AC9F 06 20            ld b,32
 69+  ACA1 3E 43            ld a,67
 70+  ACA3 11 00 58         ld de,22528                         ; top row attrs here
 71+  ACA6 CD A0 A9         call screen_setcolours
 72+  ACA9 06 20            ld b,32
 73+  ACAB 3E 46            ld a,70
 74+  ACAD 11 A0 59         ld de,22528+416                     ; 13th row attrs here
 75+  ACB0 CD A0 A9         call screen_setcolours
 76+  ACB3 06 20            ld b,32
 77+  ACB5 3E 43            ld a,67
 78+  ACB7 11 20 5A         ld de,22528+544                         ; 17th row attrs here
 79+  ACBA CD A0 A9         call screen_setcolours
 80+  ACBD 06 20            ld b,32
 81+  ACBF 3E 42            ld a,66
 82+  ACC1 11 A0 5A         ld de,22528+672                         ; 21st row attrs here
 83+  ACC4 CD A0 A9         call screen_setcolours
 84+  ACC7 C9               ret
 85+  ACC8
 86+  ACC8              ;
 87+  ACC8              ; Initialises the screen
 88+  ACC8              ;
 89+  ACC8              titlescreen_init:
 90+  ACC8              ; We want a black screen.
 91+  ACC8 3E 0B            ld a,11             ; magenta ink (7) on blue paper (0),
 92+  ACCA                                      ; bright (64).
 93+  ACCA CD 49 81         call utilities_clearscreen
 94+  ACCD 32 8D 5C         ld (23693),a        ; set our screen colours.
 95+  ACD0 3E 01            ld a,1              ; 2 is the code for red.
 96+  ACD2 D3 FE            out (254),a         ; write to port 254.
 97+  ACD4
 98+  ACD4 21 13 82         ld hl,string_titlescreen_copyright
 99+  ACD7 CD 2B 86         call string_print
100+  ACDA
101+  ACDA C9               ret
102+  ACDB
103+  ACDB              ;
104+  ACDB              ; Initialises the pre-screen
105+  ACDB              ;
106+  ACDB              titlescreen_preinit:
107+  ACDB              ; We want a red screen.
108+  ACDB 3E 10            ld a,16             ; magenta ink (7) on blue paper (0),
109+  ACDD                                      ; bright (64).
110+  ACDD CD 49 81         call utilities_clearscreen
111+  ACE0 32 8D 5C         ld (23693),a        ; set our screen colours.
112+  ACE3 3E 02            ld a,2              ; 2 is the code for red.
113+  ACE5 D3 FE            out (254),a         ; write to port 254.
114+  ACE7 C9               ret
115+  ACE8
116+  ACE8              ;
117+  ACE8              ; Initialises the screen
118+  ACE8              ;
119+  ACE8              titlescreen_alt_init:
120+  ACE8              ; We want a black screen.
121+  ACE8 3E 47            ld a,71             ; white ink (7) on black paper (0),
122+  ACEA                                      ; bright (64).
123+  ACEA CD 49 81         call utilities_clearscreen
124+  ACED 32 8D 5C         ld (23693),a        ; set our screen colours.
125+  ACF0 3E 00            ld a,0              ; 2 is the code for red.
126+  ACF2 D3 FE            out (254),a         ; write to port 254.
127+  ACF4
128+  ACF4 C9               ret
129+  ACF5
130+  ACF5              ;
131+  ACF5              ; Horiz, vert
132+  ACF5              ;
133+  ACF5              titlescreen_logo_data:
134+  ACF5 08 00 09 00      defb 8,0,9,0,10,0,12,0,15,0,17,0,18,0,19,0
134+  ACF9 0A 00 0C 00
134+  ACFD 0F 00 11 00
134+  AD01 12 00 13 00
135+  AD05 09 01 0C 01      defb 9,1,12,1,15,1,17,1
135+  AD09 0F 01 11 01
136+  AD0D 09 02 0C 02      defb 9,2,12,2,13,2,14,2,15,2,17,2,18,2,19,2
136+  AD11 0D 02 0E 02
136+  AD15 0F 02 11 02
136+  AD19 12 02 13 02
137+  AD1D 09 03 0C 03      defb 9,3,12,3,15,3,17,3
137+  AD21 0F 03 11 03
138+  AD25 09 04 0C 04      defb 9,4,12,4,15,4,17,4,18,4,19,4
138+  AD29 0F 04 11 04
138+  AD2D 12 04 13 04
139+  AD31 00 06 01 06      defb 0,6,1,6,2,6,3,6,4,6,5,6,6,6,7,6,8,6,9,6,10,6,11,6
139+  AD35 02 06 03 06
139+  AD39 04 06 05 06
139+  AD3D 06 06 07 06
139+  AD41 08 06 09 06
139+  AD45 0A 06 0B 06
140+  AD49 10 06 11 06      defb 16,6,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6
140+  AD4D 12 06 13 06
140+  AD51 14 06 15 06
140+  AD55 16 06 17 06
140+  AD59 18 06 19 06
140+  AD5D 1A 06 1B 06
141+  AD61 02 07 02 08      defb 2,7,2,8,2,9,2,10,2,11,2,12,2,13,2,14,2,15,2,16,2,17,2,18,2,19,2,20,2,21
141+  AD65 02 09 02 0A
141+  AD69 02 0B 02 0C
141+  AD6D 02 0D 02 0E
141+  AD71 02 0F 02 10
141+  AD75 02 11 02 12
141+  AD79 02 13 02 14
141+  AD7D 02 15
142+  AD7F 19 07 19 08      defb 25,7,25,8,25,9,25,10,25,11,25,12,25,13,25,14,25,15,25,16,25,17,25,18,25,19,25,20,25,21
142+  AD83 19 09 19 0A
142+  AD87 19 0B 19 0C
142+  AD8B 19 0D 19 0E
142+  AD8F 19 0F 19 10
142+  AD93 19 11 19 12
142+  AD97 19 13 19 14
142+  AD9B 19 15
143+  AD9D 03 0B 04 0B      defb 3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,11,11
143+  ADA1 05 0B 06 0B
143+  ADA5 07 0B 08 0B
143+  ADA9 09 0B 0A 0B
143+  ADAD 0B 0B
144+  ADAF 0B 07 0B 08      defb 11,7,11,8,11,9,11,10
144+  ADB3 0B 09 0B 0A
145+  ADB7 10 0D 10 0F      defb 16,13,16,15,16,16,16,17,16,18,16,19
145+  ADBB 10 10 10 11
145+  ADBF 10 12 10 13
146+  ADC3
# file closed: screen/titlescreen.asm
141   ADC3                  include "screen\lifescreen.asm"
# file opened: screen/lifescreen.asm
  1+  ADC3              ;
  2+  ADC3              ; Draws the life remaining screen
  3+  ADC3              ;
  4+  ADC3              lifescreen_draw:
  5+  ADC3 CD 16 AE         call lifescreen_init
  6+  ADC6
  7+  ADC6 3A 83 C3         ld a,(game_currentplayer)             ; get the current player
  8+  ADC9 C6 30            add 48                                ; add 48 to get char
  9+  ADCB 21 35 84         ld hl,string_lifescreen_player+10
 10+  ADCE 77               ld (hl),a                             ; load this to the string we're about to show
 11+  ADCF
 12+  ADCF 21 2B 84         ld hl,string_lifescreen_player
 13+  ADD2 CD 2B 86         call string_print
 14+  ADD5
 15+  ADD5 3A 7B C4         ld a,(player+9)                       ; get the current player lives
 16+  ADD8 C6 30            add 48                                ; add 48 to get the character
 17+  ADDA FE 31            cp 49
 18+  ADDC C2 EF AD         jp nz,lifescreen_draw0
 19+  ADDF 21 45 84         ld hl,string_lifescreen_lastman
 20+  ADE2
 21+  ADE2 06 08            ld b,8
 22+  ADE4 3E 0A            ld a,10                                ; set red
 23+  ADE6 11 6C 58         ld de,22528+108                        ; attrs here
 24+  ADE9 CD A0 A9         call screen_setcolours
 25+  ADEC
 26+  ADEC C3 F6 AD         jp lifescreen_draw1
 27+  ADEF              lifescreen_draw0:
 28+  ADEF 21 3A 84         ld hl,string_lifescreen_lives+2       ; not last man, so use the normal view
 29+  ADF2 77               ld (hl),a                             ; load this to the string we're about to show
 30+  ADF3 21 38 84         ld hl,string_lifescreen_lives
 31+  ADF6              lifescreen_draw1:
 32+  ADF6 CD 2B 86         call string_print
 33+  ADF9
 34+  ADF9 3E 86            ld a,134
 35+  ADFB 11 0B 58         ld de, 22528+11     ; get the colour for the top text
 36+  ADFE 06 0A            ld b,10
 37+  AE00 CD A0 A9         call screen_setcolours
 38+  AE03 3A 86 C3         ld a,(game_control)
 39+  AE06 FE 00            cp 0
 40+  AE08 CA 10 AE         jp z,lifescreen_draw2
 41+  AE0B 06 32            ld b,50
 42+  AE0D CD 64 81         call utilities_pauseforframes         ; pause for a second if joystick
 43+  AE10              lifescreen_draw2:
 44+  AE10 3E 64            ld a,100                              ; wait for 200 frames
 45+  AE12 CD 25 81         call utilities_waitforkey_forframes   ; wait for keypress
 46+  AE15
 47+  AE15 C9               ret
 48+  AE16
 49+  AE16              ;
 50+  AE16              ; Initialises the screen
 51+  AE16              ;
 52+  AE16              lifescreen_init:
 53+  AE16              ; We want a blue screen.
 54+  AE16                  ;call $0D6B
 55+  AE16 3E 0E            ld a,14             ; yellow ink (6) on blue paper (1),
 56+  AE18                                      ; bright (64).
 57+  AE18 CD 49 81         call utilities_clearscreen
 58+  AE1B 32 8D 5C         ld (23693),a        ; set our screen colours.
 59+  AE1E 3E 01            ld a,1              ; 1 is the code for blue.
 60+  AE20 D3 FE            out (254),a         ; write to port 254.
 61+  AE22                  ;call 3503           ; ROM routine - clears screen, opens chan 2.
 62+  AE22
 63+  AE22 C9               ret
# file closed: screen/lifescreen.asm
142   AE23                  include "screen\gameover.asm"
# file opened: screen/gameover.asm
  1+  AE23              ;
  2+  AE23              ; Draws the game over screen
  3+  AE23              ;
  4+  AE23              gameover_draw:
  5+  AE23 3E 01            ld a,1
  6+  AE25 32 83 C3         ld (game_currentplayer),a               ; do the first player first
  7+  AE28 CD DE C4         call player_init_lifestart              ; get the player config
  8+  AE2B CD 7E AE         call gameover_enterhighscores
  9+  AE2E
 10+  AE2E 3A 82 C3         ld a,(game_numberplayers)               ; check if we need to do player 2
 11+  AE31 FE 02            cp 2
 12+  AE33 C2 41 AE         jp nz,gameover_draw0
 13+  AE36 3E 02            ld a,2
 14+  AE38 32 83 C3         ld (game_currentplayer),a               ; do the second player
 15+  AE3B CD DE C4         call player_init_lifestart              ; get the player config
 16+  AE3E CD 7E AE         call gameover_enterhighscores
 17+  AE41              gameover_draw0:
 18+  AE41 CD 46 AF         call gameover_init
 19+  AE44
 20+  AE44 21 50 84         ld hl,string_gameoverscreen_gameover
 21+  AE47 CD 2B 86         call string_print
 22+  AE4A
 23+  AE4A 21 5C 84         ld hl,string_gameoverscreen_copyright
 24+  AE4D CD 2B 86         call string_print
 25+  AE50
 26+  AE50 CD 61 AE         call gameover_commontext
 27+  AE53
 28+  AE53 06 0B            ld b,11
 29+  AE55 3E 42            ld a,66
 30+  AE57 11 2B 58         ld de,22528+43                         ; attrs here
 31+  AE5A CD A0 A9         call screen_setcolours
 32+  AE5D CD 10 81         call utilities_waitforkey   ; wait for keypress
 33+  AE60
 34+  AE60 C9               ret
 35+  AE61
 36+  AE61              ;
 37+  AE61              ; Draws text shared by the game over and high score screens
 38+  AE61              ;
 39+  AE61              gameover_commontext:
 40+  AE61 CD 64 A9         call screen_setuptext       ; show scores
 41+  AE64 CD DC CB         call scores_printscores     ; print the current scores
 42+  AE67
 43+  AE67 21 84 84         ld hl,string_gameover_credits
 44+  AE6A CD 2B 86         call string_print
 45+  AE6D
 46+  AE6D 21 70 84         ld hl,string_gameoverscreen_bestscores
 47+  AE70 CD 2B 86         call string_print
 48+  AE73
 49+  AE73 06 20            ld b,32
 50+  AE75 3E 45            ld a,69
 51+  AE77 11 C0 5A         ld de,22528+704                         ; attrs here
 52+  AE7A CD A0 A9         call screen_setcolours
 53+  AE7D
 54+  AE7D C9               ret
 55+  AE7E
 56+  AE7E              ;
 57+  AE7E              ; If required, enter highscore
 58+  AE7E              ;
 59+  AE7E              gameover_enterhighscores:
 60+  AE7E                  ; check if we need to enter initial
 61+  AE7E CD 4D CC         call scores_processhighscores
 62+  AE81
 63+  AE81 3A 4B CC         ld a,(scores_highscoretmp)
 64+  AE84 FE 00            cp 0
 65+  AE86 C8               ret z
 66+  AE87 CD DC AE         call gameover_enterhighscores_init
 67+  AE8A                  ; Set the flash
 68+  AE8A 3A 4B CC         ld a,(scores_highscoretmp)              ; scoretmp has the memory offset of the start of the number
 69+  AE8D 1E 05            ld e,5
 70+  AE8F 93               sub e                                   ; get the score position back to coords
 71+  AE90 11 00 00         ld de,0
 72+  AE93 5F               ld e,a                                  ; load into de
 73+  AE94 21 61 CB         ld hl,scores_table
 74+  AE97 19               add hl,de                               ; get the memory location
 75+  AE98 4E 23 46 2B      ld bc,(hl)                              ; get the coords
 76+  AE9C CD 12 AA         call screen_getscreenattradress         ; get the memory location of the cell attr into de
 77+  AE9F 1A               ld a,(de)                               ; get the current attr
 78+  AEA0 F6 80            or 128                                  ; make it flash
 79+  AEA2 12               ld (de),a
 80+  AEA3 13               inc de
 81+  AEA4 12               ld (de),a
 82+  AEA5 13               inc de
 83+  AEA6 12               ld (de),a                               ; make all three flash
 84+  AEA7 3A 4B CC         ld a,(scores_highscoretmp)              ; get the score back again
 85+  AEAA 3D               dec a
 86+  AEAB 3D               dec a
 87+  AEAC 3D               dec a                                   ; get high score location back to position of name
 88+  AEAD 16 00            ld d,0
 89+  AEAF 5F               ld e,a
 90+  AEB0 21 61 CB         ld hl,scores_table
 91+  AEB3 19               add hl,de                               ; load memory into hl
 92+  AEB4 08               ex af,af'
 93+  AEB5 06 0F            ld b,15
 94+  AEB7 CD 64 81         call utilities_pauseforframes           ; pause for a little bit
 95+  AEBA 06 03            ld b,3                                  ; collect three chars
 96+  AEBC              gameover_enterhighscores2:
 97+  AEBC C5               push bc
 98+  AEBD E5               push hl
 99+  AEBE              gameover_enterhighscores3:
100+  AEBE CD 68 81         call utilities_readkey               ; get key into a
101+  AEC1 FE 41            cp 65
102+  AEC3 DA BE AE         jp c,gameover_enterhighscores3
103+  AEC6 FE 5B            cp 91
104+  AEC8 D2 BE AE         jp nc,gameover_enterhighscores3      ; if not a letter, get another
105+  AECB E1               pop hl
106+  AECC 77               ld (hl),a
107+  AECD 23               inc hl
108+  AECE E5               push hl
109+  AECF CD 38 CC         call scores_showtable
110+  AED2 E1               pop hl
111+  AED3 06 0F            ld b,15
112+  AED5 CD 64 81         call utilities_pauseforframes
113+  AED8 C1               pop bc
114+  AED9 10 E1            djnz gameover_enterhighscores2
115+  AEDB C9               ret
116+  AEDC
117+  AEDC              ;
118+  AEDC              ; Displays the screen text for high score entry
119+  AEDC              ;
120+  AEDC              gameover_enterhighscores_init:
121+  AEDC
122+  AEDC CD 46 AF         call gameover_init
123+  AEDF CD 61 AE         call gameover_commontext
124+  AEE2
125+  AEE2 21 90 84         ld hl,string_highscore_congratulations
126+  AEE5 CD 2B 86         call string_print
127+  AEE8
128+  AEE8 3A 83 C3         ld a,(game_currentplayer)
129+  AEEB FE 01            cp 1
130+  AEED 21 A2 84         ld hl,string_highscore_player1
131+  AEF0 C3 F6 AE         jp gameover_enterhighscores_init1
132+  AEF3              gameover_enterhighscores_init0:
133+  AEF3 21 AD 84         ld hl,string_highscore_player2
134+  AEF6              gameover_enterhighscores_init1:
135+  AEF6 CD 2B 86         call string_print
136+  AEF9 06 60            ld b,96
137+  AEFB 3E 43            ld a,67
138+  AEFD 11 A0 58         ld de,22528+160                         ; attrs here
139+  AF00 CD A0 A9         call screen_setcolours
140+  AF03
141+  AF03 21 B8 84         ld hl,string_highscore_youhaveearned
142+  AF06 CD 2B 86         call string_print
143+  AF09
144+  AF09 3A 4B CC         ld a,(scores_highscoretmp)
145+  AF0C FE 05            cp 5
146+  AF0E CA 1C AF         jp z, gameover_enterhighscores_init2    ; first place
147+  AF11 FE 11            cp 17
148+  AF13 CA 22 AF         jp z, gameover_enterhighscores_init3    ; 2nd place
149+  AF16 21 F4 84         ld hl,string_highscore_place3           ; 3rd place
150+  AF19 C3 28 AF         jp gameover_enterhighscores_init4
151+  AF1C              gameover_enterhighscores_init2
152+  AF1C 21 CA 84         ld hl,string_highscore_place1
153+  AF1F C3 28 AF         jp gameover_enterhighscores_init4
154+  AF22              gameover_enterhighscores_init3
155+  AF22 21 DF 84         ld hl,string_highscore_place2
156+  AF25 C3 28 AF         jp gameover_enterhighscores_init4
157+  AF28              gameover_enterhighscores_init4
158+  AF28 CD 2B 86         call string_print
159+  AF2B
160+  AF2B 06 60            ld b,96
161+  AF2D 3E 42            ld a,66
162+  AF2F 11 40 59         ld de,22528+320                         ; attrs here
163+  AF32 CD A0 A9         call screen_setcolours
164+  AF35
165+  AF35 21 09 85         ld hl,string_highscore_pleaseenter
166+  AF38 CD 2B 86         call string_print
167+  AF3B
168+  AF3B 06 60            ld b,96
169+  AF3D 3E 46            ld a,70
170+  AF3F 11 E0 59         ld de,22528+480                         ; attrs here
171+  AF42 CD A0 A9         call screen_setcolours
172+  AF45 C9               ret
173+  AF46
174+  AF46              ;
175+  AF46              ; Initialises the screen
176+  AF46              ;
177+  AF46              gameover_init:
178+  AF46              ; We want a black screen.
179+  AF46 3E 47            ld a,71             ; white ink (7) on black paper (0),
180+  AF48                                      ; bright (64).
181+  AF48 CD 49 81         call utilities_clearscreen
182+  AF4B 32 8D 5C         ld (23693),a        ; set our screen colours.
183+  AF4E 3E 00            ld a,0              ; 2 is the code for red.
184+  AF50 D3 FE            out (254),a         ; write to port 254.
185+  AF52 C9               ret
# file closed: screen/gameover.asm
143   AF53                  include "screen\endlevel.asm"
# file opened: screen/endlevel.asm
  1+  AF53              ;
  2+  AF53              ; Draws the level transition screen
  3+  AF53              ;
  4+  AF53              endlevel_draw:
  5+  AF53 CD 51 B0         call endlevel_init
  6+  AF56 CD 3A B0         call endlevel_commontext
  7+  AF59
  8+  AF59 21 90 84         ld hl,string_highscore_congratulations
  9+  AF5C CD 2B 86         call string_print
 10+  AF5F
 11+  AF5F 3A 83 C3         ld a,(game_currentplayer)
 12+  AF62 FE 01            cp 1
 13+  AF64 21 A2 84         ld hl,string_highscore_player1
 14+  AF67 C3 6D AF         jp endlevel_init1
 15+  AF6A              endlevel_init0:
 16+  AF6A 21 AD 84         ld hl,string_highscore_player2
 17+  AF6D              endlevel_init1:
 18+  AF6D CD 2B 86         call string_print
 19+  AF70
 20+  AF70 21 26 85         ld hl,string_endlevel_youhaveearned
 21+  AF73 CD 2B 86         call string_print
 22+  AF76
 23+  AF76 CD D9 AF         call endlevel_workoutbonus
 24+  AF79 D5               push de
 25+  AF7A 08               ex af,af'                               ; store the a value for later
 26+  AF7B CD 2B 86         call string_print
 27+  AF7E D1               pop de
 28+  AF7F 62 6B            ld hl,de                                ; get the points text into de
 29+  AF81 CD 2B 86         call string_print
 30+  AF84
 31+  AF84 21 91 85         ld hl, string_endlevel_anothergo
 32+  AF87 CD 2B 86         call string_print
 33+  AF8A
 34+  AF8A 06 20            ld b,32
 35+  AF8C 3E 23            ld a,35
 36+  AF8E 11 60 59         ld de,22528+352                         ; attrs here
 37+  AF91 CD A0 A9         call screen_setcolours
 38+  AF94
 39+  AF94 06 20            ld b,32
 40+  AF96 3E 25            ld a,37
 41+  AF98 11 A0 59         ld de,22528+416                         ; attrs here
 42+  AF9B CD A0 A9         call screen_setcolours
 43+  AF9E
 44+  AF9E 06 20            ld b,32
 45+  AFA0 3E 23            ld a,35
 46+  AFA2 11 E0 59         ld de,22528+480                         ; attrs here
 47+  AFA5 CD A0 A9         call screen_setcolours
 48+  AFA8
 49+  AFA8 06 20            ld b,32
 50+  AFAA 3E 22            ld a,34
 51+  AFAC 11 40 5A         ld de,22528+576                         ; attrs here
 52+  AFAF CD A0 A9         call screen_setcolours
 53+  AFB2
 54+  AFB2 08               ex af,af'                               ; get back a value with bonus type
 55+  AFB3 06 14            ld b,20
 56+  AFB5 CD 64 81         call utilities_pauseforframes
 57+  AFB8
 58+  AFB8 47               ld b,a                      ; put the bonus count in b
 59+  AFB9              endlevel_init2:
 60+  AFB9 C5               push bc
 61+  AFBA 06 01            ld b,1
 62+  AFBC CD 85 CB         call scores_addthousands
 63+  AFBF CD 3D C5         call player_recordcurrentstate
 64+  AFC2 CD 9C CB         call scores_printscore     ; print the current scores
 65+  AFC5 06 0A            ld b,10
 66+  AFC7 CD 64 81         call utilities_pauseforframes
 67+  AFCA C1               pop bc
 68+  AFCB 10 EC            djnz endlevel_init2
 69+  AFCD
 70+  AFCD CD 26 C4         call game_increasedifficulty ; move the difficulty up a level
 71+  AFD0 CD 3D C5         call player_recordcurrentstate
 72+  AFD3
 73+  AFD3 3E 64            ld a,100                              ; wait for 200 frames
 74+  AFD5 CD 25 81         call utilities_waitforkey_forframes   ; wait for keypress
 75+  AFD8
 76+  AFD8 C9               ret
 77+  AFD9
 78+  AFD9              ;
 79+  AFD9              ; Works out the bonus
 80+  AFD9              ; Outputs:
 81+  AFD9              ; a = 15 (all seven)
 82+  AFD9              ; a = 10 (3 large or 4 small)
 83+  AFD9              ; a = 5 (1 large diamond)
 84+  AFD9              ; hl - pointer to bonus text
 85+  AFD9              ; de - pointer to points text
 86+  AFD9              ;
 87+  AFD9              endlevel_workoutbonus:
 88+  AFD9 21 57 B7         ld hl,level_diamonds+2     ; location of state of first diamond
 89+  AFDC 06 03            ld b,3                      ; number to check
 90+  AFDE 16 00            ld d,0                      ; zero diamond count
 91+  AFE0              endlevel_workoutbonus0:
 92+  AFE0 7E               ld a,(hl)                   ; get state
 93+  AFE1 FE 01            cp 1
 94+  AFE3 C2 E7 AF         jp nz,endlevel_workoutbonus1 ; if not, move on
 95+  AFE6 14               inc d                       ; increment diamond count
 96+  AFE7              endlevel_workoutbonus1:
 97+  AFE7 23               inc hl
 98+  AFE8 23               inc hl
 99+  AFE9 23               inc hl
100+  AFEA 23               inc hl
101+  AFEB 23               inc hl                      ; get to next state
102+  AFEC 10 F2            djnz endlevel_workoutbonus0
103+  AFEE
104+  AFEE 21 67 B7         ld hl,level_gems+2     ; location of state of first gem
105+  AFF1 06 04            ld b,4                      ; number to check
106+  AFF3 1E 00            ld e,0                      ; zero gem count
107+  AFF5              endlevel_workoutbonus2:
108+  AFF5 7E               ld a,(hl)                   ; get state
109+  AFF6 FE 01            cp 1
110+  AFF8 C2 FC AF         jp nz,endlevel_workoutbonus3 ; if not, move on
111+  AFFB 1C               inc e                       ; increment diamond count
112+  AFFC              endlevel_workoutbonus3:
113+  AFFC 23               inc hl
114+  AFFD 23               inc hl
115+  AFFE 23               inc hl
116+  AFFF 23               inc hl
117+  B000 23               inc hl                     ; get to next state
118+  B001 10 F2            djnz endlevel_workoutbonus2
119+  B003
120+  B003 7A               ld a,d
121+  B004 83               add e
122+  B005 FE 07            cp 7                        ; check for max bonus
123+  B007 C2 13 B0         jp nz,endlevel_workoutbonus4 ;
124+  B00A 3E 0F            ld a,15
125+  B00C 21 56 85         ld hl, string_endlevel_bonus3
126+  B00F 11 82 85         ld de, string_endlevel_points3
127+  B012 C9               ret                         ; return with bonus of 15
128+  B013              endlevel_workoutbonus4:
129+  B013 7A               ld a,d                      ; check for for diamonds
130+  B014 FE 03            cp 3
131+  B016 C2 22 B0         jp nz,endlevel_workoutbonus5
132+  B019 3E 0A            ld a,10
133+  B01B 21 47 85         ld hl, string_endlevel_bonus2
134+  B01E 11 73 85         ld de, string_endlevel_points2
135+  B021 C9               ret                         ; return with bonus of ten
136+  B022              endlevel_workoutbonus5:
137+  B022 7B               ld a,e                      ; check for four gems
138+  B023 FE 04            cp 4
139+  B025 C2 31 B0         jp nz,endlevel_workoutbonus6
140+  B028 3E 0A            ld a,10
141+  B02A 21 47 85         ld hl, string_endlevel_bonus2
142+  B02D 11 73 85         ld de, string_endlevel_points2
143+  B030 C9               ret                         ; return with bonus of 10
144+  B031              endlevel_workoutbonus6:
145+  B031 3E 05            ld a,5                      ; otherwise, bonus is 5
146+  B033 21 38 85         ld hl, string_endlevel_bonus1
147+  B036 11 65 85         ld de, string_endlevel_points1
148+  B039 C9               ret
149+  B03A
150+  B03A              ;
151+  B03A              ; Draws text shared by the game over and high score screens
152+  B03A              ;
153+  B03A              endlevel_commontext:
154+  B03A CD 64 A9         call screen_setuptext       ; show scores
155+  B03D CD DC CB         call scores_printscores     ; print the current scores
156+  B040
157+  B040 21 70 84         ld hl,string_gameoverscreen_bestscores
158+  B043 CD 2B 86         call string_print
159+  B046
160+  B046 06 20            ld b,32
161+  B048 3E 45            ld a,69
162+  B04A 11 C0 5A         ld de,22528+704                         ; attrs here
163+  B04D CD A0 A9         call screen_setcolours
164+  B050
165+  B050 C9               ret
166+  B051
167+  B051              ;
168+  B051              ; Initialises the screen
169+  B051              ;
170+  B051              endlevel_init:
171+  B051              ; We want a green screen.
172+  B051 3E 21            ld a,33             ; white ink (7) on black paper (0),
173+  B053                                      ; bright (64).
174+  B053 CD 49 81         call utilities_clearscreen
175+  B056 32 8D 5C         ld (23693),a        ; set our screen colours.
176+  B059 3E 00            ld a,0              ; 2 is the code for red.
177+  B05B D3 FE            out (254),a         ; write to port 254.
178+  B05D C9               ret
# file closed: screen/endlevel.asm
144   B05E                  include "screen\options.asm"
# file opened: screen/options.asm
  1+  B05E              ;
  2+  B05E              ; Show the options screen
  3+  B05E              ;
  4+  B05E              options_show:
  5+  B05E CD F9 B0         call options_init
  6+  B061
  7+  B061 21 AC 85         ld hl,string_options_title
  8+  B064 CD 2B 86         call string_print
  9+  B067 21 B6 85         ld hl,string_options_1player
 10+  B06A CD 2B 86         call string_print
 11+  B06D 21 C6 85         ld hl,string_options_2player
 12+  B070 CD 2B 86         call string_print
 13+  B073 21 D6 85         ld hl,string_options_keyboard
 14+  B076 CD 2B 86         call string_print
 15+  B079 21 E4 85         ld hl,string_options_joystick
 16+  B07C CD 2B 86         call string_print
 17+  B07F 21 F2 85         ld hl,string_options_start
 18+  B082 CD 2B 86         call string_print
 19+  B085 21 FD 85         ld hl,string_options_vanity
 20+  B088 CD 2B 86         call string_print
 21+  B08B
 22+  B08B 3A 82 C3         ld a,(game_numberplayers)
 23+  B08E FE 01            cp 1
 24+  B090 C2 99 B0         jp nz,options_show0
 25+  B093 11 CA 58         ld de,22528+202                         ; top row attrs here
 26+  B096 C3 9C B0         jp options_show1
 27+  B099              options_show0:
 28+  B099 11 EA 58         ld de,22528+234                         ; top row attrs here
 29+  B09C              options_show1:
 30+  B09C 06 0D            ld b,13
 31+  B09E 3E C7            ld a,199
 32+  B0A0 CD A0 A9         call screen_setcolours                  ; highlight current player
 33+  B0A3
 34+  B0A3 3A 86 C3         ld a,(game_control)
 35+  B0A6 FE 00            cp 0
 36+  B0A8 C2 B1 B0         jp nz,options_show6
 37+  B0AB 11 0A 59         ld de,22528+266                         ; top row attrs here
 38+  B0AE C3 B4 B0         jp options_show7
 39+  B0B1              options_show6:
 40+  B0B1 11 2A 59         ld de,22528+298                         ; top row attrs here
 41+  B0B4              options_show7:
 42+  B0B4 06 0D            ld b,13
 43+  B0B6 3E C7            ld a,199
 44+  B0B8 CD A0 A9         call screen_setcolours                  ; highlight current control
 45+  B0BB              options_show8:
 46+  B0BB CD 68 81         call utilities_readkey
 47+  B0BE FE 31            cp 49                                   ; was 1 pressed
 48+  B0C0 C2 CB B0         jp nz,options_show2
 49+  B0C3 21 82 C3         ld hl,game_numberplayers
 50+  B0C6 36 01            ld (hl),1
 51+  B0C8 C3 5E B0         jp options_show
 52+  B0CB              options_show2:
 53+  B0CB FE 32            cp 50                                   ; was 2 pressed
 54+  B0CD C2 D8 B0         jp nz,options_show3
 55+  B0D0 21 82 C3         ld hl,game_numberplayers
 56+  B0D3 36 02            ld (hl),2
 57+  B0D5 C3 5E B0         jp options_show
 58+  B0D8              options_show3:
 59+  B0D8 FE 33            cp 51                                   ; was 3 pressed
 60+  B0DA C2 E5 B0         jp nz,options_show4
 61+  B0DD 21 86 C3         ld hl,game_control
 62+  B0E0 36 00            ld (hl),0
 63+  B0E2 C3 5E B0         jp options_show
 64+  B0E5              options_show4:
 65+  B0E5 FE 34            cp 52                                   ; was 4 pressed
 66+  B0E7 C2 F2 B0         jp nz,options_show5
 67+  B0EA 21 86 C3         ld hl,game_control
 68+  B0ED 36 01            ld (hl),1
 69+  B0EF C3 5E B0         jp options_show
 70+  B0F2              options_show5:
 71+  B0F2 FE 35            cp 53                                   ; was 5 pressed
 72+  B0F4 C8               ret z                                   ; exit if so
 73+  B0F5 C3 BB B0         jp options_show8                         ; otherwise, jump to top
 74+  B0F8 C9               ret
 75+  B0F9
 76+  B0F9              ;
 77+  B0F9              ; Initialise the options screen
 78+  B0F9              ;
 79+  B0F9              options_init:
 80+  B0F9 3E 47            ld a,71             ; white ink (7) on black paper (0),
 81+  B0FB                                      ; bright (64).
 82+  B0FB CD 49 81         call utilities_clearscreen
 83+  B0FE 32 8D 5C         ld (23693),a        ; set our screen colours.
 84+  B101 3E 00            ld a,0              ; 2 is the code for red.
 85+  B103 D3 FE            out (254),a         ; write to port 254.
 86+  B105
 87+  B105 C9               ret
 88+  B106 C9               ret
# file closed: screen/options.asm
145   B107
146   B107                  include "sound\sound.asm"
# file opened: sound/sound.asm
  1+  B107              sound_gemcollected:
  2+  B107 21 C8 00         ld hl,200 ; pitch.
  3+  B10A 11 3E 00         ld de,62 ; duration.
  4+  B10D CD B5 03         call 949 ; ROM beeper routine.
  5+  B110 C9               ret
  6+  B111
  7+  B111              sound_pitchbend:
  8+  B111 21 F4 01         ld hl,500 ; starting pitch.
  9+  B114 06 FA            ld b,250 ; length of pitch bend.
 10+  B116              sound_pitchbend0:
 11+  B116 C5                push bc
 12+  B117 E5               push hl ; store pitch.
 13+  B118 11 01 00         ld de,1 ; very short duration.
 14+  B11B CD B5 03         call 949 ; ROM beeper routine.
 15+  B11E E1               pop hl ; restore pitch.
 16+  B11F 23               inc hl ; pitch going up.
 17+  B120 C1               pop bc
 18+  B121 10 F3            djnz sound_pitchbend0 ; repeat.
 19+  B123 C9               ret
 20+  B124
 21+  B124              sound_rockfell:
 22+  B124 08               ex af,af'
 23+  B125 1E 32            ld e,50 ; repeat 250 times.
 24+  B127 21 00 00         ld hl,0 ; start pointer in ROM.
 25+  B12A D5           sound_rockfell2 push de
 26+  B12B 06 20            ld b,32 ; length of step.
 27+  B12D C5           sound_rockfell0 push bc
 28+  B12E 7E               ld a,(hl) ; next "random" number.
 29+  B12F 23               inc hl ; pointer.
 30+  B130 E6 F8            and 248 ; we want a black border.
 31+  B132 D3 FE            out (254),a ; write to speaker.
 32+  B134 7B               ld a,e ; as e gets smaller...
 33+  B135 2F               cpl ; ...we increase the delay.
 34+  B136 3D           sound_rockfell1 dec a ; decrement loop counter.
 35+  B137 20 FD            jr nz,sound_rockfell1 ; delay loop.
 36+  B139 C1               pop bc
 37+  B13A 10 F1            djnz sound_rockfell0 ; next step.
 38+  B13C D1               pop de
 39+  B13D 7B               ld a,e
 40+  B13E D6 18            sub 24 ; size of step.
 41+  B140 FE 1E            cp 30 ; end of range.
 42+  B142 CA 53 B1         jp z,sound_rockfell5
 43+  B145 DA 53 B1         jp c, sound_rockfell5
 44+  B148 5F               ld e,a
 45+  B149 2F               cpl
 46+  B14A 06 28        sound_rockfell3 ld b,40 ; silent period.
 47+  B14C 10 FE        sound_rockfell4 djnz sound_rockfell4
 48+  B14E 3D               dec a
 49+  B14F 20 F9            jr nz,sound_rockfell3
 50+  B151 18 D7            jr sound_rockfell2
 51+  B153              sound_rockfell5
 52+  B153 08               ex af,af'
 53+  B154 C9               ret
 54+  B155
# file closed: sound/sound.asm
147   B155
148   B155                  include "leveldata\level.asm"
# file opened: leveldata/level.asm
  1+  B155              ; ###############################################################
  2+  B155              ; Data for level 1
  3+  B155              ; ###############################################################
  4+  B155              level_layout:
  5+  B155
  6+  B155                  ;defb 09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09,09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09
  7+  B155
  8+  B155 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,05,05,02,01,01,01,03,05,05,05,05,05,05,05,05,05,05,05,00,00
  8+  B159 05 05 05 05
  8+  B15D 05 05 05 05
  8+  B161 05 05 02 01
  8+  B165 01 01 03 05
  8+  B169 05 05 05 05
  8+  B16D 05 05 05 05
  8+  B171 05 05 00 00
  9+  B175 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,03,05,05,05,05,05,05,05,05,05,00,00
  9+  B179 05 05 05 05
  9+  B17D 05 05 05 05
  9+  B181 02 01 01 01
  9+  B185 01 01 01 01
  9+  B189 03 05 05 05
  9+  B18D 05 05 05 05
  9+  B191 05 05 00 00
 10+  B195 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,01,01,01,01,03,05,13,13,13,13,13,13,00,00
 10+  B199 05 05 05 05
 10+  B19D 05 05 02 01
 10+  B1A1 01 01 01 01
 10+  B1A5 01 01 01 01
 10+  B1A9 01 01 03 05
 10+  B1AD 0D 0D 0D 0D
 10+  B1B1 0D 0D 00 00
 11+  B1B5 00 00 01 01      defb 00,00,01,01,01,01,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,03,05,05,05,05,05,05,00,00
 11+  B1B9 01 01 00 01
 11+  B1BD 01 01 01 01
 11+  B1C1 01 01 01 01
 11+  B1C5 01 01 01 01
 11+  B1C9 01 01 01 03
 11+  B1CD 05 05 05 05
 11+  B1D1 05 05 00 00
 12+  B1D5 00 00 01 01      defb 00,00,01,01,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,01,00,00
 12+  B1D9 04 04 04 04
 12+  B1DD 04 04 01 01
 12+  B1E1 01 01 01 01
 12+  B1E5 01 01 01 01
 12+  B1E9 01 01 01 01
 12+  B1ED 01 01 01 01
 12+  B1F1 00 01 00 00
 13+  B1F5 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,01,00,00
 13+  B1F9 04 04 04 04
 13+  B1FD 04 04 04 04
 13+  B201 01 01 01 01
 13+  B205 01 01 01 01
 13+  B209 01 01 01 01
 13+  B20D 00 00 00 00
 13+  B211 00 01 00 00
 14+  B215 00 00 01 04      defb 00,00,01,04,04,01,01,01,01,01,04,04,04,04,01,01,01,01,01,01,01,00,00,00,00,01,01,01,01,01,00,00
 14+  B219 04 01 01 01
 14+  B21D 01 01 04 04
 14+  B221 04 04 01 01
 14+  B225 01 01 01 01
 14+  B229 01 00 00 00
 14+  B22D 00 01 01 01
 14+  B231 01 01 00 00
 15+  B235 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,01,04,04,04,04,04,04,04,04,00,00,00,00,04,04,04,04,04,04,04,01,00,00
 15+  B239 04 04 04 04
 15+  B23D 04 01 04 04
 15+  B241 04 04 04 04
 15+  B245 04 04 00 00
 15+  B249 00 00 04 04
 15+  B24D 04 04 04 04
 15+  B251 04 01 00 00
 16+  B255 00 00 01 01      defb 00,00,01,01,01,04,01,01,01,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 16+  B259 01 04 01 01
 16+  B25D 01 01 04 04
 16+  B261 04 04 04 04
 16+  B265 04 04 00 04
 16+  B269 04 04 04 04
 16+  B26D 04 04 04 04
 16+  B271 04 01 00 00
 17+  B275 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 17+  B279 00 00 00 00
 17+  B27D 00 04 04 04
 17+  B281 04 04 04 04
 17+  B285 04 04 00 04
 17+  B289 04 04 04 04
 17+  B28D 04 04 04 04
 17+  B291 04 01 00 00
 18+  B295 00 00 01 15      defb 00,00,01,21,21,21,21,21,21,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 18+  B299 15 15 15 15
 18+  B29D 15 01 04 04
 18+  B2A1 04 04 04 04
 18+  B2A5 04 04 00 04
 18+  B2A9 04 04 04 04
 18+  B2AD 04 04 04 04
 18+  B2B1 04 01 00 00
 19+  B2B5 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,00,00,00,01,00,00
 19+  B2B9 00 00 00 00
 19+  B2BD 00 01 04 04
 19+  B2C1 04 04 04 04
 19+  B2C5 04 04 00 04
 19+  B2C9 04 04 04 04
 19+  B2CD 04 00 00 00
 19+  B2D1 00 01 00 00
 20+  B2D5 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 20+  B2D9 00 00 00 00
 20+  B2DD 00 01 04 04
 20+  B2E1 04 04 04 04
 20+  B2E5 04 04 00 04
 20+  B2E9 04 04 04 04
 20+  B2ED 04 00 04 04
 20+  B2F1 00 01 00 00
 21+  B2F5 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 21+  B2F9 06 06 06 06
 21+  B2FD 06 01 04 04
 21+  B301 04 04 04 04
 21+  B305 04 04 00 04
 21+  B309 04 04 04 04
 21+  B30D 04 00 04 04
 21+  B311 00 01 00 00
 22+  B315 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,04,00,01,00,00
 22+  B319 1A 1A 1A 1A
 22+  B31D 1A 01 04 00
 22+  B321 00 00 00 00
 22+  B325 00 00 00 00
 22+  B329 00 00 00 00
 22+  B32D 00 00 04 04
 22+  B331 00 01 00 00
 23+  B335 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 23+  B339 1A 1A 1A 1A
 23+  B33D 1A 01 04 00
 23+  B341 04 04 04 04
 23+  B345 04 04 00 04
 23+  B349 04 04 00 04
 23+  B34D 04 04 04 04
 23+  B351 00 01 00 00
 24+  B355 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 24+  B359 1A 1A 1A 1A
 24+  B35D 1A 01 04 00
 24+  B361 04 04 04 04
 24+  B365 04 04 00 04
 24+  B369 04 04 00 04
 24+  B36D 04 04 04 04
 24+  B371 00 01 00 00
 25+  B375 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 25+  B379 01 01 01 01
 25+  B37D 01 01 04 00
 25+  B381 04 04 04 04
 25+  B385 04 04 00 04
 25+  B389 04 04 00 04
 25+  B38D 04 04 04 04
 25+  B391 00 01 00 00
 26+  B395 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,00,00,00,00,04,04,04,01,00,00
 26+  B399 04 04 04 04
 26+  B39D 04 04 04 00
 26+  B3A1 04 04 04 04
 26+  B3A5 04 04 00 04
 26+  B3A9 04 04 00 00
 26+  B3AD 00 00 04 04
 26+  B3B1 04 01 00 00
 27+  B3B5 00 00 01 04      defb 00,00,01,04,04,04,00,00,00,00,00,00,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 27+  B3B9 04 04 00 00
 27+  B3BD 00 00 00 00
 27+  B3C1 04 04 04 04
 27+  B3C5 04 04 00 04
 27+  B3C9 04 04 04 04
 27+  B3CD 04 00 04 04
 27+  B3D1 04 01 00 00
 28+  B3D5 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 28+  B3D9 04 04 00 04
 28+  B3DD 04 04 04 04
 28+  B3E1 04 04 04 04
 28+  B3E5 04 04 00 04
 28+  B3E9 04 04 04 04
 28+  B3ED 04 00 04 04
 28+  B3F1 04 01 00 00
 29+  B3F5 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,04,00,04,04,04,01,00,00
 29+  B3F9 04 04 00 04
 29+  B3FD 04 04 01 01
 29+  B401 01 01 01 01
 29+  B405 01 01 01 01
 29+  B409 01 01 01 01
 29+  B40D 04 00 04 04
 29+  B411 04 01 00 00
 30+  B415 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 30+  B419 04 04 00 04
 30+  B41D 04 04 01 00
 30+  B421 00 00 00 00
 30+  B425 00 00 00 00
 30+  B429 00 00 00 01
 30+  B42D 04 00 04 04
 30+  B431 04 01 00 00
 31+  B435 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 31+  B439 04 04 00 04
 31+  B43D 04 04 01 00
 31+  B441 00 00 00 00
 31+  B445 00 00 00 00
 31+  B449 00 00 00 01
 31+  B44D 04 00 04 04
 31+  B451 04 01 00 00
 32+  B455 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 32+  B459 04 04 00 04
 32+  B45D 04 04 01 00
 32+  B461 00 00 00 00
 32+  B465 00 00 00 00
 32+  B469 00 00 00 01
 32+  B46D 04 00 04 04
 32+  B471 04 01 00 00
 33+  B475 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,00,00,00,00,00,00,00,00,00,00,00,00,04,04,04,04,04,04,01,00,00
 33+  B479 04 04 00 04
 33+  B47D 04 04 04 00
 33+  B481 00 00 00 00
 33+  B485 00 00 00 00
 33+  B489 00 00 00 04
 33+  B48D 04 04 04 04
 33+  B491 04 01 00 00
 34+  B495 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,04,04,04,04,01,00,00
 34+  B499 04 04 04 04
 34+  B49D 04 04 01 00
 34+  B4A1 00 00 00 00
 34+  B4A5 00 00 00 00
 34+  B4A9 00 00 00 01
 34+  B4AD 04 04 04 04
 34+  B4B1 04 01 00 00
 35+  B4B5 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,01,00,00,00,00,01,00,00,00,01,04,04,04,04,04,01,00,00
 35+  B4B9 04 04 04 04
 35+  B4BD 04 04 01 00
 35+  B4C1 00 00 01 00
 35+  B4C5 00 00 00 01
 35+  B4C9 00 00 00 01
 35+  B4CD 04 04 04 04
 35+  B4D1 04 01 00 00
 36+  B4D5 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00
 36+  B4D9 01 01 01 01
 36+  B4DD 01 01 01 01
 36+  B4E1 01 01 01 01
 36+  B4E5 01 01 01 01
 36+  B4E9 01 01 01 01
 36+  B4ED 01 01 01 01
 36+  B4F1 01 01 00 00
 37+  B4F5
 38+  B4F5              ; ###############################################################
 39+  B4F5              ; Object data: horiz, vert, state, memh, meml
 40+  B4F5              ; ###############################################################
 41+  B4F5              level_rocks:
 42+  B4F5 09 04 00 00      defb 9,4,0,0,0
 42+  B4F9 00
 43+  B4FA 0C 07 00 00      defb 12,7,0,0,0
 43+  B4FE 00
 44+  B4FF 10 07 00 00      defb 16,7,0,0,0
 44+  B503 00
 45+  B504 0B 08 00 00      defb 11,8,0,0,0
 45+  B508 00
 46+  B509 0A 0A 00 00      defb 10,10,0,0,0
 46+  B50D 00
 47+  B50E 0C 0A 00 00      defb 12,10,0,0,0
 47+  B512 00
 48+  B513 0D 09 00 00      defb 13,9,0,0,0
 48+  B517 00
 49+  B518 0E 08 00 00      defb 14,8,0,0,0
 49+  B51C 00
 50+  B51D 0F 0B 00 00      defb 15,11,0,0,0
 50+  B521 00
 51+  B522 0B 0C 00 00      defb 11,12,0,0,0
 51+  B526 00
 52+  B527 11 0C 00 00      defb 17,12,0,0,0
 52+  B52B 00
 53+  B52C 13 08 00 00      defb 19,8,0,0,0
 53+  B530 00
 54+  B531 16 09 00 00      defb 22,9,0,0,0
 54+  B535 00
 55+  B536 13 0A 00 00      defb 19,10,0,0,0
 55+  B53A 00
 56+  B53B 15 0A 00 00      defb 21,10,0,0,0
 56+  B53F 00
 57+  B540 15 0C 00 00      defb 21,12,0,0,0
 57+  B544 00
 58+  B545 16 0C 00 00      defb 22,12,0,0,0
 58+  B549 00
 59+  B54A 18 0A 00 00      defb 24,10,0,0,0
 59+  B54E 00
 60+  B54F 19 09 00 00      defb 25,9,0,0,0
 60+  B553 00
 61+  B554 1C 09 00 00      defb 28,9,0,0,0
 61+  B558 00
 62+  B559 1B 0C 00 00      defb 27,12,0,0,0
 62+  B55D 00
 63+  B55E 1A 0D 00 00      defb 26,13,0,0,0
 63+  B562 00
 64+  B563 19 0E 00 00      defb 25,14,0,0,0
 64+  B567 00
 65+  B568 19 10 00 00      defb 25,16,0,0,0
 65+  B56C 00
 66+  B56D 1A 11 00 00      defb 26,17,0,0,0
 66+  B571 00
 67+  B572 1B 11 00 00      defb 27,17,0,0,0
 67+  B576 00
 68+  B577 1C 12 00 00      defb 28,18,0,0,0
 68+  B57B 00
 69+  B57C 1A 13 00 00      defb 26,19,0,0,0
 69+  B580 00
 70+  B581 1B 15 00 00      defb 27,21,0,0,0
 70+  B585 00
 71+  B586 1A 17 00 00      defb 26,23,0,0,0
 71+  B58A 00
 72+  B58B 1B 18 00 00      defb 27,24,0,0,0
 72+  B58F 00
 73+  B590 19 18 00 00      defb 25,24,0,0,0
 73+  B594 00
 74+  B595 18 17 00 00      defb 24,23,0,0,0
 74+  B599 00
 75+  B59A 13 14 00 00      defb 19,20,0,0,0
 75+  B59E 00
 76+  B59F 14 12 00 00      defb 20,18,0,0,0
 76+  B5A3 00
 77+  B5A4 14 10 00 00      defb 20,16,0,0,0
 77+  B5A8 00
 78+  B5A9 15 10 00 00      defb 21,16,0,0,0
 78+  B5AD 00
 79+  B5AE 16 12 00 00      defb 22,18,0,0,0
 79+  B5B2 00
 80+  B5B3 11 14 00 00      defb 17,20,0,0,0
 80+  B5B7 00
 81+  B5B8 0D 11 00 00      defb 13,17,0,0,0
 81+  B5BC 00
 82+  B5BD 0C 13 00 00      defb 12,19,0,0,0
 82+  B5C1 00
 83+  B5C2 0B 13 00 00      defb 11,19,0,0,0
 83+  B5C6 00
 84+  B5C7 0A 11 00 00      defb 10,17,0,0,0
 84+  B5CB 00
 85+  B5CC 05 12 00 00      defb 5,18,0,0,0
 85+  B5D0 00
 86+  B5D1 07 16 00 00      defb 7,22,0,0,0
 86+  B5D5 00
 87+  B5D6 09 16 00 00      defb 9,22,0,0,0
 87+  B5DA 00
 88+  B5DB 07 18 00 00      defb 7,24,0,0,0
 88+  B5DF 00
 89+  B5E0 05 18 00 00      defb 5,24,0,0,0
 89+  B5E4 00
 90+  B5E5 06 19 00 00      defb 6,25,0,0,0
 90+  B5E9 00
 91+  B5EA 08 19 00 00      defb 8,25,0,0,0
 91+  B5EE 00
 92+  B5EF 04 17 00 00      defb 4,23,0,0,0
 92+  B5F3 00
 93+  B5F4 FF               defb 255
 94+  B5F5
 95+  B5F5              level_rocks_alt:
 96+  B5F5 09 04 00 00      defb 9,4,0,0,0
 96+  B5F9 00
 97+  B5FA 0C 07 00 00      defb 12,7,0,0,0
 97+  B5FE 00
 98+  B5FF 0B 07 00 00      defb 11,7,0,0,0
 98+  B603 00
 99+  B604 0A 08 00 00      defb 10,8,0,0,0
 99+  B608 00
100+  B609 10 07 00 00      defb 16,7,0,0,0
100+  B60D 00
101+  B60E 0E 08 00 00      defb 14,8,0,0,0
101+  B612 00
102+  B613 0D 09 00 00      defb 13,9,0,0,0
102+  B617 00
103+  B618 0C 0A 00 00      defb 12,10,0,0,0
103+  B61C 00
104+  B61D 0A 0B 00 00      defb 10,11,0,0,0
104+  B621 00
105+  B622 0B 0C 00 00      defb 11,12,0,0,0
105+  B626 00
106+  B627 0F 0B 00 00      defb 15,11,0,0,0
106+  B62B 00
107+  B62C 11 0C 00 00      defb 17,12,0,0,0
107+  B630 00
108+  B631 15 0B 00 00      defb 21,11,0,0,0
108+  B635 00
109+  B636 16 0C 00 00      defb 22,12,0,0,0
109+  B63A 00
110+  B63B 19 09 00 00      defb 25,9,0,0,0
110+  B63F 00
111+  B640 1C 09 00 00      defb 28,9,0,0,0
111+  B644 00
112+  B645 1B 0C 00 00      defb 27,12,0,0,0
112+  B649 00
113+  B64A 1B 0E 00 00      defb 27,14,0,0,0
113+  B64E 00
114+  B64F 1A 0F 00 00      defb 26,15,0,0,0
114+  B653 00
115+  B654 1B 10 00 00      defb 27,16,0,0,0
115+  B658 00
116+  B659 1C 12 00 00      defb 28,18,0,0,0
116+  B65D 00
117+  B65E 1A 13 00 00      defb 26,19,0,0,0
117+  B662 00
118+  B663 1A 15 00 00      defb 26,21,0,0,0
118+  B667 00
119+  B668 1B 17 00 00      defb 27,23,0,0,0
119+  B66C 00
120+  B66D 1A 17 00 00      defb 26,23,0,0,0
120+  B671 00
121+  B672 19 18 00 00      defb 25,24,0,0,0
121+  B676 00
122+  B677 18 17 00 00      defb 24,23,0,0,0
122+  B67B 00
123+  B67C 17 10 00 00      defb 23,16,0,0,0
123+  B680 00
124+  B681 15 10 00 00      defb 21,16,0,0,0
124+  B685 00
125+  B686 14 12 00 00      defb 20,18,0,0,0
125+  B68A 00
126+  B68B 13 14 00 00      defb 19,20,0,0,0
126+  B68F 00
127+  B690 10 13 00 00      defb 16,19,0,0,0
127+  B694 00
128+  B695 0D 14 00 00      defb 13,20,0,0,0
128+  B699 00
129+  B69A 0E 11 00 00      defb 14,17,0,0,0
129+  B69E 00
130+  B69F 0C 12 00 00      defb 12,18,0,0,0
130+  B6A3 00
131+  B6A4 0A 11 00 00      defb 10,17,0,0,0
131+  B6A8 00
132+  B6A9 05 12 00 00      defb 5,18,0,0,0
132+  B6AD 00
133+  B6AE 09 14 00 00      defb 9,20,0,0,0
133+  B6B2 00
134+  B6B3 08 15 00 00      defb 8,21,0,0,0
134+  B6B7 00
135+  B6B8 07 16 00 00      defb 7,22,0,0,0
135+  B6BC 00
136+  B6BD 08 17 00 00      defb 8,23,0,0,0
136+  B6C1 00
137+  B6C2 07 18 00 00      defb 7,24,0,0,0
137+  B6C6 00
138+  B6C7 08 1A 00 00      defb 8,26,0,0,0
138+  B6CB 00
139+  B6CC 06 19 00 00      defb 6,25,0,0,0
139+  B6D0 00
140+  B6D1 05 18 00 00      defb 5,24,0,0,0
140+  B6D5 00
141+  B6D6 04 17 00 00      defb 4,23,0,0,0
141+  B6DA 00
142+  B6DB FF               defb 255
143+  B6DC
144+  B6DC              level_missiles:
145+  B6DC 0B 17 00 00      defb 11,23,0,0,0
145+  B6E0 00
146+  B6E1 0B 16 00 00      defb 11,22,0,0,0
146+  B6E5 00
147+  B6E6 0C 17 00 00      defb 12,23,0,0,0
147+  B6EA 00
148+  B6EB 0C 16 00 00      defb 12,22,0,0,0
148+  B6EF 00
149+  B6F0 0D 17 00 00      defb 13,23,0,0,0
149+  B6F4 00
150+  B6F5 0D 16 00 00      defb 13,22,0,0,0
150+  B6F9 00
151+  B6FA 0E 17 00 00      defb 14,23,0,0,0
151+  B6FE 00
152+  B6FF 0E 16 00 00      defb 14,22,0,0,0
152+  B703 00
153+  B704 0F 17 00 00      defb 15,23,0,0,0
153+  B708 00
154+  B709 0F 16 00 00      defb 15,22,0,0,0
154+  B70D 00
155+  B70E 10 17 00 00      defb 16,23,0,0,0
155+  B712 00
156+  B713 10 16 00 00      defb 16,22,0,0,0
156+  B717 00
157+  B718 11 17 00 00      defb 17,23,0,0,0
157+  B71C 00
158+  B71D 11 16 00 00      defb 17,22,0,0,0
158+  B721 00
159+  B722 12 17 00 00      defb 18,23,0,0,0
159+  B726 00
160+  B727 12 16 00 00      defb 18,22,0,0,0
160+  B72B 00
161+  B72C 13 17 00 00      defb 19,23,0,0,0
161+  B730 00
162+  B731 13 16 00 00      defb 19,22,0,0,0
162+  B735 00
163+  B736 14 17 00 00      defb 20,23,0,0,0
163+  B73A 00
164+  B73B 14 16 00 00      defb 20,22,0,0,0
164+  B73F 00
165+  B740 15 17 00 00      defb 21,23,0,0,0
165+  B744 00
166+  B745 15 16 00 00      defb 21,22,0,0,0
166+  B749 00
167+  B74A 16 17 00 00      defb 22,23,0,0,0
167+  B74E 00
168+  B74F 16 16 00 00      defb 22,22,0,0,0
168+  B753 00
169+  B754 FF               defb 255
170+  B755
171+  B755              ;
172+  B755              ; Diamonds: x,y,state,mem1+mem2
173+  B755              ;
174+  B755              level_diamonds:
175+  B755 0C 1B 00 00      defb 12,27,0,0,0
175+  B759 00
176+  B75A 10 1B 00 00      defb 16,27,0,0,0
176+  B75E 00
177+  B75F 15 1B 00 00      defb 21,27,0,0,0
177+  B763 00
178+  B764 FF               defb 255
179+  B765
180+  B765              level_gems:
181+  B765 12 14 00 00      defb 18,20,0,0,0
181+  B769 00
182+  B76A 06 18 00 00      defb 6,24,0,0,0
182+  B76E 00
183+  B76F 19 17 00 00      defb 25,23,0,0,0
183+  B773 00
184+  B774 1C 11 00 00      defb 28,17,0,0,0
184+  B778 00
185+  B779 FF               defb 255
186+  B77A              ;
187+  B77A              ; Score area colours
188+  B77A              ;
189+  B77A              score_colours:
190+  B77A 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,67,67,67,67,67,67,67,67,66,71,71,71,71,71,71,71,71,71,71,71
190+  B77E 47 47 47 47
190+  B782 47 47 47 42
190+  B786 43 43 43 43
190+  B78A 43 43 43 43
190+  B78E 42 47 47 47
190+  B792 47 47 47 47
190+  B796 47 47 47 47
191+  B79A 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71
191+  B79E 47 47 47 47
191+  B7A2 47 47 47 46
191+  B7A6 46 46 46 46
191+  B7AA 46 46 46 46
191+  B7AE 46 47 47 47
191+  B7B2 47 47 47 47
191+  B7B6 47 47 47 47
192+  B7BA
193+  B7BA              high_score_colours:
194+  B7BA 00 00 00 42      defb  0, 0, 0,66,66,66,71,71,71,71,71,71,67,67,67,71,71,71,71,71,71,70,70,70,71,71,71,71,71,71,0,0
194+  B7BE 42 42 47 47
194+  B7C2 47 47 47 47
194+  B7C6 43 43 43 47
194+  B7CA 47 47 47 47
194+  B7CE 47 46 46 46
194+  B7D2 47 47 47 47
194+  B7D6 47 47 00 00
# file closed: leveldata/level.asm
149   B7DA                  include "graphics\font.asm"
# file opened: graphics/font.asm
  1+  B7DA              font:
  2+  B7DA 00 00 00...  	defs 256
  3+  B8DA              	; end 1
  4+  B8DA 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; space
  4+  B8DE 00 00 00 00
  5+  B8E2 18 18 18 18  	defb	  24, 24, 24, 24, 24,  0, 24, 0 ;!
  5+  B8E6 18 00 18 00
  6+  B8EA 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; "
  6+  B8EE 00 00 00 00
  7+  B8F2 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; #
  7+  B8F6 00 00 00 00
  8+  B8FA 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; $
  8+  B8FE 00 00 00 00
  9+  B902 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; %
  9+  B906 00 00 00 00
 10+  B90A 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; &
 10+  B90E 00 00 00 00
 11+  B912 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; '
 11+  B916 00 00 00 00
 12+  B91A 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; (
 12+  B91E 00 00 00 00
 13+  B922 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; )
 13+  B926 00 00 00 00
 14+  B92A 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; *
 14+  B92E 00 00 00 00
 15+  B932 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; +
 15+  B936 00 00 00 00
 16+  B93A 00 00 00 00  	defb	  0,  0,  0,  0,  0,  8, 24,  0 ; ,
 16+  B93E 00 08 18 00
 17+  B942 00 00 00 3C  	defb	  0,  0,  0, 60,  0,  0,  0,  0 ; -
 17+  B946 00 00 00 00
 18+  B94A 00 00 00 00  	defb	  0,  0,  0,  0,  0,  24,24,  0 ; .
 18+  B94E 00 18 18 00
 19+  B952 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; /
 19+  B956 00 00 00 00
 20+  B95A 1C 26 63 63  	defb	 28, 38, 99, 99, 99, 50, 28,  0 ; 0
 20+  B95E 63 32 1C 00
 21+  B962 0C 1C 0C 0C  	defb	   12, 28, 12, 12, 12, 12, 63,0 ; 1
 21+  B966 0C 0C 3F 00
 22+  B96A 3E 63 07 1E  	defb	  62, 99,  7, 30, 60, 96,127, 0 ; 2
 22+  B96E 3C 60 7F 00
 23+  B972 3F 06 0C 1E  	defb	  63,  6, 12, 30,  3, 51, 30, 0 ; 3
 23+  B976 03 33 1E 00
 24+  B97A 0E 1E 36 66  	defb	  14, 30, 54,102,127,  6,  6, 0 ; 4
 24+  B97E 7F 06 06 00
 25+  B982 7E 40 7E 03  	defb	 126, 64,126,  3,  3, 99, 62, 0 ; 5
 25+  B986 03 63 3E 00
 26+  B98A 1E 30 60 7E  	defb	 30, 48, 96,126, 99, 99, 62,  0 ; 6
 26+  B98E 63 63 3E 00
 27+  B992 7F 63 06 0C  	defb	  127, 99,  6, 12, 24, 24, 24,0 ; 7
 27+  B996 18 18 18 00
 28+  B99A 3C 62 72 3C  	defb	  60, 98,114, 60, 79, 67,62,0   ; 8
 28+  B99E 4F 43 3E 00
 29+  B9A2 3E 63 63 3F  	defb	  62, 99, 99, 63,  3,  6, 60, 0 ; 9
 29+  B9A6 03 06 3C 00
 30+  B9AA 00 00 18 18  	defb	  0,  0, 24, 24,  0,  24,24,  0 ; :
 30+  B9AE 00 18 18 00
 31+  B9B2 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ;
 31+  B9B6 00 00 00 00
 32+  B9BA 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; <
 32+  B9BE 00 00 00 00
 33+  B9C2 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; =
 33+  B9C6 00 00 00 00
 34+  B9CA 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; >
 34+  B9CE 00 00 00 00
 35+  B9D2 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ?
 35+  B9D6 00 00 00 00
 36+  B9DA              	; end 2
 37+  B9DA 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; @
 37+  B9DE 00 00 00 00
 38+  B9E2 1C 36 63 63  	defb	  28, 54, 99, 99,127, 99, 99, 0 ; A
 38+  B9E6 7F 63 63 00
 39+  B9EA 7E 63 63 7E  	defb	  126, 99, 99,126, 99, 99,126,0 ; B
 39+  B9EE 63 63 7E 00
 40+  B9F2 1E 33 60 60  	defb	  30, 51, 96, 96, 96, 51, 30, 0 ; C
 40+  B9F6 60 33 1E 00
 41+  B9FA 7C 66 63 63  	defb	  124,102, 99, 99, 99,102,124,0 ; D
 41+  B9FE 63 66 7C 00
 42+  BA02 7F 60 60 7E  	defb	  127, 96, 96,126, 96, 96,127,0 ; E
 42+  BA06 60 60 7F 00
 43+  BA0A 7F 60 60 7E  	defb	  127, 96, 96,126, 96, 96, 96,0 ; F
 43+  BA0E 60 60 60 00
 44+  BA12 1F 30 60 67  	defb	  31, 48, 96,103, 99, 51, 31, 0 ; G
 44+  BA16 63 33 1F 00
 45+  BA1A 63 63 63 7F  	defb	  99, 99, 99,127, 99, 99, 99, 0 ; H
 45+  BA1E 63 63 63 00
 46+  BA22 3F 0C 0C 0C  	defb	  63, 12, 12, 12, 12, 12, 63, 0 ; I
 46+  BA26 0C 0C 3F 00
 47+  BA2A 03 03 03 03  	defb	  3,  3,  3,  3,  3, 99, 62,  0 ; J
 47+  BA2E 03 63 3E 00
 48+  BA32 63 66 6C 78  	defb	  99,102,108,120,124,110,103, 0 ; K
 48+  BA36 7C 6E 67 00
 49+  BA3A 30 30 30 30  	defb	  48, 48, 48, 48, 48, 48, 63, 0 ; L
 49+  BA3E 30 30 3F 00
 50+  BA42 63 77 7F 7F  	defb	  99,119,127,127,107, 99, 99, 0 ; M
 50+  BA46 6B 63 63 00
 51+  BA4A 63 73 7B 7F  	defb	  99,115,123,127,111,103, 99, 0 ; N
 51+  BA4E 6F 67 63 00
 52+  BA52 3E 63 63 63  	defb	  62, 99, 99, 99, 99, 99, 62, 0 ; O
 52+  BA56 63 63 3E 00
 53+  BA5A 7E 61 61 61  	defb	  126, 97, 97, 97,126, 96, 96,0 ; P
 53+  BA5E 7E 60 60 00
 54+  BA62 3E 63 63 63  	defb	  62, 99, 99, 99,111,102, 61, 0 ; Q
 54+  BA66 6F 66 3D 00
 55+  BA6A 7E 63 63 67  	defb	  126, 99, 99,103,124,110,103,0 ; R
 55+  BA6E 7C 6E 67 00
 56+  BA72 3C 66 60 3E  	defb	  60,102, 96, 62,  3, 99, 62, 0 ; S
 56+  BA76 03 63 3E 00
 57+  BA7A 7E 18 18 18  	defb	  126, 24, 24, 24, 24, 24, 24,0 ; T
 57+  BA7E 18 18 18 00
 58+  BA82 63 63 63 63  	defb	  99, 99, 99, 99, 99, 99, 62, 0 ; U
 58+  BA86 63 63 3E 00
 59+  BA8A 63 63 63 77  	defb	  99, 99, 99,119, 62, 28,  8, 0 ; V
 59+  BA8E 3E 1C 08 00
 60+  BA92 63 63 6B 7F  	defb	  99, 99,107,127,127, 54, 34, 0 ; W
 60+  BA96 7F 36 22 00
 61+  BA9A 63 77 3E 1C  	defb	  99,119, 62, 28, 62,119, 99, 0 ; X
 61+  BA9E 3E 77 63 00
 62+  BAA2 33 33 12 1E  	defb	  51, 51, 18, 30, 12, 12, 12, 0 ; Y
 62+  BAA6 0C 0C 0C 00
 63+  BAAA 7F 07 0E 1C  	defb	  127,  7, 14, 28, 56,112,127,0 ; Z
 63+  BAAE 38 70 7F 00
 64+  BAB2 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; [
 64+  BAB6 00 00 00 00
 65+  BABA 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; \
 65+  BABE 00 00 00 00
 66+  BAC2 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ]
 66+  BAC6 00 00 00 00
 67+  BACA 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ^
 67+  BACE 00 00 00 00
 68+  BAD2 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; _
 68+  BAD6 00 00 00 00
 69+  BADA              	; end 3
 70+  BADA 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; 
 70+  BADE 00 00 00 00
 71+  BAE2 1C 36 63 63  	defb	  28, 54, 99, 99,127, 99, 99, 0 ; A
 71+  BAE6 7F 63 63 00
 72+  BAEA 7E 63 63 7E  	defb	  126, 99, 99,126, 99, 99,126,0 ; B
 72+  BAEE 63 63 7E 00
 73+  BAF2 1E 33 60 60  	defb	  30, 51, 96, 96, 96, 51, 30, 0 ; C
 73+  BAF6 60 33 1E 00
 74+  BAFA 7C 66 63 63  	defb	  124,102, 99, 99, 99,102,124,0 ; D
 74+  BAFE 63 66 7C 00
 75+  BB02 7F 60 60 7E  	defb	  127, 96, 96,126, 96, 96,127,0 ; E
 75+  BB06 60 60 7F 00
 76+  BB0A 7F 60 60 7E  	defb	  127, 96, 96,126, 96, 96, 96,0 ; F
 76+  BB0E 60 60 60 00
 77+  BB12 1F 30 60 67  	defb	  31, 48, 96,103, 99, 51, 31, 0 ; G
 77+  BB16 63 33 1F 00
 78+  BB1A 63 63 63 7F  	defb	  99, 99, 99,127, 99, 99, 99, 0 ; H
 78+  BB1E 63 63 63 00
 79+  BB22 3F 0C 0C 0C  	defb	  63, 12, 12, 12, 12, 12, 63, 0 ; I
 79+  BB26 0C 0C 3F 00
 80+  BB2A 03 03 03 03  	defb	  3,  3,  3,  3,  3, 99, 62,  0 ; J
 80+  BB2E 03 63 3E 00
 81+  BB32 63 66 6C 78  	defb	  99,102,108,120,124,110,103, 0 ; K
 81+  BB36 7C 6E 67 00
 82+  BB3A 30 30 30 30  	defb	  48, 48, 48, 48, 48, 48, 63, 0 ; L
 82+  BB3E 30 30 3F 00
 83+  BB42 63 77 7F 7F  	defb	  99,119,127,127,107, 99, 99, 0 ; M
 83+  BB46 6B 63 63 00
 84+  BB4A 63 73 7B 7F  	defb	  99,115,123,127,111,103, 99, 0 ; N
 84+  BB4E 6F 67 63 00
 85+  BB52 3E 63 63 63  	defb	  62, 99, 99, 99, 99, 99, 62, 0 ; O
 85+  BB56 63 63 3E 00
 86+  BB5A 7E 61 61 61  	defb	  126, 97, 97, 97,126, 96, 96,0 ; P
 86+  BB5E 7E 60 60 00
 87+  BB62 3E 63 63 63  	defb	  62, 99, 99, 99,111,102, 61, 0 ; Q
 87+  BB66 6F 66 3D 00
 88+  BB6A 7E 63 63 67  	defb	  126, 99, 99,103,124,110,103,0 ; R
 88+  BB6E 7C 6E 67 00
 89+  BB72 3C 66 60 3E  	defb	  60,102, 96, 62,  3, 99, 62, 0 ; S
 89+  BB76 03 63 3E 00
 90+  BB7A 7E 18 18 18  	defb	  126, 24, 24, 24, 24, 24, 24,0 ; T
 90+  BB7E 18 18 18 00
 91+  BB82 63 63 63 63  	defb	  99, 99, 99, 99, 99, 99, 62, 0 ; U
 91+  BB86 63 63 3E 00
 92+  BB8A 63 63 63 77  	defb	  99, 99, 99,119, 62, 28,  8, 0 ; V
 92+  BB8E 3E 1C 08 00
 93+  BB92 63 63 6B 7F  	defb	  99, 99,107,127,127, 54, 34, 0 ; W
 93+  BB96 7F 36 22 00
 94+  BB9A 63 77 3E 1C  	defb	  99,119, 62, 28, 62,119, 99, 0 ; X
 94+  BB9E 3E 77 63 00
 95+  BBA2 33 33 12 1E  	defb	  51, 51, 18, 30, 12, 12, 12, 0 ; Y
 95+  BBA6 0C 0C 0C 00
 96+  BBAA 7F 07 0E 1C  	defb	  127,  7, 14, 28, 56,112,127,0 ; Z
 96+  BBAE 38 70 7F 00
 97+  BBB2 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0
 97+  BBB6 00 00 00 00
 98+  BBBA 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0
 98+  BBBE 00 00 00 00
 99+  BBC2 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0
 99+  BBC6 00 00 00 00
100+  BBCA 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0
100+  BBCE 00 00 00 00
101+  BBD2 3C 42 99 A1  	defb	  60, 66,153,161,161,153, 66, 60 ; 	
101+  BBD6 A1 99 42 3C
# file closed: graphics/font.asm
150   BBDA                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  BBDA              ; Tiles graphics.
  2+  BBDA              sprites:
  3+  BBDA 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  BBDE 00 00 00 00
  4+  BBE2 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  BBE6 FF FF FF FF
  5+  BBEA 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  BBEE 1F 3F 7F FF
  6+  BBF2 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  BBF6 F8 FC FE FF
  7+  BBFA 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  BBFE 55 AA 55 AA
  8+  BC02 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 5, sky block
  8+  BC06 00 00 00 00
  9+  BC0A 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 6, slime block
  9+  BC0E 00 00 00 00
 10+  BC12 00 00 00 00      defb    0  ,0  ,  0,  0,  0,  0,  0,  0   ; 7, for reuse
 10+  BC16 00 00 00 00
 11+  BC1A 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52,  24    ; 8, diamond
 11+  BC1E F1 72 34 18
 12+  BC22 3C 7E FF 7F      defb    60,126,255,127,254,254,255,126    ; 9, rock
 12+  BC26 FE FE FF 7E
 13+  BC2A 7E FF 7F 7F  	defb	126,255,127,127,254,255,126, 60    ; 10, rock 2
 13+  BC2E FE FF 7E 3C
 14+  BC32 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,255,255   ; 11, sky block, pixel trapdoor
 14+  BC36 00 00 FF FF
 15+  BC3A 99 DB 7E 24  	defb    153,219,126, 36,255, 66, 36, 24   ; 12, missile
 15+  BC3E FF 42 24 18
 16+  BC42 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 13, sky block, tank background
 16+  BC46 00 00 00 00
 17+  BC4A 00 00 00 00  	defb    0,  0,  0,  0,  0, 60, 90, 52     ; 14, gem
 17+  BC4E 00 3C 5A 34
 18+  BC52 FD FE FD FE  	defb	253,254,253,254,253,254,253,254   ; 15, damaged mountain
 18+  BC56 FD FE FD FE
 19+  BC5A F4 F8 F4 F8  	defb	244,248,244,248,244,248,244,248   ; 16, damaged mountain 2
 19+  BC5E F4 F8 F4 F8
 20+  BC62 D0 E0 D0 E0  	defb	208,224,208,224,208,224,208,224   ; 17, damaged mountain 3
 20+  BC66 D0 E0 D0 E0
 21+  BC6A 40 80 40 80  	defb	 64,128, 64,128, 64,128, 64,128   ; 18, damaged mountain 4
 21+  BC6E 40 80 40 80
 22+  BC72 00 00 00 ED  	defb	0,  0,  0,237,237,  0,  0,  0	  ; 19, tank missile
 22+  BC76 ED 00 00 00
 23+  BC7A 99 DB 7E 24  	defb    153,219,126, 36,255,126, 60, 24   ; 20, missile active
 23+  BC7E FF 7E 3C 18
 24+  BC82 FF FF 00 00      defb	255,255,  0,  0,  0,  0,  0,  0	  ; 21, the pit 1
 24+  BC86 00 00 00 00
 25+  BC8A FC FC 00 00  	defb	252,252,  0,  0,  0,  0,  0,  0	  ; 22, the pit 2
 25+  BC8E 00 00 00 00
 26+  BC92 F0 F0 00 00  	defb	240,240,  0,  0,  0,  0,  0,  0	  ; 23, the pit 3
 26+  BC96 00 00 00 00
 27+  BC9A C0 C0 00 00  	defb	192,192,  0,  0,  0,  0,  0,  0	  ; 24, the pit 4
 27+  BC9E 00 00 00 00
 28+  BCA2 00 00 00 00  	defb	0,0,  0,  0,  0,  0,  0,  0	  	  ; 25, the pit 5
 28+  BCA6 00 00 00 00
 29+  BCAA FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 26, slime block, green on green
 29+  BCAE FF FF FF FF
 30+  BCB2 00 00 00 66  	defb    0,  0,  0,102,  0,  0,  0,  0     ; 27, bullet
 30+  BCB6 00 00 00 00
 31+  BCBA
 32+  BCBA
 33+  BCBA              sprite_attrs:
 34+  BCBA 46               defb    070 ; 0, space
 35+  BCBB 4D               defb    077 ; 1, cyan block
 36+  BCBC 4D               defb    077 ; 2, slope left
 37+  BCBD 4D               defb    077 ; 3, slope right
 38+  BCBE 46               defb    070 ; 4, dirt
 39+  BCBF 4E               defb    078 ; 5, sky
 40+  BCC0 66               defb    102 ; 6, slime
 41+  BCC1 42               defb    066 ; 7, trapdoor
 42+  BCC2 46               defb    070 ; 8, diamond
 43+  BCC3 42               defb    066 ; 9, rock
 44+  BCC4 42               defb    066 ; 10, rock 2
 45+  BCC5 49           	defb    073 ; 11, sky, trapdoor
 46+  BCC6 43           	defb    067 ; 12, missile
 47+  BCC7 4A               defb    074 ; 13, sky, red ink (tank)
 48+  BCC8 46               defb    070 ; 14, gem
 49+  BCC9 4D               defb    077 ; 15, damaged mountain
 50+  BCCA 4D               defb    077 ; 16, damaged mountain 2
 51+  BCCB 4D               defb    077 ; 17, damaged mountain 3
 52+  BCCC 4D               defb    077 ; 18, damaged mountain 4
 53+  BCCD 00           	defb 	000 ; 19, tank missile (not used
 54+  BCCE 43           	defb    067 ; 20, missile active
 55+  BCCF 42           	defb	066	; 21, the pit 1
 56+  BCD0 42           	defb	066	; 22, the pit 2
 57+  BCD1 42           	defb	066	; 23, the pit 3
 58+  BCD2 42           	defb	066	; 24, the pit 4
 59+  BCD3 42           	defb	066	; 25, the pit 5
 60+  BCD4 64           	defb    100 ; 26, slime, green on green
 61+  BCD5 46           	defb 	070 ; 27, bullet
 62+  BCD6
 63+  BCD6
 64+  BCD6              player_sprite:
 65+  BCD6 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 0 up/down 1
 65+  BCDA 38 3D C3 80
 66+  BCDE 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 1 left 1
 66+  BCE2 3C 1C 16 32
 67+  BCE6 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 2 right 1
 67+  BCEA 3C 38 68 4C
 68+  BCEE 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 3 up/down 2
 68+  BCF2 1C BC C3 01
 69+  BCF6 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 60,100, 12; 4 left 2
 69+  BCFA 3C 3C 64 0C
 70+  BCFE 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 60, 38, 48 ; 5 right 2
 70+  BD02 3C 3C 26 30
 71+  BD06 54 28 10 12  	defb	 84, 40, 16, 18, 30, 92,253, 95 ; 6 shoot up
 71+  BD0A 1E 5C FD 5F
 72+  BD0E 02 87 42 BF  	defb	 2,135, 66,191, 79,143, 25,  3  ; 7 shoot left
 72+  BD12 4F 8F 19 03
 73+  BD16 40 E1 42 FD  	defb	 64,225, 66,253,242,241,152,192 ; 8 shoot right
 73+  BD1A F2 F1 98 C0
 74+  BD1E FA BF 3A 78  	defb	 250,191, 58,120, 72,  8, 20, 42 ; 9 shoot down
 74+  BD22 48 08 14 2A
 75+  BD26 92 BA 94 78  	defb 	 146,186,148,120, 56,120, 68,195 ; 10 crushed 1
 75+  BD2A 38 78 44 C3
 76+  BD2E 49 5D 29 1E  	defb	  73, 93, 41, 30, 28, 30, 34,195 ; 11 crushed 2
 76+  BD32 1C 1E 22 C3
 77+  BD36 72 57 72 67  	defb	114, 87,114,103,111, 69,225,155  ; 12 fight 1
 77+  BD3A 6F 45 E1 9B
 78+  BD3E 4E EA 4E E6  	defb	 78,234, 78,230,246,162,135,217  ; 13 fight 2
 78+  BD42 F6 A2 87 D9
 79+  BD46
 80+  BD46              ;
 81+  BD46              ; First 4 top half, next 4 bottom 1, next 4 bottom 2
 82+  BD46              ;
 83+  BD46              ship_sprite:
 84+  BD46 00 00 00 01  	defb	  0,  0,  0,  1,  3, 31,127,255
 84+  BD4A 03 1F 7F FF
 85+  BD4E 1F 01 7F FF  	defb	 31,  1,127,255,255,255,255,255
 85+  BD52 FF FF FF FF
 86+  BD56 F8 80 FE FF  	defb	248,128,254,255,255,255,255,255
 86+  BD5A FF FF FF FF
 87+  BD5E 00 00 00 80  	defb	  0,  0,  0,128,192,248,254,255
 87+  BD62 C0 F8 FE FF
 88+  BD66 B3 B3 7F 1F  	defb	179,179,127, 31,  3,  3,  2,  7
 88+  BD6A 03 03 02 07
 89+  BD6E 8F 8F FF FF  	defb	143,143,255,255,255, 15,  7,131
 89+  BD72 FF 0F 07 83
 90+  BD76 0F 0F FF FF  	defb	 15, 15,255,255,255, 16, 32,193
 90+  BD7A FF 10 20 C1
 91+  BD7E 19 19 FE F8  	defb	 25, 25,254,248,192,192, 64,224
 91+  BD82 C0 C0 40 E0
 92+  BD86 98 98 7F 1F  	defb	152,152,127, 31,  3,  3,  2,  7
 92+  BD8A 03 03 02 07
 93+  BD8E F0 F0 FF FF  	defb	240,240,255,255,255,  8,  4,131
 93+  BD92 FF 08 04 83
 94+  BD96 F1 F1 FF FF  	defb	241,241,255,255,255,240,224,193
 94+  BD9A FF F0 E0 C1
 95+  BD9E CD CD FE F8  	defb	205,205,254,248,192,192, 64,224
 95+  BDA2 C0 C0 40 E0
 96+  BDA6
 97+  BDA6              ;
 98+  BDA6              ;  First 8 frames are tank, last frame is the gun barrel
 99+  BDA6              ;
100+  BDA6              tank_sprite:
101+  BDA6 00 00 00 7F  	defb	  0,  0,  0,127,127,  0,  0,  0
101+  BDAA 7F 00 00 00
102+  BDAE 01 03 FE FC  	defb	  1,  3,254,252,254,255,127, 64
102+  BDB2 FE FF 7F 40
103+  BDB6 FF FF 03 F9  	defb	255,255,  3,249,  3,255,255,  1
103+  BDBA 03 FF FF 01
104+  BDBE 00 00 C0 E0  	defb	  0,  0,192,224,224,192,  0,  0
104+  BDC2 E0 C0 00 00
105+  BDC6 3F 7F E1 FB  	defb	 63,127,225,251,247,225,127, 63
105+  BDCA F7 E1 7F 3F
106+  BDCE FF FF 16 52  	defb	255,255, 22, 82, 84, 22,255,255
106+  BDD2 54 16 FF FF
107+  BDD6 FF FF A8 A9  	defb	255,255,168,169,155,168,255,255
107+  BDDA 9B A8 FF FF
108+  BDDE FC FE 8F AF  	defb	252,254,143,175,159,175,254,252
108+  BDE2 9F AF FE FC
109+  BDE6 00 00 00 1F  	defb	  0,  0,  0, 31, 31,  0,  0,  0 ; +64
109+  BDEA 1F 00 00 00
110+  BDEE
111+  BDEE              monster_sprite:
112+  BDEE 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
112+  BDF2 0B D0 16 68
113+  BDF6 19 98 17 E8  	defb	 25,152, 23,232, 53,172,127,254
113+  BDFA 35 AC 7F FE
114+  BDFE FE 7F EC 37  	defb	254,127,236, 55,143,241,143,241
114+  BE02 8F F1 8F F1
115+  BE06 08 10 08 10  	defb	  8, 16,  8, 16, 24, 24,  0,  0		; frame 1
115+  BE0A 18 18 00 00
116+  BE0E 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
116+  BE12 0B D0 16 68
117+  BE16 19 98 17 E8  	defb	 25,152, 23,232,245,175,255,255
117+  BE1A F5 AF FF FF
118+  BE1E BC 3D 0E 70  	defb	188, 61, 14,112, 15,240, 15,240
118+  BE22 0F F0 0F F0
119+  BE26 10 08 30 0C  	defb	 16,  8, 48, 12,  0,  0,  0,  0		; frame 2
119+  BE2A 00 00 00 00
120+  BE2E
121+  BE2E              robot_sprite:
122+  BE2E 0E 0A CE 3E  	defb	 14, 10,206, 62,206, 18, 34,102		; left 1
122+  BE32 CE 12 22 66
123+  BE36 0E 0A 4E FE  	defb	 14, 10, 78,254, 78, 18, 36,108		; 2
123+  BE3A 4E 12 24 6C
124+  BE3E 0E 0A 4E FE  	defb	 14, 10, 78,254, 78, 50, 99,  3		; 3
124+  BE42 4E 32 63 03
125+  BE46 0E 0A CE 3E  	defb	 14, 10,206, 62,206, 10,  9, 27		; 4
125+  BE4A CE 0A 09 1B
126+  BE4E 70 50 73 7C  	defb	112, 80,115,124,115, 72, 68,102		; right 1
126+  BE52 73 48 44 66
127+  BE56 70 50 72 7F  	defb	112, 80,114,127,114, 72, 36, 54		; 2
127+  BE5A 72 48 24 36
128+  BE5E 70 50 72 7F  	defb	112, 80,114,127,114, 76,198,192		; 3
128+  BE62 72 4C C6 C0
129+  BE66 70 50 73 7C  	defb	112, 80,115,124,115, 80,144,216		; 4
129+  BE6A 73 50 90 D8
130+  BE6E 38 A9 BA 7C  	defb     56,169,186,124, 56, 42, 38, 96     ; dead 1
130+  BE72 38 2A 26 60
131+  BE76 1C 95 5D 3E  	defb	 28,149, 93, 62, 28, 84,100,  6		; dead 2
131+  BE7A 1C 54 64 06
132+  BE7E
# file closed: graphics/graphics.asm
151   BE7E
152   BE7E                  include "game\control.asm"
# file opened: game/control.asm
  1+  BE7E              ;
  2+  BE7E              ; Check the preferred input method then move
  3+  BE7E              ;
  4+  BE7E              control_input:
  5+  BE7E 3A 7D C4         ld a,(player+11)    ; first, check if player is dying
  6+  BE81 FE 04            cp 4                ; is the player falling
  7+  BE83 CC 4D BF         call z, control_fall
  8+  BE86 FE 05            cp 5                ; is the player fighting
  9+  BE88 CC 3A BF         call z, control_fight
 10+  BE8B 3A 7D C4         ld a,(player+11)    ; first, check if player is dying
 11+  BE8E FE 00            cp 0
 12+  BE90 C0               ret nz               ; if so, can't move
 13+  BE91 3A 77 C4         ld a,(player+5)      ; next, check if the player has pixels left to move
 14+  BE94 FE 00            cp 0
 15+  BE96 CA 9D BE         jp z, control_input0
 16+  BE99 CD 2B C0         call control_automove
 17+  BE9C C9               ret
 18+  BE9D              control_input0:
 19+  BE9D 3A 78 C4         ld a,(player+6)      ; next, check if the player is digging
 20+  BEA0 FE 00            cp 0
 21+  BEA2 CA A9 BE         jp z, control_input1
 22+  BEA5 CD 69 BF         call control_dig
 23+  BEA8 C9               ret
 24+  BEA9              control_input1:
 25+  BEA9 3A 86 C3         ld a,(game_control)
 26+  BEAC FE 00            cp 0                ; is this keyboard
 27+  BEAE C2 B5 BE         jp nz,control_input2
 28+  BEB1 CD B9 BE         call control_keyboard
 29+  BEB4 C9               ret
 30+  BEB5              control_input2:
 31+  BEB5                  ; do joystick
 32+  BEB5 CD FF BE         call control_joystick
 33+  BEB8 C9               ret
 34+  BEB9
 35+  BEB9              ;
 36+  BEB9              ; Check the keyboard
 37+  BEB9              ;
 38+  BEB9              control_keyboard:
 39+  BEB9 01 FE FB         ld bc,64510         ; port for keyboard row q-t.
 40+  BEBC ED 78            in a,(c)            ; read keyboard.
 41+  BEBE 47               ld b,a              ; store result in b register.
 42+  BEBF CB 18            rr b                ; check outermost key (q).
 43+  BEC1 D2 EB BE         jp nc,control_keyboard1
 44+  BEC4 01 FE FD         ld bc,65022         ; port for keyboard row a-f.
 45+  BEC7 ED 78            in a,(c)            ; read keyboard.
 46+  BEC9 47               ld b,a              ; store result in b register.
 47+  BECA CB 18            rr b                ; check outermost key (a).
 48+  BECC D2 EF BE         jp nc,control_keyboard2
 49+  BECF 01 FE DF         ld bc,57342         ; port for keyboard row y-p.
 50+  BED2 ED 78            in a,(c)            ; read keyboard.
 51+  BED4 47               ld b,a              ; store result in b register.
 52+  BED5 CB 18            rr b                ; check outermost key (p).
 53+  BED7 D2 F3 BE         jp nc,control_keyboard3
 54+  BEDA CB 18            rr b                ; check next key.
 55+  BEDC D2 F7 BE         jp nc,control_keyboard4
 56+  BEDF 01 FE 7F         ld bc,32766         ; port for keyboard row b-space.
 57+  BEE2 ED 78            in a,(c)            ; read keyboard.
 58+  BEE4 47               ld b,a              ; store result in b register.
 59+  BEE5 CB 18            rr b                ; check outermost key (space).
 60+  BEE7 D2 FB BE         jp nc,control_keyboard5
 61+  BEEA C9               ret
 62+  BEEB              control_keyboard1:
 63+  BEEB CD 74 C0         call control_pl_moveup         ; player up.
 64+  BEEE C9               ret
 65+  BEEF              control_keyboard2:
 66+  BEEF CD A1 C0         call control_pl_movedown       ; player down.
 67+  BEF2 C9               ret
 68+  BEF3              control_keyboard3:
 69+  BEF3 CD FD C0         call control_pl_moveright       ; player left.
 70+  BEF6 C9               ret
 71+  BEF7              control_keyboard4:
 72+  BEF7 CD CD C0         call control_pl_moveleft       ; player right.
 73+  BEFA C9               ret
 74+  BEFB              control_keyboard5:
 75+  BEFB CD 2B C1         call control_pl_fire       ; player fire.
 76+  BEFE C9               ret
 77+  BEFF
 78+  BEFF              ;
 79+  BEFF              ; Check the joystick
 80+  BEFF              ;
 81+  BEFF              control_joystick:
 82+  BEFF 01 1F 00         ld bc,31                        ; Kempston joystick port.
 83+  BF02 ED 78            in a,(c)                        ; read input.
 84+  BF04 E6 02            and 2                           ; check "left" bit.
 85+  BF06 C2 2E BF         jp nz,control_joystick3       ; move left.
 86+  BF09 ED 78            in a,(c)                        ; read input.
 87+  BF0B E6 01            and 1                           ; test "right" bit.
 88+  BF0D C2 32 BF         jp nz,control_joystick4       ; move right.
 89+  BF10 ED 78            in a,(c)                        ; read input.
 90+  BF12 E6 08            and 8                           ; check "up" bit.
 91+  BF14 C2 26 BF         jp nz,control_joystick1       ; move up.
 92+  BF17 ED 78            in a,(c)                        ; read input.
 93+  BF19 E6 04            and 4                           ; check "down" bit.
 94+  BF1B C2 2A BF         jp nz,control_joystick2       ; move down.
 95+  BF1E ED 78            in a,(c)                        ; read input.
 96+  BF20 E6 10            and 16                          ; try the fire bit.
 97+  BF22 C2 36 BF         jp nz,control_joystick5       ; fire pressed.
 98+  BF25 C9               ret
 99+  BF26              control_joystick1:
100+  BF26 CD 74 C0         call control_pl_moveup         ; player up.
101+  BF29 C9               ret
102+  BF2A              control_joystick2:
103+  BF2A CD A1 C0         call control_pl_movedown       ; player down.
104+  BF2D C9               ret
105+  BF2E              control_joystick3:
106+  BF2E CD CD C0         call control_pl_moveleft       ; player left.
107+  BF31 C9               ret
108+  BF32              control_joystick4:
109+  BF32 CD FD C0         call control_pl_moveright       ; player right.
110+  BF35 C9               ret
111+  BF36              control_joystick5:
112+  BF36 CD 2B C1         call control_pl_fire
113+  BF39 C9               ret
114+  BF3A
115+  BF3A              ;
116+  BF3A              ; Fights the player - just flips the players anim frame
117+  BF3A              ;
118+  BF3A              control_fight:
119+  BF3A 3A 75 C4         ld a,(player+3)             ; load the frame
120+  BF3D FE 0C            cp 12                       ; flip between 12 and 13
121+  BF3F CA 47 BF         jp z,control_fight0
122+  BF42 3E 0C            ld a,12
123+  BF44 C3 49 BF         jp control_fight1
124+  BF47              control_fight0:
125+  BF47 3E 0D            ld a,13
126+  BF49              control_fight1:
127+  BF49 32 75 C4         ld (player+3),a           ; save back
128+  BF4C C9               ret
129+  BF4D
130+  BF4D              ;
131+  BF4D              ; Falls the player
132+  BF4D              ;
133+  BF4D              control_fall:
134+  BF4D ED 4B 72 C4      ld bc,(player)              ; get coords
135+  BF51 0C               inc c
136+  BF52 ED 43 72 C4      ld (player),bc
137+  BF56 3A 75 C4         ld a,(player+3)             ; load the frame
138+  BF59 FE 03            cp 3                       ; flip between 3 and 0
139+  BF5B C2 63 BF         jp nz, control_fall0
140+  BF5E 3E 00            ld a,0
141+  BF60 C3 65 BF         jp control_fall1
142+  BF63              control_fall0:
143+  BF63 3E 03            ld a,3
144+  BF65              control_fall1:
145+  BF65 32 75 C4         ld (player+3),a           ; save back
146+  BF68 C9               ret
147+  BF69
148+  BF69              ;
149+  BF69              ; Performs a dig if the counter has reset, otherwise, messes with the graphics
150+  BF69              ;
151+  BF69              control_dig:
152+  BF69 ED 4B 72 C4      ld bc,(player)      ; load the current coords into bc
153+  BF6D C5               push bc
154+  BF6E 3A 74 C4         ld a,(player+2)     ; get the direction
155+  BF71 FE 01            cp 1                ; left
156+  BF73 CA 8B BF         jp z,control_dig0
157+  BF76 FE 02            cp 2                ; right
158+  BF78 CA A0 BF         jp z,control_dig1
159+  BF7B FE 03            cp 3                ; down
160+  BF7D CA C4 BF         jp z,control_dig5
161+  BF80 FE 00            cp 0                ; up
162+  BF82 CA B4 BF         jp z,control_dig4
163+  BF85 21 78 C4         ld hl,player+6
164+  BF88 36 00            ld (hl),0           ; turn off digging
165+  BF8A C9               ret                 ; return
166+  BF8B              control_dig0:           ; going left
167+  BF8B CD 04 AC         call sprites_scadd  ; get the current coord
168+  BF8E 62 6B            ld hl,de
169+  BF90 2B               dec hl              ; move one left
170+  BF91 C1               pop bc              ; get the coords back, subtract 8 from horiz, 8 from vert, store (will be coords of space above dug dirt)
171+  BF92 78               ld a,b
172+  BF93 06 08            ld b,8
173+  BF95 90               sub b
174+  BF96 47               ld b,a
175+  BF97 79               ld a,c
176+  BF98 0E 08            ld c,8
177+  BF9A 91               sub c
178+  BF9B 4F               ld c,a
179+  BF9C C5               push bc
180+  BF9D C3 CD BF         jp control_dig2
181+  BFA0              control_dig1:
182+  BFA0 CD 04 AC         call sprites_scadd  ; get the current coord
183+  BFA3 62 6B            ld hl,de
184+  BFA5 23               inc hl              ; move one right
185+  BFA6 C1               pop bc              ; get the coords back, add 8 to horiz, subtract 8 from vert store (will be coords of space above dug dirt)
186+  BFA7 3E 08            ld a,8
187+  BFA9 80               add a,b
188+  BFAA 47               ld b,a
189+  BFAB 79               ld a,c
190+  BFAC 0E 08            ld c,8
191+  BFAE 91               sub c
192+  BFAF 4F               ld c,a
193+  BFB0 C5               push bc
194+  BFB1 C3 CD BF         jp control_dig2
195+  BFB4              control_dig4:
196+  BFB4 CD 04 AC         call sprites_scadd  ; get the current coord
197+  BFB7 62 6B            ld hl,de
198+  BFB9 11 20 00         ld de,32
199+  BFBC ED 52            sbc hl,de             ; move one up
200+  BFBE C1               pop bc              ; get the coords back, 1 from vert, store, then we'll sub 1 from c for each row later
201+  BFBF 0D               dec c
202+  BFC0 C5               push bc
203+  BFC1 C3 E5 BF         jp control_dig6
204+  BFC4              control_dig5:
205+  BFC4 CD 04 AC         call sprites_scadd  ; get the current coord
206+  BFC7 62 6B            ld hl,de
207+  BFC9 24               inc h              ; move one down
208+  BFCA                                     ; not bothered about working out bc here, since rock will never fall if digging down
209+  BFCA C3 CD BF         jp control_dig2
210+  BFCD              ; Normal (not up) digging
211+  BFCD              control_dig2:
212+  BFCD 3A 7A C4         ld a,(player+8)     ; get the number of rows we need to overwrite
213+  BFD0 47               ld b,a              ; rows to copy over
214+  BFD1 E5               push hl             ; store the memory location of the first row for later
215+  BFD2              control_dig3:
216+  BFD2 CD 14 C0         call control_getpixelrow
217+  BFD5 77               ld (hl),a           ; load contents into row
218+  BFD6 11 20 00         ld de,32
219+  BFD9 19               add hl,de           ; move to next row
220+  BFDA 10 F6            djnz control_dig3
221+  BFDC E1               pop hl              ; get the original memory location back
222+  BFDD 11 20 00         ld de,32
223+  BFE0 ED 52            sbc hl,de           ; move to above row, ready for checking for rock
224+  BFE2 C3 FB BF         jp control_dig10
225+  BFE5              ; Special case for going up
226+  BFE5              control_dig6:
227+  BFE5 3A 7A C4         ld a,(player+8)     ; get the number of rows we need to overwrite
228+  BFE8 47               ld b,a              ; rows to copy over
229+  BFE9              control_dig7:
230+  BFE9 CD 14 C0         call control_getpixelrow
231+  BFEC              control_dig12:
232+  BFEC 77               ld (hl),a           ; load empty into row
233+  BFED 11 20 00         ld de,32
234+  BFF0 ED 52            sbc hl,de           ; move up to next row
235+  BFF2 0D               dec c               ; decrease c to track rows
236+  BFF3 10 F4            djnz control_dig7
237+  BFF5 79               ld a,c
238+  BFF6 D6 07            sub 7
239+  BFF8 C1               pop bc
240+  BFF9 4F               ld c,a
241+  BFFA C5               push bc             ; store the decreased c coord
242+  BFFB              control_dig10:
243+  BFFB DD 21 79 C4      ld ix,player+7
244+  BFFF DD 7E 00         ld a,(ix)     ; get the dig frame number
245+  C002 3D               dec a
246+  C003 DD 77 00         ld (ix),a
247+  C006                  ; call the check for rocks above the removed dirt
248+  C006 DD 21 78 C4      ld ix,player+6
249+  C00A DD 7E 00         ld a,(ix)     ; get the dig state
250+  C00D FE 00            cp 0
251+  C00F C1               pop bc
252+  C010 CC F7 C9         call z, rocks_checkforfalling ; make the check if we're no longer digging
253+  C013 C9               ret
254+  C014
255+  C014              ;
256+  C014              ; Gets a modified pixel row to overwrite dirt - if this is the last dig, overwrite with nothing, otherwise xor to flip the dirt
257+  C014              ; Inputs:
258+  C014              ; hl - memory of pixel row
259+  C014              ; Outputs:
260+  C014              ; a - modified row to write
261+  C014              ;
262+  C014              control_getpixelrow:
263+  C014 3A 79 C4         ld a,(player+7)     ; get the dig frame number
264+  C017 FE 00            cp 0                ; is this the last dig
265+  C019 CA 20 C0         jp z,control_getpixelrow1
266+  C01C 7E               ld a,(hl)           ; if not, xor with 255 to flip it
267+  C01D EE FF            xor 255
268+  C01F C9               ret
269+  C020              control_getpixelrow1:
270+  C020 DD 21 78 C4      ld ix,player+6
271+  C024 DD 36 00 00      ld (ix),0           ; turn off digging
272+  C028 3E 00            ld a,0              ; if it is, load with empty
273+  C02A C9               ret
274+  C02B
275+  C02B              ;
276+  C02B              ; Auto move the player until pixels is zero
277+  C02B              ;
278+  C02B              control_automove:
279+  C02B 5F               ld e,a              ; store the number of pixels left to move in e
280+  C02C ED 4B 72 C4      ld bc,(player)      ; load the current coords into bc
281+  C030 21 74 C4         ld hl,player+2      ; get the direction
282+  C033 7E               ld a,(hl)
283+  C034 FE 03            cp 3                ; down
284+  C036 CA 4A C0         jp z,control_automove3  ; don't need to do anything
285+  C039 FE 00            cp 0                ; going up
286+  C03B CA 56 C0         jp z,control_automove2
287+  C03E FE 01            cp 1                ; going left?
288+  C040 CA 62 C0         jp z,control_automove0
289+  C043 78               ld a,b
290+  C044 3C               inc a               ; if we're going right, increment a twice for two pixels
291+  C045 3C               inc a
292+  C046 47               ld b,a
293+  C047 C3 66 C0         jp control_automove1
294+  C04A              control_automove3:
295+  C04A 79               ld a,c
296+  C04B 3C               inc a
297+  C04C 3C               inc a               ; if we're going down, increment twice
298+  C04D 4F               ld c,a
299+  C04E FE 90            cp 144
300+  C050 CC 41 C1         call z, control_scroll_down
301+  C053 C3 66 C0         jp control_automove1
302+  C056              control_automove2:
303+  C056 79               ld a,c
304+  C057 3D               dec a
305+  C058 3D               dec a               ; if we're going up, decrement twice
306+  C059 4F               ld c,a
307+  C05A FE 60            cp 96
308+  C05C CC 4E C1         call z, control_scroll_up
309+  C05F C3 66 C0         jp control_automove1
310+  C062              control_automove0:
311+  C062 78               ld a,b
312+  C063 3D               dec a               ; if we're going left, decrement a twice
313+  C064 3D               dec a
314+  C065 47               ld b,a
315+  C066              control_automove1:
316+  C066 ED 43 72 C4      ld (player),bc      ; and back to player
317+  C06A 7B               ld a,e              ; now get the pixel count back
318+  C06B 3D               dec a               ; decrease by one
319+  C06C 21 77 C4         ld hl,player+5
320+  C06F 77               ld (hl),a           ; copy back
321+  C070 CD 7D C6         call player_justmoved
322+  C073 C9               ret
323+  C074
324+  C074              ;
325+  C074              ; Moves the player up
326+  C074              ;
327+  C074              control_pl_moveup:
328+  C074 C5               push bc
329+  C075 ED 4B 72 C4      ld bc,(player)          ; get the current coords, b horiz, c vert
330+  C079 79               ld a,c                  ; load c into the acc
331+  C07A FE 18            cp 24
332+  C07C CA 9A C0         jp z,control_pl_moveup0 ; are we at the edge of the screen
333+  C07F FE 60            cp 96
334+  C081 CC 4E C1         call z, control_scroll_up
335+  C084 CD F5 C2         call movement_checkcanmove_up ; check we can move up, e will be 1 if we can
336+  C087 F5               push af
337+  C088 7B               ld a,e                  ; put e in a
338+  C089 FE 00            cp 0
339+  C08B CA 99 C0         jp z,control_pl_moveup1 ; don't move if we can't
340+  C08E F1               pop af
341+  C08F D6 01            sub 1                   ; subtract 1
342+  C091                  ;sub 1                   ; subtract 1
343+  C091 4F               ld c,a                  ; load back to c
344+  C092 ED 43 72 C4      ld (player),bc          ; load back to player
345+  C096 C3 9A C0         jp control_pl_moveup0
346+  C099              control_pl_moveup1:
347+  C099 F1               pop af                  ; restore af if needed
348+  C09A              control_pl_moveup0:
349+  C09A 3E 00            ld a,0
350+  C09C 32 74 C4         ld (player+2),a        ; set direction to up
351+  C09F C1               pop bc
352+  C0A0 C9               ret
353+  C0A1              ;
354+  C0A1              ; Moves the player down
355+  C0A1              ;
356+  C0A1              control_pl_movedown:
357+  C0A1 C5               push bc
358+  C0A2 ED 4B 72 C4      ld bc,(player)          ; get the current coords, b horiz, c vert
359+  C0A6 79               ld a,c                  ; load c into the acc
360+  C0A7 FE E0            cp 224
361+  C0A9 CA C6 C0         jp z,control_pl_movedown0 ; are we at the edge of the screen
362+  C0AC FE 80            cp 128
363+  C0AE CC 41 C1         call z, control_scroll_down
364+  C0B1 CD C9 C2         call movement_checkcanmove_down ; check we can move down, e will be 1 if we can
365+  C0B4 F5               push af
366+  C0B5 7B               ld a,e                  ; put e in a
367+  C0B6 FE 00            cp 0
368+  C0B8 CA C5 C0         jp z,control_pl_movedown1 ; don't move if we can't
369+  C0BB F1               pop af
370+  C0BC 3C               inc a                   ; add 1
371+  C0BD                  ;inc a                   ; add 1
372+  C0BD 4F               ld c,a                  ; load back to c
373+  C0BE ED 43 72 C4      ld (player),bc          ; load back to player
374+  C0C2 C3 C6 C0         jp control_pl_movedown0
375+  C0C5              control_pl_movedown1:
376+  C0C5 F1               pop af                  ; restore af if needed
377+  C0C6              control_pl_movedown0:
378+  C0C6 3E 03            ld a,3
379+  C0C8 32 74 C4         ld (player+2),a        ; set direction to down
380+  C0CB C1               pop bc
381+  C0CC C9               ret
382+  C0CD              ;
383+  C0CD              ; Moves the player left
384+  C0CD              ;
385+  C0CD              control_pl_moveleft:
386+  C0CD C5               push bc
387+  C0CE ED 4B 72 C4      ld bc,(player)          ; get the current coords, b horiz, c vert
388+  C0D2 78               ld a,b                  ; load b into the acc
389+  C0D3 FE 10            cp 16
390+  C0D5 CA F6 C0         jp z,control_pl_moveleft0 ; are we at the edge of the screen
391+  C0D8 CD 54 C3         call movement_checkcanmove_left ; check we can move down, e will be 1 if we can
392+  C0DB F5               push af
393+  C0DC 7B               ld a,e                  ; put e in a
394+  C0DD FE 00            cp 0
395+  C0DF CA F5 C0         jp z,control_pl_moveleft1 ; don't move if we can't
396+  C0E2 21 77 C4         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
397+  C0E5 3E 03            ld a,3
398+  C0E7 77               ld (hl),a
399+  C0E8 F1               pop af
400+  C0E9 D6 01            sub 1                    ; subtract 2
401+  C0EB D6 01            sub 1
402+  C0ED 47               ld b,a                  ; load back to c
403+  C0EE ED 43 72 C4      ld (player),bc          ; load back to player
404+  C0F2 C3 F6 C0         jp control_pl_moveleft0
405+  C0F5              control_pl_moveleft1:
406+  C0F5 F1               pop af
407+  C0F6              control_pl_moveleft0:
408+  C0F6 3E 01            ld a,1
409+  C0F8 32 74 C4         ld (player+2),a        ; set direction to left
410+  C0FB C1               pop bc
411+  C0FC C9               ret
412+  C0FD              ;
413+  C0FD              ; Moves the player right
414+  C0FD              ;
415+  C0FD              control_pl_moveright:
416+  C0FD C5               push bc
417+  C0FE ED 4B 72 C4      ld bc,(player)          ; get the current coords, b horiz, c vert
418+  C102 78               ld a,b                  ; load b into the acc
419+  C103 FE F0            cp 240
420+  C105 CA 24 C1         jp z,control_pl_moveright0 ; are we at the edge of the screen
421+  C108 CD 28 C3         call movement_checkcanmove_right ; check we can move down, e will be 1 if we can
422+  C10B F5               push af
423+  C10C 7B               ld a,e                  ; put e in a
424+  C10D FE 00            cp 0
425+  C10F CA 23 C1         jp z,control_pl_moveright1 ; don't move if we can't
426+  C112 21 77 C4         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
427+  C115 3E 03            ld a,3
428+  C117 77               ld (hl),a
429+  C118 F1               pop af
430+  C119 3C               inc a                   ; add 2
431+  C11A 3C               inc a
432+  C11B 47               ld b,a                  ; load back to b
433+  C11C ED 43 72 C4      ld (player),bc          ; load back to player
434+  C120 C3 24 C1         jp control_pl_moveright0
435+  C123              control_pl_moveright1:
436+  C123 F1               pop af                  ; restore af if needed
437+  C124              control_pl_moveright0:
438+  C124 3E 02            ld a,2
439+  C126 32 74 C4         ld (player+2),a        ; set direction to right
440+  C129 C1               pop bc
441+  C12A C9               ret
442+  C12B
443+  C12B              ;
444+  C12B              ; Player fires
445+  C12B              ;
446+  C12B              control_pl_fire:
447+  C12B 3A 74 C4         ld a,(player+2)         ; get player direction
448+  C12E FE 00            cp 0
449+  C130 C8               ret z
450+  C131 FE 03            cp 3
451+  C133 C8               ret z                   ; if up or down, don't fire
452+  C134 3A 16 D5         ld a,(bullet_state+3)       ; get the state
453+  C137 FE 01            cp 1
454+  C139 C8               ret z                   ; if currently firing, don't fire
455+  C13A CD 17 D5         call bullet_init        ; initialise the bullet
456+  C13D CD 2C D5         call bullet_shoot       ; shoot the bullet
457+  C140 C9               ret
458+  C141
459+  C141              ;
460+  C141              ; Scrolls the screen down
461+  C141              ;
462+  C141              control_scroll_down:
463+  C141 F5               push af
464+  C142 3E 08            ld a,8
465+  C144 32 DD A8         ld (screen_offset),a
466+  C147 F1               pop af
467+  C148 21 2A A7         ld hl,buffer_updateall
468+  C14B 36 01            ld (hl),1         ; flag as screen needing update
469+  C14D C9               ret
470+  C14E
471+  C14E              ;
472+  C14E              ; Scrolls the screen up
473+  C14E              ;
474+  C14E              control_scroll_up:
475+  C14E F5               push af
476+  C14F 3E 00            ld a,0
477+  C151 32 DD A8         ld (screen_offset),a
478+  C154 F1               pop af
479+  C155 21 2A A7         ld hl,buffer_updateall
480+  C158 36 01            ld (hl),1         ; flag as screen needing update
481+  C15A C9               ret
482+  C15B
483+  C15B
484+  C15B
485+  C15B
# file closed: game/control.asm
153   C15B                  include "game\movement.asm"
# file opened: game/movement.asm
  1+  C15B              ;
  2+  C15B              ; The number of frames to dig for
  3+  C15B              ;
  4+  C15B              movement_numberdigframes:
  5+  C15B 0A               defb 10
  6+  C15C
  7+  C15C              ;
  8+  C15C              ; Checks the contents of a cell are empty - ie, all pixel rows are zero
  9+  C15C              ; Inputs:
 10+  C15C              ; hl - memory location of top pixel row
 11+  C15C              ; bc - screen coords, b horiz, c vert
 12+  C15C              ; Outputs:
 13+  C15C              ; e - 0 if not empty, 1 if empty
 14+  C15C              ;
 15+  C15C              movement_spaceisempty:
 16+  C15C C5               push bc
 17+  C15D E5               push hl
 18+  C15E CD 86 C1         call movement_spaceisgem        ; check if space is a gem
 19+  C161 E1               pop hl
 20+  C162 C1               pop bc
 21+  C163 7B               ld a,e
 22+  C164 FE 01            cp 1
 23+  C166 C8               ret z                           ; if e is 1, space is a gem so can move here, return
 24+  C167 3E 08            ld a,8                          ; 8 rows to check
 25+  C169              movement_spaceisempty0:
 26+  C169 08               ex af,af'                       ; store the loop counter
 27+  C16A 7E               ld a,(hl)                       ; get current pixel row
 28+  C16B FE 00            cp 0
 29+  C16D C2 81 C1         jp nz, movement_spaceisempty1    ; row is not empty, can't move here
 30+  C170 79               ld a,c                          ; load the vertical coord
 31+  C171 3C               inc a                           ; next row down
 32+  C172 11 20 00         ld de,32
 33+  C175 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 34+  C176 4F               ld c,a                          ; copy vert coord back to c
 35+  C177 08               ex af,af'                       ; get loop counter back
 36+  C178 3D               dec a                           ; decrease loop counter
 37+  C179 C2 69 C1         jp nz, movement_spaceisempty0
 38+  C17C 16 00            ld d,0
 39+  C17E 1E 01            ld e,1                          ; got to end, so space is empty
 40+  C180 C9               ret
 41+  C181              movement_spaceisempty1:
 42+  C181 16 00            ld d,0
 43+  C183 1E 00            ld e,0                          ; returning false, ie space not empty
 44+  C185 C9               ret
 45+  C186
 46+  C186              ;
 47+  C186              ; Check if a space contains a gem
 48+  C186              ; Inputs:
 49+  C186              ; bc - screen coords
 50+  C186              ; Outputs:
 51+  C186              ; e = 1 if gem
 52+  C186              movement_spaceisgem:
 53+  C186 CD 3D AA         call screen_getcharcoordsfromscreencoords   ; get the char coords we're checking into bc
 54+  C189 21 55 B7         ld hl,level_diamonds           ; check diamonds first
 55+  C18C              movement_spaceisgem0:
 56+  C18C 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 57+  C190 7B               ld a,e                          ; check for end of data
 58+  C191 FE FF            cp 255
 59+  C193 CA AE C1         jp z,movement_spaceisgem1       ; if yes, done with diamonds
 60+  C196 23               inc hl
 61+  C197 23               inc hl                          ; move to state
 62+  C198 7E               ld a,(hl)
 63+  C199 23               inc hl
 64+  C19A 23               inc hl
 65+  C19B 23               inc hl                          ; get to next
 66+  C19C FE 01            cp 1                            ; check if collected
 67+  C19E CA 8C C1         jp z,movement_spaceisgem0       ; if yes, move to next diamond
 68+  C1A1 7B               ld a,e                          ; load e again
 69+  C1A2 B9               cp c                            ; otherwise, compare c with e
 70+  C1A3 C2 8C C1         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 71+  C1A6 7A               ld a,d                          ; get d coord
 72+  C1A7 B8               cp b                            ; compare b with d
 73+  C1A8 C2 8C C1         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 74+  C1AB 1E 01            ld e,1                          ; otherwise, exit with e = 1
 75+  C1AD C9               ret
 76+  C1AE              movement_spaceisgem1:
 77+  C1AE 21 65 B7         ld hl,level_gems              ; check gems
 78+  C1B1              movement_spaceisgem2:
 79+  C1B1 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 80+  C1B5 7B               ld a,e                          ; check for end of data
 81+  C1B6 FE FF            cp 255
 82+  C1B8 CA D3 C1         jp z,movement_spaceisgem3       ; if yes, done with gems
 83+  C1BB 23               inc hl
 84+  C1BC 23               inc hl                          ; move to state
 85+  C1BD 7E               ld a,(hl)
 86+  C1BE 23               inc hl
 87+  C1BF 23               inc hl
 88+  C1C0 23               inc hl                          ; get to next
 89+  C1C1 FE 01            cp 1                            ; check if collected
 90+  C1C3 CA B1 C1         jp z,movement_spaceisgem2       ; if yes, move to next diamond
 91+  C1C6 7B               ld a,e                          ; load e again
 92+  C1C7 B9               cp c                            ; otherwise, compare c with e
 93+  C1C8 C2 B1 C1         jp nz,movement_spaceisgem2      ; if different, move to next gem
 94+  C1CB 7A               ld a,d                          ; get d coord
 95+  C1CC B8               cp b                            ; compare b with d
 96+  C1CD C2 B1 C1         jp nz,movement_spaceisgem2      ; if different, move to next gem
 97+  C1D0 1E 01            ld e,1                          ; otherwise, exit with e = 1
 98+  C1D2 C9               ret
 99+  C1D3              movement_spaceisgem3:
100+  C1D3 1E 00            ld e,0                          ; nothing found, return e = 0
101+  C1D5 C9               ret
102+  C1D6
103+  C1D6              ;
104+  C1D6              ; Checks the line of a cell below is empty - ie, first pixel rows is zero
105+  C1D6              ; Inputs:
106+  C1D6              ; hl - memory location of top pixel row
107+  C1D6              ; bc - screen coords, b horiz, c vert
108+  C1D6              ; Outputs:
109+  C1D6              ; e - 0 if not empty, 1 if empty
110+  C1D6              ;
111+  C1D6              movement_linebelowisempty:
112+  C1D6 C5               push bc
113+  C1D7 E5               push hl
114+  C1D8 CD 86 C1         call movement_spaceisgem        ; check if space is a gem
115+  C1DB E1               pop hl
116+  C1DC C1               pop bc
117+  C1DD 7B               ld a,e
118+  C1DE FE 01            cp 1
119+  C1E0 C8               ret z                           ; if e is 1, space is a gem so can move here, return
120+  C1E1 7E               ld a,(hl)                       ; get current pixel row
121+  C1E2 FE 00            cp 0
122+  C1E4 C2 EC C1         jp nz, movement_linebelowisempty1    ; row is not empty, can't move here
123+  C1E7 16 00            ld d,0
124+  C1E9 1E 01            ld e,1                          ; got to end, so space is empty
125+  C1EB C9               ret
126+  C1EC              movement_linebelowisempty1:
127+  C1EC 16 00            ld d,0
128+  C1EE 1E 00            ld e,0                          ; returning false, ie space not empty
129+  C1F0 C9               ret
130+  C1F1
131+  C1F1              ;
132+  C1F1              ; Checks the line of a cell above is empty - ie, last pixel rows are zero
133+  C1F1              ; Inputs:
134+  C1F1              ; hl - memory location of top pixel row
135+  C1F1              ; bc - screen coords, b horiz, c vert
136+  C1F1              ; Outputs:
137+  C1F1              ; e - 0 if not empty, 1 if empty
138+  C1F1              ;
139+  C1F1              movement_lineaboveisempty:
140+  C1F1 C5               push bc
141+  C1F2 E5               push hl
142+  C1F3 CD 86 C1         call movement_spaceisgem        ; check if space is a gem
143+  C1F6 E1               pop hl
144+  C1F7 C1               pop bc
145+  C1F8 7B               ld a,e
146+  C1F9 FE 01            cp 1
147+  C1FB C8               ret z
148+  C1FC 7E               ld a,(hl)                       ; get current pixel row
149+  C1FD FE 00            cp 0
150+  C1FF C2 07 C2         jp nz, movement_lineaboveisempty1    ; row is not empty, can't move here
151+  C202 16 00            ld d,0
152+  C204 1E 01            ld e,1                          ; got to end, so space is empty
153+  C206 C9               ret
154+  C207              movement_lineaboveisempty1:
155+  C207 16 00            ld d,0
156+  C209 1E 00            ld e,0                          ; returning false, ie space not empty
157+  C20B C9               ret
158+  C20C
159+  C20C              ;
160+  C20C              ; Checks the contents of a cell are diggable - ie, all pixel rows are dirt or empty
161+  C20C              ; Inputs:
162+  C20C              ; hl - memory location of top pixel row
163+  C20C              ; bc - screen coords, b horiz, c vert
164+  C20C              ; Outputs:
165+  C20C              ; none - puts player into digging mode
166+  C20C              ;
167+  C20C              movement_spaceisdiggable:
168+  C20C 3E 08            ld a,8                          ; 8 rows to check
169+  C20E              movement_spaceisdiggable0:
170+  C20E 08               ex af,af'                       ; store the loop counter
171+  C20F 7E               ld a,(hl)                       ; get current pixel row
172+  C210 FE 00            cp 0
173+  C212 CA 22 C2         jp z, movement_spaceisdiggable2  ; row is empty, can dig here
174+  C215 FE 55            cp 85
175+  C217 CA 22 C2         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
176+  C21A FE AA            cp 170
177+  C21C CA 22 C2         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
178+  C21F C3 3C C2         jp movement_spaceisdiggable1     ; otherwise, stop checking
179+  C222              movement_spaceisdiggable2:
180+  C222 79               ld a,c                          ; load the vertical coord
181+  C223 3C               inc a                           ; next row down
182+  C224 11 20 00         ld de,32
183+  C227 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
184+  C228 4F               ld c,a                          ; copy vert coord back to c
185+  C229 08               ex af,af'                       ; get loop counter back
186+  C22A 3D               dec a                           ; decrease loop counter
187+  C22B C2 0E C2         jp nz, movement_spaceisdiggable0
188+  C22E 21 78 C4         ld hl,player+6
189+  C231 36 01            ld (hl),1                       ; set the player into digging mode
190+  C233 23               inc hl
191+  C234 3A 5B C1         ld a,(movement_numberdigframes)
192+  C237 77               ld (hl),a                       ; set the number of frame to dig for
193+  C238 23               inc hl
194+  C239 36 08            ld (hl),8                       ; set the number of pixels to dig
195+  C23B C9               ret
196+  C23C              movement_spaceisdiggable1:
197+  C23C 21 78 C4         ld hl,player+6
198+  C23F 36 00            ld (hl),0                       ; set the player out of digging mode
199+  C241 C9               ret
200+  C242
201+  C242              ;
202+  C242              ; Checks the contents of a cell below are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
203+  C242              ; Inputs:
204+  C242              ; hl - memory location of top pixel row
205+  C242              ; bc - screen coords, b horiz, c vert
206+  C242              ; Outputs:
207+  C242              ; none - puts player into digging mode
208+  C242              ;
209+  C242              movement_spacebelowisdiggable:
210+  C242 7E               ld a,(hl)                       ; get first pixel row
211+  C243 FE 55            cp 85
212+  C245 CA 50 C2         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
213+  C248 FE AA            cp 170
214+  C24A CA 50 C2         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
215+  C24D C3 3C C2         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
216+  C250              movement_spacebelowisdiggable3:
217+  C250 3E 08            ld a,8                          ; rows to check
218+  C252 1E 00            ld e,0                          ; count of rows to dig
219+  C254              movement_spacebelowisdiggable0:
220+  C254 08               ex af,af'                       ; store the loop counter
221+  C255 7E               ld a,(hl)                       ; get current pixel row
222+  C256 FE 55            cp 85
223+  C258 CA 63 C2         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
224+  C25B FE AA            cp 170
225+  C25D CA 63 C2         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
226+  C260 C3 72 C2         jp movement_spacebelowisdiggable5     ; don't count this row and stop counting
227+  C263              movement_spacebelowisdiggable4:
228+  C263 1C               inc e                           ; inc count of rows to dig
229+  C264              movement_spacebelowisdiggable2:
230+  C264 79               ld a,c                          ; load the vertical coord
231+  C265 3C               inc a                           ; next row down
232+  C266 D5               push de                         ; need e for later
233+  C267 11 20 00         ld de,32
234+  C26A 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
235+  C26B 4F               ld c,a                          ; copy vert coord back to c
236+  C26C D1               pop de                          ; get e back
237+  C26D 08               ex af,af'                       ; get loop counter back
238+  C26E 3D               dec a                           ; incease loop counter
239+  C26F C2 54 C2         jp nz, movement_spacebelowisdiggable0
240+  C272              movement_spacebelowisdiggable5:
241+  C272 21 78 C4         ld hl,player+6
242+  C275 36 01            ld (hl),1                       ; set the player into digging mode
243+  C277 23               inc hl
244+  C278 3A 5B C1         ld a,(movement_numberdigframes)
245+  C27B 77               ld (hl),a                       ; set the number of frame to dig for
246+  C27C 23               inc hl
247+  C27D 73               ld (hl),e                       ; set the number of pixels to dig
248+  C27E C9               ret
249+  C27F              movement_spacebelowisdiggable1:
250+  C27F 21 78 C4         ld hl,player+6
251+  C282 36 00            ld (hl),0                       ; set the player out of digging mode
252+  C284 C9               ret
253+  C285
254+  C285              ;
255+  C285              ; Checks the contents of a cell above are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
256+  C285              ; Inputs:
257+  C285              ; hl - memory location of top pixel row
258+  C285              ; bc - screen coords, b horiz, c vert
259+  C285              ; Outputs:
260+  C285              ; none - puts player into digging mode
261+  C285              ;
262+  C285              movement_spaceaboveisdiggable:
263+  C285 7E               ld a,(hl)                       ; get first pixel row
264+  C286 FE 55            cp 85
265+  C288 CA 93 C2         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
266+  C28B FE AA            cp 170
267+  C28D CA 93 C2         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
268+  C290 C3 3C C2         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
269+  C293              movement_spaceaboveisdiggable3:
270+  C293 3E 08            ld a,8                          ; rows to check
271+  C295 1E 00            ld e,0                          ; count of rows to dig
272+  C297              movement_spaceaboveisdiggable0:
273+  C297 08               ex af,af'                       ; store the loop counter
274+  C298 7E               ld a,(hl)                       ; get current pixel row
275+  C299 FE 55            cp 85
276+  C29B CA A6 C2         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
277+  C29E FE AA            cp 170
278+  C2A0 CA A6 C2         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
279+  C2A3 C3 B6 C2         jp movement_spaceaboveisdiggable5     ; don't count this row and stop counting
280+  C2A6              movement_spaceaboveisdiggable4:
281+  C2A6 1C               inc e                           ; inc count of rows to dig
282+  C2A7              movement_spaceaboveisdiggable2:
283+  C2A7 79               ld a,c                          ; load the vertical coord
284+  C2A8 3D               dec a                           ; next row up
285+  C2A9 D5               push de                         ; need e for later
286+  C2AA 11 20 00         ld de,32
287+  C2AD ED 52            sbc hl,de                       ; otherwise, just go one up for hl, which means sub 32, because of course
288+  C2AF 4F               ld c,a                          ; copy vert coord back to c
289+  C2B0 D1               pop de                          ; get e back
290+  C2B1 08               ex af,af'                       ; get loop counter back
291+  C2B2 3D               dec a                           ; incease loop counter
292+  C2B3 C2 97 C2         jp nz, movement_spaceaboveisdiggable0
293+  C2B6              movement_spaceaboveisdiggable5:
294+  C2B6 21 78 C4         ld hl,player+6
295+  C2B9 36 01            ld (hl),1                       ; set the player into digging mode
296+  C2BB 23               inc hl
297+  C2BC 3A 5B C1         ld a,(movement_numberdigframes)
298+  C2BF 77               ld (hl),a                       ; set the number of frame to dig for
299+  C2C0 23               inc hl
300+  C2C1 73               ld (hl),e                       ; set the number of pixels to dig
301+  C2C2 C9               ret
302+  C2C3              movement_spaceaboveisdiggable1:
303+  C2C3 21 78 C4         ld hl,player+6
304+  C2C6 36 00            ld (hl),0                       ; set the player out of digging mode
305+  C2C8 C9               ret
306+  C2C9
307+  C2C9              ;
308+  C2C9              ; Checks if the player can move down
309+  C2C9              ; Inputs:
310+  C2C9              ; bc - player coords, b horiz, c vert
311+  C2C9              ; Outputs:
312+  C2C9              ; de - 1 can move
313+  C2C9              movement_checkcanmove_down:
314+  C2C9 F5               push af
315+  C2CA C5               push bc
316+  C2CB CD 04 AC         call sprites_scadd              ; get the memory location of cell into de
317+  C2CE 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
318+  C2D0 24               inc h                       ; memory location of cell beneath now in hl
319+  C2D1 3E 08            ld a,8                       ; look below
320+  C2D3 81               add c
321+  C2D4 4F               ld c,a
322+  C2D5 CD D6 C1         call movement_linebelowisempty       ; check space is empty
323+  C2D8 7B               ld a,e                          ; check space empty flag
324+  C2D9 FE 00            cp 0
325+  C2DB CA E4 C2         jp z, movement_checkcanmove_down1 ; can't move
326+  C2DE CD 7D C6         call player_justmoved
327+  C2E1 C1               pop bc
328+  C2E2 F1               pop af
329+  C2E3 C9               ret
330+  C2E4              movement_checkcanmove_down1:
331+  C2E4 C1               pop bc
332+  C2E5 CD 04 AC         call sprites_scadd              ; get the memory location of cell into de
333+  C2E8 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
334+  C2EA 24               inc h
335+  C2EB C5               push bc
336+  C2EC CD 42 C2         call movement_spacebelowisdiggable    ; can't move here, but can we dig
337+  C2EF 11 00 00         ld de,0
338+  C2F2 C1               pop bc
339+  C2F3 F1               pop af
340+  C2F4 C9               ret
341+  C2F5
342+  C2F5              ;
343+  C2F5              ; Checks if the player can move up
344+  C2F5              ; Inputs:
345+  C2F5              ; bc - player coords, b horiz, c vert
346+  C2F5              ; Outputs:
347+  C2F5              ; de - 1 can move
348+  C2F5              movement_checkcanmove_up:
349+  C2F5 F5               push af
350+  C2F6 C5               push bc
351+  C2F7 CD 04 AC         call sprites_scadd              ; get the memory location of cell into de
352+  C2FA 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
353+  C2FC 11 20 00         ld de,32
354+  C2FF ED 52            sbc hl,de                       ; memory location of line above now in hl
355+  C301 0D               dec c                           ; look above
356+  C302 CD F1 C1         call movement_lineaboveisempty       ; check space is empty
357+  C305 7B               ld a,e                          ; check space empty flag
358+  C306 FE 00            cp 0
359+  C308 CA 13 C3         jp z, movement_checkcanmove_up1 ; can't move
360+  C30B 1E 01            ld e,1
361+  C30D CD 7D C6         call player_justmoved
362+  C310 C1               pop bc
363+  C311 F1               pop af
364+  C312 C9               ret
365+  C313              movement_checkcanmove_up1:
366+  C313 C1               pop bc
367+  C314 CD 04 AC         call sprites_scadd              ; get the memory location of cell into de
368+  C317 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
369+  C319 11 20 00         ld de,32
370+  C31C ED 52            sbc hl,de                       ; memory location of line above now in hl
371+  C31E C5               push bc
372+  C31F CD 85 C2         call movement_spaceaboveisdiggable    ; can't move here, but can we dig
373+  C322 11 00 00         ld de,0
374+  C325 C1               pop bc
375+  C326 F1               pop af
376+  C327 C9               ret
377+  C328
378+  C328              ;
379+  C328              ; Checks if the player can move right
380+  C328              ; Inputs:
381+  C328              ; bc - player coords, b horiz, c vert
382+  C328              ; Outputs:
383+  C328              ; de - 1 can move
384+  C328              movement_checkcanmove_right:
385+  C328 F5               push af
386+  C329 C5               push bc
387+  C32A CD 04 AC         call sprites_scadd              ; get the memory location of cell into de
388+  C32D 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
389+  C32F 3E 08            ld a,8
390+  C331 80               add b                           ; move one cell right
391+  C332 47               ld b,a
392+  C333 23               inc hl                          ; memory location of cell to the right now in hl
393+  C334 CD 5C C1         call movement_spaceisempty       ; check space is empty
394+  C337 7B               ld a,e                          ; check space empty flag
395+  C338 FE 00            cp 0
396+  C33A CA 43 C3         jp z, movement_checkcanmove_right1 ; can't move
397+  C33D CD 7D C6         call player_justmoved
398+  C340 C1               pop bc
399+  C341 F1               pop af
400+  C342 C9               ret
401+  C343              movement_checkcanmove_right1:
402+  C343 C1               pop bc
403+  C344 CD 04 AC         call sprites_scadd              ; get the memory location of cell into de
404+  C347 62 6B            ld hl,de
405+  C349 23               inc hl                          ; memory location of cell to the right now in hl
406+  C34A C5               push bc
407+  C34B CD 0C C2         call movement_spaceisdiggable    ; can't move here, but can we dig
408+  C34E 11 00 00         ld de,0
409+  C351 C1               pop bc
410+  C352 F1               pop af
411+  C353 C9               ret
412+  C354
413+  C354              ;
414+  C354              ; Checks if the player can move left
415+  C354              ; Inputs:
416+  C354              ; bc - player coords, b horiz, c vert
417+  C354              ; Outputs:
418+  C354              ; de - 1 can move
419+  C354              movement_checkcanmove_left:
420+  C354 F5               push af
421+  C355 C5               push bc
422+  C356 CD 04 AC         call sprites_scadd              ; get the memory location of cell into de
423+  C359 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
424+  C35B 78               ld a,b
425+  C35C 06 08            ld b,8
426+  C35E 90               sub b                           ; move one cell left
427+  C35F 47               ld b,a
428+  C360 2B               dec hl                          ; memory location of cell to the right now in hl
429+  C361 CD 5C C1         call movement_spaceisempty       ; check space is empty
430+  C364 7B               ld a,e                          ; check space empty flag
431+  C365 FE 00            cp 0
432+  C367 CA 70 C3         jp z, movement_checkcanmove_left1 ; can't move
433+  C36A CD 7D C6         call player_justmoved
434+  C36D C1               pop bc
435+  C36E F1               pop af
436+  C36F C9               ret
437+  C370              movement_checkcanmove_left1:
438+  C370 C1               pop bc
439+  C371 CD 04 AC         call sprites_scadd              ; get the memory location of cell into de
440+  C374 62 6B            ld hl,de
441+  C376 2B               dec hl                          ; memory location of cell to the right now in hl
442+  C377 C5               push bc
443+  C378 CD 0C C2         call movement_spaceisdiggable    ; can't move here, but can we dig
444+  C37B 11 00 00         ld de,0
445+  C37E C1               pop bc
446+  C37F F1               pop af
447+  C380 C9               ret
# file closed: game/movement.asm
154   C381                  include "game\game.asm"
# file opened: game/game.asm
  1+  C381              ;
  2+  C381              ; The current frame count, incremented each frame
  3+  C381              ;
  4+  C381              game_framenumber:
  5+  C381 00               defb    0
  6+  C382
  7+  C382              ;
  8+  C382              ; The number of players
  9+  C382              ;
 10+  C382              game_numberplayers:
 11+  C382 01               defb 1
 12+  C383
 13+  C383              ;
 14+  C383              ; The current player
 15+  C383              ;
 16+  C383              game_currentplayer:
 17+  C383 01               defb 1
 18+  C384
 19+  C384              ;
 20+  C384              ; The default number of lives
 21+  C384              ;
 22+  C384              game_numberlives:
 23+  C384 04               defb 4
 24+  C385
 25+  C385              ;
 26+  C385              ; The current difficulty
 27+  C385              ;
 28+  C385              game_difficulty:
 29+  C385 01               defb 1
 30+  C386
 31+  C386              ;
 32+  C386              ; Control method: 0 for keyboard, 1 for kempston
 33+  C386              ;
 34+  C386              game_control:
 35+  C386 00               defb 0
 36+  C387
 37+  C387              ;
 38+  C387              ; The current rocks used
 39+  C387              ;
 40+  C387              game_current_rocks:
 41+  C387 00 00            defb 0,0
 42+  C389
 43+  C389
 44+  C389              game_tankdifficulty:
 45+  C389 46 41 3C 37      defb 70,65,60,55,50,45,40,35,30,25,20,12
 45+  C38D 32 2D 28 23
 45+  C391 1E 19 14 0C
 46+  C395              game_pitdifficulty:
 47+  C395 07 05 05 04      defb 7,5,5,4,4,4,2,2,2,2,2,2
 47+  C399 04 04 02 02
 47+  C39D 02 02 02 02
 48+  C3A1              game_robotdifficulty:
 49+  C3A1 06 04 04 04      defb 6,4,4,4,3,3,3,2,0,0,0,0
 49+  C3A5 03 03 03 02
 49+  C3A9 00 00 00 00
 50+  C3AD              game_digdifficulty:
 51+  C3AD 14 0E 0A 0A      defb 20,14,10,10,8,8,8,8,6,6,6,4
 51+  C3B1 08 08 08 08
 51+  C3B5 06 06 06 04
 52+  C3B9              game_rockdifficulty:
 53+  C3B9 28 1C 14 14      defb 40,28,20,20,16,16,16,16,16,16,16,16
 53+  C3BD 10 10 10 10
 53+  C3C1 10 10 10 10
 54+  C3C5              game_missiledifficulty:
 55+  C3C5 46 32 2D 2D      defb 70,50,45,45,40,35,35,30,30,25,25,20
 55+  C3C9 28 23 23 1E
 55+  C3CD 1E 19 19 14
 56+  C3D1              ;
 57+  C3D1              ; Moves to the next player
 58+  C3D1              ;
 59+  C3D1              game_changeplayer:
 60+  C3D1 3A 82 C3         ld a,(game_numberplayers)
 61+  C3D4 FE 01            cp 1
 62+  C3D6 C8               ret z                       ; if just one player, no need to change
 63+  C3D7 3A 83 C3         ld a,(game_currentplayer)   ; get current player
 64+  C3DA 3D               dec a                       ; otherwise decrease by one
 65+  C3DB EE 01            xor 1                       ; xor with one to flip
 66+  C3DD 3C               inc a                       ; increment
 67+  C3DE 21 83 C3         ld hl,game_currentplayer
 68+  C3E1 77               ld (hl),a                   ; store
 69+  C3E2 C9               ret
 70+  C3E3
 71+  C3E3              ;
 72+  C3E3              ; Sets the number of players at the start of the game
 73+  C3E3              ; Inputs:
 74+  C3E3              ; a - number of players
 75+  C3E3              game_setnumberofplayers:
 76+  C3E3 21 82 C3         ld hl,game_numberplayers
 77+  C3E6 77               ld (hl),a
 78+  C3E7
 79+  C3E7              ;
 80+  C3E7              ; Starts a game
 81+  C3E7              ;
 82+  C3E7              game_init:
 83+  C3E7 3E 01            ld a,1
 84+  C3E9 32 83 C3         ld (game_currentplayer),a
 85+  C3EC C9               ret
 86+  C3ED
 87+  C3ED              ;
 88+  C3ED              ; Sets the current rock layout. Odd gets 1, even gets 2
 89+  C3ED              ;
 90+  C3ED              game_setcurrentrocks:
 91+  C3ED 3A 85 C3         ld a,(game_difficulty)
 92+  C3F0 E6 01            and 1
 93+  C3F2 FE 00            cp 0
 94+  C3F4 CA 02 C4         jp z,game_setcurrentrocks0
 95+  C3F7 11 F5 B4         ld de,level_rocks
 96+  C3FA 21 87 C3         ld hl,game_current_rocks
 97+  C3FD 73 23 72 2B      ld (hl),de
 98+  C401 C9               ret
 99+  C402              game_setcurrentrocks0:
100+  C402 11 F5 B5         ld de,level_rocks_alt
101+  C405 21 87 C3         ld hl,game_current_rocks
102+  C408 73 23 72 2B      ld (hl),de
103+  C40C C9               ret
104+  C40D
105+  C40D              ;
106+  C40D              ; Increment frame number by 1
107+  C40D              ;
108+  C40D              game_incrementframe:
109+  C40D 3A 81 C3         ld a,(game_framenumber)
110+  C410 FE FF            cp 255
111+  C412 C2 17 C4         jp nz,game_incrementframe0
112+  C415 3E 00            ld a,0
113+  C417              game_incrementframe0:
114+  C417 3C               inc a
115+  C418 32 81 C3         ld (game_framenumber),a
116+  C41B C9               ret
117+  C41C
118+  C41C              ;
119+  C41C              ; Returns current frame
120+  C41C              ; Outputs:
121+  C41C              ; a - current frame
122+  C41C              ;
123+  C41C              game_getcurrentframe:
124+  C41C 3A 81 C3         ld a,(game_framenumber)
125+  C41F C9               ret
126+  C420
127+  C420              ;
128+  C420              ; Resets current frame
129+  C420              ;
130+  C420              game_resetcurrentframe:
131+  C420 21 81 C3         ld hl,game_framenumber
132+  C423 36 00            ld (hl),0
133+  C425 C9               ret
134+  C426
135+  C426              ;
136+  C426              ; Increases the current difficulty
137+  C426              ;
138+  C426              game_increasedifficulty:
139+  C426 3A 85 C3         ld a,(game_difficulty)
140+  C429 3C               inc a
141+  C42A 32 85 C3         ld (game_difficulty),a
142+  C42D
143+  C42D              ;
144+  C42D              ; Sets the various difficulties
145+  C42D              ;
146+  C42D              game_setdifficulty:
147+  C42D 3A 85 C3         ld a,(game_difficulty)
148+  C430 FE 0D            cp 13
149+  C432 C2 37 C4         jp nz,game_setdifficulty0
150+  C435 3E 0C            ld a,12                         ; limit difficulty to twelve
151+  C437              game_setdifficulty0:
152+  C437 11 00 00         ld de,0
153+  C43A 5F               ld e,a                          ; keep the difficulty in de
154+  C43B                  ; Set the tank difficulty
155+  C43B 21 89 C3         ld hl,game_tankdifficulty
156+  C43E 2B               dec hl
157+  C43F 19               add hl,de                       ; add the difficulty
158+  C440 7E               ld a,(hl)                       ; get the value
159+  C441 32 F2 C7         ld (tank_speed),a               ; set the tank speed
160+  C444                  ; Set the pit difficulty
161+  C444 21 95 C3         ld hl,game_pitdifficulty
162+  C447 2B               dec hl
163+  C448 19               add hl,de                       ; add the difficulty
164+  C449 7E               ld a,(hl)                       ; get the value
165+  C44A 32 A7 CF         ld (thepit_speed),a               ; set the pit speed
166+  C44D                  ; Set the robot difficulty
167+  C44D 21 A1 C3         ld hl,game_robotdifficulty
168+  C450 2B               dec hl
169+  C451 19               add hl,de                       ; add the difficulty
170+  C452 7E               ld a,(hl)                       ; get the value
171+  C453 32 85 D1         ld (robots_robotspeed),a        ; set the robot speed
172+  C456                  ; Set the dig difficulty
173+  C456 21 AD C3         ld hl,game_digdifficulty
174+  C459 2B               dec hl
175+  C45A 19               add hl,de                       ; add the difficulty
176+  C45B 7E               ld a,(hl)                       ; get the value
177+  C45C 32 5B C1         ld (movement_numberdigframes),a ; set the dig frames
178+  C45F                  ; Set the rock difficulty
179+  C45F 21 B9 C3         ld hl,game_rockdifficulty
180+  C462 2B               dec hl
181+  C463 19               add hl,de                       ; add the difficulty
182+  C464 7E               ld a,(hl)                       ; get the value
183+  C465 32 F4 C9         ld (rocks_numberofframestowobble),a ; set the wobble frames
184+  C468                  ; Set the missile difficulty
185+  C468 21 C5 C3         ld hl,game_missiledifficulty
186+  C46B 2B               dec hl
187+  C46C 19               add hl,de                       ; add the difficulty
188+  C46D 7E               ld a,(hl)                       ; get the value
189+  C46E 32 E3 CD         ld (missiles_speed),a           ; set the missile difficulty
190+  C471 C9               ret
# file closed: game/game.asm
155   C472                  include "game\player.asm"
# file opened: game/player.asm
  1+  C472              ;
  2+  C472              ;   Data for current player
  3+  C472              ;
  4+  C472              player:
  5+  C472 00 00            defb    0,0                 ; horiz,vert (+0,+1)
  6+  C474 02 00 01         defb    2,0,1               ; dir (0 up, 1 left, 2 right, 3 down), frame, frame transition count (+2,+3,+4)
  7+  C477 00               defb    0                   ; auto move remaining (+5)
  8+  C478 00 00 00         defb    0,0,0               ; is digging (0 no), digging count, pixels to di (+6,+7,+8)
  9+  C47B 00               defb    0                   ; lives remaining (+9)
 10+  C47C 00               defb    0                   ; died this life (+10)
 11+  C47D 00 00            defb    0,0                 ; dying (+11), frames (+12)
 12+  C47F 00               defb    0                   ; can finish level, whether can finish level or not (+13)
 13+  C480 00               defb    0                   ; difficulty (+14)
 14+  C481
 15+  C481              player_location:
 16+  C481 00               defb 0                      ; 0 normal, 1 diamond cavern, 2 the pit
 17+  C482
 18+  C482              ;
 19+  C482              ; Works out which part of the screen the player is in
 20+  C482              ; Pit is between 3,9 and 8,9
 21+  C482              ; Diamond cavern is between 11,22 and 22,28
 22+  C482              ;
 23+  C482              player_getlocation:
 24+  C482 ED 4B 72 C4      ld bc,(player)              ; get screen coords
 25+  C486 CD 3D AA         call screen_getcharcoordsfromscreencoords ; get char coords, c horiz
 26+  C489 78               ld a,b                      ; check for pit first
 27+  C48A FE 09            cp 9                        ; if not on this row, not in the pit
 28+  C48C C2 9B C4         jp nz,player_getlocation0
 29+  C48F 79               ld a,c                      ; check horizontal
 30+  C490 FE 09            cp 9
 31+  C492 D2 9B C4         jp nc, player_getlocation0  ; if more than 9, not in the pit
 32+  C495 21 81 C4         ld hl,player_location
 33+  C498 36 02            ld (hl),2                   ; load location with 2, the pit
 34+  C49A C9               ret                         ; done
 35+  C49B              player_getlocation0:            ; check for diamond cavern
 36+  C49B 78               ld a,b                      ; first check vertical
 37+  C49C FE 16            cp 22                       ; if above row 22, then not in cavern
 38+  C49E DA B2 C4         jp c,player_getlocation1
 39+  C4A1 79               ld a,c                      ; get the horizontal next
 40+  C4A2 FE 0B            cp 11
 41+  C4A4 DA B2 C4         jp c,player_getlocation1    ; if less than 11 not in diamond cave
 42+  C4A7 FE 16            cp 22
 43+  C4A9 D2 B2 C4         jp nc,player_getlocation1    ; if less than 11 not in diamond cave
 44+  C4AC 21 81 C4         ld hl,player_location
 45+  C4AF 36 01            ld (hl),1                   ; load location with 1, the cavern
 46+  C4B1 C9               ret
 47+  C4B2              player_getlocation1:
 48+  C4B2 21 81 C4         ld hl,player_location
 49+  C4B5 36 00            ld (hl),0                   ; load location with 2, the pit
 50+  C4B7 C9               ret                         ; done
 51+  C4B8
 52+  C4B8
 53+  C4B8              ;
 54+  C4B8              ; Initializes a player at start of game
 55+  C4B8              ; Copy initial coords, copy lives, copy score
 56+  C4B8              ;
 57+  C4B8              player_init_gamestart:
 58+  C4B8 3A 84 C3         ld a,(game_numberlives)
 59+  C4BB 32 79 C5         ld (player1_lives),a
 60+  C4BE 32 7A C5         ld (player2_lives),a                        ; set the initial number of lives at game start
 61+  C4C1
 62+  C4C1 21 7D C5         ld hl,player1_score+2
 63+  C4C4 06 06            ld b,6
 64+  C4C6              player_init_gamestart0:
 65+  C4C6 36 30            ld (hl),48
 66+  C4C8 23               inc hl
 67+  C4C9 10 FB            djnz player_init_gamestart0                 ; zero out player 1 score
 68+  C4CB 21 86 C5         ld hl,player2_score+2
 69+  C4CE 06 06            ld b,6
 70+  C4D0              player_init_gamestart1:
 71+  C4D0 36 30            ld (hl),48
 72+  C4D2 23               inc hl
 73+  C4D3 10 FB            djnz player_init_gamestart1                 ; zero out player 2 score
 74+  C4D5 3E 01            ld a,1
 75+  C4D7 32 8D C5         ld (player1_difficulty),a
 76+  C4DA 32 8E C5         ld (player2_difficulty),a                   ; set player difficulties to zero
 77+  C4DD C9               ret
 78+  C4DE
 79+  C4DE              ;
 80+  C4DE              ; Initializes a player at start of a life
 81+  C4DE              ; Copy initial coords, copy lives, copy score
 82+  C4DE              ;
 83+  C4DE              player_init_lifestart:
 84+  C4DE 21 77 C4         ld hl,player+5
 85+  C4E1 06 09            ld b,9                      ; initialise 9 properties
 86+  C4E3              player_init_lifestart2:
 87+  C4E3 36 00            ld (hl),0
 88+  C4E5 23               inc hl
 89+  C4E6 10 FB            djnz player_init_lifestart2
 90+  C4E8
 91+  C4E8 21 74 C4         ld hl,player+2              ; initialise some properties
 92+  C4EB 36 02            ld (hl),2
 93+  C4ED 23               inc hl
 94+  C4EE 36 00            ld (hl),0
 95+  C4F0 23               inc hl
 96+  C4F1 36 01            ld (hl),1
 97+  C4F3
 98+  C4F3 ED 4B EB 80      ld bc,(init_coord)
 99+  C4F7 ED 43 72 C4      ld (player),bc
100+  C4FB
101+  C4FB 3A 83 C3         ld a,(game_currentplayer)
102+  C4FE FE 01            cp 1
103+  C500 C2 0D C5         jp nz,player_init_lifestart4
104+  C503 01 7B C4         ld bc,player+9
105+  C506 3A 79 C5         ld a,(player1_lives)
106+  C509 02               ld (bc),a
107+  C50A C3 14 C5         jp player_init_lifestart3
108+  C50D              player_init_lifestart4:
109+  C50D 01 7B C4         ld bc,player+9
110+  C510 3A 7A C5         ld a,(player2_lives)
111+  C513 02               ld (bc),a
112+  C514              player_init_lifestart3:
113+  C514 CD AB CD         call diamonds_init      ; initialise gems
114+  C517 01 06 00         ld bc,6
115+  C51A 11 57 CB         ld de,scores_current+2
116+  C51D 3A 83 C3         ld a,(game_currentplayer)
117+  C520 FE 01            cp 1
118+  C522 C2 31 C5         jp nz,player_init_lifestart0
119+  C525 3A 8D C5         ld a,(player1_difficulty)       ; initialise player 1 difficulty
120+  C528 32 85 C3         ld (game_difficulty),a
121+  C52B 21 7D C5         ld hl,player1_score+2           ; itialise player 1 scores
122+  C52E C3 3A C5         jp player_init_lifestart1
123+  C531              player_init_lifestart0:
124+  C531 3A 8E C5         ld a,(player2_difficulty)       ; initialise player 2 difficulty
125+  C534 32 85 C3         ld (game_difficulty),a
126+  C537 21 86 C5         ld hl,player2_score+2           ; initialise player 2 scores
127+  C53A              player_init_lifestart1:
128+  C53A ED B0            ldir
129+  C53C C9               ret
130+  C53D
131+  C53D
132+  C53D              ;
133+  C53D              ; Copies the current score and difficulty in the current player
134+  C53D              ;
135+  C53D              player_recordcurrentstate:
136+  C53D 01 06 00         ld bc,6                  ; copy current score back to correct player
137+  C540 21 57 CB         ld hl,scores_current+2
138+  C543 3A 83 C3         ld a,(game_currentplayer)
139+  C546 FE 01            cp 1
140+  C548 C2 5D C5         jp nz,player_recordcurrentstate0
141+  C54B 3A 85 C3         ld a,(game_difficulty)
142+  C54E 32 8D C5         ld (player1_difficulty),a       ; store difficulty
143+  C551 11 7D C5         ld de,player1_score+2
144+  C554 3A 7B C4         ld a,(player+9)
145+  C557 32 79 C5         ld (player1_lives),a              ; record lives
146+  C55A C3 6C C5         jp player_recordcurrentstate1
147+  C55D              player_recordcurrentstate0:         ; do player 2
148+  C55D 3A 85 C3         ld a,(game_difficulty)
149+  C560 32 8E C5         ld (player2_difficulty),a       ; store difficulty
150+  C563 3A 7B C4         ld a,(player+9)
151+  C566 32 7A C5         ld (player2_lives),a              ; record lives
152+  C569 11 86 C5         ld de,player2_score+2
153+  C56C              player_recordcurrentstate1:
154+  C56C ED B0            ldir
155+  C56E C9               ret
156+  C56F
157+  C56F              ;
158+  C56F              ; Player just died, subtract a life
159+  C56F              ;
160+  C56F              player_died:
161+  C56F 01 7B C4         ld bc,player+9
162+  C572 0A               ld a,(bc)
163+  C573 3D               dec a
164+  C574 02               ld (bc),a
165+  C575 CD 3D C5         call player_recordcurrentstate
166+  C578 C9               ret
167+  C579
168+  C579              ;
169+  C579              ; Player lives
170+  C579              ;
171+  C579              player1_lives:
172+  C579 03               defb 3
173+  C57A              player2_lives:
174+  C57A 03               defb 3
175+  C57B
176+  C57B              ;
177+  C57B              ; Player scores
178+  C57B              ;
179+  C57B              player1_score:
180+  C57B 04 01 30 30      defb 4,1,'000000',255
180+  C57F 30 30 30 30
180+  C583 FF
181+  C584              player2_score:
182+  C584 16 01 30 30      defb 22,1,'000000',255
182+  C588 30 30 30 30
182+  C58C FF
183+  C58D
184+  C58D              ;
185+  C58D              ; Player difficulties
186+  C58D              ;
187+  C58D              player1_difficulty:
188+  C58D 00               defb 0
189+  C58E              player2_difficulty:
190+  C58E 00               defb 0
191+  C58F
192+  C58F              ;
193+  C58F              ; Kills a player this life
194+  C58F              ;
195+  C58F              player_killplayer:
196+  C58F 21 7C C4         ld hl,player+10
197+  C592 36 01            ld (hl),1
198+  C594 C9               ret
199+  C595
200+  C595              ;
201+  C595              ; Crush a player this life
202+  C595              ;
203+  C595              player_crushplayer:
204+  C595 21 7D C4         ld hl,player+11             ; mark as crushed
205+  C598 36 01            ld (hl),1
206+  C59A C9               ret
207+  C59B
208+  C59B              player_tankkillplayer
209+  C59B 21 7D C4         ld hl,player+11             ; mark as tanked
210+  C59E 36 02            ld (hl),2
211+  C5A0 C9               ret
212+  C5A1
213+  C5A1              player_zonkplayer
214+  C5A1 21 7D C4         ld hl,player+11             ; mark as zonked (missile)
215+  C5A4 36 03            ld (hl),3
216+  C5A6 C9               ret
217+  C5A7
218+  C5A7              player_pitkillplayer
219+  C5A7 21 7D C4         ld hl,player+11             ; mark as pit killed
220+  C5AA 36 04            ld (hl),4
221+  C5AC C9               ret
222+  C5AD
223+  C5AD              player_robotkillplayer
224+  C5AD 21 7D C4         ld hl,player+11             ; mark as robot killed
225+  C5B0 36 05            ld (hl),5
226+  C5B2 C9               ret
227+  C5B3
228+  C5B3              ;
229+  C5B3              ; Draws the player at the current position or deletes them
230+  C5B3              ;
231+  C5B3              player_drawplayer:
232+  C5B3 3A 74 C4         ld a,(player+2)             ; get the current direction
233+  C5B6 FE 03            cp 3
234+  C5B8 C2 BD C5         jp nz,player_drawplayer0
235+  C5BB 3E 00            ld a,0                      ; if 3, then down, so set the direction to 0 since the sprite is the same as up
236+  C5BD              player_drawplayer0:             ; DYING CHECKS
237+  C5BD 5F               ld e,a                      ; store in e
238+  C5BE 3A 7D C4         ld a,(player+11)             ; get the dying flag
239+  C5C1 FE 01            cp 1
240+  C5C3 CA FD C5         jp z,player_drawplayer3     ; if it's one, we're being crushed
241+  C5C6 FE 04            cp 4
242+  C5C8 CA 45 C6         jp z,player_drawplayer9     ; player is falling into the pit
243+  C5CB FE 05            cp 5
244+  C5CD CA 61 C6         jp z,player_drawplayer12    ; player has been killed by a robot
245+  C5D0              player_drawplayer4:             ; CHECK FOR DIGGING
246+  C5D0 3A 78 C4         ld a,(player+6)             ; get the dig flag
247+  C5D3 FE 01            cp 1
248+  C5D5 CA E6 C5         jp z,player_drawplayer1    ; get dig frame
249+  C5D8 3A 75 C4         ld a,(player+3)             ; this is normal movement so get the current frame
250+  C5DB 83               add a,e
251+  C5DC C3 EB C5         jp player_drawplayer2
252+  C5DF              player_drawplayer6:             ; GETTING THE DIG FRAM
253+  C5DF E6 01            and 1                       ; check for odd
254+  C5E1 C6 0A            add 10                      ; add 10, to get either 10 or 11
255+  C5E3 C3 EB C5         jp player_drawplayer2
256+  C5E6              player_drawplayer1:             ; GET THE NORMAL FRAME
257+  C5E6 3A 74 C4         ld a,(player+2)             ; digging, get the current direction again, because want all four
258+  C5E9 C6 06            add a,6                     ; add direction to 6 to get frame
259+  C5EB              player_drawplayer2:             ; WORK OUT THE FRAME
260+  C5EB 07               rlca
261+  C5EC 07               rlca
262+  C5ED 07               rlca                        ; multiply by eight
263+  C5EE 6F               ld l,a
264+  C5EF 26 00            ld h,0
265+  C5F1 11 D6 BC         ld de,player_sprite
266+  C5F4 19               add hl,de                   ; load hl with the location of the player sprite data
267+  C5F5              player_drawplayer7:             ; DRAW THE PlAYER
268+  C5F5 ED 4B 72 C4      ld bc,(player)              ; load bc with the start coords
269+  C5F9 CD 0F AB         call sprites_drawsprite     ; call the routine to draw the sprite
270+  C5FC                  ;call player_storeupdatedlines ; log updated rows
271+  C5FC C9               ret
272+  C5FD              ;
273+  C5FD              ; CRUSHING
274+  C5FD              ;
275+  C5FD              player_drawplayer3:
276+  C5FD 21 7E C4         ld hl,player+12
277+  C600 7E               ld a,(hl)                  ; crushing, so get the current anim flag
278+  C601 FE 00            cp 0
279+  C603 C2 0C C6         jp nz,player_drawplayer5    ; if this isn't zero, then this isn't the first time round, so do the crush anim
280+  C606 3E 64            ld a,100
281+  C608 77               ld (hl),a                   ; otherwise, load up the anim frames
282+  C609 C3 D0 C5         jp player_drawplayer4       ; and return to the main loop to remove the current frame
283+  C60C              player_drawplayer5:
284+  C60C 3D               dec a
285+  C60D 77               ld (hl),a
286+  C60E FE 00            cp 0
287+  C610 CC 8F C5         call z,player_killplayer     ; final animation, so kill the player
288+  C613 FE 0A            cp 10                         ; play the sound
289+  C615 CC 24 B1         call z, sound_rockfell
290+  C618 FE 14            cp 20                        ; check if we should move the rock
291+  C61A C2 2E C6         jp nz,player_drawplayer8
292+  C61D D9               exx
293+  C61E F5               push af
294+  C61F ED 4B F5 C9      ld bc,(rocks_killerrock)    ; get the coords of the rock that killed us
295+  C623 21 22 BC         ld hl,sprites+72
296+  C626 CD 0F AB         call sprites_drawsprite     ; draw a rock over current
297+  C629 F1               pop af
298+  C62A D9               exx
299+  C62B C3 DF C5         jp player_drawplayer6       ; continue drawing player
300+  C62E              player_drawplayer8:
301+  C62E FE 14            cp 20
302+  C630 D2 DF C5         jp nc,player_drawplayer6    ; if not in last 10 frames, draw as normal
303+  C633 ED 4B 72 C4      ld bc,(player)
304+  C637 CD 3D AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
305+  C63A 3E 42            ld a,66             ; load red
306+  C63C CD 95 AA         call screen_setattr
307+  C63F 21 22 BC         ld hl,sprites+72            ; otherwise, player is rock
308+  C642 C3 F5 C5         jp player_drawplayer7
309+  C645              ;
310+  C645              ; FALLING
311+  C645              ;
312+  C645              player_drawplayer9:             ; player is falling into the pit
313+  C645 21 7E C4         ld hl,player+12
314+  C648 7E               ld a,(hl)                   ; get the frames
315+  C649 FE 00            cp 0
316+  C64B C2 54 C6         jp nz,player_drawplayer10    ; if this isn't zero, then this isn't the first time round, so do the crush anim
317+  C64E 3E 50            ld a,80
318+  C650 77               ld (hl),a                   ; otherwise, load up the anim frames
319+  C651 C3 D0 C5         jp player_drawplayer4       ; and return to the main loop to remove the current frame
320+  C654              player_drawplayer10:
321+  C654 3D               dec a
322+  C655 77               ld (hl),a
323+  C656 FE 00            cp 0
324+  C658 CC 8F C5         call z,player_killplayer     ; final frame, so kill the player
325+  C65B 3A 75 C4         ld a,(player+3)
326+  C65E C3 EB C5         jp player_drawplayer2
327+  C661              ;
328+  C661              ; ROBOT KILLED
329+  C661              ;
330+  C661              player_drawplayer12:
331+  C661 21 7E C4         ld hl,player+12
332+  C664 7E               ld a,(hl)                   ; get the frames
333+  C665 FE 00            cp 0
334+  C667 C2 70 C6         jp nz,player_drawplayer13    ; if this isn't zero, then this isn't the first time round, so do the crush anim
335+  C66A 3E C8            ld a,200
336+  C66C 77               ld (hl),a                   ; otherwise, load up the anim frames
337+  C66D C3 D0 C5         jp player_drawplayer4       ; and return to the main loop to remove the current frame
338+  C670              player_drawplayer13:
339+  C670 3D               dec a
340+  C671 77               ld (hl),a
341+  C672 FE 00            cp 0
342+  C674 CC 8F C5         call z,player_killplayer     ; final frame, so kill the player
343+  C677 3A 75 C4         ld a,(player+3)
344+  C67A C3 EB C5         jp player_drawplayer2
345+  C67D
346+  C67D              ;
347+  C67D              ; Runs after the player just moved. Changes animation frame if required
348+  C67D              ;
349+  C67D              player_justmoved:
350+  C67D D9               exx
351+  C67E 3A 76 C4         ld a,(player+4)             ; get the transition count
352+  C681 FE 00            cp 0
353+  C683 CA 89 C6         jp z, player_justmoved2     ; if zero reset and change the frame
354+  C686 C3 A3 C6         jp player_justmoved1       ; otherwise decrease and continue
355+  C689              player_justmoved2:
356+  C689                  ; reset and change frame in here
357+  C689 3E 01            ld a,1
358+  C68B 32 76 C4         ld (player+4),a            ; reset back to whatever
359+  C68E 3A 75 C4         ld a,(player+3)             ; load the frame
360+  C691 FE 03            cp 3                       ; flip between 3 and 0
361+  C693 C2 9B C6         jp nz, player_justmoved4
362+  C696 3E 00            ld a,0
363+  C698 C3 9D C6         jp player_justmoved5
364+  C69B              player_justmoved4:
365+  C69B 3E 03            ld a,3
366+  C69D              player_justmoved5:
367+  C69D 32 75 C4         ld (player+3),a           ; save back
368+  C6A0 C3 A7 C6         jp player_justmoved3
369+  C6A3              player_justmoved1:
370+  C6A3                  ; decrease count
371+  C6A3 3D               dec a
372+  C6A4 32 76 C4         ld (player+4),a
373+  C6A7              player_justmoved3:
374+  C6A7 D9               exx;
375+  C6A8 C9               ret
376+  C6A9
377+  C6A9              ;
378+  C6A9              ; Called if the player has collected a diamond. Checks the current coord. If it is the start coord, then return complete
379+  C6A9              ; Outputs:
380+  C6A9              ; a - 1 for completed level
381+  C6A9              player_checkforexit:
382+  C6A9 ED 4B 72 C4      ld bc,(player)                 ; get player coords
383+  C6AD ED 5B EB 80      ld de,(init_coord)             ; get start coords
384+  C6B1 78               ld a,b
385+  C6B2 BA               cp d                         ; compare horiz
386+  C6B3 C2 BE C6         jp nz,player_checkforexit1
387+  C6B6 79               ld a,c
388+  C6B7 BB               cp e                        ; compare vert
389+  C6B8 C2 BE C6         jp nz,player_checkforexit1
390+  C6BB              player_checkforexit0:
391+  C6BB 3E 01            ld a,1                       ; hasn't completed
392+  C6BD C9               ret
393+  C6BE              player_checkforexit1:
394+  C6BE 3E 00            ld a,0                       ; has completed
395+  C6C0 C9               ret
# file closed: game/player.asm
156   C6C1                  include "game\ship.asm"
# file opened: game/ship.asm
  1+  C6C1              ;
  2+  C6C1              ; Ship initial position: vert,horiz
  3+  C6C1              ;
  4+  C6C1              ship_initpos:
  5+  C6C1 00 24            defb 0,36
  6+  C6C3              ship_initpos2:
  7+  C6C3 00 00            defb 0,0
  8+  C6C5              ship_frame:
  9+  C6C5 00               defb 0
 10+  C6C6              ;
 11+  C6C6              ; The current memory location
 12+  C6C6              ;
 13+  C6C6              ship_current_sprite:
 14+  C6C6 00 00            defb 0,0
 15+  C6C8
 16+  C6C8              ship_current_coords:
 17+  C6C8 00 00            defb 0,0
 18+  C6CA
 19+  C6CA              ship_process:
 20+  C6CA 3A 7D C4         ld a,(player+11)
 21+  C6CD FE 02            cp 2                        ; has the player been killed by tank?
 22+  C6CF C0               ret nz                      ; do nothing if not
 23+  C6D0 CD 4E C1         call control_scroll_up           ; make sure the screen is on the top screen
 24+  C6D3 CD 42 C7         call ship_takeoff           ; bye bye
 25+  C6D6 CD 8F C5         call player_killplayer      ; killed
 26+  C6D9 06 32            ld b,50
 27+  C6DB CD 64 81         call utilities_pauseforframes
 28+  C6DE C9               ret
 29+  C6DF
 30+  C6DF              ;
 31+  C6DF              ;   Draw and land the ship - first move the ship down, then across, drawing the player in the middle
 32+  C6DF              ;
 33+  C6DF              ship_land:
 34+  C6DF ED 4B C1 C6      ld bc,(ship_initpos)
 35+  C6E3 ED 43 C3 C6      ld (ship_initpos2),bc        ; save the initial position for later use
 36+  C6E7 1E 00            ld e,0                      ; store a flag to track first time round
 37+  C6E9 06 09            ld b,9                      ; move down 8 pixels
 38+  C6EB              ship_land0:
 39+  C6EB C5               push bc
 40+  C6EC 7B               ld a,e
 41+  C6ED D5               push de                     ; store de for next time round
 42+  C6EE FE 01            cp 1                        ; check first time flag
 43+  C6F0 C2 05 C7         jp nz,ship_land1             ; don't draw over previous one if first time
 44+  C6F3 CD 8A C7         call ship_draw_full         ; delete old one
 45+  C6F6 CD 6E C7         call ship_change_frame      ; increment the frame
 46+  C6F9 ED 4B C3 C6      ld bc,(ship_initpos2)       ; get the current coords
 47+  C6FD 81 C6 01         add c,1                     ; move down one pixels
 48+  C700 4F               ld c,a
 49+  C701 ED 43 C3 C6      ld (ship_initpos2),bc
 50+  C705              ship_land1:
 51+  C705 CD 8A C7         call ship_draw_full         ; draw the ship
 52+  C708 CD 83 C7         call ship_draw_screen
 53+  C70B D1               pop de
 54+  C70C 1E 01            ld e,1
 55+  C70E C1               pop bc
 56+  C70F 10 DA            djnz ship_land0             ; repeat for downward movement
 57+  C711                  ; done moving down
 58+  C711                  ; now move across
 59+  C711 CD B3 C5         call player_drawplayer      ; draw player
 60+  C714 CD 8A C7         call ship_draw_full         ; delete old one
 61+  C717 1E 00            ld e,0                      ; store a flag to track first time round
 62+  C719 06 14            ld b,20                      ; move back 20 pixels pixels
 63+  C71B              ship_land3:
 64+  C71B C5               push bc
 65+  C71C 7B               ld a,e
 66+  C71D D5               push de                     ; store de for next time round
 67+  C71E FE 01            cp 1                        ; check first time flag
 68+  C720 C2 35 C7         jp nz,ship_land2             ; don't draw over previous one if first time
 69+  C723 CD 8A C7         call ship_draw_full         ; delete old one
 70+  C726 CD 6E C7         call ship_change_frame      ; increment the frame
 71+  C729 ED 4B C3 C6      ld bc,(ship_initpos2)       ; get the current coords
 72+  C72D 78               ld a,b
 73+  C72E D6 01            sub 1                       ; move back one pixels
 74+  C730 47               ld b,a
 75+  C731 ED 43 C3 C6      ld (ship_initpos2),bc
 76+  C735              ship_land2:
 77+  C735 CD 8A C7         call ship_draw_full         ; draw the ship
 78+  C738 CD 83 C7         call ship_draw_screen       ; draw the frame to screen by clearing the buffer
 79+  C73B D1               pop de
 80+  C73C 1E 01            ld e,1                      ; set e to 1 to indicate >1 time
 81+  C73E C1               pop bc
 82+  C73F 10 DA            djnz ship_land3             ; repeat for vertical movement
 83+  C741 C9               ret
 84+  C742
 85+  C742              ;
 86+  C742              ;   Take off the ship
 87+  C742              ;
 88+  C742              ship_takeoff:
 89+  C742 1E 01            ld e,1                      ; store a flag to track first time round
 90+  C744 06 08            ld b,8                      ; move up 8 pixels
 91+  C746              ship_takeoff0:
 92+  C746 C5               push bc
 93+  C747 7B               ld a,e
 94+  C748 D5               push de                     ; store de for next time round
 95+  C749 FE 01            cp 1                        ; check first time flag
 96+  C74B C2 61 C7         jp nz,ship_takeoff1             ; don't draw over previous one if first time
 97+  C74E ED 4B C3 C6      ld bc,(ship_initpos2)       ; get the current coords
 98+  C752 CD 8A C7         call ship_draw_full         ; delete old one
 99+  C755 CD 6E C7         call ship_change_frame      ; increment the frame
100+  C758 ED 4B C3 C6      ld bc,(ship_initpos2)       ; get the current coords
101+  C75C 0D               dec c                       ; move up one pixels
102+  C75D ED 43 C3 C6      ld (ship_initpos2),bc
103+  C761              ship_takeoff1:
104+  C761 CD 8A C7         call ship_draw_full         ; draw the ship
105+  C764 CD 83 C7         call ship_draw_screen
106+  C767 D1               pop de
107+  C768 1E 01            ld e,1
108+  C76A C1               pop bc
109+  C76B 10 D9            djnz ship_takeoff0             ; repeat for upward movement
110+  C76D                  ; done moving up
111+  C76D C9               ret
112+  C76E
113+  C76E              ;
114+  C76E              ; Swap the animation frame between 0 and 32. This will be added to the memory location later
115+  C76E              ;
116+  C76E              ship_change_frame:
117+  C76E F5               push af
118+  C76F 3A C5 C6         ld a,(ship_frame)
119+  C772 FE 00            cp 0
120+  C774 CA 7C C7         jp z,ship_change_frame0
121+  C777 3E 00            ld a,0                      ; flip to 0
122+  C779 C3 7E C7         jp ship_change_frame1
123+  C77C              ship_change_frame0:
124+  C77C 3E 20            ld a,32                      ; flip to 32
125+  C77E              ship_change_frame1:
126+  C77E 32 C5 C6         ld (ship_frame),a            ; save the frame
127+  C781 F1               pop af
128+  C782 C9               ret
129+  C783
130+  C783              ship_draw_screen:
131+  C783 76               halt
132+  C784 F3               di
133+  C785 CD 06 A8         call buffer_buffertoscreen  ; copy buffer to screen
134+  C788 FB               ei                          ; enable interupts
135+  C789 C9               ret
136+  C78A
137+  C78A              ship_draw_full:
138+  C78A 21 46 BD         ld hl,ship_sprite
139+  C78D ED 4B C3 C6      ld bc,(ship_initpos2)         ; load bc with the start coords
140+  C791 22 C6 C6         ld (ship_current_sprite),hl  ; put into memory
141+  C794 ED 43 C8 C6      ld (ship_current_coords),bc  ; put into memory
142+  C798 CD B7 C7         call ship_draw
143+  C79B 08               ex af,af'
144+  C79C 3A C5 C6         ld a,(ship_frame)            ; get the animation frame
145+  C79F 16 00            ld d,0
146+  C7A1 5F               ld e,a
147+  C7A2 19               add hl,de
148+  C7A3 22 C6 C6         ld (ship_current_sprite),hl  ; put into memory
149+  C7A6 08               ex af,af'
150+  C7A7 ED 4B C3 C6      ld bc,(ship_initpos2)         ; load bc with the start coords
151+  C7AB 81 C6 08         add c,8                      ; move one line down
152+  C7AE 4F               ld c,a
153+  C7AF ED 43 C8 C6      ld (ship_current_coords),bc  ; put into memory
154+  C7B3 CD B7 C7         call ship_draw
155+  C7B6 C9               ret
156+  C7B7
157+  C7B7              ;
158+  C7B7              ; Draw the ship
159+  C7B7              ; Inputs:
160+  C7B7              ; None, all in memory
161+  C7B7              ;
162+  C7B7              ship_draw:
163+  C7B7 3E 04            ld a,4                              ; 4 pieces per half
164+  C7B9              ship_draw0:
165+  C7B9 F5               push af
166+  C7BA 2A C6 C6         ld hl,(ship_current_sprite)
167+  C7BD ED 4B C8 C6      ld bc,(ship_current_coords)         ; load bc with the start coords
168+  C7C1 CD 0F AB         call sprites_drawsprite
169+  C7C4 2A C6 C6         ld hl,(ship_current_sprite)
170+  C7C7 ED 4B C8 C6      ld bc,(ship_current_coords)         ; load bc with the start coords
171+  C7CB 11 08 00         ld de,8
172+  C7CE 19               add hl,de
173+  C7CF 80 C6 08         add b,8
174+  C7D2 47               ld b,a
175+  C7D3 22 C6 C6         ld (ship_current_sprite),hl         ; put into memory
176+  C7D6 ED 43 C8 C6      ld (ship_current_coords),bc         ; put into memory
177+  C7DA F1               pop af
178+  C7DB 3D               dec a
179+  C7DC FE 00            cp 0
180+  C7DE C2 B9 C7         jp nz,ship_draw0
181+  C7E1
182+  C7E1 C9               ret
183+  C7E2
# file closed: game/ship.asm
157   C7E2                  include "game\tank.asm"
# file opened: game/tank.asm
  1+  C7E2              ;
  2+  C7E2              ; tank initial position: vert,horiz
  3+  C7E2              ;
  4+  C7E2              tank_initpos:
  5+  C7E2 10 D0            defb 16,208
  6+  C7E4              tank_initpos2:
  7+  C7E4 00 00            defb 0,0
  8+  C7E6              tank_frame:
  9+  C7E6 00               defb 0
 10+  C7E7              tank_anim:
 11+  C7E7 11               defb 17
 12+  C7E8
 13+  C7E8              ;
 14+  C7E8              ; The damage countdown
 15+  C7E8              ;
 16+  C7E8              tank_currentdamage:
 17+  C7E8 F0               defb 240
 18+  C7E9
 19+  C7E9              ;
 20+  C7E9              ; The damage coordinate
 21+  C7E9              ;
 22+  C7E9              tank_currentdamagecoord:
 23+  C7E9 16 02            defb 22,2
 24+  C7EB
 25+  C7EB              ;
 26+  C7EB              ; Controls when the tank shoots
 27+  C7EB              ;
 28+  C7EB              tank_count:
 29+  C7EB 00               defb 0
 30+  C7EC
 31+  C7EC              ;
 32+  C7EC              ; Holds the block number of the current damage sprite
 33+  C7EC              ;
 34+  C7EC              tank_damageframe:
 35+  C7EC 00               defb 0
 36+  C7ED
 37+  C7ED              ;
 38+  C7ED              ; The current memory location
 39+  C7ED              ;
 40+  C7ED              tank_current_sprite:
 41+  C7ED 00 00            defb 0,0
 42+  C7EF
 43+  C7EF              tank_current_coords:
 44+  C7EF 00 00            defb 0,0
 45+  C7F1
 46+  C7F1              ;
 47+  C7F1              ; Is the missile displayed - will be 19 if so, 0 if not
 48+  C7F1              ;
 49+  C7F1              tank_missile_displayed:
 50+  C7F1 00               defb 0
 51+  C7F2
 52+  C7F2              ;
 53+  C7F2              ; Speed that the tank fires
 54+  C7F2              ;
 55+  C7F2              tank_speed:
 56+  C7F2 00               defb 0
 57+  C7F3
 58+  C7F3              ;
 59+  C7F3              ; Initialise the tank
 60+  C7F3              ;
 61+  C7F3              tank_init:
 62+  C7F3 ED 4B E2 C7      ld bc,(tank_initpos)
 63+  C7F7 ED 43 E4 C7      ld (tank_initpos2),bc       ; save the initial position for later use
 64+  C7FB 21 E6 C7         ld hl,tank_frame
 65+  C7FE 36 00            ld (hl),0
 66+  C800 21 E7 C7         ld hl,tank_anim
 67+  C803 36 11            ld (hl),17
 68+  C805 21 EC C7         ld hl,tank_damageframe              ; reset tank
 69+  C808 36 00            ld (hl),0
 70+  C80A 21 EB C7         ld hl,tank_count
 71+  C80D 36 00            ld (hl),0
 72+  C80F 21 E8 C7         ld hl,tank_currentdamage
 73+  C812 36 F0            ld (hl),240
 74+  C814 21 E9 C7         ld hl,tank_currentdamagecoord
 75+  C817 36 16            ld (hl),22
 76+  C819 23               inc hl
 77+  C81A 36 02            ld (hl),2
 78+  C81C 21 F1 C7         ld hl,tank_missile_displayed
 79+  C81F 36 00            ld (hl),0
 80+  C821
 81+  C821 C9               ret
 82+  C822
 83+  C822              ;
 84+  C822              ;   Draw and move the tank
 85+  C822              ;   Start processing at frame 200
 86+  C822              ;   Don't move if anim is zero
 87+  C822              ;   Decrement frame if moved
 88+  C822              ;
 89+  C822              tank_process:
 90+  C822 3A E7 C7         ld a,(tank_anim)
 91+  C825 FE 00            cp 0
 92+  C827 C2 2E C8         jp nz,tank_process0         ; fire the tank if we've already moved, or jump to movement
 93+  C82A CD 3F C8         call tank_fire
 94+  C82D C9               ret
 95+  C82E              tank_process0:
 96+  C82E CD 1C C4         call game_getcurrentframe   ; get the current frame number into a
 97+  C831 FE 4B            cp 75
 98+  C833 D8               ret c                       ; return if the frame number is below 100
 99+  C834 CD 68 C9         call tank_move              ; move tank if not
100+  C837 3A E7 C7         ld a,(tank_anim)
101+  C83A 3D               dec a
102+  C83B 32 E7 C7         ld (tank_anim),a            ; decrease the anim count
103+  C83E C9               ret
104+  C83F
105+  C83F              ;
106+  C83F              ; Fires the tank
107+  C83F              ;
108+  C83F              tank_fire:
109+  C83F 3A EB C7         ld a,(tank_count)            ; if not, don't do anything
110+  C842 3C               inc a                        ; increment
111+  C843 ED 5B F2 C7      ld de,(tank_speed)
112+  C847 BB               cp e                        ; have we reached the speed
113+  C848 C2 4D C8         jp nz,tank_fire0
114+  C84B 3E 00            ld a,0                       ; reset if reached fifty
115+  C84D              tank_fire0:                      ; DEALING WITH A NEW BLOCK
116+  C84D 32 EB C7         ld (tank_count),a            ; store tank count
117+  C850 FE 00            cp 0
118+  C852 CA 73 C8         jp z,tank_fire7              ; If this is zero, fire
119+  C855 3A F1 C7         ld a,(tank_missile_displayed) ; is the missile displaying?
120+  C858 FE 00            cp 0
121+  C85A C8               ret z                       ; don't do anything if not
122+  C85B CD 22 C9         call tank_missilegraphic     ; if not, overwrite the previous tank missile
123+  C85E 3E 00            ld a,0                       ; reset the flag
124+  C860 32 F1 C7         ld (tank_missile_displayed),a
125+  C863 3E 02            ld a,2
126+  C865 ED 4B E9 C7      ld bc,(tank_currentdamagecoord)
127+  C869 0C               inc c
128+  C86A 0C               inc c
129+  C86B ED 43 26 AC      ld (origcoords),bc
130+  C86F CD 2B A7         call buffer_marklineforupdate
131+  C872 C9               ret                        ; only shoot if we're on 0
132+  C873              tank_fire7:
133+  C873 3A E8 C7         ld a,(tank_currentdamage)    ; get the damage countdown
134+  C876 E6 07            and 7                       ; check if multiple of 8 - house keeping when moving onto a new block
135+  C878 C2 AE C8         jp nz,tank_fire1            ; not, so just do a normal frame
136+  C87B ED 4B E9 C7      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
137+  C87F 79               ld a,c
138+  C880 FE 0A            cp 10
139+  C882 C2 89 C8         jp nz, tank_fire6
140+  C885 CD 5A C9         call tank_killedbytank      ; we're through, so the player has died. Kill them.
141+  C888 C9               ret                         ; return if we're through the mountain
142+  C889              tank_fire6:
143+  C889 3E 0F            ld a,15
144+  C88B 32 EC C7         ld (tank_damageframe),a     ; reset the damage frame
145+  C88E 21 DA BB         ld hl,sprites               ; location of the empty block
146+  C891 CD 67 AA         call screen_showchar        ; show this character here
147+  C894 ED 4B E9 C7      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
148+  C898 05               dec b                       ; look one above
149+  C899 CD CB AA         call screen_ischarempty     ; check if it is empty
150+  C89C ED 4B E9 C7      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc again
151+  C8A0 FE 01            cp 1
152+  C8A2 C2 E5 C8         jp nz,tank_fire2             ; block above isn't empty, so can't move on, copy down above blocks
153+  C8A5 ED 4B E9 C7      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
154+  C8A9 0D               dec c
155+  C8AA ED 43 E9 C7      ld (tank_currentdamagecoord),bc ; store the coord
156+  C8AE              tank_fire1:                         ; DEALING WITH NORMAL DAMAGE
157+  C8AE ED 4B E9 C7      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
158+  C8B2 3A E8 C7         ld a,(tank_currentdamage)    ; get the damage countdown
159+  C8B5 E6 07            and 7                       ; is it a multiple of 8? only want to do the first line check then
160+  C8B7 C2 C2 C8         jp nz, tank_fire5
161+  C8BA CD FB AA         call screen_getcharfirstbyte    ; get the first byte to check if this is a slope
162+  C8BD FE FF            cp 255                      ; if it's a full line, it will be 255 and not a slope
163+  C8BF C2 03 C9         jp nz,tank_fire3            ; if it's a slope, handle this differently
164+  C8C2              tank_fire5:
165+  C8C2 3A EC C7         ld a,(tank_damageframe)
166+  C8C5 CD 8A AA         call screen_getblock        ; get the block data into hl
167+  C8C8 CD 67 AA         call screen_showchar        ; show this character here
168+  C8CB 3A EC C7         ld a,(tank_damageframe)
169+  C8CE 3C               inc a
170+  C8CF 32 EC C7         ld (tank_damageframe),a     ; increment the damage block and store
171+  C8D2 3A E8 C7         ld a,(tank_currentdamage)    ; get the damage countdown
172+  C8D5 3D               dec a
173+  C8D6 3D               dec a
174+  C8D7 32 E8 C7         ld (tank_currentdamage),a     ; decrease current damage by 2 and store
175+  C8DA 3A F1 C7         ld a,(tank_missile_displayed) ; is the missile displaying?
176+  C8DD FE 00            cp 0
177+  C8DF CC 22 C9         call z, tank_missilegraphic
178+  C8E2 C3 0C C9         jp tank_fire4
179+  C8E5              tank_fire2:                     ; DEALING WITH COPYING BLOCKS FROM ABOVE
180+  C8E5 05               dec b
181+  C8E6 C5               push bc
182+  C8E7 CD E4 AA         call screen_copyblockdown       ; copy the block down
183+  C8EA ED 4B E9 C7      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
184+  C8EE C1               pop bc                      ; get the coord we just checked back
185+  C8EF 78               ld a,b
186+  C8F0 FE 00            cp 0
187+  C8F2 CA AE C8         jp z,tank_fire1             ; if we're at the top of the screen, don't check any more
188+  C8F5 C5               push bc
189+  C8F6 05               dec b
190+  C8F7 CD CB AA         call screen_ischarempty     ; check if it is empty
191+  C8FA C1               pop bc
192+  C8FB FE 01            cp 1                        ; if empty
193+  C8FD C2 E5 C8         jp nz, tank_fire2            ; copy another one down
194+  C900 C3 AE C8         jp tank_fire1               ; otherwise, return to main thread
195+  C903              tank_fire3:                      ; dealing with slopes
196+  C903 3A E8 C7         ld a,(tank_currentdamage)    ; get the damage countdown
197+  C906 06 08            ld b,8
198+  C908 90               sub b                        ; special case for slopes
199+  C909 32 E8 C7         ld (tank_currentdamage),a    ; decrease the damage countdown by 8, so that next time, we get rid of this block without eroding it
200+  C90C              tank_fire4:                     ; TIDY UP
201+  C90C ED 4B E9 C7      ld bc,(tank_currentdamagecoord)
202+  C910 ED 43 26 AC      ld (origcoords),bc
203+  C914 CD 2B A7         call buffer_marklineforupdate
204+  C917 3E 01            ld a,1
205+  C919 CD 2B A7         call buffer_marklineforupdate
206+  C91C 3E 02            ld a,2
207+  C91E CD 2B A7         call buffer_marklineforupdate
208+  C921 C9               ret
209+  C922
210+  C922              ;
211+  C922              ; Displays or hides the missile graphic, and changes the gun
212+  C922              ;
213+  C922              tank_missilegraphic:
214+  C922 3A F1 C7         ld a,(tank_missile_displayed)
215+  C925 FE 00            cp 0
216+  C927 C2 2F C9         jp nz,tank_missilegraphic0
217+  C92A 3E 13            ld a,19
218+  C92C C3 31 C9         jp tank_missilegraphic1
219+  C92F              tank_missilegraphic0:
220+  C92F 3E 00            ld a,0
221+  C931              tank_missilegraphic1:
222+  C931 32 F1 C7         ld (tank_missile_displayed),a ; store the flipped graphic
223+  C934 ED 4B E9 C7      ld bc,(tank_currentdamagecoord)
224+  C938 0C               inc c
225+  C939 0C               inc c                   ; print the graphic 2 spaces right
226+  C93A CD 8A AA         call screen_getblock        ; get the block data into hl
227+  C93D CD 67 AA         call screen_showchar        ; show this character here
228+  C940 06 02            ld b,2
229+  C942 0E 18            ld c,24                     ; set gunbarrel coords
230+  C944 11 00 00         ld de,0
231+  C947 21 A6 BD         ld hl,tank_sprite           ; set hl to gunbarrel gfx, shooting is +64
232+  C94A 3A F1 C7         ld a,(tank_missile_displayed)
233+  C94D FE 00            cp 0
234+  C94F CA 55 C9         jp z,tank_missilegraphic2
235+  C952 11 40 00         ld de,64
236+  C955              tank_missilegraphic2:
237+  C955 19               add hl,de                   ; work out missile graphic
238+  C956 CD 67 AA         call screen_showchar        ; show this character here
239+  C959 C9               ret
240+  C95A
241+  C95A              ;
242+  C95A              ; Deal with the player being killed by the tank
243+  C95A              ;
244+  C95A              tank_killedbytank:
245+  C95A ED 4B E9 C7      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
246+  C95E 21 DA BB         ld hl,sprites                   ; empty sprite
247+  C961 CD 67 AA         call screen_showchar            ; hide the last piece of dirt
248+  C964 CD 9B C5         call player_tankkillplayer
249+  C967 C9               ret
250+  C968
251+  C968              tank_move:
252+  C968 ED 4B E4 C7      ld bc,(tank_initpos2)
253+  C96C C5               push bc
254+  C96D 3A E7 C7         ld a,(tank_anim)
255+  C970 FE 11            cp 17                       ; check first time flag
256+  C972 CA 84 C9         jp z,tank_move1             ; don't draw over previous one if first time
257+  C975 CD 89 C9         call tank_draw_full         ; delete old one
258+  C978 ED 4B E4 C7      ld bc,(tank_initpos2)       ; get the current coords
259+  C97C 78               ld a,b
260+  C97D D6 01            sub 1                       ; move back one pixels
261+  C97F 47               ld b,a
262+  C980 ED 43 E4 C7      ld (tank_initpos2),bc
263+  C984              tank_move1:
264+  C984 CD 89 C9         call tank_draw_full         ; draw the tank
265+  C987 C1               pop bc
266+  C988 C9               ret
267+  C989
268+  C989              tank_draw_full:
269+  C989 21 A6 BD         ld hl,tank_sprite
270+  C98C ED 4B E4 C7      ld bc,(tank_initpos2)         ; load bc with the start coords
271+  C990 22 ED C7         ld (tank_current_sprite),hl  ; put into memory
272+  C993 ED 43 EF C7      ld (tank_current_coords),bc  ; put into memory
273+  C997 CD B6 C9         call tank_draw
274+  C99A 08               ex af,af'
275+  C99B 3A E6 C7         ld a,(tank_frame)            ; get the animation frame
276+  C99E 16 00            ld d,0
277+  C9A0 5F               ld e,a
278+  C9A1 19               add hl,de
279+  C9A2 22 ED C7         ld (tank_current_sprite),hl  ; put into memory
280+  C9A5 08               ex af,af'
281+  C9A6 ED 4B E4 C7      ld bc,(tank_initpos2)         ; load bc with the start coords
282+  C9AA 81 C6 08         add c,8                      ; move one line down
283+  C9AD 4F               ld c,a
284+  C9AE ED 43 EF C7      ld (tank_current_coords),bc  ; put into memory
285+  C9B2 CD B6 C9         call tank_draw
286+  C9B5 C9               ret
287+  C9B6
288+  C9B6              ;
289+  C9B6              ; Draw the tank
290+  C9B6              ; Inputs:
291+  C9B6              ; None, all in memory
292+  C9B6              ;
293+  C9B6              tank_draw:
294+  C9B6 3E 04            ld a,4                              ; 4 pieces per half
295+  C9B8              tank_draw0:
296+  C9B8 F5               push af
297+  C9B9 2A ED C7         ld hl,(tank_current_sprite)
298+  C9BC ED 4B EF C7      ld bc,(tank_current_coords)         ; load bc with the start coords
299+  C9C0 CD 0F AB         call sprites_drawsprite
300+  C9C3 2A ED C7         ld hl,(tank_current_sprite)
301+  C9C6 ED 4B EF C7      ld bc,(tank_current_coords)         ; load bc with the start coords
302+  C9CA 11 08 00         ld de,8
303+  C9CD 19               add hl,de
304+  C9CE 80 C6 08         add b,8
305+  C9D1 47               ld b,a
306+  C9D2 22 ED C7         ld (tank_current_sprite),hl         ; put into memory
307+  C9D5 ED 43 EF C7      ld (tank_current_coords),bc         ; put into memory
308+  C9D9 F1               pop af
309+  C9DA 3D               dec a
310+  C9DB FE 00            cp 0
311+  C9DD C2 B8 C9         jp nz,tank_draw0
312+  C9E0
313+  C9E0 C9               ret
314+  C9E1
# file closed: game/tank.asm
158   C9E1                  include "game\rocks.asm"
# file opened: game/rocks.asm
  1+  C9E1              ;
  2+  C9E1              ; A structure of falling rocks
  3+  C9E1              ; Assume we'll never have more than 4 falling at any one time
  4+  C9E1              ; (1,2 - 16 bit memory location for rock graphic),state (0 fell, 1 falling, 2 wobbling), countdown
  5+  C9E1              ;
  6+  C9E1              rocks_falling:
  7+  C9E1 00 00 00 00      defb 0,0,0,0
  8+  C9E5 00 00 00 00      defb 0,0,0,0
  9+  C9E9 00 00 00 00      defb 0,0,0,0
 10+  C9ED 00 00 00 00      defb 0,0,0,0
 11+  C9F1
 12+  C9F1              rocks_tmp:
 13+  C9F1 00               defb 0
 14+  C9F2
 15+  C9F2              rocks_tmp2:
 16+  C9F2 00 00            defb 0,0
 17+  C9F4
 18+  C9F4              ;
 19+  C9F4              ; The number of frames to wobble for
 20+  C9F4              ; Must always be 10 more than the number of frames a player digs
 21+  C9F4              ;
 22+  C9F4              rocks_numberofframestowobble:
 23+  C9F4 14               defb 20
 24+  C9F5
 25+  C9F5              ;
 26+  C9F5              ; Coords of the rock that killed us
 27+  C9F5              ;
 28+  C9F5              rocks_killerrock:
 29+  C9F5 00 00            defb 0,0
 30+  C9F7
 31+  C9F7              ;
 32+  C9F7              ; Checks for a rock that needs to start falling. Takes a memory location of the first line at the bottom of the space.
 33+  C9F7              ; Checks to see if the pixel row in that location is a rock bottom. If it is, mark this rock as ready to fall.
 34+  C9F7              ; If the pixel row is not the rock bottom, stop checking.
 35+  C9F7              ; Inputs:
 36+  C9F7              ; hl- memory location
 37+  C9F7              ;
 38+  C9F7              rocks_checkforfalling:
 39+  C9F7 7E               ld a,(hl)           ; get the pixel row in this memory location
 40+  C9F8 FE 7E            cp 126              ; check against the bottom pixel row of the rock graphic
 41+  C9FA C2 00 CA         jp nz,rocks_checkforfalling2 ; not a rock, stop
 42+  C9FD CD 01 CA         call rocks_addrocktofalling ; mark the rock as falling
 43+  CA00              rocks_checkforfalling2:
 44+  CA00 C9               ret
 45+  CA01
 46+  CA01              ;
 47+  CA01              ; Adds the rock to the structure that tracks falling rocks
 48+  CA01              ; Inputs:
 49+  CA01              ; hl - memory location of falling rock graphic
 50+  CA01              ; bc - coords of rock, c vert
 51+  CA01              rocks_addrocktofalling:
 52+  CA01 C5               push bc             ; store the coords
 53+  CA02 11 E1 C9         ld de,rocks_falling
 54+  CA05 06 04            ld b,4              ; number of possible falling rocks
 55+  CA07              rocks_addrocktofalling0:
 56+  CA07 13               inc de
 57+  CA08                  ;inc de
 58+  CA08 13               inc de              ; move three along to get the state
 59+  CA09 1A               ld a,(de)           ; load the state
 60+  CA0A FE 00            cp 0                ; check if this is not falling
 61+  CA0C C2 23 CA         jp nz,rocks_addrocktofalling1 ; continue the loop if not 0
 62+  CA0F 13               inc de              ; move to frame
 63+  CA10 3A F4 C9         ld a,(rocks_numberofframestowobble) ; load the number of frames to wobble
 64+  CA13 12               ld (de),a
 65+  CA14 1B               dec de              ; move de back to state
 66+  CA15 3E 02            ld a,2
 67+  CA17 12               ld (de),a           ; set the state to wobbling
 68+  CA18 1B               dec de              ; move back coords
 69+  CA19 C1               pop bc              ; get back coords
 70+  CA1A 78               ld a,b
 71+  CA1B 12               ld (de),a           ; store the vertical
 72+  CA1C 1B               dec de
 73+  CA1D 79               ld a,c
 74+  CA1E 12               ld (de),a           ; store the horizontal
 75+  CA1F C5               push bc
 76+  CA20 C3 27 CA         jp rocks_addrocktofalling2 ; done
 77+  CA23              rocks_addrocktofalling1:
 78+  CA23 13               inc de
 79+  CA24 13               inc de              ; move memory along to next rock
 80+  CA25 10 E0            djnz rocks_addrocktofalling0 ; try the next rock
 81+  CA27              rocks_addrocktofalling2: ; done, return
 82+  CA27 C1               pop bc              ; to tidy up
 83+  CA28 C9               ret
 84+  CA29
 85+  CA29              ;
 86+  CA29              ; Processes any falling rocks
 87+  CA29              ;
 88+  CA29              rocks_processrocks:
 89+  CA29 DD 21 E1 C9      ld ix,rocks_falling
 90+  CA2D 06 04            ld b,4              ; the number of rocks to check
 91+  CA2F              rocks_processrocks0:
 92+  CA2F C5               push bc             ; store loop count
 93+  CA30 DD 4E 00 DD      ld bc,(ix)          ; load the coords for this rock into bc
 93+  CA34 46 01
 94+  CA36 DD 23            inc ix
 95+  CA38 DD 23            inc ix              ; move to the state
 96+  CA3A DD 7E 00         ld a,(ix)           ; load the state into a
 97+  CA3D FE 00            cp 0
 98+  CA3F CA 60 CA         jp z,rocks_processrocks3 ; if not falling, check next
 99+  CA42 FE 02            cp 2
100+  CA44 C2 54 CA         jp nz, rocks_processrocks2
101+  CA47                  ; we're wobbling
102+  CA47 DD 23            inc ix              ; get frame number for wobble
103+  CA49 DD 7E 00         ld a,(ix)           ; get wobble frame into a
104+  CA4C CD 23 CB         call rocks_wobble
105+  CA4F DD 23            inc ix              ; increment for next
106+  CA51 C3 64 CA         jp rocks_processrocks1  ; do next rock
107+  CA54              rocks_processrocks2:
108+  CA54                  ; we're falling
109+  CA54 C5               push bc
110+  CA55 CD 68 CA         call rocks_fall
111+  CA58 C1               pop bc
112+  CA59 DD 23            inc ix
113+  CA5B DD 23            inc ix              ; inc ix to get to next
114+  CA5D C3 64 CA         jp rocks_processrocks1
115+  CA60              rocks_processrocks3:
116+  CA60 DD 23            inc ix
117+  CA62 DD 23            inc ix
118+  CA64              rocks_processrocks1:
119+  CA64 C1               pop bc              ; get loop count back
120+  CA65 10 C8            djnz rocks_processrocks0
121+  CA67 C9               ret
122+  CA68
123+  CA68              ;
124+  CA68              ; Falls a rock one pixel, checks the next square down to see if it is empty, if not, stop falling
125+  CA68              ; bc - coord of current rock graphic on screen
126+  CA68              ; ix - memory location of current rock in rock list, currently at the 3rd position (rock state)
127+  CA68              ;
128+  CA68              rocks_fall:
129+  CA68 DD 2B            dec ix
130+  CA6A DD 2B            dec ix              ; decrease ix back to coords
131+  CA6C ED 43 F2 C9      ld (rocks_tmp2),bc  ; store original coords
132+  CA70 3E 03            ld a,3              ; move this number of pixels
133+  CA72              rocks_fall1:
134+  CA72 32 F1 C9         ld (rocks_tmp),a    ; store loop counter
135+  CA75 DD 4E 00 DD      ld bc,(ix)          ; get current coords
135+  CA79 46 01
136+  CA7B CD 04 AC         call sprites_scadd  ; get the memory of the coords into de
137+  CA7E 14               inc d               ; add 256 to get next row
138+  CA7F 1A               ld a,(de)           ; get the contents of the next row
139+  CA80 FE 00            cp 0
140+  CA82 C2 E2 CA         jp nz,rocks_fall3    ; move the rock if the row is empty
141+  CA85 0C               inc c               ; increment the vertical
142+  CA86 DD 71 00 DD      ld (ix),bc          ; store the new coords
142+  CA8A 70 01
143+  CA8C 79               ld a,c              ; get the vertical coord into a
144+  CA8D E6 07            and 7               ; divisible by 8?
145+  CA8F FE 00            cp 0
146+  CA91 C2 AE CA         jp nz,rocks_fall4   ; if not, carry on
147+  CA94 CD 3D AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
148+  CA97 3E 42            ld a,66             ; load red
149+  CA99 CD 95 AA         call screen_setattr
150+  CA9C DD 4E 00 DD      ld bc,(ix)
150+  CAA0 46 01
151+  CAA2 79               ld a,c              ; get vertical
152+  CAA3 D6 08            sub 8               ; look up one square
153+  CAA5 4F               ld c,a              ; put a back in c
154+  CAA6 CD 3D AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
155+  CAA9 3E 46            ld a,70             ; load yellow
156+  CAAB CD 95 AA         call screen_setattr
157+  CAAE              rocks_fall4:
158+  CAAE 3A F1 C9         ld a,(rocks_tmp)    ; get the loop counter
159+  CAB1 3D               dec a
160+  CAB2 FE 00            cp 0
161+  CAB4 C2 72 CA         jp nz,rocks_fall1   ; do another pixel if needed
162+  CAB7              rocks_fall2:
163+  CAB7 3E 09            ld a,9              ; rock graphic
164+  CAB9 ED 4B F2 C9      ld bc,(rocks_tmp2)  ; get the original coords
165+  CABD CD 8A AA         call screen_getblock     ; get the memory into hl
166+  CAC0 CD 0F AB         call sprites_drawsprite  ; draw the sprite - over the top of the current one
167+  CAC3 3E 09            ld a,9
168+  CAC5 DD 4E 00 DD      ld bc,(ix)          ; get the new coords
168+  CAC9 46 01
169+  CACB CD 8A AA         call screen_getblock     ; get the memory into hl
170+  CACE CD 0F AB         call sprites_drawsprite  ; draw the sprite - over the top of the current one
171+  CAD1 DD 4E 00 DD      ld bc,(ix)          ; get the coords again
171+  CAD5 46 01
172+  CAD7 CD 08 CB         call rocks_checkforplayer ; check to see if we hit a player
173+  CADA DD 23            inc ix
174+  CADC DD 23            inc ix                  ; get ix back to state
175+  CADE CD F8 CA         call rocks_makesound
176+  CAE1 C9               ret
177+  CAE2              rocks_fall3:
178+  CAE2 3E 00            ld a,0              ; set the state to fell
179+  CAE4 DD 77 02         ld (ix+2),a           ; store the falling state
180+  CAE7 DD 4E 00 DD      ld bc,(ix)          ; get the coords
180+  CAEB 46 01
181+  CAED CD 3D AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
182+  CAF0 3E 42            ld a,66             ; load magenta
183+  CAF2 CD 95 AA         call screen_setattr
184+  CAF5 C3 B7 CA         jp rocks_fall2      ; rejoin main loop
185+  CAF8
186+  CAF8              ;
187+  CAF8              ; Makes the rock sound if we're no longer falling, and if we didn't hit a player
188+  CAF8              ;
189+  CAF8              rocks_makesound:
190+  CAF8 DD 7E 00         ld a,(ix)           ; get the state
191+  CAFB FE 00            cp 0
192+  CAFD C0               ret nz              ; if we haven't fallen, don't do anything
193+  CAFE 21 7D C4         ld hl,player+11
194+  CB01 7E               ld a,(hl)
195+  CB02 FE 01            cp 1
196+  CB04 C4 24 B1         call nz, sound_rockfell ; only make sound if didn't kill player
197+  CB07 C9               ret
198+  CB08
199+  CB08              ;
200+  CB08              ; Checks to see if the rock is hitting a player
201+  CB08              ; Inputs:
202+  CB08              ; bc - coords of rock we're checking
203+  CB08              rocks_checkforplayer:
204+  CB08 ED 5B 72 C4      ld de,(player)       ; get the player coords
205+  CB0C 7B               ld a,e               ; get the vert coord first
206+  CB0D 91               sub c                ; subtract the rock vertical coord from players
207+  CB0E FE 08            cp 8                 ; the rock will only hit a player if the player is directly underneath, so this must be 8
208+  CB10 C0               ret nz               ; if not, hasn't hit
209+  CB11 7A               ld a,d               ; get the player horiz coord
210+  CB12 90               sub b                ; subtract rock coord
211+  CB13 C6 07            add 7                ; add max distance
212+  CB15 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
213+  CB17 DA 1B CB         jp c,rocks_checkforplayer0
214+  CB1A C9               ret
215+  CB1B              rocks_checkforplayer0:
216+  CB1B ED 43 F5 C9      ld (rocks_killerrock),bc; store the coords of the killer rock
217+  CB1F CD 95 C5         call player_crushplayer ; if so, jump out
218+  CB22 C9               ret
219+  CB23
220+  CB23              ;
221+  CB23              ; Wobbles a rocks
222+  CB23              ; Inputs:
223+  CB23              ; bc - coord of current rock graphic on screen
224+  CB23              ; ix - memory location of current rock in rock list, currently at the 4th position (wobble count)
225+  CB23              ; a - wobble frame
226+  CB23              rocks_wobble:
227+  CB23 DD 7E 00         ld a,(ix)           ; get the wobble count, which we'll use as frame toggle
228+  CB26 E6 01            and 1               ; is it odd or even, gets 1 or 0
229+  CB28 1E 09            ld e,9              ; this is the rock frame
230+  CB2A 83               add a,e             ; add the frame toggle
231+  CB2B C5               push bc
232+  CB2C CD 8A AA         call screen_getblock     ; get the memory into hl
233+  CB2F CD 0F AB         call sprites_drawsprite  ; draw the sprite - over the top of the current one
234+  CB32 DD 7E 00         ld a,(ix)           ; get the frame toggle again
235+  CB35 3D               dec a               ; decrease
236+  CB36 DD 77 00         ld (ix),a           ; store
237+  CB39 E6 01            and 1
238+  CB3B 1E 09            ld e,9              ; this is the rock frame
239+  CB3D 83               add a,e             ; add the frame toggle
240+  CB3E CD 8A AA         call screen_getblock     ; get the memory into hl
241+  CB41 C1               pop bc
242+  CB42 CD 0F AB         call sprites_drawsprite  ; draw the sprite again with the new frame - next time it will do the opposite
243+  CB45 DD 7E 00         ld a,(ix)           ; get the wobble count back
244+  CB48 FE 00            cp 0
245+  CB4A C0               ret nz              ; if we're not at zero, return
246+  CB4B DD 2B            dec ix              ; otherwise look to state location
247+  CB4D 3E 01            ld a,1              ; set the state to falling
248+  CB4F DD 77 00         ld (ix),a           ; store the falling state
249+  CB52 DD 23            inc ix              ; set ix back to location of wobble count, and we're done
250+  CB54 C9               ret
251+  CB55
# file closed: game/rocks.asm
159   CB55                  include "game\scores.asm"
# file opened: game/scores.asm
  1+  CB55              ;
  2+  CB55              ; The score of the current player
  3+  CB55              ;
  4+  CB55              scores_current:
  5+  CB55 04 01 30 30      defb 4,1,'000000',255       ;+2
  5+  CB59 30 30 30 30
  5+  CB5D FF
  6+  CB5E
  7+  CB5E              scores_defaultname:
  8+  CB5E 2D 2D 2D         defb '---'
  9+  CB61
 10+  CB61              ;
 11+  CB61              ; The current high score table
 12+  CB61              ;
 13+  CB61              scores_table:
 14+  CB61 03 17 47 41      defb 03,23,'GAM000000',255         ;+0, +2, +5
 14+  CB65 4D 30 30 30
 14+  CB69 30 30 30 FF
 15+  CB6D 0C 17 47 41      defb 12,23,'GAM000000',255        ;+12, +14, +17
 15+  CB71 4D 30 30 30
 15+  CB75 30 30 30 FF
 16+  CB79 15 17 47 41      defb 21,23,'GAM000000',255        ;+24, +26, +29
 16+  CB7D 4D 30 30 30
 16+  CB81 30 30 30 FF
 17+  CB85
 18+  CB85              ;
 19+  CB85              ; Add thousands to the score
 20+  CB85              ; Inputs:
 21+  CB85              ; b - number to add
 22+  CB85              ;
 23+  CB85              scores_addthousands:
 24+  CB85 21 59 CB         ld hl,scores_current+4
 25+  CB88 CD E9 CB         call scores_update
 26+  CB8B C9               ret
 27+  CB8C
 28+  CB8C              ;
 29+  CB8C              ; Add hundreds to the score
 30+  CB8C              ; Inputs:
 31+  CB8C              ; b - number to add
 32+  CB8C              ;
 33+  CB8C              scores_addhundreds:
 34+  CB8C 21 5A CB         ld hl,scores_current+5
 35+  CB8F CD E9 CB         call scores_update
 36+  CB92 C9               ret
 37+  CB93
 38+  CB93              ;
 39+  CB93              ; Temporary area for printing scores
 40+  CB93              ;
 41+  CB93              scores_printscore_tmp:
 42+  CB93 00 00 00 00      defb 0,0,0,0,0,0,0,0,255
 42+  CB97 00 00 00 00
 42+  CB9B FF
 43+  CB9C
 44+  CB9C              ;
 45+  CB9C              ; Prints the score to screen
 46+  CB9C              ;
 47+  CB9C              scores_printscore:
 48+  CB9C 3A 83 C3         ld a,(game_currentplayer)   ; get current player
 49+  CB9F 21 55 CB         ld hl,scores_current
 50+  CBA2 FE 01            cp 1
 51+  CBA4 C2 AC CB         jp nz, score_printscore0    ; if not player 1
 52+  CBA7 36 04            ld (hl),4       ; set position for player 1
 53+  CBA9 C3 AE CB         jp score_printscore1
 54+  CBAC              score_printscore0:
 55+  CBAC 36 16            ld (hl),22       ; set position for player 2
 56+  CBAE              score_printscore1:
 57+  CBAE CD B2 CB         call score_printscoreformatted
 58+  CBB1 C9               ret
 59+  CBB2
 60+  CBB2              ;
 61+  CBB2              ; Formats a score and prints to the top screen
 62+  CBB2              ; Inputs:
 63+  CBB2              ; hl - where is the score
 64+  CBB2              score_printscoreformatted:
 65+  CBB2 01 08 00         ld bc,8
 66+  CBB5 11 93 CB         ld de,scores_printscore_tmp
 67+  CBB8 ED B0            ldir                        ; copy to temp
 68+  CBBA 21 93 CB         ld hl,scores_printscore_tmp
 69+  CBBD E5 DD E1         ld ix,hl
 70+  CBC0 DD 7E 02         ld a,(ix+2)
 71+  CBC3 FE 30            cp 48                   ; is it a leading zero?
 72+  CBC5 C2 D8 CB         jp nz,score_printscore2
 73+  CBC8 DD 36 02 20      ld (ix+2),32              ; load it with a space
 74+  CBCC DD 7E 03         ld a,(ix+3)
 75+  CBCF FE 30            cp 48                   ; is it a leading zero?
 76+  CBD1 C2 D8 CB         jp nz,score_printscore2
 77+  CBD4 DD 36 03 20      ld (ix+3),32              ; load it with a space
 78+  CBD8              score_printscore2:
 79+  CBD8 CD 2B 86         call string_print
 80+  CBDB C9               ret
 81+  CBDC
 82+  CBDC              ;
 83+  CBDC              ; Prints both scores to screen
 84+  CBDC              ;
 85+  CBDC              scores_printscores:
 86+  CBDC 21 7B C5         ld hl,player1_score
 87+  CBDF CD B2 CB         call score_printscoreformatted
 88+  CBE2 21 84 C5         ld hl,player2_score
 89+  CBE5 CD B2 CB         call score_printscoreformatted
 90+  CBE8 C9               ret
 91+  CBE9
 92+  CBE9              ;
 93+  CBE9              ; Updates the current score.
 94+  CBE9              ; Inputs:
 95+  CBE9              ; hl - memory location of the score column
 96+  CBE9              ; b - number to add
 97+  CBE9              ;
 98+  CBE9              scores_update:
 99+  CBE9 7E               ld a,(hl)           ; current value of digit.
100+  CBEA 80               add a,b             ; add points to this digit.
101+  CBEB 77               ld (hl),a           ; place new digit back in string.
102+  CBEC FE 3A            cp 58               ; more than ASCII value '9'?
103+  CBEE D8               ret c               ; no - relax.
104+  CBEF D6 0A            sub 10              ; subtract 10.
105+  CBF1 77               ld (hl),a           ; put new character back in string.
106+  CBF2              scores_update0:
107+  CBF2 2B               dec hl              ; previous character in string.
108+  CBF3 34               inc (hl)            ; up this by one.
109+  CBF4 7E               ld a,(hl)           ; what's the new value?
110+  CBF5 FE 3A            cp 58               ; gone past ASCII nine?
111+  CBF7 D8               ret c               ; no, scoring done.
112+  CBF8 D6 0A            sub 10              ; down by ten.
113+  CBFA 77               ld (hl),a           ; put it back
114+  CBFB C3 F2 CB         jp scores_update0   ; go round again.
115+  CBFE
116+  CBFE
117+  CBFE              ;
118+  CBFE              ; Temporary area to store score
119+  CBFE              ;
120+  CBFE              scores_showtable_tmp:
121+  CBFE 00 00 00 00      defb 0,0,0,0,0,0,0,0,0,0,0,255
121+  CC02 00 00 00 00
121+  CC06 00 00 00 FF
122+  CC0A
123+  CC0A              ;
124+  CC0A              ; Processes a score
125+  CC0A              ; Inputs:
126+  CC0A              ; hl - location on table
127+  CC0A              ;
128+  CC0A              scores_showtable_process:
129+  CC0A 01 0B 00         ld bc,11                     ; copy this many
130+  CC0D 11 FE CB         ld de,scores_showtable_tmp
131+  CC10 ED B0            ldir
132+  CC12 DD 21 FE CB      ld ix,scores_showtable_tmp   ; decide whether to show five or six numbers
133+  CC16 DD 7E 05         ld a,(ix+5)
134+  CC19 FE 30            cp 48                        ; is this a zero?
135+  CC1B C2 31 CC         jp nz,scores_showtable_process0 ; if not, show the whole thing
136+  CC1E 01 05 00         ld bc,5                      ; copy this many
137+  CC21 DD E5 E1         ld hl,ix
138+  CC24 11 06 00         ld de,6
139+  CC27 19               add hl,de                    ; move to second digit
140+  CC28 54 5D            ld de,hl
141+  CC2A 1B               dec de
142+  CC2B ED B0            ldir
143+  CC2D DD 36 0A 20      ld (ix+10),32                ; stick a space at the end
144+  CC31              scores_showtable_process0:
145+  CC31 21 FE CB         ld hl,scores_showtable_tmp
146+  CC34 CD 2B 86         call string_print
147+  CC37 C9               ret
148+  CC38
149+  CC38              ;
150+  CC38              ; Displays the high score table at the bottom of the screen
151+  CC38              ;
152+  CC38              scores_showtable:
153+  CC38 21 61 CB         ld hl, scores_table
154+  CC3B CD 0A CC         call scores_showtable_process
155+  CC3E 21 6D CB         ld hl, scores_table+12
156+  CC41 CD 0A CC         call scores_showtable_process
157+  CC44 21 79 CB         ld hl, scores_table+24
158+  CC47 CD 0A CC         call scores_showtable_process
159+  CC4A C9               ret
160+  CC4B
161+  CC4B              ;
162+  CC4B              ; Place to store the current position we're checking
163+  CC4B              ;
164+  CC4B              scores_highscoretmp:
165+  CC4B 00               defb 0
166+  CC4C
167+  CC4C              ;
168+  CC4C              ; Place to store the equal indicator
169+  CC4C              ;
170+  CC4C              scores_highscoretmp2:
171+  CC4C 00               defb 0
172+  CC4D
173+  CC4D              ;
174+  CC4D              ; Updates the highscore table. Start at bottom score. Work way from left. Compare each digit. If current is higher than one we're checking,
175+  CC4D              ; copy checking one down (or erase) then copy current over that one. Then move up one and do the same
176+  CC4D              ;
177+  CC4D              scores_processhighscores:
178+  CC4D 21 4B CC         ld hl,scores_highscoretmp
179+  CC50 36 00            ld (hl),0  ; load up the tracking byte with 0 (ie, not on the table)
180+  CC52 3E 1D            ld a,29
181+  CC54              scores_processhighscores3:
182+  CC54 21 61 CB         ld hl,scores_table          ; position of first score column
183+  CC57 5F               ld e,a
184+  CC58 16 00            ld d,0
185+  CC5A 19               add hl,de
186+  CC5B 08               ex af,af'                   ; store a for later
187+  CC5C 11 57 CB         ld de,scores_current+2      ; position of current score column
188+  CC5F 3E 01            ld a,1
189+  CC61 32 4C CC         ld (scores_highscoretmp2),a ; set the equal indicator to 1 - this will be set to zero if a different number is found
190+  CC64 06 06            ld b,6                      ; times to loop
191+  CC66              scores_processhighscores0:
192+  CC66 7E               ld a,(hl)
193+  CC67 4F               ld c,a                      ; get first score column
194+  CC68 1A               ld a,(de)                   ; get first current column
195+  CC69 B9               cp c                        ; compare current with first
196+  CC6A DA 8C CC         jp c,scores_processhighscores4  ; if c is bigger, then this is not a higher score, so end
197+  CC6D CA 75 CC         jp z,scores_processhighscores5  ; if c is equal, then this is not a higher score, so end
198+  CC70 3E 00            ld a,0
199+  CC72 32 4C CC         ld (scores_highscoretmp2),a ; zero the equality indicator
200+  CC75              scores_processhighscores5:
201+  CC75 23               inc hl
202+  CC76 13               inc de                      ; move to next column
203+  CC77 10 ED            djnz scores_processhighscores0 ; loop
204+  CC79 3A 4C CC         ld a,(scores_highscoretmp2)   ; get the equality indicator
205+  CC7C FE 01            cp 1
206+  CC7E CA 8C CC         jp z,scores_processhighscores4 ; if it is equal, not a highscore
207+  CC81 B7               or a                            ; clear the carry flag
208+  CC82 08               ex af,af'                     ; still here, so must be bigger
209+  CC83 32 4B CC         ld (scores_highscoretmp),a  ; store the position indicator in the tracking byte
210+  CC86 0E 0C            ld c,12
211+  CC88 91               sub c
212+  CC89 D2 54 CC         jp nc,scores_processhighscores3 ; if the place we're looking is less than zero, we've gone to far, so continue, otherwise go again
213+  CC8C              scores_processhighscores4
214+  CC8C CD 90 CC         call scores_updatehighscores
215+  CC8F C9               ret
216+  CC90
217+  CC90              ;
218+  CC90              ; Update score table
219+  CC90              ;
220+  CC90              scores_updatehighscores:
221+  CC90 3A 4B CC         ld a,(scores_highscoretmp)  ; get the place we want to overwrite
222+  CC93 FE 00            cp 0
223+  CC95 C8               ret z                       ; if this is 0, didn't get a high score
224+  CC96 FE 1D            cp 29                       ; check against 29... if it's equal, we don't want to copy the current score down one
225+  CC98 CA CB CC         jp z, scores_updatehighscores3
226+  CC9B                                              ; copy old score over one below, if not first
227+  CC9B 21 61 CB         ld hl,scores_table
228+  CC9E 11 11 00         ld de,17                    ; start at second score, because this is the first one we'd ever need to copy...
229+  CCA1 19               add hl,de                   ; position of first column
230+  CCA2 2B               dec hl
231+  CCA3 2B               dec hl
232+  CCA4 2B               dec hl
233+  CCA5 E5               push hl
234+  CCA6 11 0C 00         ld de,12
235+  CCA9 19               add hl,de                   ; get position of next score
236+  CCAA 54 5D            ld de,hl
237+  CCAC E1               pop hl                      ; get hl back
238+  CCAD 01 09 00         ld bc,9
239+  CCB0 ED B0            ldir
240+  CCB2 FE 11            cp 17                       ; see if we're copying into the second place slot (17 memory offset). If so, stop copying back the scores
241+  CCB4 CA CB CC         jp z,scores_updatehighscores3
242+  CCB7 21 61 CB         ld hl,scores_table
243+  CCBA 11 02 00         ld de,2                    ; ... otherwise, copy back the first score
244+  CCBD 19               add hl,de                   ; position of first column
245+  CCBE E5               push hl
246+  CCBF 11 0C 00         ld de,12
247+  CCC2 19               add hl,de                   ; get position of next score
248+  CCC3 54 5D            ld de,hl
249+  CCC5 E1               pop hl                      ; get hl back
250+  CCC6 01 09 00         ld bc,9
251+  CCC9 ED B0            ldir
252+  CCCB              scores_updatehighscores3:
253+  CCCB 06 06            ld b,6                      ; now overwrite
254+  CCCD 21 61 CB         ld hl,scores_table
255+  CCD0 16 00            ld d,0
256+  CCD2 5F               ld e,a
257+  CCD3 19               add hl,de                   ; position of first column
258+  CCD4 08               ex af,af'
259+  CCD5 11 57 CB         ld de,scores_current+2      ; position of current score column
260+  CCD8              scores_updatehighscores2:
261+  CCD8 1A               ld a,(de)
262+  CCD9 77               ld (hl),a
263+  CCDA 23               inc hl
264+  CCDB 13               inc de
265+  CCDC 10 FA            djnz scores_updatehighscores2
266+  CCDE 11 09 00         ld de,9
267+  CCE1 ED 52            sbc hl,de
268+  CCE3 54 5D            ld de,hl                    ; get back to start of entry
269+  CCE5 21 5E CB         ld hl,scores_defaultname    ; still need to overwrite the name
270+  CCE8 01 03 00         ld bc,3                      ; 3 chars to copy
271+  CCEB ED B0            ldir
272+  CCED C9               ret
# file closed: game/scores.asm
160   CCEE                  include "game\diamonds.asm"
# file opened: game/diamonds.asm
  1+  CCEE              diamonds_tmp:
  2+  CCEE 00               defb 0
  3+  CCEF
  4+  CCEF              diamonds_tmp2:
  5+  CCEF 00               defb 0
  6+  CCF0
  7+  CCF0              ;
  8+  CCF0              ; Holds the number of thousands for the current gem type
  9+  CCF0              ;
 10+  CCF0              diamonds_score:
 11+  CCF0 00               defb 0
 12+  CCF1
 13+  CCF1              ;
 14+  CCF1              ; Changes the attribute of gem and diamond cells based on the frame count
 15+  CCF1              ; Inputs:
 16+  CCF1              ; hl - memory location of gem type
 17+  CCF1              diamonds_twinkle_type:
 18+  CCF1 CD 1C C4         call game_getcurrentframe       ; get current frame number
 19+  CCF4 E6 07            and 7                           ; want a number from 0-7
 20+  CCF6 C6 40            add 64                          ; add to 60 to get attr colour
 21+  CCF8 32 EF CC         ld (diamonds_tmp2),a             ; store the colour
 22+  CCFB              diamonds_twinkle_type0:
 23+  CCFB 4E 23 46 2B      ld bc,(hl)                      ; get coords into bc
 24+  CCFF 79               ld a,c                          ; load c into a
 25+  CD00 FE FF            cp 255                          ; is this the end?
 26+  CD02 CA 2A CD         jp z,diamonds_twinkle_type1           ; step out if so
 27+  CD05 23               inc hl
 28+  CD06 23               inc hl
 29+  CD07 7E               ld a,(hl)                       ; check the state, don't process if collected
 30+  CD08 FE 01            cp 1
 31+  CD0A CA 2B CD         jp z,diamonds_twinkle_type2           ; step out if so
 32+  CD0D CD 6B CD         call diamonds_checkforplayer    ; check to see if we've collided with player
 33+  CD10 DC 32 CD         call c,diamonds_collect     ; we collided
 34+  CD13 23               inc hl
 35+  CD14 E5               push hl
 36+  CD15 E5 DD E1         ld ix,hl
 37+  CD18 DD 4E FD DD      ld bc,(ix-3)                    ; get coords again
 37+  CD1C 46 FE
 38+  CD1E 3A EF CC         ld a,(diamonds_tmp2)
 39+  CD21 CD 95 AA         call screen_setattr
 40+  CD24 E1               pop hl
 41+  CD25 23               inc hl
 42+  CD26 23               inc hl                          ; move to next diamond
 43+  CD27 C3 FB CC         jp diamonds_twinkle_type0
 44+  CD2A              diamonds_twinkle_type1:
 45+  CD2A C9               ret
 46+  CD2B              diamonds_twinkle_type2:
 47+  CD2B 23               inc hl                          ; do stuff the we would have done anyway to get to next gem
 48+  CD2C 23               inc hl
 49+  CD2D 23               inc hl
 50+  CD2E 08               ex af,af'
 51+  CD2F C3 FB CC         jp diamonds_twinkle_type0       ; rejoin main loop
 52+  CD32
 53+  CD32              ;
 54+  CD32              ; Collect the diamond we collided with
 55+  CD32              ; Inputs:
 56+  CD32              ; hl - memory location of current diamond, currently on state
 57+  CD32              ; Output:
 58+  CD32              ; a - 70 - for yellow on black
 59+  CD32              diamonds_collect:
 60+  CD32 36 01            ld (hl),1                       ; collected
 61+  CD34 E5               push hl
 62+  CD35 2B               dec hl
 63+  CD36 2B               dec hl
 64+  CD37 4E 23 46 2B      ld bc,(hl)                      ; get the coords
 65+  CD3B CD 4D AA         call screen_getscreencoordsfromcharcoords ; get the screen coords into bc
 66+  CD3E ED 5B EE CC      ld de,(diamonds_tmp)            ; tmp stores the offset for this type of gem
 67+  CD42 16 00            ld d,0
 68+  CD44 21 DA BB         ld hl,sprites
 69+  CD47 19               add hl,de
 70+  CD48 CD 0F AB         call sprites_drawsprite     ; call the routine to draw the sprite
 71+  CD4B E1               pop hl
 72+  CD4C 3E 46            ld a,70                     ; pass this back to overwrite the attr
 73+  CD4E 32 EF CC         ld (diamonds_tmp2),a
 74+  CD51 D9               exx
 75+  CD52 3A F0 CC         ld a,(diamonds_score)
 76+  CD55 47               ld b,a
 77+  CD56 CD 85 CB         call scores_addthousands
 78+  CD59 3A EE CC         ld a,(diamonds_tmp)
 79+  CD5C FE 40            cp 64                       ; check the gem type offset, if its 64 this is a diamond, so mark the level as completable
 80+  CD5E C2 66 CD         jp nz,diamonds_collect0
 81+  CD61 21 7F C4         ld hl,player+13
 82+  CD64 36 01            ld (hl),1                   ; mark the player as able to complete the level
 83+  CD66              diamonds_collect0:
 84+  CD66 CD 07 B1         call sound_gemcollected
 85+  CD69 D9               exx
 86+  CD6A C9               ret
 87+  CD6B
 88+  CD6B              ;
 89+  CD6B              ; Checks to see if the gem is hitting a player
 90+  CD6B              ; Inputs:
 91+  CD6B              ; bc - coords of diamond we're checking
 92+  CD6B              diamonds_checkforplayer:
 93+  CD6B 78               ld a,b               ; multiply b by 8
 94+  CD6C 07               rlca
 95+  CD6D 07               rlca
 96+  CD6E 07               rlca
 97+  CD6F 47               ld b,a
 98+  CD70 ED 5B 72 C4      ld de,(player)       ; get the player coords
 99+  CD74 7B               ld a,e               ; get the vert coord first
100+  CD75 90               sub b                ; subtract the diamond vertical coord from players
101+  CD76 C6 04            add 4                ; add the max distance
102+  CD78 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
103+  CD7A D0               ret nc               ; if not, hasn't hit
104+  CD7B 79               ld a,c               ; multiply c by 8
105+  CD7C 07               rlca
106+  CD7D 07               rlca
107+  CD7E 07               rlca
108+  CD7F 4F               ld c,a
109+  CD80 7A               ld a,d               ; get the player horiz coord
110+  CD81 91               sub c                ; subtract rock coord
111+  CD82 C6 04            add 4                ; add max distance
112+  CD84 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
113+  CD86 D0               ret nc
114+  CD87 3E 00            ld a,0
115+  CD89 C9               ret
116+  CD8A
117+  CD8A
118+  CD8A              ;
119+  CD8A              ; Initialise diamonds and gems
120+  CD8A              ;
121+  CD8A              diamonds_twinkle
122+  CD8A 21 F0 CC         ld hl,diamonds_score
123+  CD8D 36 02            ld (hl),2         ; store the score we'll add
124+  CD8F 21 EE CC         ld hl,diamonds_tmp
125+  CD92 36 40            ld (hl),64         ; store the location the diamond sprite
126+  CD94 21 55 B7         ld hl, level_diamonds
127+  CD97 CD F1 CC         call diamonds_twinkle_type
128+  CD9A 21 F0 CC         ld hl,diamonds_score
129+  CD9D 36 01            ld (hl),1         ; store the score we'll add
130+  CD9F 21 EE CC         ld hl,diamonds_tmp
131+  CDA2 36 70            ld (hl),112         ; store the location the gem sprite
132+  CDA4 21 65 B7         ld hl, level_gems
133+  CDA7 CD F1 CC         call diamonds_twinkle_type
134+  CDAA C9               ret
135+  CDAB
136+  CDAB              ;
137+  CDAB              ; Initialise diamonds and gems
138+  CDAB              ;
139+  CDAB              diamonds_init:
140+  CDAB 21 55 B7         ld hl, level_diamonds
141+  CDAE CD B8 CD         call diamonds_init_type
142+  CDB1 21 65 B7         ld hl, level_gems
143+  CDB4 CD B8 CD         call diamonds_init_type
144+  CDB7 C9               ret
145+  CDB8
146+  CDB8              ;
147+  CDB8              ; Initialise diamonds or gems, get memory addresses
148+  CDB8              ; Inputs:
149+  CDB8              ; hl - memory location
150+  CDB8              diamonds_init_type:
151+  CDB8 4E               ld c,(hl)                      ; get coords into c
152+  CDB9 79               ld a,c                          ; load c into add
153+  CDBA FE FF            cp 255                          ; is this the end?
154+  CDBC CA D3 CD         jp z,diamonds_init_type1             ; step out if so
155+  CDBF 23               inc hl
156+  CDC0 46               ld b,(hl)                       ; get coords into b
157+  CDC1 E5               push hl
158+  CDC2 CD FE A9         call screen_getcellattroffset ; get memory of attr for this diamond into de
159+  CDC5 E1               pop hl
160+  CDC6 23               inc hl                          ; move to state
161+  CDC7 36 00            ld (hl),0
162+  CDC9 23               inc hl                          ; move to memory
163+  CDCA 73 23 72 2B      ld (hl),de                      ; store the memory location
164+  CDCE 23               inc hl                          ; move to next diamond
165+  CDCF 23               inc hl
166+  CDD0 C3 B8 CD         jp diamonds_init_type
167+  CDD3              diamonds_init_type1:
168+  CDD3 C9               ret
# file closed: game/diamonds.asm
161   CDD4                  include "game\missiles.asm"
# file opened: game/missiles.asm
  1+  CDD4              ;
  2+  CDD4              ; Controls when missiles fall
  3+  CDD4              ;
  4+  CDD4              missiles_count:
  5+  CDD4 00               defb 0
  6+  CDD5
  7+  CDD5              ;
  8+  CDD5              ; A structure of falling missiles
  9+  CDD5              ; Assume we'll never have more than 4 falling at any one time
 10+  CDD5              ; (1,2 - 16 bit memory location for missile graphic),state (0 fell, 1 falling)
 11+  CDD5              ;
 12+  CDD5              missiles_falling:
 13+  CDD5 00 00 00         defb 0,0,0
 14+  CDD8 00 00 00         defb 0,0,0
 15+  CDDB 00 00 00         defb 0,0,0
 16+  CDDE 00 00 00         defb 0,0,0
 17+  CDE1
 18+  CDE1              ;
 19+  CDE1              ; The coords of the missile that killed us
 20+  CDE1              ;
 21+  CDE1              missiles_killermissile:
 22+  CDE1 00 00            defb 0,0
 23+  CDE3
 24+  CDE3              ;
 25+  CDE3              ; The speed of the missiles
 26+  CDE3              ;
 27+  CDE3              missiles_speed:
 28+  CDE3 00               defb 0
 29+  CDE4
 30+  CDE4              ;
 31+  CDE4              ; Zeroes the state of each missile
 32+  CDE4              ;
 33+  CDE4              missiles_init:
 34+  CDE4 06 0C            ld b,12
 35+  CDE6 DD 21 DC B6      ld ix,level_missiles
 36+  CDEA              missiles_init0:
 37+  CDEA DD 36 02 00      ld (ix+2),0               ; set the state to zero
 38+  CDEE 11 05 00         ld de,5
 39+  CDF1 DD 19            add ix,de
 40+  CDF3 DD 36 02 00      ld (ix+2),0
 41+  CDF7 DD 19            add ix,de
 42+  CDF9 10 EF            djnz missiles_init0
 43+  CDFB 06 04            ld b,4                  ; reset four falling missiles
 44+  CDFD 21 D5 CD         ld hl,missiles_falling
 45+  CE00              missiles_init1:
 46+  CE00 36 00            ld (hl),0
 47+  CE02 23               inc hl
 48+  CE03 36 00            ld (hl),0
 49+  CE05 23               inc hl
 50+  CE06 36 00            ld (hl),0
 51+  CE08 23               inc hl
 52+  CE09 10 F5            djnz missiles_init1
 53+  CE0B C9               ret
 54+  CE0C
 55+  CE0C              ;
 56+  CE0C              ; Runs each frame and checks if a missile can fall, then selects one at random and adds to the falling missiles
 57+  CE0C              ; Processes any already falling missiles
 58+  CE0C              ;
 59+  CE0C              missiles_process:
 60+  CE0C 3A 7D C4         ld a,(player+11)                        ; check if the player was hit by a missile previously
 61+  CE0F FE 03            cp 3
 62+  CE11 C2 18 CE         jp nz,missiles_process3                 ; if not, continue
 63+  CE14 CD 58 CF         call missiles_zonkplayer
 64+  CE17 C9               ret
 65+  CE18              missiles_process3:
 66+  CE18 3A 81 C4         ld a,(player_location)
 67+  CE1B FE 01            cp 1
 68+  CE1D C2 8E CE         jp nz, missiles_process0                ; if not 1 we're not in the cavern so no need to make any more fall
 69+  CE20 21 7F C4         ld hl,player+13
 70+  CE23 7E               ld a,(hl)                               ; check if player has collected a diamond
 71+  CE24 FE 01            cp 1
 72+  CE26 C2 8E CE         jp nz, missiles_process0                ; don't activate if not
 73+  CE29 21 D4 CD         ld hl,missiles_count
 74+  CE2C 7E               ld a,(hl)                   ; get the missiles count
 75+  CE2D 3C               inc a
 76+  CE2E ED 5B E3 CD      ld de,(missiles_speed)
 77+  CE32 BB               cp e                                   ; have we reached the count yet
 78+  CE33 CA 3A CE         jp z,missiles_process2                 ; if not, don't activate a new one
 79+  CE36 77               ld (hl),a                               ; store the updated count, and continue without activating
 80+  CE37 C3 8E CE         jp missiles_process0
 81+  CE3A              missiles_process2:
 82+  CE3A 36 00            ld (hl),0                               ; zero the counter
 83+  CE3C 1E 0C            ld e,12
 84+  CE3E CD B8 81         call utilities_randomupper              ; get random number from 0 to 11
 85+  CE41 11 0A 00         ld de,10
 86+  CE44 CD 03 81         call utilities_multiply                 ; multiple random number by 10
 87+  CE47 54 5D            ld de,hl                                ; this is the offset for the random missile
 88+  CE49 DD 21 DC B6      ld ix,level_missiles                   ; load the location of the missile definitions
 89+  CE4D DD 19            add ix,de                               ; get to location of missile
 90+  CE4F DD 7E 02         ld a,(ix+2)
 91+  CE52 FE 00            cp 0
 92+  CE54 CA 64 CE         jp z,missiles_process1                  ; if this missile isn't active, activate it
 93+  CE57 11 05 00         ld de,5                                 ; otherwise, check the missile above
 94+  CE5A DD 19            add ix,de
 95+  CE5C DD 7E 02         ld a,(ix+2)
 96+  CE5F FE 00            cp 0
 97+  CE61 C2 8E CE         jp nz,missiles_process0                 ; if this is active as well, the player got lucky
 98+  CE64              missiles_process1:                          ; activate a missile
 99+  CE64 DD 36 02 01      ld (ix+2),1                               ; mark this missile as active
100+  CE68 DD 4E 00 DD      ld bc,(ix)                              ; get char coords from the missile
100+  CE6C 46 01
101+  CE6E 78               ld a,b
102+  CE6F ED 5B DD A8      ld de,(screen_offset)          ; load the screen offset, this is in rows
103+  CE73 93               sub e
104+  CE74 CD 4D AA         call screen_getscreencoordsfromcharcoords ; get screen coords into bc
105+  CE77 C5               push bc
106+  CE78 3E 0C            ld a,12                                 ; inactive missile sprite
107+  CE7A CD 8A AA         call screen_getblock
108+  CE7D CD 0F AB         call sprites_drawsprite                 ; draw the sprite over the old one
109+  CE80 C1               pop bc
110+  CE81 C5               push bc
111+  CE82 3E 14            ld a,20                                 ; active missile sprite
112+  CE84 CD 8A AA         call screen_getblock
113+  CE87 CD 0F AB         call sprites_drawsprite                 ; draw the sprite over the old one
114+  CE8A C1               pop bc
115+  CE8B CD 1C CF         call missiles_addmissiletofalling
116+  CE8E              missiles_process0:
117+  CE8E CD 92 CE         call missiles_fall
118+  CE91 C9               ret
119+  CE92
120+  CE92              ;
121+  CE92              ; Processes falling missiles
122+  CE92              ;
123+  CE92              missiles_fall:
124+  CE92 06 04            ld b,4              ; number of possible falling missiles
125+  CE94 DD 21 D5 CD      ld ix,missiles_falling
126+  CE98              missiles_fall0:
127+  CE98 C5               push bc
128+  CE99 DD 7E 02         ld a,(ix+2)
129+  CE9C FE 00            cp 0
130+  CE9E CA FB CE         jp z,missiles_fall1 ; not falling move to next
131+  CEA1 FE 01            cp 1                ; is this ready to fall
132+  CEA3 CA A9 CE         jp z, missiles_fall3
133+  CEA6 C3 15 CF         jp missiles_fall4   ; if not, decrease the countdown
134+  CEA9              missiles_fall3:
135+  CEA9 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
135+  CEAD 46 01
136+  CEAF CD 04 AC         call sprites_scadd  ; get the memory of the coords into de
137+  CEB2 14               inc d               ; add 256 to get next row
138+  CEB3 1A               ld a,(de)           ; get the contents of the next row
139+  CEB4 FE 00            cp 0
140+  CEB6 C2 0E CF         jp nz,missiles_fall2 ; if this is not empty, stop this missile falling
141+  CEB9 3E 14            ld a,20                                 ; active missile sprite
142+  CEBB CD 8A AA         call screen_getblock
143+  CEBE CD 0F AB         call sprites_drawsprite                 ; draw the sprite over the old one
144+  CEC1 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
144+  CEC5 46 01
145+  CEC7 0C               inc c               ; move down one pixel
146+  CEC8 DD 71 00 DD      ld (ix),bc          ; store the new coords
146+  CECC 70 01
147+  CECE 3E 14            ld a,20                                 ; active missile sprite
148+  CED0 CD 8A AA         call screen_getblock
149+  CED3 CD 0F AB         call sprites_drawsprite                 ; draw the sprite
150+  CED6 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
150+  CEDA 46 01
151+  CEDC 79               ld a,c              ; get the vertical coord into a
152+  CEDD E6 07            and 7               ; divisible by 8?
153+  CEDF FE 00            cp 0
154+  CEE1 C2 FB CE         jp nz,missiles_fall1   ; if not, carry on
155+  CEE4 CD 3D AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
156+  CEE7 3E 43            ld a,67             ; load magenta
157+  CEE9 CD 95 AA         call screen_setattr
158+  CEEC DD 4E 00 DD      ld bc,(ix)
158+  CEF0 46 01
159+  CEF2 CD 3D AA         call screen_getcharcoordsfromscreencoords ; get the attr address into de
160+  CEF5 05               dec b               ; look one square above
161+  CEF6 3E 46            ld a,70             ; load yellow
162+  CEF8 CD 95 AA         call screen_setattr
163+  CEFB              missiles_fall1:         ; hl at state
164+  CEFB DD 4E 00 DD      ld bc,(ix)          ; get coords back
164+  CEFF 46 01
165+  CF01 CD 3D CF         call missiles_checkforplayer ; check for player
166+  CF04 DD 23            inc ix
167+  CF06 DD 23            inc ix
168+  CF08 DD 23            inc ix              ; get to next missile
169+  CF0A C1               pop bc
170+  CF0B 10 8B            djnz missiles_fall0
171+  CF0D C9               ret
172+  CF0E              missiles_fall2:
173+  CF0E DD 36 02 00      ld (ix+2),0
174+  CF12 C3 FB CE         jp missiles_fall1   ; rejoin the loop
175+  CF15              missiles_fall4:
176+  CF15 3D               dec a               ; decrease the countdown
177+  CF16 DD 77 02         ld (ix+2),a         ; store back
178+  CF19 C3 FB CE         jp missiles_fall1   ; do next missile
179+  CF1C
180+  CF1C              ;
181+  CF1C              ; Adds the missile to the structure that tracks falling missile
182+  CF1C              ; Inputs:
183+  CF1C              ; bc - coords of missile, c vert
184+  CF1C              missiles_addmissiletofalling:
185+  CF1C C5               push bc             ; store the coords
186+  CF1D 11 D5 CD         ld de,missiles_falling
187+  CF20 06 04            ld b,4              ; number of possible falling missiles
188+  CF22              missiles_addmissiletofalling0:
189+  CF22 13               inc de
190+  CF23 13               inc de              ; move three along to get the state
191+  CF24 1A               ld a,(de)           ; load the state
192+  CF25 FE 00            cp 0                ; check if this is not falling
193+  CF27 C2 38 CF         jp nz,missiles_addmissiletofalling1 ; continue the loop if not 0
194+  CF2A 3E 19            ld a,25
195+  CF2C 12               ld (de),a           ; set the state to pre-falling
196+  CF2D 1B               dec de              ; move back coords
197+  CF2E C1               pop bc              ; get back coords
198+  CF2F 78               ld a,b
199+  CF30 12               ld (de),a           ; store the vertical
200+  CF31 1B               dec de
201+  CF32 79               ld a,c
202+  CF33 12               ld (de),a           ; store the horizontal
203+  CF34 C5               push bc
204+  CF35 C3 3B CF         jp missiles_addmissiletofalling2 ; done
205+  CF38              missiles_addmissiletofalling1:
206+  CF38 13               inc de              ; move memory along to next rock
207+  CF39 10 E7            djnz missiles_addmissiletofalling0 ; try the next missile
208+  CF3B              missiles_addmissiletofalling2: ; done, return
209+  CF3B C1               pop bc              ; to tidy up
210+  CF3C C9               ret
211+  CF3D
212+  CF3D              ;
213+  CF3D              ; Checks to see if the missile is hitting a player
214+  CF3D              ; Inputs:
215+  CF3D              ; bc - coords of missile we're checking
216+  CF3D              missiles_checkforplayer:
217+  CF3D ED 5B 72 C4      ld de,(player)       ; get the player coords
218+  CF41 7B               ld a,e               ; get the vert coord first
219+  CF42 91               sub c                ; subtract the missile vertical coord from players
220+  CF43 FE 08            cp 8                 ; the missile will only hit a player if the player is directly underneath, so this must be 8
221+  CF45 C0               ret nz               ; if not, hasn't hit
222+  CF46 7A               ld a,d               ; get the player horiz coord
223+  CF47 90               sub b                ; subtract missile coord
224+  CF48 C6 07            add 7                ; add max distance
225+  CF4A FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
226+  CF4C DA 50 CF         jp c,missiles_checkforplayer0
227+  CF4F C9               ret
228+  CF50              missiles_checkforplayer0:
229+  CF50 ED 43 E1 CD      ld (missiles_killermissile),bc; store the coords of the killer missile
230+  CF54 CD A1 C5         call player_zonkplayer ; if so, jump out
231+  CF57 C9               ret
232+  CF58
233+  CF58              ;
234+  CF58              ; Player has been hit, so draw text over them and mark as dead
235+  CF58              ;
236+  CF58              missiles_zonkplayer:
237+  CF58 CD 8F C5         call player_killplayer      ; mark as dead
238+  CF5B ED 4B 72 C4      ld bc,(player)              ; get player coords
239+  CF5F CD 3D AA         call screen_getcharcoordsfromscreencoords
240+  CF62 0D               dec c
241+  CF63 0D               dec c
242+  CF64 04               inc b
243+  CF65 C5               push bc
244+  CF66 3E 42            ld a,66
245+  CF68 CD 95 AA         call screen_setattr
246+  CF6B 0C               inc c
247+  CF6C CD 95 AA         call screen_setattr
248+  CF6F 0C               inc c
249+  CF70 CD 95 AA         call screen_setattr
250+  CF73 0C               inc c
251+  CF74 CD 95 AA         call screen_setattr
252+  CF77 0C               inc c
253+  CF78 CD 95 AA         call screen_setattr
254+  CF7B 0C               inc c
255+  CF7C CD 95 AA         call screen_setattr
256+  CF7F C1               pop bc
257+  CF80 ED 5B DD A8      ld de,(screen_offset)
258+  CF84 78               ld a,b
259+  CF85 93               sub e
260+  CF86 47               ld b,a                      ; subtract the offset
261+  CF87 04               inc b
262+  CF88 04               inc b                       ; add two for the score rows
263+  CF89 ED 43 A3 85      ld (string_zonk),bc         ; set coords of string
264+  CF8D 21 A3 85         ld hl,string_zonk
265+  CF90 CD 2B 86         call string_print
266+  CF93 06 14            ld b,20
267+  CF95 CD 64 81         call utilities_pauseforframes ; pause
268+  CF98 C9               ret
269+  CF99
# file closed: game/missiles.asm
162   CF99                  include "game\thepit.asm"
# file opened: game/thepit.asm
  1+  CF99              ;
  2+  CF99              ; Timer for deciding how fast the trap withdraws
  3+  CF99              ;
  4+  CF99              thepit_timer:
  5+  CF99 00               defb 0
  6+  CF9A
  7+  CF9A              ;
  8+  CF9A              ; Ticks for the trap state. Will count to 3 then reset
  9+  CF9A              ;
 10+  CF9A              thepit_trapcount:
 11+  CF9A 00               defb 0
 12+  CF9B
 13+  CF9B              ;
 14+  CF9B              ; The horizontal coordinate of the current pit trap
 15+  CF9B              ;
 16+  CF9B              thepit_trapcoord:
 17+  CF9B 08               defb 8
 18+  CF9C
 19+  CF9C              ;
 20+  CF9C              ; Initialises the pit
 21+  CF9C              ;
 22+  CF9C              thepit_init:
 23+  CF9C 21 9B CF         ld hl,thepit_trapcoord
 24+  CF9F 36 08            ld (hl),8
 25+  CFA1 21 9A CF         ld hl,thepit_trapcount
 26+  CFA4 36 00            ld (hl),0
 27+  CFA6 C9               ret
 28+  CFA7              ;
 29+  CFA7              ; The speed the pit will withdraw
 30+  CFA7              ;
 31+  CFA7              thepit_speed:
 32+  CFA7 00               defb 0
 33+  CFA8
 34+  CFA8              ;
 35+  CFA8              ; Performs per frame processing on the pit room
 36+  CFA8              ;
 37+  CFA8              thepit_process:
 38+  CFA8 3A 81 C4         ld a,(player_location)
 39+  CFAB FE 02            cp 2                            ; if two, the player is in the pit, so process the trap
 40+  CFAD C2 17 D0         jp nz,thepit_process0
 41+  CFB0 ED 4B 72 C4      ld bc,(player)                  ; get the player's coords to check if about to fall
 42+  CFB4 3E 08            ld a,8
 43+  CFB6 81               add a,c
 44+  CFB7 4F               ld c,a                          ; look at the square underneath
 45+  CFB8 CD 3D AA         call screen_getcharcoordsfromscreencoords ; get the cell coords
 46+  CFBB CD CB AA         call screen_ischarempty
 47+  CFBE FE 01            cp 1                            ; check if this is 1=empty
 48+  CFC0 CA 18 D0         jp z,thepit_process2
 49+  CFC3 3A 99 CF         ld a,(thepit_timer)             ; get the timer
 50+  CFC6 3C               inc a
 51+  CFC7 32 99 CF         ld (thepit_timer),a             ; store
 52+  CFCA ED 5B A7 CF      ld de,(thepit_speed)            ; get the speed
 53+  CFCE BB               cp e                           ; have we reached the trigger?
 54+  CFCF C2 17 D0         jp nz, thepit_process0          ; no need to do anything
 55+  CFD2 3E 00            ld a,0
 56+  CFD4 32 99 CF         ld (thepit_timer),a             ; zero the timer and process
 57+  CFD7 3A 9A CF         ld a,(thepit_trapcount)         ; get the current count
 58+  CFDA 3C               inc a
 59+  CFDB 32 9A CF         ld (thepit_trapcount),a         ; reset the trap count
 60+  CFDE FE 04            cp 4                            ; do we need to begin another character?
 61+  CFE0 C2 FF CF         jp nz,thepit_process1           ; if not, draw as normal
 62+  CFE3 3E 00            ld a,0
 63+  CFE5 32 9A CF         ld (thepit_trapcount),a         ; reset the trap count
 64+  CFE8 3A 9B CF         ld a,(thepit_trapcoord)         ; get the trap horiz coord
 65+  CFEB FE 02            cp 2
 66+  CFED CA 17 D0         jp z,thepit_process0
 67+  CFF0 4F               ld c,a
 68+  CFF1 06 0A            ld b,10
 69+  CFF3 3E 46            ld a,70
 70+  CFF5 CD 95 AA         call screen_setattr             ; set the attr of the empty square to yellow on black
 71+  CFF8 3A 9B CF         ld a,(thepit_trapcoord)         ; get the trap horiz coord
 72+  CFFB 3D               dec a
 73+  CFFC 32 9B CF         ld (thepit_trapcoord),a         ; store the reduced coord
 74+  CFFF
 75+  CFFF              thepit_process1:                    ; draw the trapdoor in current position
 76+  CFFF 3A 9B CF         ld a,(thepit_trapcoord)
 77+  D002 FE 02            cp 2
 78+  D004 CA 17 D0         jp z, thepit_process0           ; don't process outside of the pit
 79+  D007 4F               ld c,a
 80+  D008 06 0A            ld b,10                         ; vertical coord will always be the same
 81+  D00A 3A 9A CF         ld a,(thepit_trapcount)         ; get the trap count
 82+  D00D 5F               ld e,a                          ; store in e
 83+  D00E 3E 16            ld a,22                         ; 21 is full trapdoor
 84+  D010 83               add a,e
 85+  D011 CD 8A AA         call screen_getblock
 86+  D014 CD 67 AA         call screen_showchar            ; show the char
 87+  D017
 88+  D017              thepit_process0:
 89+  D017 C9               ret
 90+  D018              thepit_process2:
 91+  D018 CD A7 C5         call player_pitkillplayer
 92+  D01B C9               ret
 93+  D01C
# file closed: game/thepit.asm
163   D01C                  include "game\monster.asm"
# file opened: game/monster.asm
  1+  D01C
  2+  D01C              ;
  3+  D01C              ; Where the monster currently is
  4+  D01C              ;
  5+  D01C              monster_currentcoords:
  6+  D01C 00 00            defb 0,0
  7+  D01E
  8+  D01E              ;
  9+  D01E              ; The start coords of the monster
 10+  D01E              ;
 11+  D01E              monster_initcoords:
 12+  D01E 70 1B            defb 112,27
 13+  D020
 14+  D020              ;
 15+  D020              ; Store the memory location of the current jump position
 16+  D020              ;
 17+  D020              monster_jumppos:
 18+  D020 00 00            defb 0,0
 19+  D022
 20+  D022              ;
 21+  D022              ; The jump table for the monster.
 22+  D022              ;
 23+  D022              monster_jumptable:
 24+  D022 FF 03 02 02      defb 255,3,2,2,2,2,2,2,2,2,1,1,1,1,1,1,255
 24+  D026 02 02 02 02
 24+  D02A 02 02 01 01
 24+  D02E 01 01 01 01
 24+  D032 FF
 25+  D033
 26+  D033              ;
 27+  D033              ; The vertical direction: 0 up, 1 down
 28+  D033              ;
 29+  D033              monster_jumpdirectionvert:
 30+  D033 00               defb 0
 31+  D034
 32+  D034              ;
 33+  D034              ; The horiz direction: 0 right, 1 left
 34+  D034              ;
 35+  D034              monster_jumpdirectionhoriz:
 36+  D034 00               defb 0
 37+  D035
 38+  D035              ;
 39+  D035              ; Frame offset, 0 or 32
 40+  D035              ;
 41+  D035              monster_frameoffset:
 42+  D035 00               defb 0
 43+  D036
 44+  D036              ;
 45+  D036              ; Monster tick
 46+  D036              ;
 47+  D036              monster_tick:
 48+  D036 00               defb 0
 49+  D037
 50+  D037              ;
 51+  D037              ; The colour of the monster
 52+  D037              ;
 53+  D037              monster_colour:
 54+  D037 06               defb 6
 55+  D038
 56+  D038              ;
 57+  D038              ; Initialises the pit monster
 58+  D038              ;
 59+  D038              monster_init:
 60+  D038 ED 4B 1E D0      ld bc,(monster_initcoords)              ; load the initial coords
 61+  D03C ED 43 1C D0      ld (monster_currentcoords),bc           ; save in current coords
 62+  D040 21 23 D0         ld hl,monster_jumptable+1
 63+  D043 22 20 D0         ld (monster_jumppos),hl                 ; store the initial position in the jump table
 64+  D046 3E 00            ld a,0
 65+  D048 32 33 D0         ld (monster_jumpdirectionvert),a        ; going up
 66+  D04B 32 35 D0         ld (monster_frameoffset),a
 67+  D04E 32 36 D0         ld (monster_tick),a
 68+  D051 CD DB D0         call monster_draw                       ; the monster
 69+  D054 C9               ret
 70+  D055
 71+  D055              ;
 72+  D055              ; Animate the monster
 73+  D055              ;
 74+  D055              monster_process:
 75+  D055 3A 36 D0         ld a,(monster_tick)                     ; check if we should draw this frame
 76+  D058 FE 01            cp 1
 77+  D05A CA 62 D0         jp z,monster_process6
 78+  D05D 3C               inc a
 79+  D05E 32 36 D0         ld (monster_tick),a                     ; increase the tick and continue
 80+  D061 C9               ret
 81+  D062              monster_process6:
 82+  D062 3E 00            ld a,0
 83+  D064 32 36 D0         ld (monster_tick),a                     ; zero the tick
 84+  D067 CD DB D0         call monster_draw                       ; overwrite the old sprite
 85+  D06A 3A 35 D0         ld a,(monster_frameoffset)              ; get the anim frame offset
 86+  D06D EE 20            xor 32                                  ; flip between 0 and 32
 87+  D06F 32 35 D0         ld (monster_frameoffset),a              ; store
 88+  D072 ED 4B 1C D0      ld bc,(monster_currentcoords)           ; get the current coords
 89+  D076 2A 20 D0         ld hl,(monster_jumppos)                 ; get the position in the jump table
 90+  D079 56               ld d,(hl)                               ; get the jump modifier
 91+  D07A 3A 33 D0         ld a,(monster_jumpdirectionvert)        ; get the vertical direction
 92+  D07D FE 00            cp 0                                    ; if 0, going up, so dec vert
 93+  D07F C2 88 D0         jp nz,monster_process0
 94+  D082 79               ld a,c
 95+  D083 92               sub d
 96+  D084 23               inc hl                                  ; move forward a jump pos
 97+  D085 C3 8B D0         jp monster_process1
 98+  D088              monster_process0:
 99+  D088 79               ld a,c                                   ; going down so inc c
100+  D089 82               add a,d
101+  D08A 2B               dec hl                                  ; move back a jump pos
102+  D08B              monster_process1:
103+  D08B 4F               ld c,a                                  ; get the vertical coord back
104+  D08C 7E               ld a,(hl)                               ; check the next jump pos
105+  D08D FE FF            cp 255                                  ; if 255 reverse
106+  D08F CA 98 D0         jp z,monster_process3
107+  D092 22 20 D0         ld (monster_jumppos),hl                 ; store the new pos
108+  D095 C3 AA D0         jp monster_process2                     ; keep going
109+  D098              monster_process3:
110+  D098 3A 33 D0         ld a,(monster_jumpdirectionvert)        ; get the direction
111+  D09B EE 01            xor 1                                   ; flip it
112+  D09D 32 33 D0         ld (monster_jumpdirectionvert),a        ; store it
113+  D0A0 FE 01            cp 1
114+  D0A2 CA AA D0         jp z,monster_process2
115+  D0A5 D9               exx
116+  D0A6 CD EE D0         call monster_colourchange
117+  D0A9 D9               exx
118+  D0AA              monster_process2:
119+  D0AA 3A 34 D0         ld a,(monster_jumpdirectionhoriz)       ; get the horiz direction
120+  D0AD FE 00            cp 0                                    ; is it right?
121+  D0AF C2 C4 D0         jp nz,monster_process4
122+  D0B2 04               inc b                                   ; 1 pixel right
123+  D0B3 78               ld a,b
124+  D0B4 FE 38            cp 56                                   ; reached the edge of the pit?
125+  D0B6 C2 D3 D0         jp nz,monster_process5
126+  D0B9 3A 34 D0         ld a,(monster_jumpdirectionhoriz)
127+  D0BC EE 01            xor 1
128+  D0BE 32 34 D0         ld (monster_jumpdirectionhoriz),a       ; flip direction
129+  D0C1 C3 D3 D0         jp monster_process5
130+  D0C4              monster_process4:
131+  D0C4 05               dec b                                   ; 1 pixel left
132+  D0C5 78               ld a,b
133+  D0C6 FE 18            cp 24                                   ; reached the edge of the pit?
134+  D0C8 C2 D3 D0         jp nz,monster_process5
135+  D0CB 3A 34 D0         ld a,(monster_jumpdirectionhoriz)
136+  D0CE EE 01            xor 1
137+  D0D0 32 34 D0         ld (monster_jumpdirectionhoriz),a       ; flip direction
138+  D0D3              monster_process5:
139+  D0D3 ED 43 1C D0      ld (monster_currentcoords),bc           ; store the new vertical coords
140+  D0D7 CD DB D0         call monster_draw                       ; finally, draw the monster
141+  D0DA C9               ret
142+  D0DB
143+  D0DB              ;
144+  D0DB              ; Draw the monster at the current location
145+  D0DB              ;
146+  D0DB              monster_draw:
147+  D0DB ED 4B 1C D0      ld bc,(monster_currentcoords)
148+  D0DF 3A 35 D0         ld a,(monster_frameoffset)
149+  D0E2 11 00 00         ld de,0
150+  D0E5 5F               ld e,a
151+  D0E6 21 EE BD         ld hl,monster_sprite                    ; load the first frame
152+  D0E9 19               add hl,de
153+  D0EA CD 6D AB         call sprites_draw2by2sprite
154+  D0ED C9               ret
155+  D0EE
156+  D0EE              ;
157+  D0EE              ; Changes the monster colour whenever it reaches the bottom of its jump
158+  D0EE              ;
159+  D0EE              monster_colourchange:
160+  D0EE 3A 37 D0         ld a,(monster_colour)
161+  D0F1 3C               inc a
162+  D0F2 FE 07            cp 7
163+  D0F4 C2 F9 D0         jp nz, monster_colourchange0
164+  D0F7 3E 01            ld a,1
165+  D0F9              monster_colourchange0:
166+  D0F9 32 37 D0         ld (monster_colour),a                   ; save the monster colour
167+  D0FC 3A DD A8         ld a,(screen_offset)
168+  D0FF FE 00            cp 0
169+  D101 CA 2E D1         jp z,monster_colourchange1
170+  D104 3A 37 D0         ld a,(monster_colour)                   ; get the monster colour
171+  D107 06 06            ld b,6
172+  D109 0E 40            ld c,64
173+  D10B 81               add c                                   ; want this with black background, so add 64
174+  D10C 11 A3 58         ld de,22528+163                         ; attrs here
175+  D10F CD A0 A9         call screen_setcolours
176+  D112 3A 37 D0         ld a,(monster_colour)                   ; get the monster colour
177+  D115 06 06            ld b,6
178+  D117 0E 40            ld c,64
179+  D119 81               add c                                   ; want this with black background, so add 64
180+  D11A 11 C3 58         ld de,22528+195                         ; attrs here
181+  D11D CD A0 A9         call screen_setcolours
182+  D120 3A 37 D0         ld a,(monster_colour)                   ; get the monster colour
183+  D123 F6 60            or 96
184+  D125 06 06            ld b,6
185+  D127 11 E3 58         ld de,22528+227                         ; attrs here
186+  D12A CD A0 A9         call screen_setcolours
187+  D12D C9               ret
188+  D12E              monster_colourchange1:
189+  D12E 3A 37 D0         ld a,(monster_colour)                   ; get the monster colour
190+  D131 06 06            ld b,6
191+  D133 0E 40            ld c,64
192+  D135 81               add c                                   ; want this with black background, so add 64
193+  D136 11 A3 59         ld de,22528+419                         ; attrs here
194+  D139 CD A0 A9         call screen_setcolours
195+  D13C 3A 37 D0         ld a,(monster_colour)                   ; get the monster colour
196+  D13F 06 06            ld b,6
197+  D141 0E 40            ld c,64
198+  D143 81               add c                                   ; want this with black background, so add 64
199+  D144 11 C3 59         ld de,22528+451                         ; attrs here
200+  D147 CD A0 A9         call screen_setcolours
201+  D14A 3A 37 D0         ld a,(monster_colour)                   ; get the monster colour
202+  D14D F6 60            or 96
203+  D14F 06 06            ld b,6
204+  D151 11 E3 59         ld de,22528+483                         ; attrs here
205+  D154 CD A0 A9         call screen_setcolours
206+  D157 C9               ret
# file closed: game/monster.asm
164   D158                  include "game\robots.asm"
# file opened: game/robots.asm
  1+  D158
  2+  D158              ;
  3+  D158              ; Array of robot states
  4+  D158              ; x,y,state (0 inactive, 1 active), direction (0 left, 1 right), anim offset, automove frames remaining, move direction (0 left, 1 right, 3 up, 4 down)
  5+  D158              robots_robots:
  6+  D158 00 00 00 00      defb 0,0,0,0,0,0,0
  6+  D15C 00 00 00
  7+  D15F 00 00 00 00      defb 0,0,0,0,0,0,0
  7+  D163 00 00 00
  8+  D166 00 00 00 00      defb 0,0,0,0,0,0,0
  8+  D16A 00 00 00
  9+  D16D 00 00 00 00      defb 0,0,0,0,0,0,0
  9+  D171 00 00 00
 10+  D174 00 00 00 00      defb 0,0,0,0,0,0,0
 10+  D178 00 00 00
 11+  D17B
 12+  D17B              robots_initcoords:
 13+  D17B 18 E8            defb 24,232
 14+  D17D
 15+  D17D              ;
 16+  D17D              ; When this reaches zero, spawn a new robot
 17+  D17D              ;
 18+  D17D              robots_spawntimer:
 19+  D17D FA               defb 250
 20+  D17E
 21+  D17E              ;
 22+  D17E              ; When this reaches max, change the anim frame
 23+  D17E              ;
 24+  D17E              robots_animtimer:
 25+  D17E 00               defb 0
 26+  D17F
 27+  D17F              ;
 28+  D17F              ; When this reaches max, change move the robot
 29+  D17F              ;
 30+  D17F              robots_movetimer:
 31+  D17F 00               defb 0
 32+  D180
 33+  D180
 34+  D180              ;
 35+  D180              ; The number of robots active
 36+  D180              ;
 37+  D180              robots_numberactive:
 38+  D180 00               defb 0
 39+  D181
 40+  D181              ;
 41+  D181              ; Tracks which directions a robot can move
 42+  D181              ; up,down,left,right
 43+  D181              robots_canmovedirections:
 44+  D181 00 00 00 00      defb 0,0,0,0
 45+  D185
 46+  D185              ;
 47+  D185              ; The current robot speed
 48+  D185              ;
 49+  D185              robots_robotspeed:
 50+  D185 02               defb 2
 51+  D186
 52+  D186              ;
 53+  D186              ; The current max robots
 54+  D186              ;
 55+  D186              robots_robotsmax:
 56+  D186 03               defb 3
 57+  D187
 58+  D187              ;
 59+  D187              ; Initialises the robots
 60+  D187              ;
 61+  D187              robots_init:
 62+  D187 06 23            ld b,35
 63+  D189 DD 21 58 D1      ld ix,robots_robots
 64+  D18D              robots_init0:
 65+  D18D DD 36 00 00      ld (ix),0                       ; reset robot states back to zero
 66+  D191 DD 23            inc ix
 67+  D193 10 F8            djnz robots_init0
 68+  D195 3E 00            ld a,0
 69+  D197 32 80 D1         ld (robots_numberactive),a
 70+  D19A 3E FA            ld a,250
 71+  D19C 32 7D D1         ld (robots_spawntimer),a
 72+  D19F                  ; Self writing code
 73+  D19F                  ; Robot speed
 74+  D19F 3A 85 D1         ld a,(robots_robotspeed)
 75+  D1A2 32 3C D2         ld (robots_process7+1),a
 76+  D1A5 3C               inc a
 77+  D1A6 32 6C D2         ld (robots_process6+1),a
 78+  D1A9                  ; Robots max
 79+  D1A9 3A 86 D1         ld a,(robots_robotsmax)
 80+  D1AC 32 B7 D1         ld (robots_spawn+1),a
 81+  D1AF 32 0E D2         ld (robots_process8+1),a
 82+  D1B2 32 2A D2         ld (robots_process0+1),a
 83+  D1B5 C9               ret
 84+  D1B6
 85+  D1B6              ;
 86+  D1B6              ; Spawns a new robot
 87+  D1B6              ; Inputs:
 88+  D1B6              ; ix - pointer to start of robot array entry
 89+  D1B6              ;
 90+  D1B6              robots_spawn:
 91+  D1B6 06 03            ld b,3                      ;(SELF WRITING CODE)
 92+  D1B8 DD 21 58 D1      ld ix,robots_robots
 93+  D1BC              robots_spawn0:
 94+  D1BC DD 7E 02         ld a,(ix+2)                 ; get the state
 95+  D1BF FE 00            cp 0
 96+  D1C1 C2 ED D1         jp nz,robots_spawn1         ; if already active, move on
 97+  D1C4 ED 4B 7B D1      ld bc,(robots_initcoords)
 98+  D1C8 DD 71 00 DD      ld (ix),bc
 98+  D1CC 70 01
 99+  D1CE DD 36 02 01      ld (ix+2),1
100+  D1D2 DD 36 03 00      ld (ix+3),0
101+  D1D6 DD 36 04 00      ld (ix+4),0
102+  D1DA DD 36 05 00      ld (ix+5),0
103+  D1DE DD 36 06 00      ld (ix+6),0
104+  D1E2 3A 80 D1         ld a,(robots_numberactive)
105+  D1E5 3C               inc a
106+  D1E6 32 80 D1         ld (robots_numberactive),a  ; increase the number active
107+  D1E9 CD A4 D4         call robots_draw            ; draw initial frame
108+  D1EC C9               ret
109+  D1ED              robots_spawn1:
110+  D1ED 11 07 00         ld de,7
111+  D1F0 DD 19            add ix,de
112+  D1F2 10 C8            djnz robots_spawn0
113+  D1F4 C9               ret
114+  D1F5              ;
115+  D1F5              ; Kills robot
116+  D1F5              ; Inputs:
117+  D1F5              ; ix - pointer to start of robot array entry
118+  D1F5              ;
119+  D1F5              robots_kill:
120+  D1F5 3A 80 D1         ld a,(robots_numberactive)
121+  D1F8 3D               dec a
122+  D1F9 32 80 D1         ld (robots_numberactive),a
123+  D1FC DD 36 02 00      ld (ix+2),0                     ; set to inactive
124+  D200 C5               push bc
125+  D201 E5               push hl
126+  D202 06 01            ld b,1
127+  D204 CD 8C CB         call scores_addhundreds
128+  D207 E1               pop hl
129+  D208 C1               pop bc
130+  D209 C9               ret
131+  D20A
132+  D20A              ;
133+  D20A              ; Processes the robots
134+  D20A              ;
135+  D20A              robots_process:
136+  D20A 3A 80 D1         ld a,(robots_numberactive)              ; first, check if we need to spawn a new robot
137+  D20D              robots_process8:
138+  D20D FE 03            cp 3                                    ; 3 is the maximum
139+  D20F CA 29 D2         jp z,robots_process0                    ; if already three, nothing to do
140+  D212 3A 7D D1         ld a,(robots_spawntimer)                ; now check the spawn timer
141+  D215 FE 00            cp 0
142+  D217 C2 25 D2         jp nz,robots_process1                   ; if it hasn't reached zero yet, just decrease
143+  D21A 3E FA            ld a,250
144+  D21C 32 7D D1         ld (robots_spawntimer),a                ; reset the spawn timer
145+  D21F CD B6 D1         call robots_spawn                       ; spawn a robot
146+  D222 C3 29 D2         jp robots_process0                      ; carry on
147+  D225              robots_process1:
148+  D225 3D               dec a
149+  D226 32 7D D1         ld (robots_spawntimer),a                ; decrease the spawn timer and store
150+  D229              robots_process0:
151+  D229 06 03            ld b,3                                  ; max number of robots (SELF WRITING CODE)
152+  D22B DD 21 58 D1      ld ix, robots_robots                    ; point ix at the robot array
153+  D22F              robots_process2:
154+  D22F C5               push bc
155+  D230 DD 7E 02         ld a,(ix+2)                             ; check the state
156+  D233 FE 00            cp 0
157+  D235 CA 51 D2         jp z,robots_process3                    ; if not active, move on
158+  D238 3A 7F D1         ld a,(robots_movetimer)
159+  D23B              robots_process7:                            ; self writing code - the number in the comparison will be ovewritten
160+  D23B FE 04            cp 4
161+  D23D C2 51 D2         jp nz,robots_process3                   ; can we move this frame
162+  D240 CD A4 D4         call robots_draw                        ; draw over existing
163+  D243 CD 76 D2         call robots_move                        ; move the
164+  D246 DD 7E 02         ld a,(ix+2)                             ; get the state again
165+  D249 FE 00            cp 0
166+  D24B CA 51 D2         jp z,robots_process3                    ; move to next if this robot has become inactive
167+  D24E CD A4 D4         call robots_draw                        ; draw the new robot
168+  D251              robots_process3:
169+  D251 C1               pop bc
170+  D252 11 07 00         ld de,7
171+  D255 DD 19            add ix,de
172+  D257 10 D6            djnz robots_process2
173+  D259 3A 7E D1         ld a,(robots_animtimer)
174+  D25C 3C               inc a
175+  D25D FE 08            cp 8
176+  D25F C2 64 D2         jp nz,robots_process4
177+  D262 3E 00            ld a,0                                  ; reset if we reached max
178+  D264              robots_process4:
179+  D264 32 7E D1         ld (robots_animtimer),a
180+  D267 3A 7F D1         ld a,(robots_movetimer)                 ; increment the robot move timer
181+  D26A 3C               inc a
182+  D26B              robots_process6:                            ; self writing code - the number in the comparison will be ovewritten
183+  D26B FE 05            cp 5                                    ; there is another reference to this number above
184+  D26D C2 72 D2         jp nz,robots_process5
185+  D270 3E 00            ld a,0
186+  D272              robots_process5:
187+  D272 32 7F D1         ld (robots_movetimer),a
188+  D275
189+  D275 C9               ret
190+  D276
191+  D276
192+  D276              ;
193+  D276              ; Moves a robot
194+  D276              ; Inputs:
195+  D276              ; ix - points to first byte of robot in array
196+  D276              robots_move:
197+  D276 DD 7E 02         ld a,(ix+2)                             ; get the state
198+  D279 FE 02            cp 2
199+  D27B CA AC D2         jp z,robots_move4                       ; don't move if shot, just change the anim
200+  D27E 3A 7E D1         ld a,(robots_animtimer)                 ; get the anim timer
201+  D281 FE 07            cp 7                                    ; compare with 8
202+  D283 C2 96 D2         jp nz,robots_move1                       ; if even, don't increment frame
203+  D286 DD 7E 04         ld a,(ix+4)                             ; get the anim frame
204+  D289 06 08            ld b,8
205+  D28B 80               add a,b                                 ; add to anim frame
206+  D28C FE 20            cp 32
207+  D28E C2 93 D2         jp nz,robots_move0                      ; if not 32, then just store
208+  D291 3E 00            ld a,0                                  ; otherwise, reset
209+  D293              robots_move0:
210+  D293 DD 77 04         ld (ix+4),a                             ; store
211+  D296              robots_move1:
212+  D296 DD 7E 05         ld a,(ix+5)
213+  D299 FE 00            cp 0                                    ; are we automoving
214+  D29B CA A4 D2         jp z,robots_move2                       ; if not, keep directions
215+  D29E CD C0 D2         call robots_automove
216+  D2A1 C3 A8 D2         jp robots_move3
217+  D2A4              robots_move2:
218+  D2A4 CD F5 D2         call robots_checkdirectionsandmove
219+  D2A7 C9               ret
220+  D2A8              robots_move3:
221+  D2A8 CD ED D4         call robots_checkforplayer              ; check to see if we collided with a player
222+  D2AB C9               ret
223+  D2AC              robots_move4:
224+  D2AC DD 7E 04         ld a,(ix+4)
225+  D2AF FE 48            cp 72
226+  D2B1 C2 BA D2         jp nz,robots_move5
227+  D2B4 3E 40            ld a,64
228+  D2B6 DD 77 04         ld (ix+4),a
229+  D2B9 C9               ret
230+  D2BA              robots_move5:
231+  D2BA 3E 48            ld a,72
232+  D2BC DD 77 04         ld (ix+4),a
233+  D2BF C9               ret
234+  D2C0
235+  D2C0
236+  D2C0              ;
237+  D2C0              ; Processes automove
238+  D2C0              ; Inputs:
239+  D2C0              ; ix - points to the current robot
240+  D2C0              ; a - number of frames left to move
241+  D2C0              robots_automove:
242+  D2C0 3D               dec a
243+  D2C1 DD 77 05         ld (ix+5),a                         ; store the decreased frames
244+  D2C4 DD 4E 00 DD      ld bc,(ix)                          ; get coords
244+  D2C8 46 01
245+  D2CA DD 7E 06         ld a,(ix+6)                         ; get the direction
246+  D2CD FE 00            cp 0                                ; left
247+  D2CF CA E0 D2         jp z,robots_automove1
248+  D2D2 FE 02            cp 2                                ; up
249+  D2D4 CA E4 D2         jp z,robots_automove3
250+  D2D7 FE 03            cp 3                                ; down
251+  D2D9 CA E9 D2         jp z,robots_automove4
252+  D2DC 04               inc b                               ; right
253+  D2DD C3 EE D2         jp robots_automove2
254+  D2E0              robots_automove1:
255+  D2E0 05               dec b
256+  D2E1 C3 EE D2         jp robots_automove2
257+  D2E4              robots_automove3:
258+  D2E4 0D               dec c
259+  D2E5 0D               dec c
260+  D2E6 C3 EE D2         jp robots_automove2
261+  D2E9              robots_automove4:
262+  D2E9 0C               inc c
263+  D2EA 0C               inc c
264+  D2EB C3 EE D2         jp robots_automove2
265+  D2EE              robots_automove2:
266+  D2EE DD 71 00 DD      ld (ix),bc
266+  D2F2 70 01
267+  D2F4 C9               ret
268+  D2F5
269+  D2F5              ;
270+  D2F5              ; Checks if a robot can move in all directions, then picks one and moves there.
271+  D2F5              ; This looks complicated, but really what it does is:
272+  D2F5              ; 1) Look at the current direction
273+  D2F5              ; 2) Randomly determine which orthoganal direction check first
274+  D2F5              ; 3) If orthogonal can't be moved, keep going in direction we're going
275+  D2F5              ; 4) Otherwise, back the way we came
276+  D2F5              ; Inputs:
277+  D2F5              ; ix - points to the current robot
278+  D2F5              ;
279+  D2F5              robots_checkdirectionsandmove:
280+  D2F5 DD 7E 06         ld a,(ix+6)                 ; get the direction
281+  D2F8 FE 00            cp 0                        ; left
282+  D2FA C2 21 D3         jp nz,robots_checkdirectionsandmove0
283+  D2FD                  ; random check
284+  D2FD CD 1C C4         call game_getcurrentframe
285+  D300 E6 01            and 1                       ; odd or even
286+  D302 CA 0E D3         jp z,robots_checkdirectionsandmove3
287+  D305 CD A7 D3         call robots_checkupthendown ; prefer up over down
288+  D308 FE 01            cp 1
289+  D30A C8               ret z
290+  D30B C3 14 D3         jp robots_checkdirectionsandmove4
291+  D30E              robots_checkdirectionsandmove3:
292+  D30E CD 9D D3         call robots_checkdownthenup ; prefer down over up
293+  D311 FE 01            cp 1
294+  D313 C8               ret z
295+  D314              robots_checkdirectionsandmove4:
296+  D314                  ; check left
297+  D314 CD 2D D4         call robots_checkleftandmove
298+  D317 FE 01            cp 1
299+  D319 C8               ret z                       ; if we moved, don't check again
300+  D31A                  ; check right
301+  D31A CD 66 D4         call robots_checkrightandmove
302+  D31D FE 01            cp 1
303+  D31F C8               ret z                       ; if we moved, don't check again
304+  D320                  ; if we're here and haven't moved...
305+  D320 C9               ret
306+  D321              robots_checkdirectionsandmove0
307+  D321 FE 01            cp 1                        ; right
308+  D323 C2 4A D3         jp nz,robots_checkdirectionsandmove1
309+  D326                  ; ALREADY MOVING RIGHT
310+  D326                  ; random check
311+  D326 CD 1C C4         call game_getcurrentframe
312+  D329 E6 01            and 1                       ; odd or even
313+  D32B CA 37 D3         jp z,robots_checkdirectionsandmove5
314+  D32E CD 9D D3         call robots_checkdownthenup ; prefer down over up
315+  D331 FE 01            cp 1
316+  D333 C8               ret z
317+  D334 C3 3D D3         jp robots_checkdirectionsandmove6
318+  D337              robots_checkdirectionsandmove5:
319+  D337 CD A7 D3         call robots_checkupthendown ; prefer down over up
320+  D33A FE 01            cp 1
321+  D33C C8               ret z
322+  D33D              robots_checkdirectionsandmove6:
323+  D33D                  ; check right
324+  D33D CD 66 D4         call robots_checkrightandmove
325+  D340 FE 01            cp 1
326+  D342 C8               ret z                       ; if we moved, don't check again
327+  D343                  ; check left
328+  D343 CD 2D D4         call robots_checkleftandmove
329+  D346 FE 01            cp 1
330+  D348 C8               ret z                       ; if we moved, don't check again
331+  D349                  ; if we're here and haven't moved...
332+  D349 C9               ret
333+  D34A              robots_checkdirectionsandmove1
334+  D34A FE 02            cp 2                        ; up
335+  D34C C2 73 D3         jp nz,robots_checkdirectionsandmove2
336+  D34F                  ; ALREADY MOVING UP
337+  D34F                  ; random check
338+  D34F CD 1C C4         call game_getcurrentframe
339+  D352 E6 01            and 1                       ; odd or even
340+  D354 CA 60 D3         jp z,robots_checkdirectionsandmove7
341+  D357 CD BD D3         call robots_checkleftthenright ; prefer left over right
342+  D35A FE 01            cp 1
343+  D35C C8               ret z
344+  D35D C3 66 D3         jp robots_checkdirectionsandmove8
345+  D360              robots_checkdirectionsandmove7:
346+  D360 CD B3 D3         call robots_checkrightthenleft ; prefer right over left
347+  D363 FE 01            cp 1
348+  D365 C8               ret z
349+  D366              robots_checkdirectionsandmove8:
350+  D366                  ; check up
351+  D366 CD C9 D3         call robots_checkupandmove
352+  D369 FE 01            cp 1
353+  D36B C8               ret z                       ; if we moved, don't check again
354+  D36C                  ; check down
355+  D36C CD FF D3         call robots_checkdownandmove
356+  D36F FE 01            cp 1
357+  D371 C8               ret z                       ; if we moved, don't check again
358+  D372                  ; if we're here and haven't moved...
359+  D372 C9               ret
360+  D373              robots_checkdirectionsandmove2
361+  D373                  ; ALREADY MOVING DOWN
362+  D373                  ; random check
363+  D373 CD 1C C4         call game_getcurrentframe
364+  D376 E6 01            and 1                       ; odd or even
365+  D378 CA 84 D3         jp z,robots_checkdirectionsandmove9
366+  D37B CD B3 D3         call robots_checkrightthenleft ; prefer right over left
367+  D37E FE 01            cp 1
368+  D380 C8               ret z
369+  D381 C3 8A D3         jp robots_checkdirectionsandmove10
370+  D384              robots_checkdirectionsandmove9:
371+  D384 CD BD D3         call robots_checkleftthenright ; prefer left over right
372+  D387 FE 01            cp 1
373+  D389 C8               ret z
374+  D38A              robots_checkdirectionsandmove10:
375+  D38A                  ; check down
376+  D38A CD FF D3         call robots_checkdownandmove
377+  D38D FE 01            cp 1
378+  D38F C8               ret z                       ; if we moved, don't check again
379+  D390                  ; check right first
380+  D390 CD 66 D4         call robots_checkrightandmove
381+  D393 FE 01            cp 1
382+  D395 C8               ret z                       ; if we moved, don't check again
383+  D396                  ; check up
384+  D396 CD C9 D3         call robots_checkupandmove
385+  D399 FE 01            cp 1
386+  D39B C8               ret z                       ; if we moved, don't check again
387+  D39C                  ; if we're here and haven't moved...
388+  D39C C9               ret
389+  D39D
390+  D39D              ;
391+  D39D              ; Different orders of checking directions, for pseudo random motion
392+  D39D              ;
393+  D39D              robots_checkdownthenup:
394+  D39D                  ; check down
395+  D39D CD FF D3         call robots_checkdownandmove
396+  D3A0 FE 01            cp 1
397+  D3A2 C8               ret z                       ; if we moved, don't check again
398+  D3A3                  ; check up
399+  D3A3 CD C9 D3         call robots_checkupandmove
400+  D3A6 C9               ret
401+  D3A7
402+  D3A7              robots_checkupthendown:
403+  D3A7                  ; check up
404+  D3A7 CD C9 D3         call robots_checkupandmove
405+  D3AA FE 01            cp 1
406+  D3AC C8               ret z
407+  D3AD                  ; check down
408+  D3AD CD FF D3         call robots_checkdownandmove
409+  D3B0 FE 01            cp 1
410+  D3B2 C9               ret
411+  D3B3              robots_checkrightthenleft:
412+  D3B3                  ; check right
413+  D3B3 CD 66 D4         call robots_checkrightandmove
414+  D3B6 FE 01            cp 1
415+  D3B8 C8               ret z                       ; if we moved, don't check again
416+  D3B9                  ; check left
417+  D3B9 CD 2D D4         call robots_checkleftandmove
418+  D3BC C9               ret
419+  D3BD
420+  D3BD              robots_checkleftthenright:
421+  D3BD                  ; check left
422+  D3BD CD 2D D4         call robots_checkleftandmove
423+  D3C0 FE 01            cp 1
424+  D3C2 C8               ret z
425+  D3C3                  ; check right
426+  D3C3 CD 66 D4         call robots_checkrightandmove
427+  D3C6 FE 01            cp 1
428+  D3C8 C9               ret
429+  D3C9
430+  D3C9              ;
431+  D3C9              ; Checks up for movement
432+  D3C9              ; Outputs:
433+  D3C9              ; a - 1 if have moved
434+  D3C9              robots_checkupandmove:
435+  D3C9                  ; check above
436+  D3C9 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
436+  D3CD 46 01
437+  D3CF 79               ld a,c
438+  D3D0 FE 28            cp 40
439+  D3D2 D8               ret c
440+  D3D3 CD 04 AC         call sprites_scadd              ; get the memory location of cell into de
441+  D3D6 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
442+  D3D8 11 20 00         ld de,32
443+  D3DB ED 52            sbc hl,de                       ; memory location of line above now in hl
444+  D3DD 7E               ld a,(hl)                       ; get the contents of the line
445+  D3DE FE 00            cp 0
446+  D3E0 C2 FC D3         jp nz,robots_checkupandmove0    ; can't move here so return
447+  D3E3 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
447+  D3E7 46 01
448+  D3E9 0D               dec c                       ; move up
449+  D3EA 0D               dec c
450+  D3EB DD 71 00 DD      ld (ix),bc
450+  D3EF 70 01
451+  D3F1 DD 36 06 02      ld (ix+6),2
452+  D3F5 DD 36 05 03      ld (ix+5),3                 ; set the auto move frames
453+  D3F9 3E 01            ld a,1
454+  D3FB C9               ret
455+  D3FC              robots_checkupandmove0:
456+  D3FC 3E 00            ld a,0
457+  D3FE C9               ret
458+  D3FF
459+  D3FF              ;
460+  D3FF              ; Checks down for movement
461+  D3FF              ; Outputs:
462+  D3FF              ; a - 1 if have moved
463+  D3FF              robots_checkdownandmove:
464+  D3FF                  ; check below
465+  D3FF DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
465+  D403 46 01
466+  D405 CD 04 AC         call sprites_scadd              ; get the memory location of cell into de
467+  D408 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
468+  D40A 24               inc h                       ; memory location of cell beneath now in hl
469+  D40B 7E               ld a,(hl)                       ; get the contents of the line
470+  D40C FE 00            cp 0
471+  D40E C2 2A D4         jp nz,robots_checkdownandmove0    ; can't move here so return
472+  D411 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
472+  D415 46 01
473+  D417 0C               inc c                       ; move up
474+  D418 0C               inc c
475+  D419 DD 71 00 DD      ld (ix),bc
475+  D41D 70 01
476+  D41F DD 36 06 03      ld (ix+6),3
477+  D423 DD 36 05 03      ld (ix+5),3                 ; set the auto move frames
478+  D427 3E 01            ld a,1
479+  D429 C9               ret
480+  D42A              robots_checkdownandmove0:
481+  D42A 3E 00            ld a,0
482+  D42C C9               ret
483+  D42D
484+  D42D              ;
485+  D42D              ; Checks left for movement
486+  D42D              ; Outputs:
487+  D42D              ; a - 1 if have moved
488+  D42D              robots_checkleftandmove:
489+  D42D                  ; check below
490+  D42D DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
490+  D431 46 01
491+  D433 CD 04 AC         call sprites_scadd              ; get the memory location of cell into de
492+  D436 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
493+  D438 78               ld a,b
494+  D439 06 08            ld b,8
495+  D43B 90               sub b                           ; move one cell left
496+  D43C 47               ld b,a
497+  D43D 2B               dec hl                          ; memory location of cell to the right now in hl
498+  D43E CD 5C C1         call movement_spaceisempty       ; check space is empty
499+  D441 7B               ld a,e                          ; check space empty flag
500+  D442 FE 00            cp 0
501+  D444 CA 63 D4         jp z,robots_checkleftandmove0    ; if zero can't move
502+  D447 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
502+  D44B 46 01
503+  D44D 05               dec b
504+  D44E DD 71 00 DD      ld (ix),bc
504+  D452 70 01
505+  D454 DD 36 06 00      ld (ix+6),0
506+  D458 DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
507+  D45C DD 36 03 00      ld (ix+3),0                 ; set to right
508+  D460 3E 01            ld a,1
509+  D462 C9               ret
510+  D463              robots_checkleftandmove0:
511+  D463 3E 00            ld a,0
512+  D465 C9               ret
513+  D466
514+  D466              ;
515+  D466              ; Checks right for movement
516+  D466              ; Outputs:
517+  D466              ; a - 1 if have moved
518+  D466              robots_checkrightandmove:
519+  D466                  ; check below
520+  D466 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
520+  D46A 46 01
521+  D46C 78               ld a,b
522+  D46D FE E8            cp 232
523+  D46F CA A1 D4         jp z,robots_checkrightandmove0  ; can't move if at edge
524+  D472 CD 04 AC         call sprites_scadd              ; get the memory location of cell into de
525+  D475 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
526+  D477 3E 08            ld a,8
527+  D479 80               add b                           ; move one cell right
528+  D47A 47               ld b,a
529+  D47B 23               inc hl                          ; memory location of cell to the right now in hl
530+  D47C CD 5C C1         call movement_spaceisempty       ; check space is empty
531+  D47F 7B               ld a,e                          ; check space empty flag
532+  D480 FE 00            cp 0
533+  D482 CA A1 D4         jp z,robots_checkrightandmove0    ; if zero can't move
534+  D485 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
534+  D489 46 01
535+  D48B 04               inc b
536+  D48C DD 71 00 DD      ld (ix),bc
536+  D490 70 01
537+  D492 DD 36 06 01      ld (ix+6),1
538+  D496 DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
539+  D49A DD 36 03 01      ld (ix+3),1                 ; set to right
540+  D49E 3E 01            ld a,1
541+  D4A0 C9               ret
542+  D4A1              robots_checkrightandmove0:
543+  D4A1 3E 00            ld a,0
544+  D4A3 C9               ret
545+  D4A4
546+  D4A4              ;
547+  D4A4              ; Draws a robot
548+  D4A4              ; Inputs:
549+  D4A4              ; ix - points to first byte of robot in array
550+  D4A4              robots_draw:
551+  D4A4 DD 4E 00 DD      ld bc,(ix)
551+  D4A8 46 01
552+  D4AA 21 2E BE         ld hl,robot_sprite                      ; set to the robot sprite
553+  D4AD DD 7E 02         ld a,(ix+2)                             ; get the state
554+  D4B0 FE 02            cp 2                                    ; is this dying
555+  D4B2 CA CD D4         jp z,robots_draw1
556+  D4B5              robots_draw3:
557+  D4B5 DD 7E 03         ld a,(ix+3)                             ; get the direction
558+  D4B8 FE 00            cp 0
559+  D4BA CA C1 D4         jp z,robots_draw0                       ; if left, nothing to do
560+  D4BD 11 20 00         ld de,32
561+  D4C0 19               add hl,de                               ; add four frames to sprite
562+  D4C1              robots_draw0:
563+  D4C1 DD 7E 04         ld a,(ix+4)                             ; get the anim frame
564+  D4C4 11 00 00         ld de,0
565+  D4C7 5F               ld e,a
566+  D4C8 19               add hl,de                               ; add to base
567+  D4C9 CD 0F AB         call sprites_drawsprite
568+  D4CC C9               ret
569+  D4CD              ;
570+  D4CD              ; Dying
571+  D4CD              ;
572+  D4CD              robots_draw1:
573+  D4CD DD 7E 05         ld a,(ix+5)                             ; get anim frames
574+  D4D0 FE 00            cp 0                                    ; if zero this is the first time around
575+  D4D2 C2 DD D4         jp nz,robots_draw2
576+  D4D5 3E 18            ld a,24
577+  D4D7 DD 77 05         ld (ix+5),a                             ; load up the anim frames
578+  D4DA C3 B5 D4         jp robots_draw3                         ; return to main loop to draw as normal
579+  D4DD              robots_draw2:
580+  D4DD 3D               dec a
581+  D4DE DD 77 05         ld (ix+5),a
582+  D4E1 FE 00            cp 0                                    ; have we reached the end yet
583+  D4E3 C2 E9 D4         jp nz, robots_draw4
584+  D4E6 CD F5 D1         call robots_kill
585+  D4E9              robots_draw4:
586+  D4E9 C3 C1 D4         jp robots_draw0
587+  D4EC C9               ret
588+  D4ED
589+  D4ED              ;
590+  D4ED              ; Checks to see if the robot is hitting a player
591+  D4ED              ; Inputs:
592+  D4ED              ; ix - memory location of robot we're checking
593+  D4ED              robots_checkforplayer:
594+  D4ED 3A 7D C4         ld a,(player+11)     ; get player state
595+  D4F0 FE 00            cp 0
596+  D4F2 C0               ret nz               ; if already dying, don't kill again
597+  D4F3 DD 4E 00 DD      ld bc,(ix)           ; get coords
597+  D4F7 46 01
598+  D4F9 ED 5B 72 C4      ld de,(player)       ; get the player coords
599+  D4FD 7B               ld a,e               ; get the vert coord first
600+  D4FE 91               sub c                ; subtract the diamond vertical coord from players
601+  D4FF C6 08            add 8                ; add the max distance
602+  D501 FE 11            cp 17                ; compare to max*2+1? if carry flag set, they've hit
603+  D503 D0               ret nc               ; if not, hasn't hit
604+  D504 7A               ld a,d               ; get the player horiz coord
605+  D505 90               sub b                ; subtract rock coord
606+  D506 C6 08            add 8                ; add max distance
607+  D508 FE 11            cp 17                ; compare to max*2+1? if carry flag set, they've hit
608+  D50A D0               ret nc
609+  D50B DD 36 02 00      ld (ix+2),0          ; mark as inactive
610+  D50F CD AD C5         call player_robotkillplayer ; mark the player as killed
611+  D512 C9               ret
# file closed: game/robots.asm
165   D513                  include "game\bullet.asm"
# file opened: game/bullet.asm
  1+  D513              ;
  2+  D513              ; Current state: x & y coords (screen), direction (0 left, 1 right), state
  3+  D513              ;
  4+  D513              bullet_state:
  5+  D513 00 00 00 00      defb 0,0,0,0
  6+  D517
  7+  D517              ;
  8+  D517              ; Initialise a the bullet
  9+  D517              ;
 10+  D517              bullet_init:
 11+  D517 DD 21 13 D5      ld ix,bullet_state
 12+  D51B DD 36 00 00      ld (ix),0
 13+  D51F DD 36 01 00      ld (ix+1),0
 14+  D523 DD 36 02 00      ld (ix+2),0
 15+  D527 DD 36 03 00      ld (ix+3),0
 16+  D52B C9               ret
 17+  D52C
 18+  D52C              ;
 19+  D52C              ; Shoots the bullet
 20+  D52C              ;
 21+  D52C              bullet_shoot:
 22+  D52C DD 21 13 D5      ld ix,bullet_state
 23+  D530 ED 4B 72 C4      ld bc,(player)              ; get the player coords
 24+  D534 3A 74 C4         ld a,(player+2)             ; get the player direction
 25+  D537 FE 01            cp 1                        ; going left?
 26+  D539 CA 47 D5         jp z,bullet_shoot0
 27+  D53C 3E 08            ld a,8
 28+  D53E 80               add a,b                     ; going right so add eight to start coords
 29+  D53F 47               ld b,a
 30+  D540 DD 36 02 01      ld (ix+2),1                 ; set right
 31+  D544 C3 50 D5         jp bullet_shoot1
 32+  D547              bullet_shoot0:
 33+  D547 78               ld a,b
 34+  D548 06 08            ld b,8
 35+  D54A 90               sub b
 36+  D54B 47               ld b,a                      ; going left so subtract eight to start coords
 37+  D54C DD 36 02 00      ld (ix+2),0                 ; set right
 38+  D550              bullet_shoot1:
 39+  D550 DD 71 00 DD      ld (ix),bc        ; store coords
 39+  D554 70 01
 40+  D556 DD 36 03 01      ld (ix+3),1       ; set state to 1
 41+  D55A CD B0 D5         call bullet_draw ; draw the initial frame
 42+  D55D C9               ret
 43+  D55E
 44+  D55E              ;
 45+  D55E              ; Performs bullet processing
 46+  D55E              ;
 47+  D55E              bullet_process:
 48+  D55E 3A 16 D5         ld a,(bullet_state+3)       ; get the state
 49+  D561 FE 00            cp 0
 50+  D563 C8               ret z                       ; don't draw if this has become inactive
 51+  D564 CD B0 D5         call bullet_draw            ; delete current frame
 52+  D567 CD 74 D5         call bullet_move            ; move the bullet
 53+  D56A 3A 16 D5         ld a,(bullet_state+3)       ; get the state
 54+  D56D FE 00            cp 0
 55+  D56F C8               ret z                       ; don't draw if this has become inactive
 56+  D570 CD B0 D5         call bullet_draw            ; draw new frame
 57+  D573 C9               ret
 58+  D574
 59+  D574              ;
 60+  D574              ; Moves the bullet, checking for collisions
 61+  D574              ;
 62+  D574              bullet_move:
 63+  D574 DD 21 13 D5      ld ix,bullet_state
 64+  D578 DD 4E 00 DD      ld bc,(ix)
 64+  D57C 46 01
 65+  D57E DD 7E 02         ld a,(ix+2)                 ; get the direction
 66+  D581 FE 00            cp 0                        ; going left?
 67+  D583 CA 8D D5         jp z,bullet_move0
 68+  D586 3E 08            ld a,8
 69+  D588 80               add b
 70+  D589 47               ld b,a                      ; add 8 since going right
 71+  D58A C3 92 D5         jp bullet_move1
 72+  D58D              bullet_move0:
 73+  D58D 78               ld a,b
 74+  D58E 06 08            ld b,8
 75+  D590 90               sub b
 76+  D591 47               ld b,a                      ; subtract 8 since going left
 77+  D592              bullet_move1:
 78+  D592 DD 71 00 DD      ld (ix),bc                  ; store new coords
 78+  D596 70 01
 79+  D598 C5               push bc
 80+  D599 CD BD D5         call bullets_checkforrobot
 81+  D59C C1               pop bc
 82+  D59D FE 01            cp 1                        ; if we hit a robot, keep moving
 83+  D59F C8               ret z
 84+  D5A0 CD 04 AC         call sprites_scadd          ; get memory loc of this block into de
 85+  D5A3 21 60 00         ld hl,96
 86+  D5A6 19               add hl,de
 87+  D5A7 7E               ld a,(hl)                   ; get the content
 88+  D5A8 FE 00            cp 0
 89+  D5AA C8               ret z                       ; if empty, continue
 90+  D5AB DD 36 03 00      ld (ix+3),0                 ; otherwise, mark bullet as inactive
 91+  D5AF C9               ret
 92+  D5B0
 93+  D5B0              ;
 94+  D5B0              ; Draw the bullet
 95+  D5B0              ;
 96+  D5B0              bullet_draw:
 97+  D5B0 ED 4B 13 D5      ld bc,(bullet_state)        ; get coords
 98+  D5B4 3E 1B            ld a,27
 99+  D5B6 CD 8A AA         call screen_getblock        ; get the block address
100+  D5B9 CD 0F AB         call sprites_drawsprite     ; draw the sprite
101+  D5BC C9               ret
102+  D5BD
103+  D5BD              ;
104+  D5BD              ; Checks to see if the robot is hitting a bullet
105+  D5BD              ; Outputs:
106+  D5BD              ; a = 0 if not robot hit
107+  D5BD              ; a = 1 if robot not hit
108+  D5BD              bullets_checkforrobot:
109+  D5BD 3E 00            ld a,0
110+  D5BF 32 13 D6         ld (bullets_tmp),a
111+  D5C2 3A 86 D1         ld a,(robots_robotsmax) ; robots to check
112+  D5C5 47               ld b,a
113+  D5C6 FD 21 58 D1      ld iy,robots_robots   ; start of robot array
114+  D5CA              bullets_checkforrobot0:
115+  D5CA C5               push bc
116+  D5CB FD 7E 02         ld a,(iy+2)             ; get the state
117+  D5CE FE 01            cp 1
118+  D5D0 C2 07 D6         jp nz,bullets_checkforrobot1 ; if not active, don't check
119+  D5D3 FD 5E 00 FD      ld de,(iy)              ; get robot coords
119+  D5D7 56 01
120+  D5D9 7A               ld a,d
121+  D5DA E6 F8            and 248                 ; get nearest multiple of 8
122+  D5DC 57               ld d,a
123+  D5DD ED 4B 13 D5      ld bc,(bullet_state)    ; get bullet coords
124+  D5E1 7A               ld a,d               ; get the player horiz coord
125+  D5E2 90               sub b                ; subtract robot coord
126+  D5E3 FE 00            cp 0                ; should be the same
127+  D5E5 C2 F1 D5         jp nz,bullets_checkforrobot2 ; if not, might have hit, so check the next char along... if matched, check vert
128+  D5E8 3E 08            ld a,8
129+  D5EA 82               add a,d
130+  D5EB 90               sub b                ; check again for the next char along
131+  D5EC FE 00            cp 0
132+  D5EE C2 07 D6         jp nz,bullets_checkforrobot1 ; if not, haven't hit
133+  D5F1              bullets_checkforrobot2:
134+  D5F1 7B               ld a,e               ; get the vert coord
135+  D5F2 91               sub c                ; subtract the bullet vertical coord from robots
136+  D5F3 C6 04            add 4                ; add the max distance
137+  D5F5 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
138+  D5F7 D2 07 D6         jp nc,bullets_checkforrobot1   ; if not, hasn't hit
139+  D5FA FD 36 02 02      ld (iy+2),2             ; mark the robot as killed
140+  D5FE FD 36 05 00      ld (iy+5),0             ; mark the anim frames as zero
141+  D602 3E 01            ld a,1
142+  D604 32 13 D6         ld (bullets_tmp),a      ; hit the flag to say we killed a robot
143+  D607              bullets_checkforrobot1:
144+  D607 11 07 00         ld de,7
145+  D60A FD 19            add iy,de              ; move to next robot
146+  D60C C1               pop bc
147+  D60D 10 BB            djnz bullets_checkforrobot0
148+  D60F 3A 13 D6         ld a,(bullets_tmp)
149+  D612 C9               ret
150+  D613
151+  D613              bullets_tmp:
152+  D613 00               defb 0
153+  D614
# file closed: game/bullet.asm
166   D614
167   D614              ;===========================================================================
168   D614              ; Stack.
169   D614              ;===========================================================================
170   D614
171   D614              ; Stack: this area is reserved for the stack
172   D614              STACK_SIZE: equ 100    ; in words
173   D614
174   D614              ; Reserve stack space
175   D614 00 00            defw 0  ; WPMEM, 2
176   D616              stack_bottom:
177   D616 00 00 00...      defs    STACK_SIZE*2, 0
178   D6DE              stack_top:
179   D6DE 00 00            defw 0  ; WPMEM, 2
180   D6E0
181   D6E0                     SAVESNA "./dist/ThePit.sna", main
182   D6E0                     ;SAVETAP "./dist/ThePit.tap", main
# file closed: main.asm
