# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;===========================================================================
  6   8000              ; Persistent watchpoint.
  7   8000              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
  8   8000              ; If you do so the program will hit a breakpoint when it tries to
  9   8000              ; write to the first byte of the 3rd line.
 10   8000              ; When program breaks in the fill_memory sub routine please hover over hl
 11   8000              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 12   8000              ;===========================================================================
 13   8000
 14   8000              ; WPMEMx 0x5840, 1, w
 15   8000
 16   8000
 17   8000              ;===========================================================================
 18   8000              ; main routine - the code execution starts here.
 19   8000              ; Sets up the new interrupt routine, the memory
 20   8000              ; banks and jumps to the start loop.
 21   8000              ;===========================================================================
 22   8000              main:
 23   8000 21 9F B7         ld hl,font
 24   8003 22 36 5C         ld (23606),hl
 25   8006 CD 23 B0         call options_show
 26   8009
 27   8009                  ; Draw the title screen
 28   8009              main_titlescreen:
 29   8009 CD 28 AC         call titlescreen_show
 30   800C CD 62 C3         call game_init
 31   800F CD CE C3         call player_init_gamestart
 32   8012
 33   8012              main_lifestart:
 34   8012
 35   8012 CD F4 C3         call player_init_lifestart
 36   8015
 37   8015 CD A8 AD         call lifescreen_draw        ; show the lives remaining screen
 38   8018
 39   8018 CD C3 80         call init_start
 40   801B CD F2 A8         call screen_draw
 41   801E CD 41 A8         call buffer_allbuffertoscreen
 42   8021
 43   8021 CD F5 CC         call missiles_init
 44   8024 CD F5 C5         call ship_land              ; land the ship
 45   8027 CD 08 C7         call tank_init
 46   802A CD BD CC         call diamonds_init
 47   802D CD A6 CE         call thepit_init
 48   8030 CD 3D CF         call monster_init
 49   8033 CD 18 D0         call robots_init
 50   8036 CD A8 D3         call bullet_init
 51   8039
 52   8039              mloop:
 53   8039                  ;halt
 54   8039 CD 80 80         call main_loop_processing
 55   803C
 56   803C                  ;
 57   803C                  ; Check if the player died
 58   803C                  ;
 59   803C 21 92 C3         ld hl,player+10
 60   803F 7E               ld a,(hl)                   ; check if the player died this frame
 61   8040 FE 01            cp 1
 62   8042 C2 6C 80         jp nz,mloop0
 63   8045 CD 85 C4         call player_died        ; do end of life housekeeping
 64   8048 06 28            ld b,40
 65   804A CD 5E 81         call utilities_pauseforframes
 66   804D
 67   804D 21 91 C3         ld hl,player+9        ; check lives remaining
 68   8050 7E               ld a,(hl)
 69   8051 FE 00            cp 0
 70   8053 C2 66 80         jp nz,mloop1         ; haven't finished, so keep going
 71   8056
 72   8056 3A 47 C3         ld a,(game_numberplayers) ; get the number of players
 73   8059 FE 01            cp 1
 74   805B CA B4 80         jp z,main_gameover   ; if just one player, then this is game over
 75   805E
 76   805E 3A 48 C3         ld a,(game_currentplayer) ; get the current player
 77   8061 FE 02            cp 2                    ; if we're here, we have no lives, and if the current player is 2, then we're done
 78   8063 CA B4 80         jp z,main_gameover            ; if it's  two game over
 79   8066
 80   8066              mloop1:
 81   8066 CD 4C C3         call game_changeplayer ; change player if needed
 82   8069 C3 12 80         jp main_lifestart    ; otherwise, start a new life
 83   806C              mloop0:
 84   806C                  ;
 85   806C                  ; Check if the player completed the level
 86   806C                  ;
 87   806C 21 95 C3         ld hl,player+13
 88   806F 7E               ld a,(hl)
 89   8070 FE 01            cp 1
 90   8072 C2 39 80         jp nz,mloop
 91   8075 CD BF C5         call player_checkforexit
 92   8078 FE 01            cp 1                        ; look at return, if 1, level has been completed
 93   807A CA BA 80         jp z,main_endlevel          ; jump to level transition screen
 94   807D C3 39 80         jp mloop                ; start the loop again
 95   8080
 96   8080
 97   8080              main_loop_processing:
 98   8080
 99   8080 CD 00 A8         call buffer_buffertoscreen  ; copy buffer to screen
100   8083 CD 65 A7         call buffer_clearlist       ; zero the updated lines list
101   8086 CD 98 C3         call player_getlocation     ; figure out where the player is
102   8089 CD C9 C4         call player_drawplayer      ; delete player
103   808C CD 43 BE         call control_input          ; check input
104   808F CD C9 C4         call player_drawplayer      ; draw player
105   8092 CD 37 C7         call tank_process           ; prcoess the tank
106   8095 CD E0 C5         call ship_process           ; proces the ship
107   8098 CD 3B C9         call rocks_processrocks     ; process falling rocks
108   809B CD B1 CE         call thepit_process         ; process the pit trap
109   809E CD 1D CD         call missiles_process       ; process missiles
110   80A1 CD 5A CF         call monster_process        ; process monster
111   80A4 CD 9B D0         call robots_process         ; process robots
112   80A7 CD EF D3         call bullet_process         ; process the bullet
113   80AA CD 9C CC         call diamonds_twinkle       ; make the diamonds twinkle
114   80AD CD AE CA         call scores_printscore      ; update the score on screen
115   80B0 CD 68 C3         call game_incrementframe    ; increment the game frame
116   80B3
117   80B3 C9               ret
118   80B4
119   80B4              main_gameover:
120   80B4 CD 08 AE         call gameover_draw          ; show the game over screen
121   80B7 C3 09 80         jp main_titlescreen         ; go back to title
122   80BA
123   80BA              main_endlevel:
124   80BA CD 53 C4         call player_recordcurrentstate
125   80BD CD 1B AF         call endlevel_draw          ; show the end level screen
126   80C0 C3 12 80         jp main_lifestart           ; start a new life
127   80C3
128   80C3
129   80C3              ;===========================================================================
130   80C3              ; Include modules
131   80C3              ;===========================================================================
132   80C3                  include "init.asm"
# file opened: init.asm
  1+  80C3              ;
  2+  80C3              ; Set up at start up
  3+  80C3              ;
  4+  80C3              init_start:
  5+  80C3              ; We want a black screen.
  6+  80C3
  7+  80C3 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  80C5                                      ; bright (64).
  9+  80C5 CD 43 81         call utilities_clearscreen
 10+  80C8 32 8D 5C         ld (23693),a        ; set our screen colours.
 11+  80CB AF               xor a               ; quick way to load accumulator with zero.
 12+  80CC CD 9B 22         call 8859           ; set permanent border colours.
 13+  80CF
 14+  80CF 21 D7 A8         ld hl,screen_offset ; reset some temp variables
 15+  80D2 36 00            ld (hl),0
 16+  80D4 21 D8 A8         ld hl,screen_tmp
 17+  80D7 36 00            ld (hl),0
 18+  80D9 21 0D A7         ld hl,buffer_tmp
 19+  80DC 36 00            ld (hl),0
 20+  80DE 23               inc hl
 21+  80DF 36 00            ld (hl),0
 22+  80E1
 23+  80E1 CD 7B C3         call game_resetcurrentframe ; reset current frame
 24+  80E4
 25+  80E4 C9               ret
 26+  80E5
 27+  80E5              ;
 28+  80E5              ;   Start coord
 29+  80E5              ;   vert c, horiz b
 30+  80E5              init_coord:
 31+  80E5 18 30            defb 24,48
 32+  80E7
 33+  80E7              ;
 34+  80E7              ; Number of lives to start
 35+  80E7              ;
 36+  80E7              init_lives:
 37+  80E7 03               defb 3
 38+  80E8
 39+  80E8              ;
 40+  80E8              ; Score to start
 41+  80E8              ;
 42+  80E8              init_score:
 43+  80E8 30 30 30 30      defb '000000'
 43+  80EC 30 30
# file closed: init.asm
133   80EE                  include "utilities.asm"
# file opened: utilities.asm
  1+  80EE              ; ##########################################################################
  2+  80EE              ; Print a character
  3+  80EE              ; Inputs:
  4+  80EE              ; b - x coord
  5+  80EE              ; c - y coord
  6+  80EE              ; d - character
  7+  80EE              ; e - colour
  8+  80EE              ; ##########################################################################
  9+  80EE              utilities_print_char:
 10+  80EE 7B               ld a,e
 11+  80EF 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  80F2 3E 16            ld a,22
 13+  80F4 D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  80F5 78               ld a,b              ; Gets the X co-ordinate
 15+  80F6 3D               dec a
 16+  80F7 D7               rst 16
 17+  80F8 79               ld a,c              ; and the Y co-ordinate
 18+  80F9 D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  80FA 7A               ld a,d              ; ASCII code for udg.
 20+  80FB D7               rst 16              ; draw block.
 21+  80FC C9               ret
 22+  80FD
 23+  80FD
 24+  80FD              ;Inputs:
 25+  80FD              ;     DE and A are factors
 26+  80FD              ;Outputs:
 27+  80FD              ;     A is not changed
 28+  80FD              ;     B is 0
 29+  80FD              ;     C is not changed
 30+  80FD              ;     DE is not changed
 31+  80FD              ;     HL is the product
 32+  80FD              ;Time:
 33+  80FD              ;     342+6x
 34+  80FD              ;
 35+  80FD              utilities_multiply:
 36+  80FD 06 08            ld b,8          ;7           7
 37+  80FF 21 00 00         ld hl,0         ;10         10
 38+  8102 29               add hl,hl     ;11*8       88
 39+  8103 07               rlca          ;4*8        32
 40+  8104 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  8106 19                   add hl,de   ;--         --
 42+  8107 10 F9            djnz $-5      ;13*7+8     99
 43+  8109 C9               ret             ;10         10
 44+  810A
 45+  810A              utilities_waitforkey:
 46+  810A 21 08 5C         ld hl,23560         ; LAST K system variable.
 47+  810D 36 00            ld (hl),0           ; put null value there.
 48+  810F              utilities_waitforkey0:
 49+  810F 7E               ld a,(hl)           ; new value of LAST K.
 50+  8110 FE 00            cp 0                ; is it still zero?
 51+  8112 20 0A            jr nz,utilities_waitforkey1           ; yes, so no key pressed.
 52+  8114 01 1F 00         ld bc,31                        ; Kempston joystick port.
 53+  8117 ED 78            in a,(c)                        ; read input.
 54+  8119 E6 10            and 16
 55+  811B CA 0F 81         jp z,utilities_waitforkey0
 56+  811E              utilities_waitforkey1:
 57+  811E C9               ret                 ; key was pressed.
 58+  811F
 59+  811F              ;
 60+  811F              ; Waits number of frames for keypress. If got, returns 1, if not 0
 61+  811F              ; Inputs:
 62+  811F              ; a - number of frames to waits
 63+  811F              ; Ouputs:
 64+  811F              ; e - 0 not pressed, 1 pressed
 65+  811F              utilities_waitforkey_forframes:
 66+  811F 21 08 5C         ld hl,23560         ; LAST K system variable.
 67+  8122 36 00            ld (hl),0           ; put null value there.
 68+  8124 47               ld b,a              ; number of frames to wait
 69+  8125              utilities_waitforkey_forframes0:
 70+  8125 7E               ld a,(hl)           ; new value of LAST K.
 71+  8126 FE 00            cp 0                ; is it still zero?
 72+  8128 28 03            jr z,utilities_waitforkey_forframes1           ; yes, so no key pressed.
 73+  812A 1E 01            ld e,1              ; set the pressed flag
 74+  812C C9               ret                 ; key was pressed.
 75+  812D              utilities_waitforkey_forframes1:
 76+  812D C5               push bc
 77+  812E 01 1F 00         ld bc,31                        ; Kempston joystick port.
 78+  8131 ED 78            in a,(c)                        ; read input.
 79+  8133 C1               pop bc
 80+  8134 E6 10            and 16
 81+  8136 CA 3C 81         jp z,utilities_waitforkey_forframes2
 82+  8139 1E 01            ld e,1              ; set the pressed flag
 83+  813B C9               ret                 ; key was pressed.
 84+  813C              utilities_waitforkey_forframes2:
 85+  813C 76               halt                ; wait for frame
 86+  813D 76               halt                ; wait for frame
 87+  813E 10 E5            djnz utilities_waitforkey_forframes0 ; loop again
 88+  8140 1E 00            ld e,0              ; nothing pressed in time
 89+  8142 C9               ret
 90+  8143
 91+  8143              ;
 92+  8143              ; Clears the screen
 93+  8143              ; Inputs:
 94+  8143              ; a - attribute colour
 95+  8143              utilities_clearscreen:
 96+  8143 76               halt
 97+  8144 21 00 58         ld hl,22528         ; attr
 98+  8147 11 01 58         ld de,22529         ; attr+1
 99+  814A 01 FF 02         ld bc,767
100+  814D 77               ld (hl),a
101+  814E ED B0            ldir
102+  8150
103+  8150 21 00 40         ld hl, 16384        ;pixels
104+  8153 11 01 40         ld de, 16385        ;pixels + 1
105+  8156 01 FF 17         ld bc, 6143         ;pixels area length - 1
106+  8159 36 00            ld (hl), 0          ;set first byte to '0'
107+  815B ED B0            ldir                ;copy bytes
108+  815D
109+  815D C9               ret
110+  815E
111+  815E              ;
112+  815E              ; Wait for a number of frames
113+  815E              ; Inputs:
114+  815E              ; b - number of frames
115+  815E              utilities_pauseforframes:
116+  815E 76               halt
117+  815F 10 FD            djnz utilities_pauseforframes
118+  8161 C9               ret
119+  8162
120+  8162              utilities_readkey:
121+  8162 21 82 81         LD HL,utilties_keymap              ; Point HL at the keyboard list
122+  8165 16 08            LD D,8                                  ; This is the number of ports (rows) to check
123+  8167 0E FE            LD C,$FE                            ; C is always FEh for reading keyboard ports
124+  8169              utilities_readkey_0:
125+  8169 46               LD B,(HL)                               ; Get the keyboard port address from table
126+  816A 23               INC HL                                  ; Increment to list of keys
127+  816B ED 78            IN A,(C)                                ; Read the row of keys in
128+  816D E6 1F            AND $1F                                     ; We are only interested in the first five bits
129+  816F 1E 05            LD E,5                                  ; This is the number of keys in the row
130+  8171              utilities_readkey_1:
131+  8171 CB 3F            SRL A                                   ; Shift A right; bit 0 sets carry bit
132+  8173 30 0B            JR NC,utilities_readkey_2   ; If the bit is 0, we've found our key
133+  8175 23               INC HL                                  ; Go to next table address
134+  8176 1D               DEC E                                   ; Decrement key loop counter
135+  8177 20 F8            JR NZ,utilities_readkey_1   ; Loop around until this row finished
136+  8179 15               DEC D                                   ; Decrement row loop counter
137+  817A 20 ED            JR NZ,utilities_readkey_0   ; Loop around until we are done
138+  817C A7               AND A                                   ; Clear A (no key found)
139+  817D C3 62 81         jp utilities_readkey
140+  8180              utilities_readkey_2:
141+  8180 7E               LD A,(HL)                               ; We've found a key at this point; fetch the character code!
142+  8181 C9               RET
143+  8182
144+  8182              utilties_keymap:
145+  8182 FE 23 5A 58      defb $FE,"#","Z","X","C","V"
145+  8186 43 56
146+  8188 FD 41 53 44      defb $FD,"A","S","D","F","G"
146+  818C 46 47
147+  818E FB 51 57 45      defb $FB,"Q","W","E","R","T"
147+  8192 52 54
148+  8194 F7 31 32 33      defb $F7,"1","2","3","4","5"
148+  8198 34 35
149+  819A EF 30 39 38      defb $EF,"0","9","8","7","6"
149+  819E 37 36
150+  81A0 DF 50 4F 49      defb $DF,"P","O","I","U","Y"
150+  81A4 55 59
151+  81A6 BF 23 4C 4B      defb $BF,"#","L","K","J","H"
151+  81AA 4A 48
152+  81AC 7F 20 23 4D      defb $7F," ","#","M","N","B"
152+  81B0 4E 42
153+  81B2
154+  81B2
155+  81B2              ;
156+  81B2              ; Generates a randomish number in the range 0 to e
157+  81B2              ; Inputs:
158+  81B2              ; e - upper value
159+  81B2              ; Outputs:
160+  81B2              ; a - random number
161+  81B2              utilities_randomupper
162+  81B2 3A 46 C3         ld a,(game_framenumber)
163+  81B5 6F               ld l,a
164+  81B6 26 00            ld h,0
165+  81B8 16 00            ld d,0
166+  81BA 42 4B            ld bc,de
167+  81BC              utilities_randomupper0:
168+  81BC B7               or a
169+  81BD ED 42            sbc hl,bc
170+  81BF F2 BC 81         jp p,utilities_randomupper0
171+  81C2 09               add hl,bc
172+  81C3 01 00 00         ld bc,0
173+  81C6 09               add hl,bc
174+  81C7 7D               ld a,l
175+  81C8 C9               ret
176+  81C9
# file closed: utilities.asm
134   81C9                  include "strings.asm"
# file opened: strings.asm
  1+  81C9              string_score1:
  2+  81C9 04 00 53 43      defb 4,0,'SCORE1',255
  2+  81CD 4F 52 45 31
  2+  81D1 FF
  3+  81D2              string_scorenumbers1:
  4+  81D2 04 01 30 30      defb 4,1,'000000',255
  4+  81D6 30 30 30 30
  4+  81DA FF
  5+  81DB              string_company:
  6+  81DB 0C 00 43 45      defb 12,0,'CENTURI',255
  6+  81DF 4E 54 55 52
  6+  81E3 49 FF
  7+  81E5              string_player1:
  8+  81E5 0C 01 50 4C      defb 12,1,'PLAYER 1',255
  8+  81E9 41 59 45 52
  8+  81ED 20 31 FF
  9+  81F0              string_player2:
 10+  81F0 0C 01 50 4C      defb 12,1,'PLAYER 2',255
 10+  81F4 41 59 45 52
 10+  81F8 20 32 FF
 11+  81FB              string_score2:
 12+  81FB 16 00 53 43      defb 22,0,'SCORE2',255
 12+  81FF 4F 52 45 32
 12+  8203 FF
 13+  8204              string_scorenumbers2:
 14+  8204 16 01 30 30      defb 22,1,'000000',255
 14+  8208 30 30 30 30
 14+  820C FF
 15+  820D              string_titlescreen_copyright:
 16+  820D 06 15 7F 31      defb 6,21, 127,'1982  CENTURI INC',255
 16+  8211 39 38 32 20
 16+  8215 20 43 45 4E
 16+  8219 54 55 52 49
 16+  821D 20 49 4E 43
 16+  8221 FF
 17+  8222
 18+  8222
 19+  8222              string_alttitlescreen_1:
 20+  8222 0C 00 43 52      defb 12,0,'CREDITS 1',255
 20+  8226 45 44 49 54
 20+  822A 53 20 31 FF
 21+  822E              string_alttitlescreen_2:
 22+  822E 00 02 20 20      defb 0,2,'           THE OBJECT',254
 22+  8232 20 20 20 20
 22+  8236 20 20 20 20
 22+  823A 20 54 48 45
 22+  823E 20 4F 42 4A
 22+  8242 45 43 54 FE
 23+  8246 00 03 20 20      defb 0,3,'          OF THIS GAME',254
 23+  824A 20 20 20 20
 23+  824E 20 20 20 20
 23+  8252 4F 46 20 54
 23+  8256 48 49 53 20
 23+  825A 47 41 4D 45
 23+  825E FE
 24+  825F 00 04 20 20      defb 0,4,'         IS TO DIG DOWN',254
 24+  8263 20 20 20 20
 24+  8267 20 20 20 49
 24+  826B 53 20 54 4F
 24+  826F 20 44 49 47
 24+  8273 20 44 4F 57
 24+  8277 4E FE
 25+  8279 00 05 20 20      defb 0,5,'        TO THE BOTTOM PIT',254
 25+  827D 20 20 20 20
 25+  8281 20 20 54 4F
 25+  8285 20 54 48 45
 25+  8289 20 42 4F 54
 25+  828D 54 4F 4D 20
 25+  8291 50 49 54 FE
 26+  8295 00 06 20 20      defb 0,6,'               AND',254
 26+  8299 20 20 20 20
 26+  829D 20 20 20 20
 26+  82A1 20 20 20 20
 26+  82A5 20 41 4E 44
 26+  82A9 FE
 27+  82AA 00 07 20 20      defb 0,7,'        COLLECT AT LEAST',254
 27+  82AE 20 20 20 20
 27+  82B2 20 20 43 4F
 27+  82B6 4C 4C 45 43
 27+  82BA 54 20 41 54
 27+  82BE 20 4C 45 41
 27+  82C2 53 54 FE
 28+  82C5 00 08 20 20      defb 0,8,'         ONE LARGE JEWEL',254
 28+  82C9 20 20 20 20
 28+  82CD 20 20 20 4F
 28+  82D1 4E 45 20 4C
 28+  82D5 41 52 47 45
 28+  82D9 20 4A 45 57
 28+  82DD 45 4C FE
 29+  82E0 00 09 20 20      defb 0,9,'              THEN',254
 29+  82E4 20 20 20 20
 29+  82E8 20 20 20 20
 29+  82EC 20 20 20 20
 29+  82F0 54 48 45 4E
 29+  82F4 FE
 30+  82F5 00 0A 20 20      defb 0,10,'         RETURN TO SHIP',254
 30+  82F9 20 20 20 20
 30+  82FD 20 20 20 52
 30+  8301 45 54 55 52
 30+  8305 4E 20 54 4F
 30+  8309 20 53 48 49
 30+  830D 50 FE
 31+  830F 00 0B 20 20      defb 0,11,'         THRU UPPER PIT',255
 31+  8313 20 20 20 20
 31+  8317 20 20 20 54
 31+  831B 48 52 55 20
 31+  831F 55 50 50 45
 31+  8323 52 20 50 49
 31+  8327 54 FF
 32+  8329              string_alttitlescreen_3:
 33+  8329 00 0D 20 20      defb 0,13,'    SINGLE BONUS  5000 POINTS',254
 33+  832D 20 20 53 49
 33+  8331 4E 47 4C 45
 33+  8335 20 42 4F 4E
 33+  8339 55 53 20 20
 33+  833D 35 30 30 30
 33+  8341 20 50 4F 49
 33+  8345 4E 54 53 FE
 34+  8349 00 0E 20 20      defb 0,14,'      COLLECT 1 LARGE JEWEL',254
 34+  834D 20 20 20 20
 34+  8351 43 4F 4C 4C
 34+  8355 45 43 54 20
 34+  8359 31 20 4C 41
 34+  835D 52 47 45 20
 34+  8361 4A 45 57 45
 34+  8365 4C FE
 35+  8367 00 0F 20 20      defb 0,15,'       AND RETURN TO SHIP',254
 35+  836B 20 20 20 20
 35+  836F 20 41 4E 44
 35+  8373 20 52 45 54
 35+  8377 55 52 4E 20
 35+  837B 54 4F 20 53
 35+  837F 48 49 50 FE
 36+  8383 00 11 20 20      defb 0,17,'    DOUBLE BONUS  10000 POINTS',254
 36+  8387 20 20 44 4F
 36+  838B 55 42 4C 45
 36+  838F 20 42 4F 4E
 36+  8393 55 53 20 20
 36+  8397 31 30 30 30
 36+  839B 30 20 50 4F
 36+  839F 49 4E 54 53
 36+  83A3 FE
 37+  83A4 00 12 20 20      defb 0,18,'    COLLECT ALL 3 LARGE JEWELS',254
 37+  83A8 20 20 43 4F
 37+  83AC 4C 4C 45 43
 37+  83B0 54 20 41 4C
 37+  83B4 4C 20 33 20
 37+  83B8 4C 41 52 47
 37+  83BC 45 20 4A 45
 37+  83C0 57 45 4C 53
 37+  83C4 FE
 38+  83C5 00 13 20 20      defb 0,19,'       OR   ALL 4 SMALL JEWELS',254
 38+  83C9 20 20 20 20
 38+  83CD 20 4F 52 20
 38+  83D1 20 20 41 4C
 38+  83D5 4C 20 34 20
 38+  83D9 53 4D 41 4C
 38+  83DD 4C 20 4A 45
 38+  83E1 57 45 4C 53
 38+  83E5 FE
 39+  83E6 00 15 20 20      defb 0,21,'    TRIPLE BONUS  15000 POINTS',254
 39+  83EA 20 20 54 52
 39+  83EE 49 50 4C 45
 39+  83F2 20 42 4F 4E
 39+  83F6 55 53 20 20
 39+  83FA 31 35 30 30
 39+  83FE 30 20 50 4F
 39+  8402 49 4E 54 53
 39+  8406 FE
 40+  8407 00 16 20 20      defb 0,22,'       COLLECT ALL 7 JEWELS',255
 40+  840B 20 20 20 20
 40+  840F 20 43 4F 4C
 40+  8413 4C 45 43 54
 40+  8417 20 41 4C 4C
 40+  841B 20 37 20 4A
 40+  841F 45 57 45 4C
 40+  8423 53 FF
 41+  8425
 42+  8425              string_lifescreen_player:
 43+  8425 0B 00 20 50      defb 11,0,' PLAYER 1 ',255
 43+  8429 4C 41 59 45
 43+  842D 52 20 31 20
 43+  8431 FF
 44+  8432              string_lifescreen_lives:
 45+  8432 0B 03 30 20      defb 11,3,48,' MEN LEFT',255
 45+  8436 4D 45 4E 20
 45+  843A 4C 45 46 54
 45+  843E FF
 46+  843F              string_lifescreen_lastman:
 47+  843F 0C 03 4C 41      defb 12,3,'LAST MAN',255
 47+  8443 53 54 20 4D
 47+  8447 41 4E FF
 48+  844A
 49+  844A              string_gameoverscreen_gameover:
 50+  844A 0B 06 47 41      defb 11,6,'GAME OVER',255
 50+  844E 4D 45 20 4F
 50+  8452 56 45 52 FF
 51+  8456              string_gameoverscreen_copyright:
 52+  8456 07 12 7F 31      defb 7,18,127,'1982 CENTURI INC',255
 52+  845A 39 38 32 20
 52+  845E 43 45 4E 54
 52+  8462 55 52 49 20
 52+  8466 49 4E 43 FF
 53+  846A              string_gameoverscreen_bestscores:
 54+  846A 07 16 42 45      defb 7,22,'BEST SCORES TODAY',255
 54+  846E 53 54 20 53
 54+  8472 43 4F 52 45
 54+  8476 53 20 54 4F
 54+  847A 44 41 59 FF
 55+  847E              string_gameover_credits:
 56+  847E 0C 01 43 52      defb 12,1,'CREDITS 0',255
 56+  8482 45 44 49 54
 56+  8486 53 20 30 FF
 57+  848A
 58+  848A              string_highscore_congratulations:
 59+  848A 08 05 43 4F      defb 8,5,'CONGRATULATIONS',255
 59+  848E 4E 47 52 41
 59+  8492 54 55 4C 41
 59+  8496 54 49 4F 4E
 59+  849A 53 FF
 60+  849C              string_highscore_player1:
 61+  849C 0C 07 50 4C      defb 12,7,'PLAYER 1',255
 61+  84A0 41 59 45 52
 61+  84A4 20 31 FF
 62+  84A7              string_highscore_player2:
 63+  84A7 0C 07 50 4C      defb 12,7,'PLAYER 2',255
 63+  84AB 41 59 45 52
 63+  84AF 20 32 FF
 64+  84B2              string_highscore_youhaveearned:
 65+  84B2 08 0A 59 4F      defb 8,10,'YOU HAVE EARNED',255
 65+  84B6 55 20 48 41
 65+  84BA 56 45 20 45
 65+  84BE 41 52 4E 45
 65+  84C2 44 FF
 66+  84C4              string_highscore_place1:
 67+  84C4 06 0C 54 48      defb 6,12,'THE GREATEST SCORE',255
 67+  84C8 45 20 47 52
 67+  84CC 45 41 54 45
 67+  84D0 53 54 20 53
 67+  84D4 43 4F 52 45
 67+  84D8 FF
 68+  84D9              string_highscore_place2:
 69+  84D9 06 0C 54 48      defb 6,12,'THE 2ND BEST SCORE',255
 69+  84DD 45 20 32 4E
 69+  84E1 44 20 42 45
 69+  84E5 53 54 20 53
 69+  84E9 43 4F 52 45
 69+  84ED FF
 70+  84EE              string_highscore_place3:
 71+  84EE 06 0C 54 48      defb 6,12,'THE 3RD BEST SCORE',255
 71+  84F2 45 20 33 52
 71+  84F6 44 20 42 45
 71+  84FA 53 54 20 53
 71+  84FE 43 4F 52 45
 71+  8502 FF
 72+  8503              string_highscore_pleaseenter
 73+  8503 03 0F 52 45      defb 3,15,'RECORD YOUR INITIALS BELOW',255
 73+  8507 43 4F 52 44
 73+  850B 20 59 4F 55
 73+  850F 52 20 49 4E
 73+  8513 49 54 49 41
 73+  8517 4C 53 20 42
 73+  851B 45 4C 4F 57
 73+  851F FF
 74+  8520
 75+  8520              string_endlevel_youhaveearned:
 76+  8520 08 0B 59 4F      defb 8,11,'YOU HAVE EARNED',255
 76+  8524 55 20 48 41
 76+  8528 56 45 20 45
 76+  852C 41 52 4E 45
 76+  8530 44 FF
 77+  8532              string_endlevel_bonus1:
 78+  8532 09 0D 53 49      defb 9,13,'SINGLE BONUS',255
 78+  8536 4E 47 4C 45
 78+  853A 20 42 4F 4E
 78+  853E 55 53 FF
 79+  8541              string_endlevel_bonus2:
 80+  8541 09 0D 44 4F      defb 9,13,'DOUBLE BONUS',255
 80+  8545 55 42 4C 45
 80+  8549 20 42 4F 4E
 80+  854D 55 53 FF
 81+  8550              string_endlevel_bonus3:
 82+  8550 09 0D 54 52      defb 9,13,'TRIPLE BONUS',255
 82+  8554 49 50 4C 45
 82+  8558 20 42 4F 4E
 82+  855C 55 53 FF
 83+  855F              string_endlevel_points1:
 84+  855F 0A 0F 35 30      defb 10,15,'5000 POINTS',255
 84+  8563 30 30 20 50
 84+  8567 4F 49 4E 54
 84+  856B 53 FF
 85+  856D              string_endlevel_points2:
 86+  856D 09 0F 31 30      defb 9,15,'10000 POINTS',255
 86+  8571 30 30 30 20
 86+  8575 50 4F 49 4E
 86+  8579 54 53 FF
 87+  857C              string_endlevel_points3:
 88+  857C 09 0F 31 35      defb 9,15,'15000 POINTS',255
 88+  8580 30 30 30 20
 88+  8584 50 4F 49 4E
 88+  8588 54 53 FF
 89+  858B              string_endlevel_anothergo:
 90+  858B 08 12 48 41      defb 8,18,'HAVE ANOTHER GO',255
 90+  858F 56 45 20 41
 90+  8593 4E 4F 54 48
 90+  8597 45 52 20 47
 90+  859B 4F FF
 91+  859D
 92+  859D              string_zonk:
 93+  859D 00 00 5A 4F      defb 0,0,'ZONK!!',255
 93+  85A1 4E 4B 21 21
 93+  85A5 FF
 94+  85A6
 95+  85A6
 96+  85A6              string_options_title:
 97+  85A6 0D 03 54 48      defb 13,3,'THE PIT',255
 97+  85AA 45 20 50 49
 97+  85AE 54 FF
 98+  85B0              string_options_1player:
 99+  85B0 0A 06 31 2E      defb 10,6,'1. ONE PLAYER',255
 99+  85B4 20 4F 4E 45
 99+  85B8 20 50 4C 41
 99+  85BC 59 45 52 FF
100+  85C0              string_options_2player:
101+  85C0 0A 07 32 2E      defb 10,7,'2. TWO PLAYER',255
101+  85C4 20 54 57 4F
101+  85C8 20 50 4C 41
101+  85CC 59 45 52 FF
102+  85D0              string_options_keyboard:
103+  85D0 0A 08 33 2E      defb 10,8,'3. KEYBOARD',255
103+  85D4 20 4B 45 59
103+  85D8 42 4F 41 52
103+  85DC 44 FF
104+  85DE              string_options_joystick:
105+  85DE 0A 09 34 2E      defb 10,9,'4. KEMPSTON',255
105+  85E2 20 4B 45 4D
105+  85E6 50 53 54 4F
105+  85EA 4E FF
106+  85EC              string_options_start:
107+  85EC 0A 0A 35 2E      defb 10,10,'5. START',255
107+  85F0 20 53 54 41
107+  85F4 52 54 FF
108+  85F7              string_options_vanity:
109+  85F7 08 16 53 70      defb 8,22,'Spectrum Conversion',254
109+  85FB 65 63 74 72
109+  85FF 75 6D 20 43
109+  8603 6F 6E 76 65
109+  8607 72 73 69 6F
109+  860B 6E FE
110+  860D 07 17 62 79      defb 7,23,'by Dave Tansley, 2020',255
110+  8611 20 44 61 76
110+  8615 65 20 54 61
110+  8619 6E 73 6C 65
110+  861D 79 2C 20 32
110+  8621 30 32 30 FF
111+  8625
112+  8625              ;
113+  8625              ; Prints specified string
114+  8625              ; Inputs:
115+  8625              ; de: pointer to string
116+  8625              ; bc: length of string
117+  8625              ;
118+  8625              ; Print String Data
119+  8625              ; First two bytes of string contain X and Y char position, then the string
120+  8625              ; Individual strings are terminated with 0xFE
121+  8625              ; End of data is terminated with 0xFF
122+  8625              ; HL: Address of string
123+  8625              ;
124+  8625 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
125+  8626 23                                   INC HL                          ; Increase HL to the next memory location
126+  8627 56                                   LD D,(HL)                       ; Fetch the Y coordinate
127+  8628 23                                   INC HL                          ; Increase HL to the next memory location
128+  8629 CD 3C 86                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
129+  862C 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
130+  862D 23                                   INC HL                          ; Increase HL to the next character
131+  862E FE FE                                CP 0xFE                         ; Compare with 0xFE
132+  8630 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
133+  8632 D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
134+  8633 E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
135+  8634 CD 4C 86                             CALL Print_Char                 ; Print the character
136+  8637 E1                                   POP HL                          ; Retrieve HL back off the stack
137+  8638 1C                                   INC E                           ; Go to the next screen address
138+  8639 18 F1                                JR string_print_0               ; Loop back to print next character
139+  863B C9                                   RET
140+  863C
141+  863C              ; Get screen address
142+  863C              ; D = Y character position
143+  863C              ; E = X character position
144+  863C              ; Returns address in DE
145+  863C              ;
146+  863C 7A           string_getcharaddress:       LD A,D
147+  863D E6 07                                AND %00000111
148+  863F 1F                                   RRA
149+  8640 1F                                   RRA
150+  8641 1F                                   RRA
151+  8642 1F                                   RRA
152+  8643 B3                                   OR E
153+  8644 5F                                   LD E,A
154+  8645 7A                                   LD A,D
155+  8646 E6 18                                AND %00011000
156+  8648 F6 40                                OR %01000000
157+  864A 57                                   LD D,A
158+  864B C9                                   RET                             ; Returns screen address in DE
159+  864C
160+  864C              ; Print a single character out
161+  864C              ; A:  Character to print
162+  864C              ; DE: Screen address to print character at
163+  864C              ;
164+  864C 2A 36 5C     Print_Char:             LD HL,(23606)                    ; Address of character set table in ROM
165+  864F 06 00                                LD B,0                          ; Set BC to A
166+  8651 4F                                   LD C,A
167+  8652 E6 FF                                AND 0xFF                        ; Clear the carry bit
168+  8654 CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
169+  8656 CB 10                                RL B
170+  8658 CB 11                                RL C
171+  865A CB 10                                RL B
172+  865C CB 11                                RL C
173+  865E CB 10                                RL B
174+  8660 09                                   ADD HL,BC                       ; Get the character address in HL
175+  8661 0E 08                                LD C,8                          ; Loop counter
176+  8663 D5                                   PUSH DE
177+  8664 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
178+  8665 12                                   LD (DE),A                       ; Stick A onto the screen
179+  8666 14                                   INC D                           ; Goto next line on screen
180+  8667 23                                   INC HL                           ; Goto next byte of character
181+  8668 0D                                   DEC C                           ; Decrease the loop counter
182+  8669 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
183+  866B D1                                   POP DE
184+  866C C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
135   866D                  include "screen\buffer.asm"
# file opened: screen/buffer.asm
  1+  866D              buffer_buffer:
  2+  866D 00 00 00...      defs 7424                   ; area reserved for screen
  3+  A36D
  4+  A36D              buffer_attr_buffer:
  5+  A36D 00 00 00...      defs 928                    ; attrs buffer area
  6+  A70D
  7+  A70D              buffer_tmp:
  8+  A70D 00 00            defb 0,0                    ; temp area
  9+  A70F
 10+  A70F              ;
 11+  A70F              ; This list stores lines to be updated by the buffer.
 12+  A70F              ; This is done by half line. Lines are encded with.
 13+  A70F              ; 00hlllll
 14+  A70F              ; Where h is the half of the screen (0 or 1), lllll is the line number
 15+  A70F              buffer_updatedlines:
 16+  A70F FF FF FF...      defs 21,255
 17+  A724
 18+  A724              buffer_updateall:
 19+  A724 00               defb 0
 20+  A725
 21+  A725              ;
 22+  A725              ; Stores a line number in the update list
 23+  A725              ; Inputs:
 24+  A725              ; a - row number
 25+  A725              buffer_marklineforupdate:
 26+  A725 FE 15            cp 21
 27+  A727 D0               ret nc                          ; dont store lines that we shouldn't draw
 28+  A728 5F               ld e,a                          ; store in e
 29+  A729 ED 4B 20 AC      ld bc,(origcoords)              ; this should hold the coords of what was drawn
 30+  A72D 79               ld a,c                          ; get the horiz coord
 31+  A72E FE 0F            cp 15
 32+  A730 CA 47 A7         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 33+  A733 FE 10            cp 16                           ; if this is 15 or less, the first half of screen
 34+  A735 CA 47 A7         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 35+  A738 DA 43 A7         jp c,buffer_marklineforupdate4  ; if first half, nothing to do
 36+  A73B 78               ld a,b                          ; get the vertical
 37+  A73C 3E 20            ld a,32                         ; set the 6th bit by adding 32
 38+  A73E 83               add a,e
 39+  A73F 5F               ld e,a                          ; store this value
 40+  A740 C3 4E A7         jp buffer_marklineforupdate2
 41+  A743              buffer_marklineforupdate4:
 42+  A743 78               ld a,b
 43+  A744 C3 4E A7         jp buffer_marklineforupdate2    ; just get the vertical
 44+  A747              buffer_marklineforupdate3:          ; special case for 15,16 - need to render both halves, since might be between
 45+  A747 CD 52 A7         call buffer_storelineforupdate  ; call store update for e
 46+  A74A 3E 20            ld a,32
 47+  A74C 83               add a,e
 48+  A74D 5F               ld e,a
 49+  A74E              buffer_marklineforupdate2:
 50+  A74E CD 52 A7         call buffer_storelineforupdate  ; call store update for e
 51+  A751 C9               ret
 52+  A752
 53+  A752
 54+  A752              ;
 55+  A752              ; Stores the calculated line and half if needed
 56+  A752              ; Inputs:
 57+  A752              ; e - half/row
 58+  A752              ;
 59+  A752              buffer_storelineforupdate:
 60+  A752 06 15            ld b,21
 61+  A754 21 0F A7         ld hl,buffer_updatedlines
 62+  A757              buffer_storelineforupdate0:
 63+  A757 7E               ld a,(hl)                       ; get the line stored in updated lines
 64+  A758 BB               cp e                            ; is this the same as the row number passed in?
 65+  A759 C8               ret z                           ; if so, don't need to do anything
 66+  A75A FE FF            cp 255                          ; is this 255, ie the end of the buffer
 67+  A75C C2 61 A7         jp nz,buffer_storelineforupdate1 ; if not, move to next
 68+  A75F 73               ld (hl),e
 69+  A760 C9               ret
 70+  A761              buffer_storelineforupdate1:
 71+  A761 23               inc hl
 72+  A762 10 F3            djnz buffer_storelineforupdate0
 73+  A764 C9               ret
 74+  A765
 75+  A765              ;
 76+  A765              ; Zeroes the updated lines list
 77+  A765              ;
 78+  A765              buffer_clearlist:
 79+  A765 06 15            ld b,21
 80+  A767 21 0F A7         ld hl,buffer_updatedlines
 81+  A76A              buffer_clearlist0:
 82+  A76A 36 FF            ld (hl),255
 83+  A76C 23               inc hl
 84+  A76D 10 FB            djnz buffer_clearlist0
 85+  A76F C9               ret
 86+  A770
 87+  A770              ;
 88+  A770              ; Which half are we displaying? 0 left 1 right
 89+  A770              ;
 90+  A770              buffer_bufferhalf:
 91+  A770 00               defb 0
 92+  A771
 93+  A771              ;
 94+  A771              ; Copies the buffer to the screen. Use stack.
 95+  A771              ; Inputs:
 96+  A771              ; hl - half/line number to display - 0 is first half, 0 is first line
 97+  A771              ;
 98+  A771              buffer_bufferlinetoscreen:
 99+  A771 7C               ld a,h
100+  A772 32 70 A7         ld (buffer_bufferhalf),a        ; store the half
101+  A775 7D               ld a,l
102+  A776 4F               ld c,a                          ; store a
103+  A777 ED 5B D7 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows, want it *256
104+  A77B 83               add a,e                       ; add the row number
105+  A77C 11 00 01         ld de,256
106+  A77F CD FD 80         call utilities_multiply
107+  A782 54 5D            ld de,hl
108+  A784 21 6D 86         ld hl,buffer_buffer
109+  A787 19               add hl,de                   ; add the offset
110+  A788 79               ld a,c                      ; get original row back
111+  A789 ED 73 FC A7      ld (buffer_bufferlinetoscreen3+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
112+  A78D D9               exx
113+  A78E 0E 00            ld c,0                      ; zero horizontal
114+  A790 47               ld b,a                      ; load the row number into vertical coord
115+  A791 04               inc b
116+  A792 04               inc b                       ; move forward 2 to allow for scores
117+  A793 CD CF A9         call screen_getcelladdress  ; get the memory into de
118+  A796 21 10 00         ld hl,16                    ; offset by 16 chars to get to the centre, since populating stack from right
119+  A799 19               add hl,de
120+  A79A 3A 70 A7         ld a,(buffer_bufferhalf)    ; get the half
121+  A79D FE 01            cp 1
122+  A79F CA CC A7         jp z,buffer_bufferlinetoscreen4
123+  A7A2              buffer_bufferlinetoscreen0:     ; PROCESS THE LEFT HALF
124+  A7A2 D9               exx                         ; hl is now buffer
125+  A7A3 23               inc hl
126+  A7A4 23               inc hl                      ; move hl forward 2 to skip first two blocks
127+  A7A5 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
128+  A7A6 F1               pop af
129+  A7A7 C1               pop bc
130+  A7A8 D1               pop de
131+  A7A9 DD E1            pop ix
132+  A7AB D9               exx                         ; hl is now screen
133+  A7AC 08               ex af,af'
134+  A7AD F1               pop af
135+  A7AE C1               pop bc
136+  A7AF D1               pop de
137+  A7B0 F9               ld sp,hl                    ; sp pointing at screen
138+  A7B1 D5               push de
139+  A7B2 C5               push bc
140+  A7B3 F5               push af
141+  A7B4 08               ex af,af'
142+  A7B5 D9               exx                         ; hl is now buffer
143+  A7B6 DD E5            push ix
144+  A7B8 D5               push de
145+  A7B9 C5               push bc
146+  A7BA F5               push af
147+  A7BB 11 1E 00         ld de,30                    ; add thirty to get to next line
148+  A7BE 19               add hl,de
149+  A7BF F9               ld sp,hl                    ; sp pointing at buffer
150+  A7C0 D9               exx                         ; hl is now screen
151+  A7C1 08               ex af,af'
152+  A7C2 24               inc h
153+  A7C3 7C               ld a,h
154+  A7C4 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
155+  A7C6 C2 A2 A7         jp nz,buffer_bufferlinetoscreen0 ; next line in cell
156+  A7C9              buffer_bufferlinetoscreen1:
157+  A7C9 C3 FB A7         jp buffer_bufferlinetoscreen3
158+  A7CC              buffer_bufferlinetoscreen4:     ; PROCESS THE RIGHT HALF
159+  A7CC D9               exx                         ; hl is buffer
160+  A7CD 11 10 00         ld de,16
161+  A7D0 19               add hl,de                   ; move halfway across
162+  A7D1 D9               exx                         ; hl is screen
163+  A7D2 11 0E 00         ld de,14
164+  A7D5 19               add hl,de
165+  A7D6              buffer_bufferlinetoscreen2:
166+  A7D6 D9               exx                         ; hl is now buffer
167+  A7D7 F9               ld sp,hl                    ; do first fourteen for right hand side, sp pointing at buffer
168+  A7D8 F1               pop af
169+  A7D9 C1               pop bc
170+  A7DA D1               pop de
171+  A7DB DD E1            pop ix
172+  A7DD D9               exx                         ; hl is now screen
173+  A7DE 08               ex af,af'
174+  A7DF F1               pop af
175+  A7E0 C1               pop bc
176+  A7E1 D1               pop de
177+  A7E2 F9               ld sp,hl                    ; sp pointing at screen
178+  A7E3 D5               push de
179+  A7E4 C5               push bc
180+  A7E5 F5               push af
181+  A7E6 08               ex af,af'
182+  A7E7 D9               exx                         ; hl is now buffer
183+  A7E8 DD E5            push ix
184+  A7EA D5               push de
185+  A7EB C5               push bc
186+  A7EC F5               push af
187+  A7ED 11 20 00         ld de,32                    ; add thirty two to get to next line
188+  A7F0 19               add hl,de
189+  A7F1 F9               ld sp,hl                    ; sp pointing at buffer
190+  A7F2 D9               exx                         ; hl is now screen
191+  A7F3 08               ex af,af'
192+  A7F4 24               inc h
193+  A7F5 7C               ld a,h
194+  A7F6 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
195+  A7F8 C2 D6 A7         jp nz,buffer_bufferlinetoscreen2 ; next line in cell
196+  A7FB              buffer_bufferlinetoscreen3:
197+  A7FB 31 00 00         ld sp,0
198+  A7FE D9               exx
199+  A7FF C9               ret
200+  A800
201+  A800              ;
202+  A800              ; Copies the buffer to the screen for updated lines. Use stack.
203+  A800              ; Inputs: none
204+  A800              ;
205+  A800              buffer_buffertoscreen:
206+  A800 3A 24 A7         ld a,(buffer_updateall)      ; get the all update flag
207+  A803 FE 00            cp 0
208+  A805 CA 11 A8         jp z,buffer_buffertoscreen2  ; if not set, draw only updated
209+  A808 CD 41 A8         call buffer_allbuffertoscreen ; otherwise, draw whole screen
210+  A80B 21 24 A7         ld hl,buffer_updateall
211+  A80E 36 00            ld (hl),0                    ; reset flag
212+  A810 C9               ret
213+  A811              buffer_buffertoscreen2:
214+  A811 06 15            ld b,21
215+  A813 FD 21 0F A7      ld iy,buffer_updatedlines    ; the location of the updated lines
216+  A817              buffer_buffertoscreen0:
217+  A817 FD 7E 00         ld a,(iy)
218+  A81A FE FF            cp 255
219+  A81C CA 40 A8         jp z,buffer_buffertoscreen1                       ; if this is 255, then we're at the end of the updated list
220+  A81F 6F               ld l,a
221+  A820 26 00            ld h,0
222+  A822 E6 20            and 32                      ; and with 32 to see if 6th bit is set
223+  A824 FE 20            cp 32                       ; if so, second half of screen
224+  A826 C2 31 A8         jp nz,buffer_buffertoscreen3
225+  A829 26 01            ld h,1                      ; store half in h
226+  A82B FD 7E 00         ld a,(iy)
227+  A82E D6 20            sub 32                      ; remove 32
228+  A830 6F               ld l,a                      ; stor in line number
229+  A831              buffer_buffertoscreen3:
230+  A831 C5               push bc
231+  A832 FD E5            push iy
232+  A834 F3               di
233+  A835 CD 71 A7         call buffer_bufferlinetoscreen      ; hl has h=half (0 or 1), l=line
234+  A838 FB               ei
235+  A839 FD E1            pop iy
236+  A83B C1               pop bc
237+  A83C FD 23            inc iy
238+  A83E 10 D7            djnz buffer_buffertoscreen0
239+  A840              buffer_buffertoscreen1:
240+  A840                  ;call buffer_buffertoattrsfast
241+  A840 C9               ret
242+  A841
243+  A841              ;
244+  A841              ; Copies the buffer to the screen. Use stack.
245+  A841              ; Inputs: none
246+  A841              ;
247+  A841              buffer_allbuffertoscreen:
248+  A841 06 15            ld b,21
249+  A843 3E 00            ld a,0
250+  A845              buffer_allbuffertoscreen0:
251+  A845 C5               push bc
252+  A846 F5               push af
253+  A847 F3               di
254+  A848 26 00            ld h,0
255+  A84A 6F               ld l,a
256+  A84B CD 71 A7         call buffer_bufferlinetoscreen
257+  A84E FB               ei
258+  A84F F1               pop af
259+  A850 F5               push af
260+  A851 F3               di
261+  A852 26 01            ld h,1
262+  A854 6F               ld l,a
263+  A855 CD 71 A7         call buffer_bufferlinetoscreen
264+  A858 FB               ei
265+  A859 F1               pop af
266+  A85A C1               pop bc
267+  A85B 3C               inc a
268+  A85C 10 E7            djnz buffer_allbuffertoscreen0
269+  A85E F3               di
270+  A85F CD 64 A8         call buffer_buffertoattrsfast
271+  A862 FB               ei
272+  A863 C9               ret
273+  A864
274+  A864              ;
275+  A864              ; Copies the attrs buffer to screen with the stack
276+  A864              ;
277+  A864              buffer_buffertoattrsfast:
278+  A864 ED 73 D3 A8      ld (buffer_buffertoattrsfast1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
279+  A868 3A D7 A8         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
280+  A86B 11 20 00         ld de,32
281+  A86E CD FD 80         call utilities_multiply
282+  A871 54 5D            ld de,hl
283+  A873 21 6D A3         ld hl,buffer_attr_buffer
284+  A876 19               add hl,de                       ; add the offset, start of attr buffer now in hl
285+  A877 D9               exx
286+  A878 21 50 58         ld hl,22528+80                  ; start of attr memory + 2 lines for score + 16 to start at right side
287+  A87B FD 21 0D A7      ld iy,buffer_tmp
288+  A87F FD 36 00 15      ld (iy),21              ; number of times to loop
289+  A883              buffer_buffertoattrsfast0:
290+  A883 D9               exx                         ; hl is now buffer
291+  A884 23               inc hl
292+  A885 23               inc hl                      ; move hl forward 2 to skip first two blocks
293+  A886 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
294+  A887 F1               pop af
295+  A888 C1               pop bc
296+  A889 D1               pop de
297+  A88A DD E1            pop ix
298+  A88C D9               exx                         ; hl is now screen
299+  A88D 08               ex af,af'
300+  A88E F1               pop af
301+  A88F C1               pop bc
302+  A890 D1               pop de
303+  A891 F9               ld sp,hl                    ; sp pointing at screen
304+  A892 D5               push de
305+  A893 C5               push bc
306+  A894 F5               push af
307+  A895 08               ex af,af'
308+  A896 D9               exx                         ; hl is now buffer
309+  A897 DD E5            push ix
310+  A899 D5               push de
311+  A89A C5               push bc
312+  A89B F5               push af
313+  A89C 1E 0E            ld e,14                    ; do another fourteen for right hand side
314+  A89E 16 00            ld d,0
315+  A8A0 19               add hl,de
316+  A8A1 F9               ld sp,hl                    ; sp pointing at buffer
317+  A8A2 F1               pop af
318+  A8A3 C1               pop bc
319+  A8A4 D1               pop de
320+  A8A5 DD E1            pop ix
321+  A8A7 D9               exx                         ; hl is now screen
322+  A8A8 08               ex af,af'
323+  A8A9 1E 0E            ld e,14
324+  A8AB 16 00            ld d,0
325+  A8AD 19               add hl,de
326+  A8AE F1               pop af
327+  A8AF C1               pop bc
328+  A8B0 D1               pop de
329+  A8B1 F9               ld sp,hl                    ; sp pointing at screen
330+  A8B2 D5               push de
331+  A8B3 C5               push bc
332+  A8B4 F5               push af
333+  A8B5 08               ex af,af'
334+  A8B6 D9               exx                         ; hl is now buffer
335+  A8B7 DD E5            push ix
336+  A8B9 D5               push de
337+  A8BA C5               push bc
338+  A8BB F5               push af
339+  A8BC 1E 10            ld e,16
340+  A8BE 16 00            ld d,0
341+  A8C0 19               add hl,de
342+  A8C1 D9               exx                         ; hl is now screen
343+  A8C2 11 12 00         ld de,18
344+  A8C5 19               add hl,de
345+  A8C6 FD 7E 00         ld a,(iy)
346+  A8C9 3D               dec a
347+  A8CA FE 00            cp 0
348+  A8CC FD 77 00         ld (iy),a
349+  A8CF C2 83 A8         jp nz,buffer_buffertoattrsfast0 ; do another row
350+  A8D2              buffer_buffertoattrsfast1:
351+  A8D2 31 00 00         ld sp,0
352+  A8D5 D9               exx
353+  A8D6 C9               ret
# file closed: screen/buffer.asm
136   A8D7                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  A8D7              screen_offset:
  2+  A8D7 00               defb 0                      ; offset from top of screen in lines
  3+  A8D8
  4+  A8D8              screen_tmp:
  5+  A8D8 00 00            defb 0,0                      ; temporary memory
  6+  A8DA
  7+  A8DA              screen_setscorecolours:
  8+  A8DA 21 3F B7         ld hl,score_colours
  9+  A8DD 11 00 58         ld de,22528                     ; attrs here
 10+  A8E0 01 40 00         ld bc,64
 11+  A8E3 ED B0            ldir
 12+  A8E5 C9               ret
 13+  A8E6
 14+  A8E6              screen_sethighscorecolours:
 15+  A8E6 21 7F B7         ld hl,high_score_colours
 16+  A8E9 11 E0 5A         ld de,22528+736                 ; attrs here
 17+  A8EC 01 20 00         ld bc,32
 18+  A8EF ED B0            ldir
 19+  A8F1 C9               ret
 20+  A8F2
 21+  A8F2              ; Draw the screen
 22+  A8F2              ; Inputs:
 23+  A8F2              ; none
 24+  A8F2              ; Notes:
 25+  A8F2              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
 26+  A8F2              screen_draw:
 27+  A8F2                  ;call clear_screen
 28+  A8F2 0E 00            ld c,0                      ; horiz
 29+  A8F4 06 00            ld b,0                      ; vert, 0 at top
 30+  A8F6 DD 21 1A B1      ld ix,level_layout               ; point ix at level data
 31+  A8FA FD 21 6D A3      ld iy,buffer_attr_buffer    ; point iy at attr data
 32+  A8FE              screen_draw0:
 33+  A8FE DD 7E 00         ld a,(ix)                   ; load the block number
 34+  A901 C5               push bc                     ; store bc, contains loop count
 35+  A902 CD BD AA         call screen_getattr         ; get the memory location for this cell's attr into hl
 36+  A905 7E               ld a,(hl)                   ; get the attr value at the address
 37+  A906 FD 77 00         ld (iy),a                   ; load the attr into memory
 38+  A909 DD 7E 00         ld a,(ix)                   ; load the block number
 39+  A90C CD 84 AA         call screen_getblock        ; get the block data into hl
 40+  A90F CD 61 AA         call screen_showchar        ; show this character here
 41+  A912 C1               pop bc                      ; get the loop counter back
 42+  A913 DD 23            inc ix                      ; increment level location
 43+  A915 FD 23            inc iy                      ; increment attr location
 44+  A917 0C               inc c                       ; increment horiz
 45+  A918 79               ld a,c
 46+  A919 FE 20            cp 32                       ; check if horiz has reach edge of screen
 47+  A91B C2 FE A8         jp nz,screen_draw0          ; if not, loop
 48+  A91E 0E 00            ld c,0                      ; if so, reset horiz
 49+  A920 04               inc b                       ; increment vertical
 50+  A921 78               ld a,b
 51+  A922 FE 1D            cp 29                       ; check if at bottom
 52+  A924 C2 FE A8         jp nz,screen_draw0          ; if not, loop
 53+  A927 21 D8 A8         ld hl, screen_tmp
 54+  A92A 36 09            ld (hl),9                   ; load the block number into memory
 55+  A92C DD 21 BA B5      ld ix,level_rocks          ; rock memory
 56+  A930 CD 9F A9         call screen_initobjects     ; draw rocks
 57+  A933 21 D8 A8         ld hl, screen_tmp
 58+  A936 36 0C            ld (hl),12                  ; load the block number into memory
 59+  A938 DD 21 A1 B6      ld ix,level_missiles       ; missile memory
 60+  A93C CD 9F A9         call screen_initobjects     ; draw missiles
 61+  A93F 21 D8 A8         ld hl, screen_tmp
 62+  A942 36 08            ld (hl),08                  ; load the block number into memory
 63+  A944 DD 21 1A B7      ld ix,level_diamonds       ; diamond memory
 64+  A948 CD 9F A9         call screen_initobjects     ; draw diamonds
 65+  A94B 21 D8 A8         ld hl, screen_tmp
 66+  A94E 36 0E            ld (hl),14                  ; load the block number into memory
 67+  A950 DD 21 2A B7      ld ix,level_gems           ; gems memory
 68+  A954 CD 9F A9         call screen_initobjects     ; draw gems
 69+  A957 CD 5E A9         call screen_setuptext       ; draws text on the screen
 70+  A95A CD EE CA         call scores_printscores     ; print the current scores
 71+  A95D C9               ret
 72+  A95E
 73+  A95E              ;
 74+  A95E              ; Sets up text on the screen
 75+  A95E              ;
 76+  A95E              screen_setuptext:
 77+  A95E CD 4A CB         call scores_showtable
 78+  A961 CD E6 A8         call screen_sethighscorecolours
 79+  A964 21 C9 81         ld hl, string_score1
 80+  A967 CD 25 86         call string_print
 81+  A96A 21 D2 81         ld hl, string_scorenumbers1
 82+  A96D CD 25 86         call string_print
 83+  A970 21 DB 81         ld hl, string_company
 84+  A973 CD 25 86         call string_print
 85+  A976 21 FB 81         ld hl, string_score2
 86+  A979 CD 25 86         call string_print
 87+  A97C 21 04 82         ld hl, string_scorenumbers2
 88+  A97F CD 25 86         call string_print
 89+  A982 3A 48 C3         ld a,(game_currentplayer)
 90+  A985 FE 01            cp 1
 91+  A987 C2 90 A9         jp nz,screen_setuptext0
 92+  A98A 21 E5 81         ld hl, string_player1
 93+  A98D C3 93 A9         jp screen_setuptext1
 94+  A990              screen_setuptext0:
 95+  A990 21 F0 81         ld hl, string_player2
 96+  A993              screen_setuptext1:
 97+  A993 CD 25 86         call string_print
 98+  A996 CD DA A8         call screen_setscorecolours
 99+  A999 C9               ret
100+  A99A
101+  A99A              ;
102+  A99A              ; Sets a line of colours
103+  A99A              ; Inputs:
104+  A99A              ; a - colour to set
105+  A99A              ; b - number to set
106+  A99A              ; de - start memory location
107+  A99A              ;
108+  A99A              screen_setcolours:
109+  A99A 12               ld (de),a
110+  A99B 13               inc de
111+  A99C 10 FC            djnz screen_setcolours
112+  A99E C9               ret
113+  A99F
114+  A99F              ;
115+  A99F              ; Draw initial object positions
116+  A99F              ; Inputs:
117+  A99F              ; ix - memory location of objects
118+  A99F              ; a - graphic
119+  A99F              screen_initobjects:
120+  A99F DD 4E 00         ld c,(ix)                   ; get the horiz coord
121+  A9A2 79               ld a,c
122+  A9A3 FE FF            cp 255
123+  A9A5 CA CE A9         jp z,screen_initobjects2
124+  A9A8 DD 23            inc ix                      ; move to next
125+  A9AA DD 46 00         ld b,(ix)                   ; get the vert coord
126+  A9AD DD 23            inc ix
127+  A9AF CD E0 A9         call screen_getcellattradress ; get the memory address of b,c attr into de
128+  A9B2 D5               push de
129+  A9B3 3A D8 A8         ld a,(screen_tmp)                  ; get the block number back
130+  A9B6 CD BD AA         call screen_getattr         ; get the memory location for this cell's attr into hl
131+  A9B9 D1               pop de
132+  A9BA 7E               ld a,(hl)                   ; get the attr value at the address
133+  A9BB 12               ld (de),a                   ; load the attr into memory
134+  A9BC 3A D8 A8         ld a,(screen_tmp)                  ; get the block number back
135+  A9BF CD 84 AA         call screen_getblock        ; get the block data into hl
136+  A9C2 CD 61 AA         call screen_showchar        ; show this character here
137+  A9C5
138+  A9C5              screen_initobjects1:
139+  A9C5 DD 23            inc ix                      ; move past state
140+  A9C7 DD 23            inc ix
141+  A9C9 DD 23            inc ix                      ; move past mem
142+  A9CB C3 9F A9         jp screen_initobjects
143+  A9CE              screen_initobjects2:
144+  A9CE C9               ret
145+  A9CF
146+  A9CF
147+  A9CF              ;
148+  A9CF              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
149+  A9CF              ; Inputs:
150+  A9CF              ; bc: coords
151+  A9CF              ; Outputs:
152+  A9CF              ; de: memory location
153+  A9CF              ;
154+  A9CF              screen_getcelladdress:
155+  A9CF 78               ld a,b      ; vertical position.
156+  A9D0 E6 18            and 24      ; which segment, 0, 1 or 2?
157+  A9D2 C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
158+  A9D4 57               ld d,a      ; this is our high byte.
159+  A9D5 78               ld a,b      ; what was that vertical position again?
160+  A9D6 E6 07            and 7       ; which row within segment?
161+  A9D8 0F               rrca        ; multiply row by 32.
162+  A9D9 0F               rrca
163+  A9DA 0F               rrca
164+  A9DB 5F               ld e,a      ; low byte.
165+  A9DC 79               ld a,c      ; add on y coordinate.
166+  A9DD 83               add a,e     ; mix with low byte.
167+  A9DE 5F               ld e,a      ; address of screen position in de.
168+  A9DF C9               ret
169+  A9E0
170+  A9E0              ;
171+  A9E0              ; Calculate buffer address of attribute for character at (b, c).
172+  A9E0              ; Inputs:
173+  A9E0              ; bc: coords
174+  A9E0              ; Outputs:
175+  A9E0              ; de: memory location
176+  A9E0              ;
177+  A9E0              screen_getcellattradress:
178+  A9E0 11 6D A3         ld de,buffer_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
179+  A9E3 69               ld l,c      ; x position.
180+  A9E4 26 00            ld h,0      ; 0 h
181+  A9E6 19               add hl,de
182+  A9E7 54 5D            ld de,hl    ; horiz done
183+  A9E9 78               ld a,b      ; do vert
184+  A9EA D5               push de
185+  A9EB C5               push bc
186+  A9EC 11 20 00         ld de,32
187+  A9EF CD FD 80         call utilities_multiply
188+  A9F2 C1               pop bc
189+  A9F3 D1               pop de
190+  A9F4 19               add hl,de
191+  A9F5 54 5D            ld de,hl    ; vert done
192+  A9F7 C9               ret
193+  A9F8
194+  A9F8              ;
195+  A9F8              ; Calculate buffer address offset of attribute for character at (b, c).
196+  A9F8              ; Inputs:
197+  A9F8              ; bc: coords
198+  A9F8              ; Outputs:
199+  A9F8              ; de: memory location
200+  A9F8              ;
201+  A9F8              screen_getcellattroffset:
202+  A9F8 69               ld l,c      ; x position.
203+  A9F9 26 00            ld h,0      ; 0 h
204+  A9FB 54 5D            ld de,hl    ; horiz done
205+  A9FD 78               ld a,b      ; do vert
206+  A9FE D5               push de
207+  A9FF C5               push bc
208+  AA00 11 20 00         ld de,32
209+  AA03 CD FD 80         call utilities_multiply
210+  AA06 C1               pop bc
211+  AA07 D1               pop de
212+  AA08 19               add hl,de
213+  AA09 54 5D            ld de,hl    ; vert done
214+  AA0B C9               ret
215+  AA0C
216+  AA0C              ;
217+  AA0C              ; Calculate buffer address of attribute for character at (b, c).
218+  AA0C              ; Inputs:
219+  AA0C              ; bc: coords
220+  AA0C              ; Outputs:
221+  AA0C              ; de: memory location
222+  AA0C              ;
223+  AA0C              screen_getscreenattradress:
224+  AA0C 11 00 58         ld de,22528 ; memory is at base + horiz (c) + vert*32 (b)
225+  AA0F 69               ld l,c      ; x position.
226+  AA10 26 00            ld h,0      ; 0 h
227+  AA12 19               add hl,de
228+  AA13 54 5D            ld de,hl    ; horiz done
229+  AA15 78               ld a,b      ; do vert
230+  AA16 D5               push de
231+  AA17 C5               push bc
232+  AA18 11 20 00         ld de,32
233+  AA1B CD FD 80         call utilities_multiply
234+  AA1E C1               pop bc
235+  AA1F D1               pop de
236+  AA20 19               add hl,de
237+  AA21 54 5D            ld de,hl    ; vert done
238+  AA23 C9               ret
239+  AA24
240+  AA24              ;
241+  AA24              ; Gets the attr memory location for a screen coord
242+  AA24              ; Will overwrite bc
243+  AA24              ; Inputs:
244+  AA24              ; bc - screen coords
245+  AA24              ; Outputs:
246+  AA24              ; de - memory location
247+  AA24              ; bc - character coords
248+  AA24              ;
249+  AA24              screen_getattraddressfromscreencoords:
250+  AA24 78               ld a,b                          ; get the player block coords of current block
251+  AA25 E6 F8            and 248                         ; find closest multiple of eight
252+  AA27 0F               rrca
253+  AA28 0F               rrca
254+  AA29 0F               rrca                ; divide by 8
255+  AA2A 47               ld b,a
256+  AA2B 79               ld a,c
257+  AA2C 48               ld c,b                         ; swap b and c
258+  AA2D E6 F8            and 248
259+  AA2F 0F               rrca
260+  AA30 0F               rrca
261+  AA31 0F               rrca                ; divide by 8
262+  AA32 47               ld b,a
263+  AA33 CD E0 A9         call screen_getcellattradress   ; work out memory location of current block attributes, memory in de
264+  AA36 C9               ret
265+  AA37
266+  AA37
267+  AA37              ; Gets the nearest cell coords for a screen coord
268+  AA37              ; Will overwrite bc
269+  AA37              ; Inputs:
270+  AA37              ; bc - screen coords
271+  AA37              ; Outputs:
272+  AA37              ; bc - character coords
273+  AA37              ;
274+  AA37              screen_getcharcoordsfromscreencoords:
275+  AA37 78               ld a,b                          ; get the player block coords of current block
276+  AA38 E6 F8            and 248                         ; find closest multiple of eight
277+  AA3A 0F               rrca
278+  AA3B 0F               rrca
279+  AA3C 0F               rrca                ; divide by 8
280+  AA3D 47               ld b,a
281+  AA3E 79               ld a,c
282+  AA3F 48               ld c,b                         ; swap b and c
283+  AA40 E6 F8            and 248
284+  AA42 0F               rrca
285+  AA43 0F               rrca
286+  AA44 0F               rrca                ; divide by 8
287+  AA45 47               ld b,a
288+  AA46 C9               ret
289+  AA47
290+  AA47              ; Gets the screen coords for a cell coord
291+  AA47              ; Will overwrite bc
292+  AA47              ; Inputs:
293+  AA47              ; bc - char coords
294+  AA47              ; Outputs:
295+  AA47              ; bc - screen coords
296+  AA47              ;
297+  AA47              screen_getscreencoordsfromcharcoords:
298+  AA47 78               ld a,b                          ; get the player block coords of current block
299+  AA48 07               rlca
300+  AA49 07               rlca
301+  AA4A 07               rlca                ; multiply by 8
302+  AA4B 47               ld b,a
303+  AA4C 79               ld a,c
304+  AA4D 48               ld c,b                         ; swap b and c
305+  AA4E 07               rlca
306+  AA4F 07               rlca
307+  AA50 07               rlca                ; divide by 8
308+  AA51 47               ld b,a
309+  AA52 C9               ret
310+  AA53
311+  AA53              ;
312+  AA53              ; Get buffer address for a character at b,c - b vert
313+  AA53              ; Buffer memory is stored as sequential block
314+  AA53              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
315+  AA53              ; Inputs:
316+  AA53              ; bc - coords
317+  AA53              ; Outputs:
318+  AA53              ; de - memory location of first byte
319+  AA53              screen_getbufferaddress:
320+  AA53 21 6D 86         ld hl, buffer_buffer    ; first get screen buffer start
321+  AA56 50               ld d,b                  ; then work out vertical offset
322+  AA57 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
323+  AA59 19               add hl,de               ; add to base
324+  AA5A 59               ld e,c                  ; then add horizontal offset (c)
325+  AA5B 16 00            ld d,0
326+  AA5D 19               add hl,de               ; add to base
327+  AA5E 54 5D            ld de,hl
328+  AA60 C9               ret
329+  AA61
330+  AA61              ;
331+  AA61              ; Display character hl at (b, c) to buffer.
332+  AA61              ; Stored sequentially
333+  AA61              ; Inputs:
334+  AA61              ; hl: block address
335+  AA61              ; bc: coords
336+  AA61              ;
337+  AA61              screen_showchar:
338+  AA61 ED 43 20 AC      ld (origcoords),bc   ; store char coords
339+  AA65 3E 00            ld a,0
340+  AA67 E5               push hl
341+  AA68 CD 53 AA         call screen_getbufferaddress ; get the current screen buffer pointer
342+  AA6B E1               pop hl
343+  AA6C 06 08            ld b,8              ; number of pixels high.
344+  AA6E              screen_showchar0:
345+  AA6E 7E               ld a,(hl)           ; source graphic.
346+  AA6F 12               ld (de),a           ; transfer to screen.
347+  AA70 23               inc hl              ; next piece of data.
348+  AA71 E5               push hl             ; store hl
349+  AA72 62 6B            ld hl,de            ; put de in hl
350+  AA74 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
351+  AA76 16 00            ld d,0
352+  AA78 19               add hl,de              ; add de to hl
353+  AA79 54 5D            ld de,hl            ; load back to de
354+  AA7B E1               pop hl              ; restore hl
355+  AA7C
356+  AA7C 10 F0            djnz screen_showchar0 ; repeat
357+  AA7E 2E 01            ld l,1
358+  AA80 CD D1 AB         call sprites_marklinesforupdatechar
359+  AA83
360+  AA83 C9               ret
361+  AA84
362+  AA84
363+  AA84              ;
364+  AA84              ; Get cell graphic.
365+  AA84              ; Inputs:
366+  AA84              ; a: block
367+  AA84              ; Outputs:
368+  AA84              ; hl: memory
369+  AA84              ;
370+  AA84              screen_getblock:
371+  AA84 07               rlca                        ; multiply block number by eight.
372+  AA85 07               rlca
373+  AA86 07               rlca
374+  AA87 5F               ld e,a                      ; displacement to graphic address.
375+  AA88 16 00            ld d,0                      ; no high byte.
376+  AA8A 21 9F BB         ld hl,sprites               ; address of character blocks.
377+  AA8D 19               add hl,de                   ; point to block.
378+  AA8E C9               ret
379+  AA8F
380+  AA8F              ;
381+  AA8F              ; Set a the attr of a coord
382+  AA8F              ; Inputs:
383+  AA8F              ; bc - char coords
384+  AA8F              ; a - attr
385+  AA8F              ;
386+  AA8F              screen_setattr:
387+  AA8F DD E5            push ix
388+  AA91 C5               push bc
389+  AA92 08               ex af, af'
390+  AA93 CD F8 A9         call screen_getcellattroffset   ; get offset into de
391+  AA96 21 6D A3         ld hl,buffer_attr_buffer
392+  AA99 19               add hl,de                       ; get the memory location
393+  AA9A 08               ex af, af'                      ; get attr back
394+  AA9B 77               ld (hl),a                         ; set the attr
395+  AA9C 08               ex af, af'                      ; get attr back
396+  AA9D ED 5B D7 A8      ld de,(screen_offset)           ; get the offset
397+  AAA1 78               ld a,b                          ; get the vertical
398+  AAA2 93               sub e                           ; subtract the offset
399+  AAA3 DA B9 AA         jp c,screen_setattr0            ; if less than zero, don't update the attr on screen
400+  AAA6 FE 15            cp 21
401+  AAA8 D2 B9 AA         jp nc,screen_setattr0           ; if more than 21, don't update the attr on screen
402+  AAAB 47               ld b,a                          ; put the coord back in b
403+  AAAC CD 0C AA         call screen_getscreenattradress ; screen attr address in de
404+  AAAF 21 40 00         ld hl,64                        ; attr memory + two rows for scores
405+  AAB2 19               add hl,de
406+  AAB3 08               ex af, af'                      ; get attr back
407+  AAB4 77               ld (hl),a
408+  AAB5 C1               pop bc
409+  AAB6 DD E1            pop ix
410+  AAB8 C9               ret
411+  AAB9              screen_setattr0:
412+  AAB9 C1               pop bc
413+  AABA DD E1            pop ix
414+  AABC C9               ret
415+  AABD
416+  AABD              ;
417+  AABD              ; Get cell attribute.
418+  AABD              ; Inputs:
419+  AABD              ; a: block
420+  AABD              ; Outputs:
421+  AABD              ; hl: memory
422+  AABD              ;
423+  AABD              screen_getattr:
424+  AABD 5F               ld e,a                      ; displacement to attribute address.
425+  AABE 16 00            ld d,0                      ; no high byte.
426+  AAC0 21 7F BC         ld hl,sprite_attrs          ; address of block attributes.
427+  AAC3 19               add hl,de                   ; point to attribute.
428+  AAC4 C9               ret
429+  AAC5
430+  AAC5              ;
431+  AAC5              ; Checks whether a character block has anything in it
432+  AAC5              ; Inputs:
433+  AAC5              ; bc - char coords
434+  AAC5              ; Outputs:
435+  AAC5              ; a - 1, empty
436+  AAC5              screen_ischarempty:
437+  AAC5 CD 53 AA         call screen_getbufferaddress ; get the current screen buffer pointer
438+  AAC8 06 08            ld b,8                      ; check 8 rows
439+  AACA              screen_ischarempty2:
440+  AACA 1A               ld a,(de)                   ; check line
441+  AACB FE 00            cp 0
442+  AACD C2 DB AA         jp nz,screen_ischarempty1   ; if not zero, jump out with false
443+  AAD0 21 20 00         ld hl,32
444+  AAD3 19               add hl,de
445+  AAD4 54 5D            ld de,hl                    ; move to next row
446+  AAD6 10 F2            djnz screen_ischarempty2
447+  AAD8              screen_ischarempty0:
448+  AAD8 3E 01            ld a,1
449+  AADA C9               ret
450+  AADB              screen_ischarempty1:
451+  AADB 3E 00            ld a,0
452+  AADD C9               ret
453+  AADE
454+  AADE              ;
455+  AADE              ; Copies a block from one place to another directly underneath, leaves the original empty
456+  AADE              ; Inputs:
457+  AADE              ; bc - coords of block to copy from
458+  AADE              screen_copyblockdown
459+  AADE CD 53 AA         call screen_getbufferaddress ; get the current screen buffer pointer for source
460+  AAE1 06 08            ld b,8                      ; copy 8 rows
461+  AAE3              screen_copyblock0:
462+  AAE3 1A               ld a,(de)                    ; get what we're copying
463+  AAE4 08               ex af,af'
464+  AAE5 3E 00            ld a,0
465+  AAE7 12               ld (de),a                    ; replace with empty
466+  AAE8 08               ex af,af'
467+  AAE9 14               inc d                        ; add 256 to get to the next row
468+  AAEA 12               ld (de),a                    ; copy to the next row
469+  AAEB 15               dec d
470+  AAEC 21 20 00         ld hl,32
471+  AAEF 19               add hl,de                       ; return back to source, next row down
472+  AAF0 54 5D            ld de,hl
473+  AAF2 10 EF            djnz screen_copyblock0
474+  AAF4 C9               ret
475+  AAF5
476+  AAF5              ;
477+  AAF5              ; Returns the first byte of a character. Useful for figuring out what's there
478+  AAF5              ; Inputs:
479+  AAF5              ; bc - coords
480+  AAF5              ; Outputs:
481+  AAF5              ; a - first byte
482+  AAF5              ;
483+  AAF5              screen_getcharfirstbyte:
484+  AAF5 CD 53 AA         call screen_getbufferaddress ; get the current screen buffer pointer for source
485+  AAF8 1A               ld a,(de)
486+  AAF9 C9               ret
487+  AAFA
# file closed: screen/screen.asm
137   AAFA                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  AAFA              ;
  2+  AAFA              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  AAFA              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  AAFA              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  AAFA              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  AAFA              ; routine takes care of all the shifting itself. This means that sprite
  7+  AAFA              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  AAFA              ; space they would require in pre-shifted form.
  9+  AAFA              ; Inputs:
 10+  AAFA              ; hl - sprite data
 11+  AAFA              ; bc - screen coords
 12+  AAFA              ;
 13+  AAFA              sprites_drawsprite7:
 14+  AAFA EE 07            xor 7               ; complement last 3 bits.
 15+  AAFC 3C               inc a               ; add one for luck!
 16+  AAFD              sprites_drawsprite3:
 17+  AAFD CB 11            rl c                ; ...into middle byte...
 18+  AAFF CB 12            rl d                ; ...and finally into left character cell.
 19+  AB01 3D               dec a               ; count shifts we've done.
 20+  AB02 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  AB04                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  AB04 79               ld a,c              ; left edge of image is currently in e.
 23+  AB05 4A               ld c,d              ; put right edge there instead.
 24+  AB06 57               ld d,a              ; and the left edge back into c.
 25+  AB07 18 29            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  AB09              sprites_drawsprite:
 27+  AB09 ED 43 20 AC      ld (origcoords),bc  ; store coords
 28+  AB0D ED 43 22 AC      ld (dispx),bc       ; store coords in dispx for now.
 29+  AB11 E5               push hl
 30+  AB12 CD FE AB         call sprites_scadd  ; calculate screen address.
 31+  AB15 E1               pop hl
 32+  AB16 3E 08            ld a,8              ; height of sprite in pixels.
 33+  AB18              sprites_drawsprite1:
 34+  AB18 08               ex af,af'           ; store loop counter.
 35+  AB19 D5               push de             ; store screen address.
 36+  AB1A 4E               ld c,(hl)           ; first sprite graphic.
 37+  AB1B 23               inc hl              ; increment poiinter to sprite data.
 38+  AB1C 22 24 AC         ld (sprtmp),hl      ; store it for later.
 39+  AB1F 16 00            ld d,0              ; blank right byte for now.
 40+  AB21 78               ld a,b              ; b holds y position.
 41+  AB22 E6 07            and 7               ; how are we straddling character cells?
 42+  AB24 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 43+  AB26 FE 05            cp 5                ; 5 or more right shifts needed?
 44+  AB28 30 D0            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 45+  AB2A A7               and a               ; oops, carry flag is set so clear it.
 46+  AB2B              sprites_drawsprite2:
 47+  AB2B CB 19            rr c                ; rotate left byte right...
 48+  AB2D CB 1A            rr d                ; ...into right byte.
 49+  AB2F 3D               dec a               ; one less shift to do.
 50+  AB30 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 51+  AB32              sprites_drawsprite0:
 52+  AB32 E1               pop hl              ; pop screen address from stack.
 53+  AB33 7E               ld a,(hl)           ; what's there already.
 54+  AB34 A9               xor c               ; merge in image data.
 55+  AB35 77               ld (hl),a           ; place onto screen.
 56+  AB36 23               inc hl
 57+  AB37 7E               ld a,(hl)           ; what's already there.
 58+  AB38 AA               xor d               ; right edge of sprite image data.
 59+  AB39 77               ld (hl),a           ; plonk it on screen.
 60+  AB3A 3A 22 AC         ld a,(dispx)        ; vertical coordinate.
 61+  AB3D 3C               inc a               ; next line down.
 62+  AB3E 32 22 AC         ld (dispx),a        ; store new position.
 63+  AB41 2B               dec hl
 64+  AB42 11 20 00         ld de,32            ; add 32 to get to the next row
 65+  AB45 19               add hl,de           ; add 32
 66+  AB46              sprites_drawsprite6:
 67+  AB46 EB               ex de,hl            ; screen address in de.
 68+  AB47 2A 24 AC         ld hl,(sprtmp)      ; restore graphic address.
 69+  AB4A 08               ex af,af'           ; restore loop counter.
 70+  AB4B 3D               dec a               ; decrement it.
 71+  AB4C C2 18 AB         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 72+  AB4F 2E 02            ld l,2
 73+  AB51 CD C0 AB         call sprites_marklinesforupdatescreen
 74+  AB54 C9               ret                 ; job done.
 75+  AB55
 76+  AB55              ; Inputs:
 77+  AB55              ; hl - sprite data
 78+  AB55              ; bc - screen coords
 79+  AB55              ;
 80+  AB55              sprites_draw2by2sprite7
 81+  AB55 EE 07            xor 7               ; complement last 3 bits.
 82+  AB57 3C               inc a               ; add one for luck!
 83+  AB58              sprites_draw2by2sprite3
 84+  AB58 CB 12            rl d                ; rotate left...
 85+  AB5A CB 11            rl c                ; ...into middle byte...
 86+  AB5C CB 13            rl e                ; ...and finally into left character cell.
 87+  AB5E 3D               dec a               ; count shifts we've done.
 88+  AB5F 20 F7            jr nz,sprites_draw2by2sprite3 ; return until all shifts complete.
 89+  AB61                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 90+  AB61 7B               ld a,e              ; left edge of image is currently in e.
 91+  AB62 5A               ld e,d              ; put right edge there instead.
 92+  AB63 51               ld d,c              ; middle bit goes in d.
 93+  AB64 4F               ld c,a              ; and the left edge back into c.
 94+  AB65 18 31            jr sprites_draw2by2sprite0 ; we've done the switch so transfer to screen.
 95+  AB67              sprites_draw2by2sprite
 96+  AB67 ED 43 20 AC      ld (origcoords),bc  ; store coords
 97+  AB6B ED 43 22 AC      ld (dispx),bc       ; store coords in dispx for now.
 98+  AB6F 79               ld a,c
 99+  AB70 32 26 AC         ld (sprtmp0),a         ; store vertical.
100+  AB73 E5               push hl
101+  AB74 CD FE AB         call sprites_scadd          ; calculate screen address.
102+  AB77 E1               pop hl
103+  AB78 3E 10            ld a,16             ; height of sprite in pixels.
104+  AB7A              sprites_draw2by2sprite1
105+  AB7A 08               ex af,af'           ; store loop counter.
106+  AB7B D5               push de             ; store screen address.
107+  AB7C 4E               ld c,(hl)           ; first sprite graphic.
108+  AB7D 23               inc hl              ; increment poiinter to sprite data.
109+  AB7E 56               ld d,(hl)           ; next bit of sprite image.
110+  AB7F 23               inc hl              ; point to next row of sprite data.
111+  AB80 22 24 AC         ld (sprtmp),hl        ; store in tmp0 for later.
112+  AB83 1E 00            ld e,0              ; blank right byte for now.
113+  AB85 78               ld a,b              ; b holds y position.
114+  AB86 E6 07            and 7               ; how are we straddling character cells?
115+  AB88 28 0E            jr z,sprites_draw2by2sprite0 ; we're not straddling them, don't bother shifting.
116+  AB8A FE 05            cp 5                ; 5 or more right shifts needed?
117+  AB8C 30 C7            jr nc,sprites_draw2by2sprite7 ; yes, shift from left as it's quicker.
118+  AB8E A7               and a               ; oops, carry flag is set so clear it.
119+  AB8F              sprites_draw2by2sprite2
120+  AB8F CB 19            rr c                ; rotate left byte right...
121+  AB91 CB 1A            rr d                ; ...through middle byte...
122+  AB93 CB 1B            rr e                ; ...into right byte.
123+  AB95 3D               dec a               ; one less shift to do.
124+  AB96 20 F7            jr nz,sprites_draw2by2sprite2 ; return until all shifts complete.
125+  AB98              sprites_draw2by2sprite0
126+  AB98 E1               pop hl              ; pop screen address from stack.
127+  AB99 7E               ld a,(hl)           ; what's there already.
128+  AB9A A9               xor c               ; merge in image data.
129+  AB9B 77               ld (hl),a           ; place onto screen.
130+  AB9C 23               inc hl               ; next character cell to right please.
131+  AB9D 7E               ld a,(hl)           ; what's there already.
132+  AB9E AA               xor d               ; merge with middle bit of image.
133+  AB9F 77               ld (hl),a           ; put back onto screen.
134+  ABA0 23               inc hl              ; next bit of screen area.
135+  ABA1 7E               ld a,(hl)           ; what's already there.
136+  ABA2 AB               xor e               ; right edge of sprite image data.
137+  ABA3 77               ld (hl),a           ; plonk it on screen.
138+  ABA4 3A 26 AC         ld a,(sprtmp0)         ; temporary vertical coordinate.
139+  ABA7 3C               inc a               ; next line down.
140+  ABA8 32 26 AC         ld (sprtmp0),a         ; store new position.
141+  ABAB 2B               dec hl
142+  ABAC 2B               dec hl
143+  ABAD 11 20 00         ld de,32            ; add 32 to get to the next row
144+  ABB0 19               add hl,de           ; add 32
145+  ABB1              sprites_draw2by2sprite6
146+  ABB1 EB               ex de,hl            ; screen address in de.
147+  ABB2 2A 24 AC         ld hl,(sprtmp)        ; restore graphic address.
148+  ABB5 08               ex af,af'           ; restore loop counter.
149+  ABB6 3D               dec a               ; decrement it.
150+  ABB7 C2 7A AB         jp nz,sprites_draw2by2sprite1 ; not reached bottom of sprite yet to repeat.
151+  ABBA 2E 03            ld l,3
152+  ABBC CD C0 AB         call sprites_marklinesforupdatescreen
153+  ABBF C9               ret                 ; job done.
154+  ABC0
155+  ABC0              ;
156+  ABC0              ; Marks lines for update with screen coords
157+  ABC0              ; Inputs:
158+  ABC0              ; l - number to update
159+  ABC0              ;
160+  ABC0              sprites_marklinesforupdatescreen:
161+  ABC0 F5               push af
162+  ABC1 ED 4B 20 AC      ld bc,(origcoords)
163+  ABC5 CD 37 AA         call screen_getcharcoordsfromscreencoords
164+  ABC8 ED 43 20 AC      ld (origcoords),bc
165+  ABCC CD DB AB         call sprites_marklinesforupdate
166+  ABCF F1               pop af
167+  ABD0 C9               ret
168+  ABD1
169+  ABD1              ;
170+  ABD1              ; Marks lines for update with char coords
171+  ABD1              ; Inputs:
172+  ABD1              ; l - number to update
173+  ABD1              ;
174+  ABD1              sprites_marklinesforupdatechar:
175+  ABD1 F5               push af
176+  ABD2 ED 43 20 AC      ld (origcoords),bc
177+  ABD6 CD DB AB         call sprites_marklinesforupdate
178+  ABD9 F1               pop af
179+  ABDA C9               ret
180+  ABDB
181+  ABDB              ;
182+  ABDB              ; Marks lines for update
183+  ABDB              ; Inputs:
184+  ABDB              ; l - number to update
185+  ABDB              ;
186+  ABDB              sprites_marklinesforupdate:
187+  ABDB ED 4B 20 AC      ld bc,(origcoords)
188+  ABDF ED 5B D7 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows
189+  ABE3 78               ld a,b
190+  ABE4 93               sub e
191+  ABE5 47               ld b,a
192+  ABE6 7D               ld a,l                          ; get loop counter
193+  ABE7              sprites_marklinesforupdate0:
194+  ABE7 C5               push bc
195+  ABE8 08               ex af,af'                     ; store loop counter
196+  ABE9 78               ld a,b
197+  ABEA CD 25 A7         call buffer_marklineforupdate ; mark this line for update
198+  ABED ED 4B 20 AC      ld bc,(origcoords)            ; move the coords for the next line
199+  ABF1 04               inc b
200+  ABF2 ED 43 20 AC      ld (origcoords),bc
201+  ABF6 C1               pop bc
202+  ABF7 04               inc b
203+  ABF8 08               ex af,af'                     ; restore loop counter
204+  ABF9 3D               dec a
205+  ABFA C2 E7 AB         jp nz,sprites_marklinesforupdate0
206+  ABFD C9               ret
207+  ABFE
208+  ABFE              ;
209+  ABFE              ; This routine returns a buffer address for (c, b) in de (c vert).
210+  ABFE              ; For example: 0,0 will be at memory offset 0
211+  ABFE              ; 1,0 (1 down) will be at memory offset 1
212+  ABFE              ; 0,7 will be at memory offset 0
213+  ABFE              ; 9,1 will be at memory offset 8+1
214+  ABFE              ; 8,0 will be at memory offset 256
215+  ABFE              ; 9,0 will be at memory offset 257
216+  ABFE              ; Outputs:
217+  ABFE              ; de - coords
218+  ABFE              ;
219+  ABFE              sprites_scadd:
220+  ABFE 79               ld a,c               ; calculate vertical offset
221+  ABFF E6 F8            and 248             ;  to get nearest multiple of 8
222+  AC01 0F               rrca
223+  AC02 0F               rrca
224+  AC03 0F               rrca                ; divide by 8
225+  AC04 67               ld h,a
226+  AC05 78               ld a,b               ; calculate horizontal offset
227+  AC06 E6 F8            and 248             ;  to get nearest multiple of 8
228+  AC08 0F               rrca
229+  AC09 0F               rrca
230+  AC0A 0F               rrca                ; divide by 8
231+  AC0B 6F               ld l,a
232+  AC0C C5               push bc             ; store the screen coords
233+  AC0D 44 4D            ld bc,hl            ; load bc with the character coords
234+  AC0F CD 53 AA         call screen_getbufferaddress
235+  AC12 C1               pop bc              ; get back screen coords, de is now memory of character
236+  AC13 79               ld a,c              ; now add the vertical within the cell
237+  AC14 E6 07            and 7
238+  AC16 0F               rrca                ; multiply by 32.
239+  AC17 0F               rrca
240+  AC18 0F               rrca
241+  AC19 6F               ld l,a
242+  AC1A 26 00            ld h,0
243+  AC1C 19               add hl,de
244+  AC1D 54 5D            ld de,hl
245+  AC1F C9               ret
246+  AC20
247+  AC20 00 00        origcoords   defb 0,0           ; general-use coordinates.
248+  AC22
249+  AC22 00           dispx   defb 0           ; general-use coordinates.
250+  AC23 00           dispy   defb 0
251+  AC24 00 00        sprtmp  defb 0,0           ; sprite temporary address.
252+  AC26 00 00        sprtmp0  defb 0,0           ; sprite temporary address.
253+  AC28
# file closed: screen/sprites.asm
138   AC28                  include "screen\titlescreen.asm"
# file opened: screen/titlescreen.asm
  1+  AC28              ;
  2+  AC28              ; Draws the title screen
  3+  AC28              ;
  4+  AC28              titlescreen_show:
  5+  AC28 CD BA AC         call titlescreen_init
  6+  AC2B CD 63 AC         call titlescreen_drawtitle
  7+  AC2E 3A 4B C3         ld a,(game_control)
  8+  AC31 FE 00            cp 0
  9+  AC33 CA 3B AC         jp z,titlescreen_show1
 10+  AC36 06 32            ld b,50
 11+  AC38 CD 5E 81         call utilities_pauseforframes         ; pause for a second
 12+  AC3B              titlescreen_show1:
 13+  AC3B 3E FA            ld a,250                              ; wait for 200 frames
 14+  AC3D CD 1F 81         call utilities_waitforkey_forframes   ; wait for keypress
 15+  AC40 7B               ld a,e
 16+  AC41 FE 01            cp 1                                  ; was anything pressed?
 17+  AC43 C8               ret z                                 ; end titlescreen if so
 18+  AC44
 19+  AC44 CD CD AC         call titlescreen_alt_init             ; otherwise, draw alt screen
 20+  AC47 CD 7F AC         call titlescreen_alt_drawtitle
 21+  AC4A 3A 4B C3         ld a,(game_control)
 22+  AC4D FE 00            cp 0
 23+  AC4F CA 57 AC         jp z,titlescreen_show0
 24+  AC52 06 32            ld b,50
 25+  AC54 CD 5E 81         call utilities_pauseforframes         ; pause for a second if joystick
 26+  AC57              titlescreen_show0:
 27+  AC57 3E FA            ld a,250                              ; wait for 200 frames
 28+  AC59 CD 1F 81         call utilities_waitforkey_forframes   ; wait for keypress
 29+  AC5C 7B               ld a,e
 30+  AC5D FE 01            cp 1                                  ; was anything pressed?
 31+  AC5F C2 28 AC         jp nz,titlescreen_show                ; start again if not
 32+  AC62 C9               ret
 33+  AC63
 34+  AC63              ;
 35+  AC63              ; Draws the iconic logo
 36+  AC63              ;
 37+  AC63              titlescreen_drawtitle:
 38+  AC63 06 67            ld b,103              ; number of points
 39+  AC65 DD 21 DA AC      ld ix,titlescreen_logo_data
 40+  AC69              titlescreen_drawtitle0:
 41+  AC69 C5               push bc
 42+  AC6A DD 4E 00         ld c,(ix)                   ; got horiz
 43+  AC6D DD 23            inc ix
 44+  AC6F DD 46 00         ld b,(ix)                   ; got vert
 45+  AC72 DD 23            inc ix
 46+  AC74 CD 0C AA         call screen_getscreenattradress ; memory in de
 47+  AC77 13               inc de                      ; slide one to the right, since I'm too lazy to change the data
 48+  AC78 3E 13            ld a,19
 49+  AC7A 12               ld (de),a
 50+  AC7B C1               pop bc
 51+  AC7C 10 EB            djnz titlescreen_drawtitle0 ; loop if we're not at the end
 52+  AC7E C9               ret
 53+  AC7F
 54+  AC7F              ;
 55+  AC7F              ; Draws the alternate title screen
 56+  AC7F              ;
 57+  AC7F              titlescreen_alt_drawtitle:
 58+  AC7F 21 22 82         ld hl,string_alttitlescreen_1
 59+  AC82 CD 25 86         call string_print
 60+  AC85 21 2E 82         ld hl,string_alttitlescreen_2
 61+  AC88 CD 25 86         call string_print
 62+  AC8B 21 29 83         ld hl,string_alttitlescreen_3
 63+  AC8E CD 25 86         call string_print
 64+  AC91 06 20            ld b,32
 65+  AC93 3E 43            ld a,67
 66+  AC95 11 00 58         ld de,22528                         ; top row attrs here
 67+  AC98 CD 9A A9         call screen_setcolours
 68+  AC9B 06 20            ld b,32
 69+  AC9D 3E 46            ld a,70
 70+  AC9F 11 A0 59         ld de,22528+416                     ; 13th row attrs here
 71+  ACA2 CD 9A A9         call screen_setcolours
 72+  ACA5 06 20            ld b,32
 73+  ACA7 3E 43            ld a,67
 74+  ACA9 11 20 5A         ld de,22528+544                         ; 17th row attrs here
 75+  ACAC CD 9A A9         call screen_setcolours
 76+  ACAF 06 20            ld b,32
 77+  ACB1 3E 42            ld a,66
 78+  ACB3 11 A0 5A         ld de,22528+672                         ; 21st row attrs here
 79+  ACB6 CD 9A A9         call screen_setcolours
 80+  ACB9 C9               ret
 81+  ACBA
 82+  ACBA              ;
 83+  ACBA              ; Initialises the screen
 84+  ACBA              ;
 85+  ACBA              titlescreen_init:
 86+  ACBA              ; We want a black screen.
 87+  ACBA 3E 0B            ld a,11             ; magenta ink (7) on blue paper (0),
 88+  ACBC                                      ; bright (64).
 89+  ACBC CD 43 81         call utilities_clearscreen
 90+  ACBF 32 8D 5C         ld (23693),a        ; set our screen colours.
 91+  ACC2 3E 01            ld a,1              ; 2 is the code for red.
 92+  ACC4 D3 FE            out (254),a         ; write to port 254.
 93+  ACC6
 94+  ACC6 21 0D 82         ld hl,string_titlescreen_copyright
 95+  ACC9 CD 25 86         call string_print
 96+  ACCC
 97+  ACCC C9               ret
 98+  ACCD
 99+  ACCD              ;
100+  ACCD              ; Initialises the screen
101+  ACCD              ;
102+  ACCD              titlescreen_alt_init:
103+  ACCD              ; We want a black screen.
104+  ACCD 3E 47            ld a,71             ; white ink (7) on black paper (0),
105+  ACCF                                      ; bright (64).
106+  ACCF CD 43 81         call utilities_clearscreen
107+  ACD2 32 8D 5C         ld (23693),a        ; set our screen colours.
108+  ACD5 3E 00            ld a,0              ; 2 is the code for red.
109+  ACD7 D3 FE            out (254),a         ; write to port 254.
110+  ACD9
111+  ACD9 C9               ret
112+  ACDA
113+  ACDA              ;
114+  ACDA              ; Horiz, vert
115+  ACDA              ;
116+  ACDA              titlescreen_logo_data:
117+  ACDA 08 00 09 00      defb 8,0,9,0,10,0,12,0,15,0,17,0,18,0,19,0
117+  ACDE 0A 00 0C 00
117+  ACE2 0F 00 11 00
117+  ACE6 12 00 13 00
118+  ACEA 09 01 0C 01      defb 9,1,12,1,15,1,17,1
118+  ACEE 0F 01 11 01
119+  ACF2 09 02 0C 02      defb 9,2,12,2,13,2,14,2,15,2,17,2,18,2,19,2
119+  ACF6 0D 02 0E 02
119+  ACFA 0F 02 11 02
119+  ACFE 12 02 13 02
120+  AD02 09 03 0C 03      defb 9,3,12,3,15,3,17,3
120+  AD06 0F 03 11 03
121+  AD0A 09 04 0C 04      defb 9,4,12,4,15,4,17,4,18,4,19,4
121+  AD0E 0F 04 11 04
121+  AD12 12 04 13 04
122+  AD16 00 06 01 06      defb 0,6,1,6,2,6,3,6,4,6,5,6,6,6,7,6,8,6,9,6,10,6,11,6
122+  AD1A 02 06 03 06
122+  AD1E 04 06 05 06
122+  AD22 06 06 07 06
122+  AD26 08 06 09 06
122+  AD2A 0A 06 0B 06
123+  AD2E 10 06 11 06      defb 16,6,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6
123+  AD32 12 06 13 06
123+  AD36 14 06 15 06
123+  AD3A 16 06 17 06
123+  AD3E 18 06 19 06
123+  AD42 1A 06 1B 06
124+  AD46 02 07 02 08      defb 2,7,2,8,2,9,2,10,2,11,2,12,2,13,2,14,2,15,2,16,2,17,2,18,2,19,2,20,2,21
124+  AD4A 02 09 02 0A
124+  AD4E 02 0B 02 0C
124+  AD52 02 0D 02 0E
124+  AD56 02 0F 02 10
124+  AD5A 02 11 02 12
124+  AD5E 02 13 02 14
124+  AD62 02 15
125+  AD64 19 07 19 08      defb 25,7,25,8,25,9,25,10,25,11,25,12,25,13,25,14,25,15,25,16,25,17,25,18,25,19,25,20,25,21
125+  AD68 19 09 19 0A
125+  AD6C 19 0B 19 0C
125+  AD70 19 0D 19 0E
125+  AD74 19 0F 19 10
125+  AD78 19 11 19 12
125+  AD7C 19 13 19 14
125+  AD80 19 15
126+  AD82 03 0B 04 0B      defb 3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,11,11
126+  AD86 05 0B 06 0B
126+  AD8A 07 0B 08 0B
126+  AD8E 09 0B 0A 0B
126+  AD92 0B 0B
127+  AD94 0B 07 0B 08      defb 11,7,11,8,11,9,11,10
127+  AD98 0B 09 0B 0A
128+  AD9C 10 0D 10 0F      defb 16,13,16,15,16,16,16,17,16,18,16,19
128+  ADA0 10 10 10 11
128+  ADA4 10 12 10 13
129+  ADA8
# file closed: screen/titlescreen.asm
139   ADA8                  include "screen\lifescreen.asm"
# file opened: screen/lifescreen.asm
  1+  ADA8              ;
  2+  ADA8              ; Draws the life remaining screen
  3+  ADA8              ;
  4+  ADA8              lifescreen_draw:
  5+  ADA8 CD FB AD         call lifescreen_init
  6+  ADAB
  7+  ADAB 3A 48 C3         ld a,(game_currentplayer)             ; get the current player
  8+  ADAE C6 30            add 48                                ; add 48 to get char
  9+  ADB0 21 2F 84         ld hl,string_lifescreen_player+10
 10+  ADB3 77               ld (hl),a                             ; load this to the string we're about to show
 11+  ADB4
 12+  ADB4 21 25 84         ld hl,string_lifescreen_player
 13+  ADB7 CD 25 86         call string_print
 14+  ADBA
 15+  ADBA 3A 91 C3         ld a,(player+9)                       ; get the current player lives
 16+  ADBD C6 30            add 48                                ; add 48 to get the character
 17+  ADBF FE 31            cp 49
 18+  ADC1 C2 D4 AD         jp nz,lifescreen_draw0
 19+  ADC4 21 3F 84         ld hl,string_lifescreen_lastman
 20+  ADC7
 21+  ADC7 06 08            ld b,8
 22+  ADC9 3E 0A            ld a,10                                ; set red
 23+  ADCB 11 6C 58         ld de,22528+108                        ; attrs here
 24+  ADCE CD 9A A9         call screen_setcolours
 25+  ADD1
 26+  ADD1 C3 DB AD         jp lifescreen_draw1
 27+  ADD4              lifescreen_draw0:
 28+  ADD4 21 34 84         ld hl,string_lifescreen_lives+2       ; not last man, so use the normal view
 29+  ADD7 77               ld (hl),a                             ; load this to the string we're about to show
 30+  ADD8 21 32 84         ld hl,string_lifescreen_lives
 31+  ADDB              lifescreen_draw1:
 32+  ADDB CD 25 86         call string_print
 33+  ADDE
 34+  ADDE 3E 86            ld a,134
 35+  ADE0 11 0B 58         ld de, 22528+11     ; get the colour for the top text
 36+  ADE3 06 0A            ld b,10
 37+  ADE5 CD 9A A9         call screen_setcolours
 38+  ADE8 3A 4B C3         ld a,(game_control)
 39+  ADEB FE 00            cp 0
 40+  ADED CA F5 AD         jp z,lifescreen_draw2
 41+  ADF0 06 32            ld b,50
 42+  ADF2 CD 5E 81         call utilities_pauseforframes         ; pause for a second if joystick
 43+  ADF5              lifescreen_draw2:
 44+  ADF5 3E 64            ld a,100                              ; wait for 200 frames
 45+  ADF7 CD 1F 81         call utilities_waitforkey_forframes   ; wait for keypress
 46+  ADFA
 47+  ADFA C9               ret
 48+  ADFB
 49+  ADFB              ;
 50+  ADFB              ; Initialises the screen
 51+  ADFB              ;
 52+  ADFB              lifescreen_init:
 53+  ADFB              ; We want a blue screen.
 54+  ADFB                  ;call $0D6B
 55+  ADFB 3E 0E            ld a,14             ; yellow ink (6) on blue paper (1),
 56+  ADFD                                      ; bright (64).
 57+  ADFD CD 43 81         call utilities_clearscreen
 58+  AE00 32 8D 5C         ld (23693),a        ; set our screen colours.
 59+  AE03 3E 01            ld a,1              ; 1 is the code for blue.
 60+  AE05 D3 FE            out (254),a         ; write to port 254.
 61+  AE07                  ;call 3503           ; ROM routine - clears screen, opens chan 2.
 62+  AE07
 63+  AE07 C9               ret
# file closed: screen/lifescreen.asm
140   AE08                  include "screen\gameover.asm"
# file opened: screen/gameover.asm
  1+  AE08              ;
  2+  AE08              ; Draws the game over screen
  3+  AE08              ;
  4+  AE08              gameover_draw:
  5+  AE08 3E 01            ld a,1
  6+  AE0A 32 48 C3         ld (game_currentplayer),a               ; do the first player first
  7+  AE0D CD F4 C3         call player_init_lifestart              ; get the player config
  8+  AE10 CD 63 AE         call gameover_enterhighscores
  9+  AE13
 10+  AE13 3A 47 C3         ld a,(game_numberplayers)               ; check if we need to do player 2
 11+  AE16 FE 02            cp 2
 12+  AE18 C2 26 AE         jp nz,gameover_draw0
 13+  AE1B 3E 02            ld a,2
 14+  AE1D 32 48 C3         ld (game_currentplayer),a               ; do the second player
 15+  AE20 CD F4 C3         call player_init_lifestart              ; get the player config
 16+  AE23 CD 63 AE         call gameover_enterhighscores
 17+  AE26              gameover_draw0:
 18+  AE26 CD 0E AF         call gameover_init
 19+  AE29
 20+  AE29 21 4A 84         ld hl,string_gameoverscreen_gameover
 21+  AE2C CD 25 86         call string_print
 22+  AE2F
 23+  AE2F 21 56 84         ld hl,string_gameoverscreen_copyright
 24+  AE32 CD 25 86         call string_print
 25+  AE35
 26+  AE35 CD 46 AE         call gameover_commontext
 27+  AE38
 28+  AE38 06 0B            ld b,11
 29+  AE3A 3E 42            ld a,66
 30+  AE3C 11 2B 58         ld de,22528+43                         ; attrs here
 31+  AE3F CD 9A A9         call screen_setcolours
 32+  AE42 CD 0A 81         call utilities_waitforkey   ; wait for keypress
 33+  AE45
 34+  AE45 C9               ret
 35+  AE46
 36+  AE46              ;
 37+  AE46              ; Draws text shared by the game over and high score screens
 38+  AE46              ;
 39+  AE46              gameover_commontext:
 40+  AE46 CD 5E A9         call screen_setuptext       ; show scores
 41+  AE49 CD EE CA         call scores_printscores     ; print the current scores
 42+  AE4C
 43+  AE4C 21 7E 84         ld hl,string_gameover_credits
 44+  AE4F CD 25 86         call string_print
 45+  AE52
 46+  AE52 21 6A 84         ld hl,string_gameoverscreen_bestscores
 47+  AE55 CD 25 86         call string_print
 48+  AE58
 49+  AE58 06 20            ld b,32
 50+  AE5A 3E 45            ld a,69
 51+  AE5C 11 C0 5A         ld de,22528+704                         ; attrs here
 52+  AE5F CD 9A A9         call screen_setcolours
 53+  AE62
 54+  AE62 C9               ret
 55+  AE63
 56+  AE63              ;
 57+  AE63              ; If required, enter highscore
 58+  AE63              ;
 59+  AE63              gameover_enterhighscores:
 60+  AE63                  ; check if we need to enter initial
 61+  AE63 CD 5F CB         call scores_processhighscores
 62+  AE66
 63+  AE66 3A 5D CB         ld a,(scores_highscoretmp)
 64+  AE69 FE 00            cp 0
 65+  AE6B C8               ret z
 66+  AE6C CD A4 AE         call gameover_enterhighscores_init
 67+  AE6F 3A 5D CB         ld a,(scores_highscoretmp)
 68+  AE72 3D               dec a
 69+  AE73 3D               dec a
 70+  AE74 3D               dec a                                   ; get high score location back to position of name
 71+  AE75 16 00            ld d,0
 72+  AE77 5F               ld e,a
 73+  AE78 21 73 CA         ld hl,scores_table
 74+  AE7B 19               add hl,de                               ; load memory into hl
 75+  AE7C 08               ex af,af'
 76+  AE7D 06 0F            ld b,15
 77+  AE7F CD 5E 81         call utilities_pauseforframes           ; pause for a little bit
 78+  AE82 06 03            ld b,3                                  ; collect three chars
 79+  AE84              gameover_enterhighscores2:
 80+  AE84 C5               push bc
 81+  AE85 E5               push hl
 82+  AE86              gameover_enterhighscores3:
 83+  AE86 CD 62 81         call utilities_readkey               ; get key into a
 84+  AE89 FE 41            cp 65
 85+  AE8B DA 86 AE         jp c,gameover_enterhighscores3
 86+  AE8E FE 5B            cp 91
 87+  AE90 D2 86 AE         jp nc,gameover_enterhighscores3      ; if not a letter, get another
 88+  AE93 E1               pop hl
 89+  AE94 77               ld (hl),a
 90+  AE95 23               inc hl
 91+  AE96 E5               push hl
 92+  AE97 CD 4A CB         call scores_showtable
 93+  AE9A E1               pop hl
 94+  AE9B 06 0F            ld b,15
 95+  AE9D CD 5E 81         call utilities_pauseforframes
 96+  AEA0 C1               pop bc
 97+  AEA1 10 E1            djnz gameover_enterhighscores2
 98+  AEA3 C9               ret
 99+  AEA4
100+  AEA4              ;
101+  AEA4              ; Displays the screen text for high score entry
102+  AEA4              ;
103+  AEA4              gameover_enterhighscores_init:
104+  AEA4
105+  AEA4 CD 0E AF         call gameover_init
106+  AEA7 CD 46 AE         call gameover_commontext
107+  AEAA
108+  AEAA 21 8A 84         ld hl,string_highscore_congratulations
109+  AEAD CD 25 86         call string_print
110+  AEB0
111+  AEB0 3A 48 C3         ld a,(game_currentplayer)
112+  AEB3 FE 01            cp 1
113+  AEB5 21 9C 84         ld hl,string_highscore_player1
114+  AEB8 C3 BE AE         jp gameover_enterhighscores_init1
115+  AEBB              gameover_enterhighscores_init0:
116+  AEBB 21 A7 84         ld hl,string_highscore_player2
117+  AEBE              gameover_enterhighscores_init1:
118+  AEBE CD 25 86         call string_print
119+  AEC1 06 60            ld b,96
120+  AEC3 3E 43            ld a,67
121+  AEC5 11 A0 58         ld de,22528+160                         ; attrs here
122+  AEC8 CD 9A A9         call screen_setcolours
123+  AECB
124+  AECB 21 B2 84         ld hl,string_highscore_youhaveearned
125+  AECE CD 25 86         call string_print
126+  AED1
127+  AED1 3A 5D CB         ld a,(scores_highscoretmp)
128+  AED4 FE 05            cp 5
129+  AED6 CA E4 AE         jp z, gameover_enterhighscores_init2    ; first place
130+  AED9 FE 11            cp 17
131+  AEDB CA EA AE         jp z, gameover_enterhighscores_init3    ; 2nd place
132+  AEDE 21 EE 84         ld hl,string_highscore_place3           ; 3rd place
133+  AEE1 C3 F0 AE         jp gameover_enterhighscores_init4
134+  AEE4              gameover_enterhighscores_init2
135+  AEE4 21 C4 84         ld hl,string_highscore_place1
136+  AEE7 C3 F0 AE         jp gameover_enterhighscores_init4
137+  AEEA              gameover_enterhighscores_init3
138+  AEEA 21 D9 84         ld hl,string_highscore_place2
139+  AEED C3 F0 AE         jp gameover_enterhighscores_init4
140+  AEF0              gameover_enterhighscores_init4
141+  AEF0 CD 25 86         call string_print
142+  AEF3
143+  AEF3 06 60            ld b,96
144+  AEF5 3E 42            ld a,66
145+  AEF7 11 40 59         ld de,22528+320                         ; attrs here
146+  AEFA CD 9A A9         call screen_setcolours
147+  AEFD
148+  AEFD 21 03 85         ld hl,string_highscore_pleaseenter
149+  AF00 CD 25 86         call string_print
150+  AF03
151+  AF03 06 60            ld b,96
152+  AF05 3E 46            ld a,70
153+  AF07 11 E0 59         ld de,22528+480                         ; attrs here
154+  AF0A CD 9A A9         call screen_setcolours
155+  AF0D C9               ret
156+  AF0E
157+  AF0E              ;
158+  AF0E              ; Initialises the screen
159+  AF0E              ;
160+  AF0E              gameover_init:
161+  AF0E              ; We want a black screen.
162+  AF0E 3E 47            ld a,71             ; white ink (7) on black paper (0),
163+  AF10                                      ; bright (64).
164+  AF10 CD 43 81         call utilities_clearscreen
165+  AF13 32 8D 5C         ld (23693),a        ; set our screen colours.
166+  AF16 3E 00            ld a,0              ; 2 is the code for red.
167+  AF18 D3 FE            out (254),a         ; write to port 254.
168+  AF1A C9               ret
# file closed: screen/gameover.asm
141   AF1B                  include "screen\endlevel.asm"
# file opened: screen/endlevel.asm
  1+  AF1B              ;
  2+  AF1B              ; Draws the level transition screen
  3+  AF1B              ;
  4+  AF1B              endlevel_draw:
  5+  AF1B CD 16 B0         call endlevel_init
  6+  AF1E CD FF AF         call endlevel_commontext
  7+  AF21
  8+  AF21 21 8A 84         ld hl,string_highscore_congratulations
  9+  AF24 CD 25 86         call string_print
 10+  AF27
 11+  AF27 3A 48 C3         ld a,(game_currentplayer)
 12+  AF2A FE 01            cp 1
 13+  AF2C 21 9C 84         ld hl,string_highscore_player1
 14+  AF2F C3 35 AF         jp endlevel_init1
 15+  AF32              endlevel_init0:
 16+  AF32 21 A7 84         ld hl,string_highscore_player2
 17+  AF35              endlevel_init1:
 18+  AF35 CD 25 86         call string_print
 19+  AF38
 20+  AF38 21 20 85         ld hl,string_endlevel_youhaveearned
 21+  AF3B CD 25 86         call string_print
 22+  AF3E
 23+  AF3E CD 9E AF         call endlevel_workoutbonus
 24+  AF41 D5               push de
 25+  AF42 08               ex af,af'                               ; store the a value for later
 26+  AF43 CD 25 86         call string_print
 27+  AF46 D1               pop de
 28+  AF47 62 6B            ld hl,de                                ; get the points text into de
 29+  AF49 CD 25 86         call string_print
 30+  AF4C
 31+  AF4C 21 8B 85         ld hl, string_endlevel_anothergo
 32+  AF4F CD 25 86         call string_print
 33+  AF52
 34+  AF52 06 20            ld b,32
 35+  AF54 3E 23            ld a,35
 36+  AF56 11 60 59         ld de,22528+352                         ; attrs here
 37+  AF59 CD 9A A9         call screen_setcolours
 38+  AF5C
 39+  AF5C 06 20            ld b,32
 40+  AF5E 3E 25            ld a,37
 41+  AF60 11 A0 59         ld de,22528+416                         ; attrs here
 42+  AF63 CD 9A A9         call screen_setcolours
 43+  AF66
 44+  AF66 06 20            ld b,32
 45+  AF68 3E 23            ld a,35
 46+  AF6A 11 E0 59         ld de,22528+480                         ; attrs here
 47+  AF6D CD 9A A9         call screen_setcolours
 48+  AF70
 49+  AF70 06 20            ld b,32
 50+  AF72 3E 22            ld a,34
 51+  AF74 11 40 5A         ld de,22528+576                         ; attrs here
 52+  AF77 CD 9A A9         call screen_setcolours
 53+  AF7A
 54+  AF7A 08               ex af,af'                               ; get back a value with bonus type
 55+  AF7B 06 14            ld b,20
 56+  AF7D CD 5E 81         call utilities_pauseforframes
 57+  AF80
 58+  AF80 47               ld b,a                      ; put the bonus count in b
 59+  AF81              endlevel_init2:
 60+  AF81 C5               push bc
 61+  AF82 06 01            ld b,1
 62+  AF84 CD 97 CA         call scores_addthousands
 63+  AF87 CD 53 C4         call player_recordcurrentstate
 64+  AF8A CD AE CA         call scores_printscore     ; print the current scores
 65+  AF8D 06 0A            ld b,10
 66+  AF8F CD 5E 81         call utilities_pauseforframes
 67+  AF92 C1               pop bc
 68+  AF93 10 EC            djnz endlevel_init2
 69+  AF95
 70+  AF95 CD 81 C3         call game_increasedifficulty ; move the difficulty up a level
 71+  AF98
 72+  AF98 3E 64            ld a,100                              ; wait for 200 frames
 73+  AF9A CD 1F 81         call utilities_waitforkey_forframes   ; wait for keypress
 74+  AF9D
 75+  AF9D C9               ret
 76+  AF9E
 77+  AF9E              ;
 78+  AF9E              ; Works out the bonus
 79+  AF9E              ; Outputs:
 80+  AF9E              ; a = 15 (all seven)
 81+  AF9E              ; a = 10 (3 large or 4 small)
 82+  AF9E              ; a = 5 (1 large diamond)
 83+  AF9E              ; hl - pointer to bonus text
 84+  AF9E              ; de - pointer to points text
 85+  AF9E              ;
 86+  AF9E              endlevel_workoutbonus:
 87+  AF9E 21 1C B7         ld hl,level_diamonds+2     ; location of state of first diamond
 88+  AFA1 06 03            ld b,3                      ; number to check
 89+  AFA3 16 00            ld d,0                      ; zero diamond count
 90+  AFA5              endlevel_workoutbonus0:
 91+  AFA5 7E               ld a,(hl)                   ; get state
 92+  AFA6 FE 01            cp 1
 93+  AFA8 C2 AC AF         jp nz,endlevel_workoutbonus1 ; if not, move on
 94+  AFAB 14               inc d                       ; increment diamond count
 95+  AFAC              endlevel_workoutbonus1:
 96+  AFAC 23               inc hl
 97+  AFAD 23               inc hl
 98+  AFAE 23               inc hl
 99+  AFAF 23               inc hl
100+  AFB0 23               inc hl                      ; get to next state
101+  AFB1 10 F2            djnz endlevel_workoutbonus0
102+  AFB3
103+  AFB3 21 2C B7         ld hl,level_gems+2     ; location of state of first gem
104+  AFB6 06 04            ld b,4                      ; number to check
105+  AFB8 1E 00            ld e,0                      ; zero gem count
106+  AFBA              endlevel_workoutbonus2:
107+  AFBA 7E               ld a,(hl)                   ; get state
108+  AFBB FE 01            cp 1
109+  AFBD C2 C1 AF         jp nz,endlevel_workoutbonus3 ; if not, move on
110+  AFC0 1C               inc e                       ; increment diamond count
111+  AFC1              endlevel_workoutbonus3:
112+  AFC1 23               inc hl
113+  AFC2 23               inc hl
114+  AFC3 23               inc hl
115+  AFC4 23               inc hl
116+  AFC5 23               inc hl                     ; get to next state
117+  AFC6 10 F2            djnz endlevel_workoutbonus2
118+  AFC8
119+  AFC8 7A               ld a,d
120+  AFC9 83               add e
121+  AFCA FE 07            cp 7                        ; check for max bonus
122+  AFCC C2 D8 AF         jp nz,endlevel_workoutbonus4 ;
123+  AFCF 3E 0F            ld a,15
124+  AFD1 21 50 85         ld hl, string_endlevel_bonus3
125+  AFD4 11 7C 85         ld de, string_endlevel_points3
126+  AFD7 C9               ret                         ; return with bonus of 15
127+  AFD8              endlevel_workoutbonus4:
128+  AFD8 7A               ld a,d                      ; check for for diamonds
129+  AFD9 FE 03            cp 3
130+  AFDB C2 E7 AF         jp nz,endlevel_workoutbonus5
131+  AFDE 3E 0A            ld a,10
132+  AFE0 21 41 85         ld hl, string_endlevel_bonus2
133+  AFE3 11 6D 85         ld de, string_endlevel_points2
134+  AFE6 C9               ret                         ; return with bonus of ten
135+  AFE7              endlevel_workoutbonus5:
136+  AFE7 7B               ld a,e                      ; check for four gems
137+  AFE8 FE 04            cp 4
138+  AFEA C2 F6 AF         jp nz,endlevel_workoutbonus6
139+  AFED 3E 0A            ld a,10
140+  AFEF 21 41 85         ld hl, string_endlevel_bonus2
141+  AFF2 11 6D 85         ld de, string_endlevel_points2
142+  AFF5 C9               ret                         ; return with bonus of 10
143+  AFF6              endlevel_workoutbonus6:
144+  AFF6 3E 05            ld a,5                      ; otherwise, bonus is 5
145+  AFF8 21 32 85         ld hl, string_endlevel_bonus1
146+  AFFB 11 5F 85         ld de, string_endlevel_points1
147+  AFFE C9               ret
148+  AFFF
149+  AFFF              ;
150+  AFFF              ; Draws text shared by the game over and high score screens
151+  AFFF              ;
152+  AFFF              endlevel_commontext:
153+  AFFF CD 5E A9         call screen_setuptext       ; show scores
154+  B002 CD EE CA         call scores_printscores     ; print the current scores
155+  B005
156+  B005 21 6A 84         ld hl,string_gameoverscreen_bestscores
157+  B008 CD 25 86         call string_print
158+  B00B
159+  B00B 06 20            ld b,32
160+  B00D 3E 45            ld a,69
161+  B00F 11 C0 5A         ld de,22528+704                         ; attrs here
162+  B012 CD 9A A9         call screen_setcolours
163+  B015
164+  B015 C9               ret
165+  B016
166+  B016              ;
167+  B016              ; Initialises the screen
168+  B016              ;
169+  B016              endlevel_init:
170+  B016              ; We want a green screen.
171+  B016 3E 21            ld a,33             ; white ink (7) on black paper (0),
172+  B018                                      ; bright (64).
173+  B018 CD 43 81         call utilities_clearscreen
174+  B01B 32 8D 5C         ld (23693),a        ; set our screen colours.
175+  B01E 3E 00            ld a,0              ; 2 is the code for red.
176+  B020 D3 FE            out (254),a         ; write to port 254.
177+  B022 C9               ret
# file closed: screen/endlevel.asm
142   B023                  include "screen\options.asm"
# file opened: screen/options.asm
  1+  B023              ;
  2+  B023              ; Show the options screen
  3+  B023              ;
  4+  B023              options_show:
  5+  B023 CD BE B0         call options_init
  6+  B026
  7+  B026 21 A6 85         ld hl,string_options_title
  8+  B029 CD 25 86         call string_print
  9+  B02C 21 B0 85         ld hl,string_options_1player
 10+  B02F CD 25 86         call string_print
 11+  B032 21 C0 85         ld hl,string_options_2player
 12+  B035 CD 25 86         call string_print
 13+  B038 21 D0 85         ld hl,string_options_keyboard
 14+  B03B CD 25 86         call string_print
 15+  B03E 21 DE 85         ld hl,string_options_joystick
 16+  B041 CD 25 86         call string_print
 17+  B044 21 EC 85         ld hl,string_options_start
 18+  B047 CD 25 86         call string_print
 19+  B04A 21 F7 85         ld hl,string_options_vanity
 20+  B04D CD 25 86         call string_print
 21+  B050
 22+  B050 3A 47 C3         ld a,(game_numberplayers)
 23+  B053 FE 01            cp 1
 24+  B055 C2 5E B0         jp nz,options_show0
 25+  B058 11 CA 58         ld de,22528+202                         ; top row attrs here
 26+  B05B C3 61 B0         jp options_show1
 27+  B05E              options_show0:
 28+  B05E 11 EA 58         ld de,22528+234                         ; top row attrs here
 29+  B061              options_show1:
 30+  B061 06 0D            ld b,13
 31+  B063 3E C7            ld a,199
 32+  B065 CD 9A A9         call screen_setcolours                  ; highlight current player
 33+  B068
 34+  B068 3A 4B C3         ld a,(game_control)
 35+  B06B FE 00            cp 0
 36+  B06D C2 76 B0         jp nz,options_show6
 37+  B070 11 0A 59         ld de,22528+266                         ; top row attrs here
 38+  B073 C3 79 B0         jp options_show7
 39+  B076              options_show6:
 40+  B076 11 2A 59         ld de,22528+298                         ; top row attrs here
 41+  B079              options_show7:
 42+  B079 06 0D            ld b,13
 43+  B07B 3E C7            ld a,199
 44+  B07D CD 9A A9         call screen_setcolours                  ; highlight current control
 45+  B080              options_show8:
 46+  B080 CD 62 81         call utilities_readkey
 47+  B083 FE 31            cp 49                                   ; was 1 pressed
 48+  B085 C2 90 B0         jp nz,options_show2
 49+  B088 21 47 C3         ld hl,game_numberplayers
 50+  B08B 36 01            ld (hl),1
 51+  B08D C3 23 B0         jp options_show
 52+  B090              options_show2:
 53+  B090 FE 32            cp 50                                   ; was 2 pressed
 54+  B092 C2 9D B0         jp nz,options_show3
 55+  B095 21 47 C3         ld hl,game_numberplayers
 56+  B098 36 02            ld (hl),2
 57+  B09A C3 23 B0         jp options_show
 58+  B09D              options_show3:
 59+  B09D FE 33            cp 51                                   ; was 3 pressed
 60+  B09F C2 AA B0         jp nz,options_show4
 61+  B0A2 21 4B C3         ld hl,game_control
 62+  B0A5 36 00            ld (hl),0
 63+  B0A7 C3 23 B0         jp options_show
 64+  B0AA              options_show4:
 65+  B0AA FE 34            cp 52                                   ; was 4 pressed
 66+  B0AC C2 B7 B0         jp nz,options_show5
 67+  B0AF 21 4B C3         ld hl,game_control
 68+  B0B2 36 01            ld (hl),1
 69+  B0B4 C3 23 B0         jp options_show
 70+  B0B7              options_show5:
 71+  B0B7 FE 35            cp 53                                   ; was 5 pressed
 72+  B0B9 C8               ret z                                   ; exit if so
 73+  B0BA C3 80 B0         jp options_show8                         ; otherwise, jump to top
 74+  B0BD C9               ret
 75+  B0BE
 76+  B0BE              ;
 77+  B0BE              ; Initialise the options screen
 78+  B0BE              ;
 79+  B0BE              options_init:
 80+  B0BE 3E 47            ld a,71             ; white ink (7) on black paper (0),
 81+  B0C0                                      ; bright (64).
 82+  B0C0 CD 43 81         call utilities_clearscreen
 83+  B0C3 32 8D 5C         ld (23693),a        ; set our screen colours.
 84+  B0C6 3E 00            ld a,0              ; 2 is the code for red.
 85+  B0C8 D3 FE            out (254),a         ; write to port 254.
 86+  B0CA
 87+  B0CA C9               ret
 88+  B0CB C9               ret
# file closed: screen/options.asm
143   B0CC
144   B0CC                  include "sound\sound.asm"
# file opened: sound/sound.asm
  1+  B0CC              sound_gemcollected:
  2+  B0CC 21 C8 00         ld hl,200 ; pitch.
  3+  B0CF 11 3E 00         ld de,62 ; duration.
  4+  B0D2 CD B5 03         call 949 ; ROM beeper routine.
  5+  B0D5 C9               ret
  6+  B0D6
  7+  B0D6              sound_pitchbend:
  8+  B0D6 21 F4 01         ld hl,500 ; starting pitch.
  9+  B0D9 06 FA            ld b,250 ; length of pitch bend.
 10+  B0DB              sound_pitchbend0:
 11+  B0DB C5                push bc
 12+  B0DC E5               push hl ; store pitch.
 13+  B0DD 11 01 00         ld de,1 ; very short duration.
 14+  B0E0 CD B5 03         call 949 ; ROM beeper routine.
 15+  B0E3 E1               pop hl ; restore pitch.
 16+  B0E4 23               inc hl ; pitch going up.
 17+  B0E5 C1               pop bc
 18+  B0E6 10 F3            djnz sound_pitchbend0 ; repeat.
 19+  B0E8 C9               ret
 20+  B0E9
 21+  B0E9              sound_rockfell:
 22+  B0E9 08               ex af,af'
 23+  B0EA 1E 32            ld e,50 ; repeat 250 times.
 24+  B0EC 21 00 00         ld hl,0 ; start pointer in ROM.
 25+  B0EF D5           sound_rockfell2 push de
 26+  B0F0 06 20            ld b,32 ; length of step.
 27+  B0F2 C5           sound_rockfell0 push bc
 28+  B0F3 7E               ld a,(hl) ; next "random" number.
 29+  B0F4 23               inc hl ; pointer.
 30+  B0F5 E6 F8            and 248 ; we want a black border.
 31+  B0F7 D3 FE            out (254),a ; write to speaker.
 32+  B0F9 7B               ld a,e ; as e gets smaller...
 33+  B0FA 2F               cpl ; ...we increase the delay.
 34+  B0FB 3D           sound_rockfell1 dec a ; decrement loop counter.
 35+  B0FC 20 FD            jr nz,sound_rockfell1 ; delay loop.
 36+  B0FE C1               pop bc
 37+  B0FF 10 F1            djnz sound_rockfell0 ; next step.
 38+  B101 D1               pop de
 39+  B102 7B               ld a,e
 40+  B103 D6 18            sub 24 ; size of step.
 41+  B105 FE 1E            cp 30 ; end of range.
 42+  B107 CA 18 B1         jp z,sound_rockfell5
 43+  B10A DA 18 B1         jp c, sound_rockfell5
 44+  B10D 5F               ld e,a
 45+  B10E 2F               cpl
 46+  B10F 06 28        sound_rockfell3 ld b,40 ; silent period.
 47+  B111 10 FE        sound_rockfell4 djnz sound_rockfell4
 48+  B113 3D               dec a
 49+  B114 20 F9            jr nz,sound_rockfell3
 50+  B116 18 D7            jr sound_rockfell2
 51+  B118              sound_rockfell5
 52+  B118 08               ex af,af'
 53+  B119 C9               ret
 54+  B11A
# file closed: sound/sound.asm
145   B11A
146   B11A                  include "leveldata\level.asm"
# file opened: leveldata/level.asm
  1+  B11A              ; ###############################################################
  2+  B11A              ; Data for level 1
  3+  B11A              ; ###############################################################
  4+  B11A              level_layout:
  5+  B11A
  6+  B11A                  ;defb 09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09,09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09
  7+  B11A
  8+  B11A 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,05,05,02,01,01,01,03,05,05,05,05,05,05,05,05,05,05,05,00,00
  8+  B11E 05 05 05 05
  8+  B122 05 05 05 05
  8+  B126 05 05 02 01
  8+  B12A 01 01 03 05
  8+  B12E 05 05 05 05
  8+  B132 05 05 05 05
  8+  B136 05 05 00 00
  9+  B13A 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,03,05,05,05,05,05,05,05,05,05,00,00
  9+  B13E 05 05 05 05
  9+  B142 05 05 05 05
  9+  B146 02 01 01 01
  9+  B14A 01 01 01 01
  9+  B14E 03 05 05 05
  9+  B152 05 05 05 05
  9+  B156 05 05 00 00
 10+  B15A 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,01,01,01,01,03,05,13,13,13,13,13,13,00,00
 10+  B15E 05 05 05 05
 10+  B162 05 05 02 01
 10+  B166 01 01 01 01
 10+  B16A 01 01 01 01
 10+  B16E 01 01 03 05
 10+  B172 0D 0D 0D 0D
 10+  B176 0D 0D 00 00
 11+  B17A 00 00 01 01      defb 00,00,01,01,01,01,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,03,05,05,05,05,05,05,00,00
 11+  B17E 01 01 00 01
 11+  B182 01 01 01 01
 11+  B186 01 01 01 01
 11+  B18A 01 01 01 01
 11+  B18E 01 01 01 03
 11+  B192 05 05 05 05
 11+  B196 05 05 00 00
 12+  B19A 00 00 01 01      defb 00,00,01,01,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,01,00,00
 12+  B19E 04 04 04 04
 12+  B1A2 04 04 01 01
 12+  B1A6 01 01 01 01
 12+  B1AA 01 01 01 01
 12+  B1AE 01 01 01 01
 12+  B1B2 01 01 01 01
 12+  B1B6 00 01 00 00
 13+  B1BA 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,01,00,00
 13+  B1BE 04 04 04 04
 13+  B1C2 04 04 04 04
 13+  B1C6 01 01 01 01
 13+  B1CA 01 01 01 01
 13+  B1CE 01 01 01 01
 13+  B1D2 00 00 00 00
 13+  B1D6 00 01 00 00
 14+  B1DA 00 00 01 04      defb 00,00,01,04,04,01,01,01,01,01,04,04,04,04,01,01,01,01,01,01,01,00,00,00,00,01,01,01,01,01,00,00
 14+  B1DE 04 01 01 01
 14+  B1E2 01 01 04 04
 14+  B1E6 04 04 01 01
 14+  B1EA 01 01 01 01
 14+  B1EE 01 00 00 00
 14+  B1F2 00 01 01 01
 14+  B1F6 01 01 00 00
 15+  B1FA 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,01,04,04,04,04,04,04,04,04,00,00,00,00,04,04,04,04,04,04,04,01,00,00
 15+  B1FE 04 04 04 04
 15+  B202 04 01 04 04
 15+  B206 04 04 04 04
 15+  B20A 04 04 00 00
 15+  B20E 00 00 04 04
 15+  B212 04 04 04 04
 15+  B216 04 01 00 00
 16+  B21A 00 00 01 01      defb 00,00,01,01,01,04,01,01,01,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 16+  B21E 01 04 01 01
 16+  B222 01 01 04 04
 16+  B226 04 04 04 04
 16+  B22A 04 04 00 04
 16+  B22E 04 04 04 04
 16+  B232 04 04 04 04
 16+  B236 04 01 00 00
 17+  B23A 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 17+  B23E 00 00 00 00
 17+  B242 00 04 04 04
 17+  B246 04 04 04 04
 17+  B24A 04 04 00 04
 17+  B24E 04 04 04 04
 17+  B252 04 04 04 04
 17+  B256 04 01 00 00
 18+  B25A 00 00 01 15      defb 00,00,01,21,21,21,21,21,21,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 18+  B25E 15 15 15 15
 18+  B262 15 01 04 04
 18+  B266 04 04 04 04
 18+  B26A 04 04 00 04
 18+  B26E 04 04 04 04
 18+  B272 04 04 04 04
 18+  B276 04 01 00 00
 19+  B27A 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,00,00,00,01,00,00
 19+  B27E 00 00 00 00
 19+  B282 00 01 04 04
 19+  B286 04 04 04 04
 19+  B28A 04 04 00 04
 19+  B28E 04 04 04 04
 19+  B292 04 00 00 00
 19+  B296 00 01 00 00
 20+  B29A 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 20+  B29E 00 00 00 00
 20+  B2A2 00 01 04 04
 20+  B2A6 04 04 04 04
 20+  B2AA 04 04 00 04
 20+  B2AE 04 04 04 04
 20+  B2B2 04 00 04 04
 20+  B2B6 00 01 00 00
 21+  B2BA 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 21+  B2BE 06 06 06 06
 21+  B2C2 06 01 04 04
 21+  B2C6 04 04 04 04
 21+  B2CA 04 04 00 04
 21+  B2CE 04 04 04 04
 21+  B2D2 04 00 04 04
 21+  B2D6 00 01 00 00
 22+  B2DA 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,04,00,01,00,00
 22+  B2DE 1A 1A 1A 1A
 22+  B2E2 1A 01 04 00
 22+  B2E6 00 00 00 00
 22+  B2EA 00 00 00 00
 22+  B2EE 00 00 00 00
 22+  B2F2 00 00 04 04
 22+  B2F6 00 01 00 00
 23+  B2FA 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 23+  B2FE 1A 1A 1A 1A
 23+  B302 1A 01 04 00
 23+  B306 04 04 04 04
 23+  B30A 04 04 00 04
 23+  B30E 04 04 00 04
 23+  B312 04 04 04 04
 23+  B316 00 01 00 00
 24+  B31A 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 24+  B31E 1A 1A 1A 1A
 24+  B322 1A 01 04 00
 24+  B326 04 04 04 04
 24+  B32A 04 04 00 04
 24+  B32E 04 04 00 04
 24+  B332 04 04 04 04
 24+  B336 00 01 00 00
 25+  B33A 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 25+  B33E 01 01 01 01
 25+  B342 01 01 04 00
 25+  B346 04 04 04 04
 25+  B34A 04 04 00 04
 25+  B34E 04 04 00 04
 25+  B352 04 04 04 04
 25+  B356 00 01 00 00
 26+  B35A 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,00,00,00,00,04,04,04,01,00,00
 26+  B35E 04 04 04 04
 26+  B362 04 04 04 00
 26+  B366 04 04 04 04
 26+  B36A 04 04 00 04
 26+  B36E 04 04 00 00
 26+  B372 00 00 04 04
 26+  B376 04 01 00 00
 27+  B37A 00 00 01 04      defb 00,00,01,04,04,04,00,00,00,00,00,00,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 27+  B37E 04 04 00 00
 27+  B382 00 00 00 00
 27+  B386 04 04 04 04
 27+  B38A 04 04 00 04
 27+  B38E 04 04 04 04
 27+  B392 04 00 04 04
 27+  B396 04 01 00 00
 28+  B39A 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 28+  B39E 04 04 00 04
 28+  B3A2 04 04 04 04
 28+  B3A6 04 04 04 04
 28+  B3AA 04 04 00 04
 28+  B3AE 04 04 04 04
 28+  B3B2 04 00 04 04
 28+  B3B6 04 01 00 00
 29+  B3BA 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,04,00,04,04,04,01,00,00
 29+  B3BE 04 04 00 04
 29+  B3C2 04 04 01 01
 29+  B3C6 01 01 01 01
 29+  B3CA 01 01 01 01
 29+  B3CE 01 01 01 01
 29+  B3D2 04 00 04 04
 29+  B3D6 04 01 00 00
 30+  B3DA 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 30+  B3DE 04 04 00 04
 30+  B3E2 04 04 01 00
 30+  B3E6 00 00 00 00
 30+  B3EA 00 00 00 00
 30+  B3EE 00 00 00 01
 30+  B3F2 04 00 04 04
 30+  B3F6 04 01 00 00
 31+  B3FA 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 31+  B3FE 04 04 00 04
 31+  B402 04 04 01 00
 31+  B406 00 00 00 00
 31+  B40A 00 00 00 00
 31+  B40E 00 00 00 01
 31+  B412 04 00 04 04
 31+  B416 04 01 00 00
 32+  B41A 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 32+  B41E 04 04 00 04
 32+  B422 04 04 01 00
 32+  B426 00 00 00 00
 32+  B42A 00 00 00 00
 32+  B42E 00 00 00 01
 32+  B432 04 00 04 04
 32+  B436 04 01 00 00
 33+  B43A 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,00,00,00,00,00,00,00,00,00,00,00,00,04,04,04,04,04,04,01,00,00
 33+  B43E 04 04 00 04
 33+  B442 04 04 04 00
 33+  B446 00 00 00 00
 33+  B44A 00 00 00 00
 33+  B44E 00 00 00 04
 33+  B452 04 04 04 04
 33+  B456 04 01 00 00
 34+  B45A 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,04,04,04,04,01,00,00
 34+  B45E 04 04 04 04
 34+  B462 04 04 01 00
 34+  B466 00 00 00 00
 34+  B46A 00 00 00 00
 34+  B46E 00 00 00 01
 34+  B472 04 04 04 04
 34+  B476 04 01 00 00
 35+  B47A 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,01,00,00,00,00,01,00,00,00,01,04,04,04,04,04,01,00,00
 35+  B47E 04 04 04 04
 35+  B482 04 04 01 00
 35+  B486 00 00 01 00
 35+  B48A 00 00 00 01
 35+  B48E 00 00 00 01
 35+  B492 04 04 04 04
 35+  B496 04 01 00 00
 36+  B49A 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00
 36+  B49E 01 01 01 01
 36+  B4A2 01 01 01 01
 36+  B4A6 01 01 01 01
 36+  B4AA 01 01 01 01
 36+  B4AE 01 01 01 01
 36+  B4B2 01 01 01 01
 36+  B4B6 01 01 00 00
 37+  B4BA
 38+  B4BA              ; ###############################################################
 39+  B4BA              ; Object data: horiz, vert, state, memh, meml
 40+  B4BA              ; ###############################################################
 41+  B4BA              level_rocks_alt:
 42+  B4BA 09 04 00 00      defb 9,4,0,0,0
 42+  B4BE 00
 43+  B4BF 0C 07 00 00      defb 12,7,0,0,0
 43+  B4C3 00
 44+  B4C4 10 07 00 00      defb 16,7,0,0,0
 44+  B4C8 00
 45+  B4C9 0B 08 00 00      defb 11,8,0,0,0
 45+  B4CD 00
 46+  B4CE 0A 0A 00 00      defb 10,10,0,0,0
 46+  B4D2 00
 47+  B4D3 0C 0A 00 00      defb 12,10,0,0,0
 47+  B4D7 00
 48+  B4D8 0D 09 00 00      defb 13,9,0,0,0
 48+  B4DC 00
 49+  B4DD 0E 08 00 00      defb 14,8,0,0,0
 49+  B4E1 00
 50+  B4E2 0F 0B 00 00      defb 15,11,0,0,0
 50+  B4E6 00
 51+  B4E7 0B 0C 00 00      defb 11,12,0,0,0
 51+  B4EB 00
 52+  B4EC 11 0C 00 00      defb 17,12,0,0,0
 52+  B4F0 00
 53+  B4F1 13 08 00 00      defb 19,8,0,0,0
 53+  B4F5 00
 54+  B4F6 16 09 00 00      defb 22,9,0,0,0
 54+  B4FA 00
 55+  B4FB 13 0A 00 00      defb 19,10,0,0,0
 55+  B4FF 00
 56+  B500 15 0A 00 00      defb 21,10,0,0,0
 56+  B504 00
 57+  B505 15 0C 00 00      defb 21,12,0,0,0
 57+  B509 00
 58+  B50A 16 0C 00 00      defb 22,12,0,0,0
 58+  B50E 00
 59+  B50F 18 0A 00 00      defb 24,10,0,0,0
 59+  B513 00
 60+  B514 19 09 00 00      defb 25,9,0,0,0
 60+  B518 00
 61+  B519 1C 09 00 00      defb 28,9,0,0,0
 61+  B51D 00
 62+  B51E 1B 0C 00 00      defb 27,12,0,0,0
 62+  B522 00
 63+  B523 1A 0D 00 00      defb 26,13,0,0,0
 63+  B527 00
 64+  B528 19 0E 00 00      defb 25,14,0,0,0
 64+  B52C 00
 65+  B52D 19 10 00 00      defb 25,16,0,0,0
 65+  B531 00
 66+  B532 1A 11 00 00      defb 26,17,0,0,0
 66+  B536 00
 67+  B537 1B 11 00 00      defb 27,17,0,0,0
 67+  B53B 00
 68+  B53C 1C 12 00 00      defb 28,18,0,0,0
 68+  B540 00
 69+  B541 1A 13 00 00      defb 26,19,0,0,0
 69+  B545 00
 70+  B546 1B 15 00 00      defb 27,21,0,0,0
 70+  B54A 00
 71+  B54B 1A 17 00 00      defb 26,23,0,0,0
 71+  B54F 00
 72+  B550 1B 18 00 00      defb 27,24,0,0,0
 72+  B554 00
 73+  B555 19 18 00 00      defb 25,24,0,0,0
 73+  B559 00
 74+  B55A 18 17 00 00      defb 24,23,0,0,0
 74+  B55E 00
 75+  B55F 13 14 00 00      defb 19,20,0,0,0
 75+  B563 00
 76+  B564 14 12 00 00      defb 20,18,0,0,0
 76+  B568 00
 77+  B569 14 10 00 00      defb 20,16,0,0,0
 77+  B56D 00
 78+  B56E 15 10 00 00      defb 21,16,0,0,0
 78+  B572 00
 79+  B573 16 12 00 00      defb 22,18,0,0,0
 79+  B577 00
 80+  B578 11 14 00 00      defb 17,20,0,0,0
 80+  B57C 00
 81+  B57D 0D 11 00 00      defb 13,17,0,0,0
 81+  B581 00
 82+  B582 0C 13 00 00      defb 12,19,0,0,0
 82+  B586 00
 83+  B587 0B 13 00 00      defb 11,19,0,0,0
 83+  B58B 00
 84+  B58C 0A 11 00 00      defb 10,17,0,0,0
 84+  B590 00
 85+  B591 05 12 00 00      defb 5,18,0,0,0
 85+  B595 00
 86+  B596 07 16 00 00      defb 7,22,0,0,0
 86+  B59A 00
 87+  B59B 09 16 00 00      defb 9,22,0,0,0
 87+  B59F 00
 88+  B5A0 07 18 00 00      defb 7,24,0,0,0
 88+  B5A4 00
 89+  B5A5 05 18 00 00      defb 5,24,0,0,0
 89+  B5A9 00
 90+  B5AA 06 19 00 00      defb 6,25,0,0,0
 90+  B5AE 00
 91+  B5AF 08 19 00 00      defb 8,25,0,0,0
 91+  B5B3 00
 92+  B5B4 04 17 00 00      defb 4,23,0,0,0
 92+  B5B8 00
 93+  B5B9 FF               defb 255
 94+  B5BA
 95+  B5BA              level_rocks:
 96+  B5BA 09 04 00 00      defb 9,4,0,0,0
 96+  B5BE 00
 97+  B5BF 0C 07 00 00      defb 12,7,0,0,0
 97+  B5C3 00
 98+  B5C4 0B 07 00 00      defb 11,7,0,0,0
 98+  B5C8 00
 99+  B5C9 0A 08 00 00      defb 10,8,0,0,0
 99+  B5CD 00
100+  B5CE 10 07 00 00      defb 16,7,0,0,0
100+  B5D2 00
101+  B5D3 0E 08 00 00      defb 14,8,0,0,0
101+  B5D7 00
102+  B5D8 0D 09 00 00      defb 13,9,0,0,0
102+  B5DC 00
103+  B5DD 0C 0A 00 00      defb 12,10,0,0,0
103+  B5E1 00
104+  B5E2 0A 0B 00 00      defb 10,11,0,0,0
104+  B5E6 00
105+  B5E7 0B 0C 00 00      defb 11,12,0,0,0
105+  B5EB 00
106+  B5EC 0F 0B 00 00      defb 15,11,0,0,0
106+  B5F0 00
107+  B5F1 11 0C 00 00      defb 17,12,0,0,0
107+  B5F5 00
108+  B5F6 15 0B 00 00      defb 21,11,0,0,0
108+  B5FA 00
109+  B5FB 16 0C 00 00      defb 22,12,0,0,0
109+  B5FF 00
110+  B600 19 09 00 00      defb 25,9,0,0,0
110+  B604 00
111+  B605 1C 09 00 00      defb 28,9,0,0,0
111+  B609 00
112+  B60A 1B 0C 00 00      defb 27,12,0,0,0
112+  B60E 00
113+  B60F 1B 0E 00 00      defb 27,14,0,0,0
113+  B613 00
114+  B614 1A 0F 00 00      defb 26,15,0,0,0
114+  B618 00
115+  B619 1B 10 00 00      defb 27,16,0,0,0
115+  B61D 00
116+  B61E 1C 12 00 00      defb 28,18,0,0,0
116+  B622 00
117+  B623 1A 13 00 00      defb 26,19,0,0,0
117+  B627 00
118+  B628 1A 15 00 00      defb 26,21,0,0,0
118+  B62C 00
119+  B62D 1B 17 00 00      defb 27,23,0,0,0
119+  B631 00
120+  B632 1A 17 00 00      defb 26,23,0,0,0
120+  B636 00
121+  B637 19 18 00 00      defb 25,24,0,0,0
121+  B63B 00
122+  B63C 18 17 00 00      defb 24,23,0,0,0
122+  B640 00
123+  B641 17 10 00 00      defb 23,16,0,0,0
123+  B645 00
124+  B646 15 10 00 00      defb 21,16,0,0,0
124+  B64A 00
125+  B64B 14 12 00 00      defb 20,18,0,0,0
125+  B64F 00
126+  B650 13 14 00 00      defb 19,20,0,0,0
126+  B654 00
127+  B655 10 13 00 00      defb 16,19,0,0,0
127+  B659 00
128+  B65A 0D 14 00 00      defb 13,20,0,0,0
128+  B65E 00
129+  B65F 0E 11 00 00      defb 14,17,0,0,0
129+  B663 00
130+  B664 0C 12 00 00      defb 12,18,0,0,0
130+  B668 00
131+  B669 0A 11 00 00      defb 10,17,0,0,0
131+  B66D 00
132+  B66E 05 12 00 00      defb 5,18,0,0,0
132+  B672 00
133+  B673 09 14 00 00      defb 9,20,0,0,0
133+  B677 00
134+  B678 08 15 00 00      defb 8,21,0,0,0
134+  B67C 00
135+  B67D 07 16 00 00      defb 7,22,0,0,0
135+  B681 00
136+  B682 08 17 00 00      defb 8,23,0,0,0
136+  B686 00
137+  B687 07 18 00 00      defb 7,24,0,0,0
137+  B68B 00
138+  B68C 08 1A 00 00      defb 8,26,0,0,0
138+  B690 00
139+  B691 06 19 00 00      defb 6,25,0,0,0
139+  B695 00
140+  B696 05 18 00 00      defb 5,24,0,0,0
140+  B69A 00
141+  B69B 04 17 00 00      defb 4,23,0,0,0
141+  B69F 00
142+  B6A0 FF               defb 255
143+  B6A1
144+  B6A1              level_missiles:
145+  B6A1 0B 17 00 00      defb 11,23,0,0,0
145+  B6A5 00
146+  B6A6 0B 16 00 00      defb 11,22,0,0,0
146+  B6AA 00
147+  B6AB 0C 17 00 00      defb 12,23,0,0,0
147+  B6AF 00
148+  B6B0 0C 16 00 00      defb 12,22,0,0,0
148+  B6B4 00
149+  B6B5 0D 17 00 00      defb 13,23,0,0,0
149+  B6B9 00
150+  B6BA 0D 16 00 00      defb 13,22,0,0,0
150+  B6BE 00
151+  B6BF 0E 17 00 00      defb 14,23,0,0,0
151+  B6C3 00
152+  B6C4 0E 16 00 00      defb 14,22,0,0,0
152+  B6C8 00
153+  B6C9 0F 17 00 00      defb 15,23,0,0,0
153+  B6CD 00
154+  B6CE 0F 16 00 00      defb 15,22,0,0,0
154+  B6D2 00
155+  B6D3 10 17 00 00      defb 16,23,0,0,0
155+  B6D7 00
156+  B6D8 10 16 00 00      defb 16,22,0,0,0
156+  B6DC 00
157+  B6DD 11 17 00 00      defb 17,23,0,0,0
157+  B6E1 00
158+  B6E2 11 16 00 00      defb 17,22,0,0,0
158+  B6E6 00
159+  B6E7 12 17 00 00      defb 18,23,0,0,0
159+  B6EB 00
160+  B6EC 12 16 00 00      defb 18,22,0,0,0
160+  B6F0 00
161+  B6F1 13 17 00 00      defb 19,23,0,0,0
161+  B6F5 00
162+  B6F6 13 16 00 00      defb 19,22,0,0,0
162+  B6FA 00
163+  B6FB 14 17 00 00      defb 20,23,0,0,0
163+  B6FF 00
164+  B700 14 16 00 00      defb 20,22,0,0,0
164+  B704 00
165+  B705 15 17 00 00      defb 21,23,0,0,0
165+  B709 00
166+  B70A 15 16 00 00      defb 21,22,0,0,0
166+  B70E 00
167+  B70F 16 17 00 00      defb 22,23,0,0,0
167+  B713 00
168+  B714 16 16 00 00      defb 22,22,0,0,0
168+  B718 00
169+  B719 FF               defb 255
170+  B71A
171+  B71A              ;
172+  B71A              ; Diamonds: x,y,state,mem1+mem2
173+  B71A              ;
174+  B71A              level_diamonds:
175+  B71A 0C 1B 00 00      defb 12,27,0,0,0
175+  B71E 00
176+  B71F 10 1B 00 00      defb 16,27,0,0,0
176+  B723 00
177+  B724 15 1B 00 00      defb 21,27,0,0,0
177+  B728 00
178+  B729 FF               defb 255
179+  B72A
180+  B72A              level_gems:
181+  B72A 12 14 00 00      defb 18,20,0,0,0
181+  B72E 00
182+  B72F 06 18 00 00      defb 6,24,0,0,0
182+  B733 00
183+  B734 19 17 00 00      defb 25,23,0,0,0
183+  B738 00
184+  B739 1C 11 00 00      defb 28,17,0,0,0
184+  B73D 00
185+  B73E FF               defb 255
186+  B73F              ;
187+  B73F              ; Score area colours
188+  B73F              ;
189+  B73F              score_colours:
190+  B73F 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,67,67,67,67,67,67,67,67,66,71,71,71,71,71,71,71,71,71,71,71
190+  B743 47 47 47 47
190+  B747 47 47 47 42
190+  B74B 43 43 43 43
190+  B74F 43 43 43 43
190+  B753 42 47 47 47
190+  B757 47 47 47 47
190+  B75B 47 47 47 47
191+  B75F 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71
191+  B763 47 47 47 47
191+  B767 47 47 47 46
191+  B76B 46 46 46 46
191+  B76F 46 46 46 46
191+  B773 46 47 47 47
191+  B777 47 47 47 47
191+  B77B 47 47 47 47
192+  B77F
193+  B77F              high_score_colours:
194+  B77F 00 00 00 42      defb  0, 0, 0,66,66,66,71,71,71,71,71,71,67,67,67,71,71,71,71,71,71,70,70,70,71,71,71,71,71,71,0,0
194+  B783 42 42 47 47
194+  B787 47 47 47 47
194+  B78B 43 43 43 47
194+  B78F 47 47 47 47
194+  B793 47 46 46 46
194+  B797 47 47 47 47
194+  B79B 47 47 00 00
# file closed: leveldata/level.asm
147   B79F                  include "graphics\font.asm"
# file opened: graphics/font.asm
  1+  B79F              font:
  2+  B79F 00 00 00...  	defs 256
  3+  B89F              	; end 1
  4+  B89F 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; space
  4+  B8A3 00 00 00 00
  5+  B8A7 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ;!
  5+  B8AB 00 00 00 00
  6+  B8AF 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; "
  6+  B8B3 00 00 00 00
  7+  B8B7 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; #
  7+  B8BB 00 00 00 00
  8+  B8BF 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; $
  8+  B8C3 00 00 00 00
  9+  B8C7 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; %
  9+  B8CB 00 00 00 00
 10+  B8CF 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; &
 10+  B8D3 00 00 00 00
 11+  B8D7 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; '
 11+  B8DB 00 00 00 00
 12+  B8DF 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; (
 12+  B8E3 00 00 00 00
 13+  B8E7 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; )
 13+  B8EB 00 00 00 00
 14+  B8EF 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; *
 14+  B8F3 00 00 00 00
 15+  B8F7 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; +
 15+  B8FB 00 00 00 00
 16+  B8FF 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ,
 16+  B903 00 00 00 00
 17+  B907 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; -
 17+  B90B 00 00 00 00
 18+  B90F 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; .
 18+  B913 00 00 00 00
 19+  B917 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; /
 19+  B91B 00 00 00 00
 20+  B91F 1C 26 63 63  	defb	 28, 38, 99, 99, 99, 50, 28,  0 ; 0
 20+  B923 63 32 1C 00
 21+  B927 0C 1C 0C 0C  	defb	   12, 28, 12, 12, 12, 12, 63,0 ; 1
 21+  B92B 0C 0C 3F 00
 22+  B92F 3E 63 07 1E  	defb	  62, 99,  7, 30, 60, 96,127, 0 ; 2
 22+  B933 3C 60 7F 00
 23+  B937 3F 06 0C 1E  	defb	  63,  6, 12, 30,  3, 51, 30, 0 ; 3
 23+  B93B 03 33 1E 00
 24+  B93F 0E 1E 36 66  	defb	  14, 30, 54,102,127,  6,  6, 0 ; 4
 24+  B943 7F 06 06 00
 25+  B947 7E 40 7E 03  	defb	 126, 64,126,  3,  3, 99, 62, 0 ; 5
 25+  B94B 03 63 3E 00
 26+  B94F 1E 30 60 7E  	defb	 30, 48, 96,126, 99, 99, 62,  0 ; 6
 26+  B953 63 63 3E 00
 27+  B957 7F 63 06 0C  	defb	  127, 99,  6, 12, 24, 24, 24,0 ; 7
 27+  B95B 18 18 18 00
 28+  B95F 3C 62 72 3C  	defb	  60, 98,114, 60, 79, 67,62,0 ; 8
 28+  B963 4F 43 3E 00
 29+  B967 3E 63 63 3F  	defb	  62, 99, 99, 63,  3,  6, 60, 0 ; 9
 29+  B96B 03 06 3C 00
 30+  B96F 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; :
 30+  B973 00 00 00 00
 31+  B977 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ;
 31+  B97B 00 00 00 00
 32+  B97F 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; <
 32+  B983 00 00 00 00
 33+  B987 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; =
 33+  B98B 00 00 00 00
 34+  B98F 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; >
 34+  B993 00 00 00 00
 35+  B997 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ?
 35+  B99B 00 00 00 00
 36+  B99F              	; end 2
 37+  B99F 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; @
 37+  B9A3 00 00 00 00
 38+  B9A7 1C 36 63 63  	defb	  28, 54, 99, 99,127, 99, 99, 0 ; A
 38+  B9AB 7F 63 63 00
 39+  B9AF 7E 63 63 7E  	defb	  126, 99, 99,126, 99, 99,126,0 ; B
 39+  B9B3 63 63 7E 00
 40+  B9B7 1E 33 60 60  	defb	  30, 51, 96, 96, 96, 51, 30, 0 ; C
 40+  B9BB 60 33 1E 00
 41+  B9BF 7C 66 63 63  	defb	  124,102, 99, 99, 99,102,124,0 ; D
 41+  B9C3 63 66 7C 00
 42+  B9C7 7F 60 60 7E  	defb	  127, 96, 96,126, 96, 96,127,0 ; E
 42+  B9CB 60 60 7F 00
 43+  B9CF 7F 60 60 7E  	defb	  127, 96, 96,126, 96, 96, 96,0 ; F
 43+  B9D3 60 60 60 00
 44+  B9D7 1F 30 60 67  	defb	  31, 48, 96,103, 99, 51, 31, 0 ; G
 44+  B9DB 63 33 1F 00
 45+  B9DF 63 63 63 7F  	defb	  99, 99, 99,127, 99, 99, 99, 0 ; H
 45+  B9E3 63 63 63 00
 46+  B9E7 3F 0C 0C 0C  	defb	  63, 12, 12, 12, 12, 12, 63, 0 ; I
 46+  B9EB 0C 0C 3F 00
 47+  B9EF 03 03 03 03  	defb	  3,  3,  3,  3,  3, 99, 62,  0 ; J
 47+  B9F3 03 63 3E 00
 48+  B9F7 63 66 6C 78  	defb	  99,102,108,120,124,110,103, 0 ; K
 48+  B9FB 7C 6E 67 00
 49+  B9FF 30 30 30 30  	defb	  48, 48, 48, 48, 48, 48, 63, 0 ; L
 49+  BA03 30 30 3F 00
 50+  BA07 63 77 7F 7F  	defb	  99,119,127,127,107, 99, 99, 0 ; M
 50+  BA0B 6B 63 63 00
 51+  BA0F 63 73 7B 7F  	defb	  99,115,123,127,111,103, 99, 0 ; N
 51+  BA13 6F 67 63 00
 52+  BA17 3E 63 63 63  	defb	  62, 99, 99, 99, 99, 99, 62, 0 ; O
 52+  BA1B 63 63 3E 00
 53+  BA1F 7E 61 61 61  	defb	  126, 97, 97, 97,126, 96, 96,0 ; P
 53+  BA23 7E 60 60 00
 54+  BA27 3E 63 63 63  	defb	  62, 99, 99, 99,111,102, 61, 0 ; Q
 54+  BA2B 6F 66 3D 00
 55+  BA2F 7E 63 63 67  	defb	  126, 99, 99,103,124,110,103,0 ; R
 55+  BA33 7C 6E 67 00
 56+  BA37 3C 66 60 3E  	defb	  60,102, 96, 62,  3, 99, 62, 0 ; S
 56+  BA3B 03 63 3E 00
 57+  BA3F 7E 18 18 18  	defb	  126, 24, 24, 24, 24, 24, 24,0 ; T
 57+  BA43 18 18 18 00
 58+  BA47 63 63 63 63  	defb	  99, 99, 99, 99, 99, 99, 62, 0 ; U
 58+  BA4B 63 63 3E 00
 59+  BA4F 63 63 63 77  	defb	  99, 99, 99,119, 62, 28,  8, 0 ; V
 59+  BA53 3E 1C 08 00
 60+  BA57 63 63 6B 7F  	defb	  99, 99,107,127,127, 54, 34, 0 ; W
 60+  BA5B 7F 36 22 00
 61+  BA5F 63 77 3E 1C  	defb	  99,119, 62, 28, 62,119, 99, 0 ; X
 61+  BA63 3E 77 63 00
 62+  BA67 33 33 12 1E  	defb	  51, 51, 18, 30, 12, 12, 12, 0 ; Y
 62+  BA6B 0C 0C 0C 00
 63+  BA6F 7F 07 0E 1C  	defb	  127,  7, 14, 28, 56,112,127,0 ; Z
 63+  BA73 38 70 7F 00
 64+  BA77 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; [
 64+  BA7B 00 00 00 00
 65+  BA7F 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; \
 65+  BA83 00 00 00 00
 66+  BA87 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ]
 66+  BA8B 00 00 00 00
 67+  BA8F 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ^
 67+  BA93 00 00 00 00
 68+  BA97 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; _
 68+  BA9B 00 00 00 00
 69+  BA9F              	; end 3
 70+  BA9F 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; 
 70+  BAA3 00 00 00 00
 71+  BAA7 1C 36 63 63  	defb	  28, 54, 99, 99,127, 99, 99, 0 ; A
 71+  BAAB 7F 63 63 00
 72+  BAAF 7E 63 63 7E  	defb	  126, 99, 99,126, 99, 99,126,0 ; B
 72+  BAB3 63 63 7E 00
 73+  BAB7 1E 33 60 60  	defb	  30, 51, 96, 96, 96, 51, 30, 0 ; C
 73+  BABB 60 33 1E 00
 74+  BABF 7C 66 63 63  	defb	  124,102, 99, 99, 99,102,124,0 ; D
 74+  BAC3 63 66 7C 00
 75+  BAC7 7F 60 60 7E  	defb	  127, 96, 96,126, 96, 96,127,0 ; E
 75+  BACB 60 60 7F 00
 76+  BACF 7F 60 60 7E  	defb	  127, 96, 96,126, 96, 96, 96,0 ; F
 76+  BAD3 60 60 60 00
 77+  BAD7 1F 30 60 67  	defb	  31, 48, 96,103, 99, 51, 31, 0 ; G
 77+  BADB 63 33 1F 00
 78+  BADF 63 63 63 7F  	defb	  99, 99, 99,127, 99, 99, 99, 0 ; H
 78+  BAE3 63 63 63 00
 79+  BAE7 3F 0C 0C 0C  	defb	  63, 12, 12, 12, 12, 12, 63, 0 ; I
 79+  BAEB 0C 0C 3F 00
 80+  BAEF 03 03 03 03  	defb	  3,  3,  3,  3,  3, 99, 62,  0 ; J
 80+  BAF3 03 63 3E 00
 81+  BAF7 63 66 6C 78  	defb	  99,102,108,120,124,110,103, 0 ; K
 81+  BAFB 7C 6E 67 00
 82+  BAFF 30 30 30 30  	defb	  48, 48, 48, 48, 48, 48, 63, 0 ; L
 82+  BB03 30 30 3F 00
 83+  BB07 63 77 7F 7F  	defb	  99,119,127,127,107, 99, 99, 0 ; M
 83+  BB0B 6B 63 63 00
 84+  BB0F 63 73 7B 7F  	defb	  99,115,123,127,111,103, 99, 0 ; N
 84+  BB13 6F 67 63 00
 85+  BB17 3E 63 63 63  	defb	  62, 99, 99, 99, 99, 99, 62, 0 ; O
 85+  BB1B 63 63 3E 00
 86+  BB1F 7E 61 61 61  	defb	  126, 97, 97, 97,126, 96, 96,0 ; P
 86+  BB23 7E 60 60 00
 87+  BB27 3E 63 63 63  	defb	  62, 99, 99, 99,111,102, 61, 0 ; Q
 87+  BB2B 6F 66 3D 00
 88+  BB2F 7E 63 63 67  	defb	  126, 99, 99,103,124,110,103,0 ; R
 88+  BB33 7C 6E 67 00
 89+  BB37 3C 66 60 3E  	defb	  60,102, 96, 62,  3, 99, 62, 0 ; S
 89+  BB3B 03 63 3E 00
 90+  BB3F 7E 18 18 18  	defb	  126, 24, 24, 24, 24, 24, 24,0 ; T
 90+  BB43 18 18 18 00
 91+  BB47 63 63 63 63  	defb	  99, 99, 99, 99, 99, 99, 62, 0 ; U
 91+  BB4B 63 63 3E 00
 92+  BB4F 63 63 63 77  	defb	  99, 99, 99,119, 62, 28,  8, 0 ; V
 92+  BB53 3E 1C 08 00
 93+  BB57 63 63 6B 7F  	defb	  99, 99,107,127,127, 54, 34, 0 ; W
 93+  BB5B 7F 36 22 00
 94+  BB5F 63 77 3E 1C  	defb	  99,119, 62, 28, 62,119, 99, 0 ; X
 94+  BB63 3E 77 63 00
 95+  BB67 33 33 12 1E  	defb	  51, 51, 18, 30, 12, 12, 12, 0 ; Y
 95+  BB6B 0C 0C 0C 00
 96+  BB6F 7F 07 0E 1C  	defb	  127,  7, 14, 28, 56,112,127,0 ; Z
 96+  BB73 38 70 7F 00
 97+  BB77 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0
 97+  BB7B 00 00 00 00
 98+  BB7F 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0
 98+  BB83 00 00 00 00
 99+  BB87 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0
 99+  BB8B 00 00 00 00
100+  BB8F 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0
100+  BB93 00 00 00 00
101+  BB97 3C 42 99 A1  	defb	  60, 66,153,161,161,153, 66, 60 ; 	
101+  BB9B A1 99 42 3C
# file closed: graphics/font.asm
148   BB9F                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  BB9F              ; Tiles graphics.
  2+  BB9F              sprites:
  3+  BB9F 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  BBA3 00 00 00 00
  4+  BBA7 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  BBAB FF FF FF FF
  5+  BBAF 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  BBB3 1F 3F 7F FF
  6+  BBB7 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  BBBB F8 FC FE FF
  7+  BBBF 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  BBC3 55 AA 55 AA
  8+  BBC7 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 5, sky block
  8+  BBCB 00 00 00 00
  9+  BBCF 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 6, slime block
  9+  BBD3 00 00 00 00
 10+  BBD7 00 00 00 00      defb    0  ,0  ,  0,  0,  0,  0,  0,  0   ; 7, for reuse
 10+  BBDB 00 00 00 00
 11+  BBDF 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52,  24    ; 8, diamond
 11+  BBE3 F1 72 34 18
 12+  BBE7 3C 7E FF 7F      defb    60,126,255,127,254,254,255,126    ; 9, rock
 12+  BBEB FE FE FF 7E
 13+  BBEF 7E FF 7F 7F  	defb	126,255,127,127,254,255,126, 60    ; 10, rock 2
 13+  BBF3 FE FF 7E 3C
 14+  BBF7 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,255,255   ; 11, sky block, pixel trapdoor
 14+  BBFB 00 00 FF FF
 15+  BBFF 99 DB 7E 24  	defb    153,219,126, 36,255, 66, 36, 24   ; 12, missile
 15+  BC03 FF 42 24 18
 16+  BC07 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 13, sky block, tank background
 16+  BC0B 00 00 00 00
 17+  BC0F 00 00 00 00  	defb    0,  0,  0,  0,  0, 60, 90, 52     ; 14, gem
 17+  BC13 00 3C 5A 34
 18+  BC17 FD FE FD FE  	defb	253,254,253,254,253,254,253,254   ; 15, damaged mountain
 18+  BC1B FD FE FD FE
 19+  BC1F F4 F8 F4 F8  	defb	244,248,244,248,244,248,244,248   ; 16, damaged mountain 2
 19+  BC23 F4 F8 F4 F8
 20+  BC27 D0 E0 D0 E0  	defb	208,224,208,224,208,224,208,224   ; 17, damaged mountain 3
 20+  BC2B D0 E0 D0 E0
 21+  BC2F 40 80 40 80  	defb	 64,128, 64,128, 64,128, 64,128   ; 18, damaged mountain 4
 21+  BC33 40 80 40 80
 22+  BC37 00 00 00 ED  	defb	0,  0,  0,237,237,  0,  0,  0	  ; 19, tank missile
 22+  BC3B ED 00 00 00
 23+  BC3F 99 DB 7E 24  	defb    153,219,126, 36,255,126, 60, 24   ; 20, missile active
 23+  BC43 FF 7E 3C 18
 24+  BC47 FF FF 00 00      defb	255,255,  0,  0,  0,  0,  0,  0	  ; 21, the pit 1
 24+  BC4B 00 00 00 00
 25+  BC4F FC FC 00 00  	defb	252,252,  0,  0,  0,  0,  0,  0	  ; 22, the pit 2
 25+  BC53 00 00 00 00
 26+  BC57 F0 F0 00 00  	defb	240,240,  0,  0,  0,  0,  0,  0	  ; 23, the pit 3
 26+  BC5B 00 00 00 00
 27+  BC5F C0 C0 00 00  	defb	192,192,  0,  0,  0,  0,  0,  0	  ; 24, the pit 4
 27+  BC63 00 00 00 00
 28+  BC67 00 00 00 00  	defb	0,0,  0,  0,  0,  0,  0,  0	  	  ; 25, the pit 5
 28+  BC6B 00 00 00 00
 29+  BC6F FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 26, slime block, green on green
 29+  BC73 FF FF FF FF
 30+  BC77 00 00 00 66  	defb    0,  0,  0,102,  0,  0,  0,  0     ; 27, bullet
 30+  BC7B 00 00 00 00
 31+  BC7F
 32+  BC7F
 33+  BC7F              sprite_attrs:
 34+  BC7F 46               defb    070 ; 0, space
 35+  BC80 4D               defb    077 ; 1, cyan block
 36+  BC81 4D               defb    077 ; 2, slope left
 37+  BC82 4D               defb    077 ; 3, slope right
 38+  BC83 46               defb    070 ; 4, dirt
 39+  BC84 4E               defb    078 ; 5, sky
 40+  BC85 66               defb    102 ; 6, slime
 41+  BC86 42               defb    066 ; 7, trapdoor
 42+  BC87 46               defb    070 ; 8, diamond
 43+  BC88 42               defb    066 ; 9, rock
 44+  BC89 42               defb    066 ; 10, rock 2
 45+  BC8A 49           	defb    073 ; 11, sky, trapdoor
 46+  BC8B 43           	defb    067 ; 12, missile
 47+  BC8C 4A               defb    074 ; 13, sky, red ink (tank)
 48+  BC8D 46               defb    070 ; 14, gem
 49+  BC8E 4D               defb    077 ; 15, damaged mountain
 50+  BC8F 4D               defb    077 ; 16, damaged mountain 2
 51+  BC90 4D               defb    077 ; 17, damaged mountain 3
 52+  BC91 4D               defb    077 ; 18, damaged mountain 4
 53+  BC92 00           	defb 	000 ; 19, tank missile (not used
 54+  BC93 43           	defb    067 ; 20, missile active
 55+  BC94 42           	defb	066	; 21, the pit 1
 56+  BC95 42           	defb	066	; 22, the pit 2
 57+  BC96 42           	defb	066	; 23, the pit 3
 58+  BC97 42           	defb	066	; 24, the pit 4
 59+  BC98 42           	defb	066	; 25, the pit 5
 60+  BC99 64           	defb    100 ; 26, slime, green on green
 61+  BC9A 46           	defb 	070 ; 27, bullet
 62+  BC9B
 63+  BC9B
 64+  BC9B              player_sprite:
 65+  BC9B 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 0 up/down 1
 65+  BC9F 38 3D C3 80
 66+  BCA3 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 1 left 1
 66+  BCA7 3C 1C 16 32
 67+  BCAB 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 2 right 1
 67+  BCAF 3C 38 68 4C
 68+  BCB3 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 3 up/down 2
 68+  BCB7 1C BC C3 01
 69+  BCBB 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 60,100, 12; 4 left 2
 69+  BCBF 3C 3C 64 0C
 70+  BCC3 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 60, 38, 48 ; 5 right 2
 70+  BCC7 3C 3C 26 30
 71+  BCCB 54 28 10 12  	defb	 84, 40, 16, 18, 30, 92,253, 95 ; 6 shoot up
 71+  BCCF 1E 5C FD 5F
 72+  BCD3 02 87 42 BF  	defb	 2,135, 66,191, 79,143, 25,  3  ; 7 shoot left
 72+  BCD7 4F 8F 19 03
 73+  BCDB 40 E1 42 FD  	defb	 64,225, 66,253,242,241,152,192 ; 8 shoot right
 73+  BCDF F2 F1 98 C0
 74+  BCE3 FA BF 3A 78  	defb	 250,191, 58,120, 72,  8, 20, 42 ; 9 shoot down
 74+  BCE7 48 08 14 2A
 75+  BCEB 92 BA 94 78  	defb 	 146,186,148,120, 56,120, 68,195 ; 10 crushed 1
 75+  BCEF 38 78 44 C3
 76+  BCF3 49 5D 29 1E  	defb	  73, 93, 41, 30, 28, 30, 34,195 ; 11 crushed 2
 76+  BCF7 1C 1E 22 C3
 77+  BCFB 72 57 72 67  	defb	114, 87,114,103,111, 69,225,155  ; 12 fight 1
 77+  BCFF 6F 45 E1 9B
 78+  BD03 4E EA 4E E6  	defb	 78,234, 78,230,246,162,135,217  ; 13 fight 2
 78+  BD07 F6 A2 87 D9
 79+  BD0B
 80+  BD0B              ;
 81+  BD0B              ; First 4 top half, next 4 bottom 1, next 4 bottom 2
 82+  BD0B              ;
 83+  BD0B              ship_sprite:
 84+  BD0B 00 00 00 01  	defb	  0,  0,  0,  1,  3, 31,127,255
 84+  BD0F 03 1F 7F FF
 85+  BD13 1F 01 7F FF  	defb	 31,  1,127,255,255,255,255,255
 85+  BD17 FF FF FF FF
 86+  BD1B F8 80 FE FF  	defb	248,128,254,255,255,255,255,255
 86+  BD1F FF FF FF FF
 87+  BD23 00 00 00 80  	defb	  0,  0,  0,128,192,248,254,255
 87+  BD27 C0 F8 FE FF
 88+  BD2B B3 B3 7F 1F  	defb	179,179,127, 31,  3,  3,  2,  7
 88+  BD2F 03 03 02 07
 89+  BD33 8F 8F FF FF  	defb	143,143,255,255,255, 15,  7,131
 89+  BD37 FF 0F 07 83
 90+  BD3B 0F 0F FF FF  	defb	 15, 15,255,255,255, 16, 32,193
 90+  BD3F FF 10 20 C1
 91+  BD43 19 19 FE F8  	defb	 25, 25,254,248,192,192, 64,224
 91+  BD47 C0 C0 40 E0
 92+  BD4B 98 98 7F 1F  	defb	152,152,127, 31,  3,  3,  2,  7
 92+  BD4F 03 03 02 07
 93+  BD53 F0 F0 FF FF  	defb	240,240,255,255,255,  8,  4,131
 93+  BD57 FF 08 04 83
 94+  BD5B F1 F1 FF FF  	defb	241,241,255,255,255,240,224,193
 94+  BD5F FF F0 E0 C1
 95+  BD63 CD CD FE F8  	defb	205,205,254,248,192,192, 64,224
 95+  BD67 C0 C0 40 E0
 96+  BD6B
 97+  BD6B              ;
 98+  BD6B              ;  First 8 frames are tank, last frame is the gun barrel
 99+  BD6B              ;
100+  BD6B              tank_sprite:
101+  BD6B 00 00 00 7F  	defb	  0,  0,  0,127,127,  0,  0,  0
101+  BD6F 7F 00 00 00
102+  BD73 01 03 FE FC  	defb	  1,  3,254,252,254,255,127, 64
102+  BD77 FE FF 7F 40
103+  BD7B FF FF 03 F9  	defb	255,255,  3,249,  3,255,255,  1
103+  BD7F 03 FF FF 01
104+  BD83 00 00 C0 E0  	defb	  0,  0,192,224,224,192,  0,  0
104+  BD87 E0 C0 00 00
105+  BD8B 3F 7F E1 FB  	defb	 63,127,225,251,247,225,127, 63
105+  BD8F F7 E1 7F 3F
106+  BD93 FF FF 16 52  	defb	255,255, 22, 82, 84, 22,255,255
106+  BD97 54 16 FF FF
107+  BD9B FF FF A8 A9  	defb	255,255,168,169,155,168,255,255
107+  BD9F 9B A8 FF FF
108+  BDA3 FC FE 8F AF  	defb	252,254,143,175,159,175,254,252
108+  BDA7 9F AF FE FC
109+  BDAB 00 00 00 1F  	defb	  0,  0,  0, 31, 31,  0,  0,  0 ; +64
109+  BDAF 1F 00 00 00
110+  BDB3
111+  BDB3              monster_sprite:
112+  BDB3 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
112+  BDB7 0B D0 16 68
113+  BDBB 19 98 17 E8  	defb	 25,152, 23,232, 53,172,127,254
113+  BDBF 35 AC 7F FE
114+  BDC3 FE 7F EC 37  	defb	254,127,236, 55,143,241,143,241
114+  BDC7 8F F1 8F F1
115+  BDCB 08 10 08 10  	defb	  8, 16,  8, 16, 24, 24,  0,  0		; frame 1
115+  BDCF 18 18 00 00
116+  BDD3 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
116+  BDD7 0B D0 16 68
117+  BDDB 19 98 17 E8  	defb	 25,152, 23,232,245,175,255,255
117+  BDDF F5 AF FF FF
118+  BDE3 BC 3D 0E 70  	defb	188, 61, 14,112, 15,240, 15,240
118+  BDE7 0F F0 0F F0
119+  BDEB 10 08 30 0C  	defb	 16,  8, 48, 12,  0,  0,  0,  0		; frame 2
119+  BDEF 00 00 00 00
120+  BDF3
121+  BDF3              robot_sprite:
122+  BDF3 0E 0A CE 3E  	defb	 14, 10,206, 62,206, 18, 34,102		; left 1
122+  BDF7 CE 12 22 66
123+  BDFB 0E 0A 4E FE  	defb	 14, 10, 78,254, 78, 18, 36,108		; 2
123+  BDFF 4E 12 24 6C
124+  BE03 0E 0A 4E FE  	defb	 14, 10, 78,254, 78, 50, 99,  3		; 3
124+  BE07 4E 32 63 03
125+  BE0B 0E 0A CE 3E  	defb	 14, 10,206, 62,206, 10,  9, 27		; 4
125+  BE0F CE 0A 09 1B
126+  BE13 70 50 73 7C  	defb	112, 80,115,124,115, 72, 68,102		; right 1
126+  BE17 73 48 44 66
127+  BE1B 70 50 72 7F  	defb	112, 80,114,127,114, 72, 36, 54		; 2
127+  BE1F 72 48 24 36
128+  BE23 70 50 72 7F  	defb	112, 80,114,127,114, 76,198,192		; 3
128+  BE27 72 4C C6 C0
129+  BE2B 70 50 73 7C  	defb	112, 80,115,124,115, 80,144,216		; 4
129+  BE2F 73 50 90 D8
130+  BE33 38 A9 BA 7C  	defb     56,169,186,124, 56, 42, 38, 96     ; dead 1
130+  BE37 38 2A 26 60
131+  BE3B 1C 95 5D 3E  	defb	 28,149, 93, 62, 28, 84,100,  6		; dead 2
131+  BE3F 1C 54 64 06
132+  BE43
# file closed: graphics/graphics.asm
149   BE43
150   BE43                  include "game\control.asm"
# file opened: game/control.asm
  1+  BE43              ;
  2+  BE43              ; Check the preferred input method then move
  3+  BE43              ;
  4+  BE43              control_input:
  5+  BE43 3A 93 C3         ld a,(player+11)    ; first, check if player is dying
  6+  BE46 FE 04            cp 4                ; is the player falling
  7+  BE48 CC 12 BF         call z, control_fall
  8+  BE4B FE 05            cp 5                ; is the player fighting
  9+  BE4D CC FF BE         call z, control_fight
 10+  BE50 3A 93 C3         ld a,(player+11)    ; first, check if player is dying
 11+  BE53 FE 00            cp 0
 12+  BE55 C0               ret nz               ; if so, can't move
 13+  BE56 3A 8D C3         ld a,(player+5)      ; next, check if the player has pixels left to move
 14+  BE59 FE 00            cp 0
 15+  BE5B CA 62 BE         jp z, control_input0
 16+  BE5E CD F0 BF         call control_automove
 17+  BE61 C9               ret
 18+  BE62              control_input0:
 19+  BE62 3A 8E C3         ld a,(player+6)      ; next, check if the player is digging
 20+  BE65 FE 00            cp 0
 21+  BE67 CA 6E BE         jp z, control_input1
 22+  BE6A CD 2E BF         call control_dig
 23+  BE6D C9               ret
 24+  BE6E              control_input1:
 25+  BE6E 3A 4B C3         ld a,(game_control)
 26+  BE71 FE 00            cp 0                ; is this keyboard
 27+  BE73 C2 7A BE         jp nz,control_input2
 28+  BE76 CD 7E BE         call control_keyboard
 29+  BE79 C9               ret
 30+  BE7A              control_input2:
 31+  BE7A                  ; do joystick
 32+  BE7A CD C4 BE         call control_joystick
 33+  BE7D C9               ret
 34+  BE7E
 35+  BE7E              ;
 36+  BE7E              ; Check the keyboard
 37+  BE7E              ;
 38+  BE7E              control_keyboard:
 39+  BE7E 01 FE FB         ld bc,64510         ; port for keyboard row q-t.
 40+  BE81 ED 78            in a,(c)            ; read keyboard.
 41+  BE83 47               ld b,a              ; store result in b register.
 42+  BE84 CB 18            rr b                ; check outermost key (q).
 43+  BE86 D2 B0 BE         jp nc,control_keyboard1
 44+  BE89 01 FE FD         ld bc,65022         ; port for keyboard row a-f.
 45+  BE8C ED 78            in a,(c)            ; read keyboard.
 46+  BE8E 47               ld b,a              ; store result in b register.
 47+  BE8F CB 18            rr b                ; check outermost key (a).
 48+  BE91 D2 B4 BE         jp nc,control_keyboard2
 49+  BE94 01 FE DF         ld bc,57342         ; port for keyboard row y-p.
 50+  BE97 ED 78            in a,(c)            ; read keyboard.
 51+  BE99 47               ld b,a              ; store result in b register.
 52+  BE9A CB 18            rr b                ; check outermost key (p).
 53+  BE9C D2 B8 BE         jp nc,control_keyboard3
 54+  BE9F CB 18            rr b                ; check next key.
 55+  BEA1 D2 BC BE         jp nc,control_keyboard4
 56+  BEA4 01 FE 7F         ld bc,32766         ; port for keyboard row b-space.
 57+  BEA7 ED 78            in a,(c)            ; read keyboard.
 58+  BEA9 47               ld b,a              ; store result in b register.
 59+  BEAA CB 18            rr b                ; check outermost key (space).
 60+  BEAC D2 C0 BE         jp nc,control_keyboard5
 61+  BEAF C9               ret
 62+  BEB0              control_keyboard1:
 63+  BEB0 CD 39 C0         call control_pl_moveup         ; player up.
 64+  BEB3 C9               ret
 65+  BEB4              control_keyboard2:
 66+  BEB4 CD 66 C0         call control_pl_movedown       ; player down.
 67+  BEB7 C9               ret
 68+  BEB8              control_keyboard3:
 69+  BEB8 CD C2 C0         call control_pl_moveright       ; player left.
 70+  BEBB C9               ret
 71+  BEBC              control_keyboard4:
 72+  BEBC CD 92 C0         call control_pl_moveleft       ; player right.
 73+  BEBF C9               ret
 74+  BEC0              control_keyboard5:
 75+  BEC0 CD F0 C0         call control_pl_fire       ; player fire.
 76+  BEC3 C9               ret
 77+  BEC4
 78+  BEC4              ;
 79+  BEC4              ; Check the joystick
 80+  BEC4              ;
 81+  BEC4              control_joystick:
 82+  BEC4 01 1F 00         ld bc,31                        ; Kempston joystick port.
 83+  BEC7 ED 78            in a,(c)                        ; read input.
 84+  BEC9 E6 02            and 2                           ; check "left" bit.
 85+  BECB C2 F3 BE         jp nz,control_joystick3       ; move left.
 86+  BECE ED 78            in a,(c)                        ; read input.
 87+  BED0 E6 01            and 1                           ; test "right" bit.
 88+  BED2 C2 F7 BE         jp nz,control_joystick4       ; move right.
 89+  BED5 ED 78            in a,(c)                        ; read input.
 90+  BED7 E6 08            and 8                           ; check "up" bit.
 91+  BED9 C2 EB BE         jp nz,control_joystick1       ; move up.
 92+  BEDC ED 78            in a,(c)                        ; read input.
 93+  BEDE E6 04            and 4                           ; check "down" bit.
 94+  BEE0 C2 EF BE         jp nz,control_joystick2       ; move down.
 95+  BEE3 ED 78            in a,(c)                        ; read input.
 96+  BEE5 E6 10            and 16                          ; try the fire bit.
 97+  BEE7 C2 FB BE         jp nz,control_joystick5       ; fire pressed.
 98+  BEEA C9               ret
 99+  BEEB              control_joystick1:
100+  BEEB CD 39 C0         call control_pl_moveup         ; player up.
101+  BEEE C9               ret
102+  BEEF              control_joystick2:
103+  BEEF CD 66 C0         call control_pl_movedown       ; player down.
104+  BEF2 C9               ret
105+  BEF3              control_joystick3:
106+  BEF3 CD 92 C0         call control_pl_moveleft       ; player left.
107+  BEF6 C9               ret
108+  BEF7              control_joystick4:
109+  BEF7 CD C2 C0         call control_pl_moveright       ; player right.
110+  BEFA C9               ret
111+  BEFB              control_joystick5:
112+  BEFB CD F0 C0         call control_pl_fire
113+  BEFE C9               ret
114+  BEFF
115+  BEFF              ;
116+  BEFF              ; Fights the player - just flips the players anim frame
117+  BEFF              ;
118+  BEFF              control_fight:
119+  BEFF 3A 8B C3         ld a,(player+3)             ; load the frame
120+  BF02 FE 0C            cp 12                       ; flip between 12 and 13
121+  BF04 CA 0C BF         jp z,control_fight0
122+  BF07 3E 0C            ld a,12
123+  BF09 C3 0E BF         jp control_fight1
124+  BF0C              control_fight0:
125+  BF0C 3E 0D            ld a,13
126+  BF0E              control_fight1:
127+  BF0E 32 8B C3         ld (player+3),a           ; save back
128+  BF11 C9               ret
129+  BF12
130+  BF12              ;
131+  BF12              ; Falls the player
132+  BF12              ;
133+  BF12              control_fall:
134+  BF12 ED 4B 88 C3      ld bc,(player)              ; get coords
135+  BF16 0C               inc c
136+  BF17 ED 43 88 C3      ld (player),bc
137+  BF1B 3A 8B C3         ld a,(player+3)             ; load the frame
138+  BF1E FE 03            cp 3                       ; flip between 3 and 0
139+  BF20 C2 28 BF         jp nz, control_fall0
140+  BF23 3E 00            ld a,0
141+  BF25 C3 2A BF         jp control_fall1
142+  BF28              control_fall0:
143+  BF28 3E 03            ld a,3
144+  BF2A              control_fall1:
145+  BF2A 32 8B C3         ld (player+3),a           ; save back
146+  BF2D C9               ret
147+  BF2E
148+  BF2E              ;
149+  BF2E              ; Performs a dig if the counter has reset, otherwise, messes with the graphics
150+  BF2E              ;
151+  BF2E              control_dig:
152+  BF2E ED 4B 88 C3      ld bc,(player)      ; load the current coords into bc
153+  BF32 C5               push bc
154+  BF33 3A 8A C3         ld a,(player+2)     ; get the direction
155+  BF36 FE 01            cp 1                ; left
156+  BF38 CA 50 BF         jp z,control_dig0
157+  BF3B FE 02            cp 2                ; right
158+  BF3D CA 65 BF         jp z,control_dig1
159+  BF40 FE 03            cp 3                ; down
160+  BF42 CA 89 BF         jp z,control_dig5
161+  BF45 FE 00            cp 0                ; up
162+  BF47 CA 79 BF         jp z,control_dig4
163+  BF4A 21 8E C3         ld hl,player+6
164+  BF4D 36 00            ld (hl),0           ; turn off digging
165+  BF4F C9               ret                 ; return
166+  BF50              control_dig0:           ; going left
167+  BF50 CD FE AB         call sprites_scadd  ; get the current coord
168+  BF53 62 6B            ld hl,de
169+  BF55 2B               dec hl              ; move one left
170+  BF56 C1               pop bc              ; get the coords back, subtract 8 from horiz, 8 from vert, store (will be coords of space above dug dirt)
171+  BF57 78               ld a,b
172+  BF58 06 08            ld b,8
173+  BF5A 90               sub b
174+  BF5B 47               ld b,a
175+  BF5C 79               ld a,c
176+  BF5D 0E 08            ld c,8
177+  BF5F 91               sub c
178+  BF60 4F               ld c,a
179+  BF61 C5               push bc
180+  BF62 C3 92 BF         jp control_dig2
181+  BF65              control_dig1:
182+  BF65 CD FE AB         call sprites_scadd  ; get the current coord
183+  BF68 62 6B            ld hl,de
184+  BF6A 23               inc hl              ; move one right
185+  BF6B C1               pop bc              ; get the coords back, add 8 to horiz, subtract 8 from vert store (will be coords of space above dug dirt)
186+  BF6C 3E 08            ld a,8
187+  BF6E 80               add a,b
188+  BF6F 47               ld b,a
189+  BF70 79               ld a,c
190+  BF71 0E 08            ld c,8
191+  BF73 91               sub c
192+  BF74 4F               ld c,a
193+  BF75 C5               push bc
194+  BF76 C3 92 BF         jp control_dig2
195+  BF79              control_dig4:
196+  BF79 CD FE AB         call sprites_scadd  ; get the current coord
197+  BF7C 62 6B            ld hl,de
198+  BF7E 11 20 00         ld de,32
199+  BF81 ED 52            sbc hl,de             ; move one up
200+  BF83 C1               pop bc              ; get the coords back, 1 from vert, store, then we'll sub 1 from c for each row later
201+  BF84 0D               dec c
202+  BF85 C5               push bc
203+  BF86 C3 AA BF         jp control_dig6
204+  BF89              control_dig5:
205+  BF89 CD FE AB         call sprites_scadd  ; get the current coord
206+  BF8C 62 6B            ld hl,de
207+  BF8E 24               inc h              ; move one down
208+  BF8F                                     ; not bothered about working out bc here, since rock will never fall if digging down
209+  BF8F C3 92 BF         jp control_dig2
210+  BF92              ; Normal (not up) digging
211+  BF92              control_dig2:
212+  BF92 3A 90 C3         ld a,(player+8)     ; get the number of rows we need to overwrite
213+  BF95 47               ld b,a              ; rows to copy over
214+  BF96 E5               push hl             ; store the memory location of the first row for later
215+  BF97              control_dig3:
216+  BF97 CD D9 BF         call control_getpixelrow
217+  BF9A 77               ld (hl),a           ; load contents into row
218+  BF9B 11 20 00         ld de,32
219+  BF9E 19               add hl,de           ; move to next row
220+  BF9F 10 F6            djnz control_dig3
221+  BFA1 E1               pop hl              ; get the original memory location back
222+  BFA2 11 20 00         ld de,32
223+  BFA5 ED 52            sbc hl,de           ; move to above row, ready for checking for rock
224+  BFA7 C3 C0 BF         jp control_dig10
225+  BFAA              ; Special case for going up
226+  BFAA              control_dig6:
227+  BFAA 3A 90 C3         ld a,(player+8)     ; get the number of rows we need to overwrite
228+  BFAD 47               ld b,a              ; rows to copy over
229+  BFAE              control_dig7:
230+  BFAE CD D9 BF         call control_getpixelrow
231+  BFB1              control_dig12:
232+  BFB1 77               ld (hl),a           ; load empty into row
233+  BFB2 11 20 00         ld de,32
234+  BFB5 ED 52            sbc hl,de           ; move up to next row
235+  BFB7 0D               dec c               ; decrease c to track rows
236+  BFB8 10 F4            djnz control_dig7
237+  BFBA 79               ld a,c
238+  BFBB D6 07            sub 7
239+  BFBD C1               pop bc
240+  BFBE 4F               ld c,a
241+  BFBF C5               push bc             ; store the decreased c coord
242+  BFC0              control_dig10:
243+  BFC0 DD 21 8F C3      ld ix,player+7
244+  BFC4 DD 7E 00         ld a,(ix)     ; get the dig frame number
245+  BFC7 3D               dec a
246+  BFC8 DD 77 00         ld (ix),a
247+  BFCB                  ; call the check for rocks above the removed dirt
248+  BFCB DD 21 8E C3      ld ix,player+6
249+  BFCF DD 7E 00         ld a,(ix)     ; get the dig state
250+  BFD2 FE 00            cp 0
251+  BFD4 C1               pop bc
252+  BFD5 CC 09 C9         call z, rocks_checkforfalling ; make the check if we're no longer digging
253+  BFD8 C9               ret
254+  BFD9
255+  BFD9              ;
256+  BFD9              ; Gets a modified pixel row to overwrite dirt - if this is the last dig, overwrite with nothing, otherwise xor to flip the dirt
257+  BFD9              ; Inputs:
258+  BFD9              ; hl - memory of pixel row
259+  BFD9              ; Outputs:
260+  BFD9              ; a - modified row to write
261+  BFD9              ;
262+  BFD9              control_getpixelrow:
263+  BFD9 3A 8F C3         ld a,(player+7)     ; get the dig frame number
264+  BFDC FE 00            cp 0                ; is this the last dig
265+  BFDE CA E5 BF         jp z,control_getpixelrow1
266+  BFE1 7E               ld a,(hl)           ; if not, xor with 255 to flip it
267+  BFE2 EE FF            xor 255
268+  BFE4 C9               ret
269+  BFE5              control_getpixelrow1:
270+  BFE5 DD 21 8E C3      ld ix,player+6
271+  BFE9 DD 36 00 00      ld (ix),0           ; turn off digging
272+  BFED 3E 00            ld a,0              ; if it is, load with empty
273+  BFEF C9               ret
274+  BFF0
275+  BFF0              ;
276+  BFF0              ; Auto move the player until pixels is zero
277+  BFF0              ;
278+  BFF0              control_automove:
279+  BFF0 5F               ld e,a              ; store the number of pixels left to move in e
280+  BFF1 ED 4B 88 C3      ld bc,(player)      ; load the current coords into bc
281+  BFF5 21 8A C3         ld hl,player+2      ; get the direction
282+  BFF8 7E               ld a,(hl)
283+  BFF9 FE 03            cp 3                ; down
284+  BFFB CA 0F C0         jp z,control_automove3  ; don't need to do anything
285+  BFFE FE 00            cp 0                ; going up
286+  C000 CA 1B C0         jp z,control_automove2
287+  C003 FE 01            cp 1                ; going left?
288+  C005 CA 27 C0         jp z,control_automove0
289+  C008 78               ld a,b
290+  C009 3C               inc a               ; if we're going right, increment a twice for two pixels
291+  C00A 3C               inc a
292+  C00B 47               ld b,a
293+  C00C C3 2B C0         jp control_automove1
294+  C00F              control_automove3:
295+  C00F 79               ld a,c
296+  C010 3C               inc a
297+  C011 3C               inc a               ; if we're going down, increment twice
298+  C012 4F               ld c,a
299+  C013 FE 90            cp 144
300+  C015 CC 06 C1         call z, control_scroll_down
301+  C018 C3 2B C0         jp control_automove1
302+  C01B              control_automove2:
303+  C01B 79               ld a,c
304+  C01C 3D               dec a
305+  C01D 3D               dec a               ; if we're going up, decrement twice
306+  C01E 4F               ld c,a
307+  C01F FE 60            cp 96
308+  C021 CC 13 C1         call z, control_scroll_up
309+  C024 C3 2B C0         jp control_automove1
310+  C027              control_automove0:
311+  C027 78               ld a,b
312+  C028 3D               dec a               ; if we're going left, decrement a twice
313+  C029 3D               dec a
314+  C02A 47               ld b,a
315+  C02B              control_automove1:
316+  C02B ED 43 88 C3      ld (player),bc      ; and back to player
317+  C02F 7B               ld a,e              ; now get the pixel count back
318+  C030 3D               dec a               ; decrease by one
319+  C031 21 8D C3         ld hl,player+5
320+  C034 77               ld (hl),a           ; copy back
321+  C035 CD 93 C5         call player_justmoved
322+  C038 C9               ret
323+  C039
324+  C039              ;
325+  C039              ; Moves the player up
326+  C039              ;
327+  C039              control_pl_moveup:
328+  C039 C5               push bc
329+  C03A ED 4B 88 C3      ld bc,(player)          ; get the current coords, b horiz, c vert
330+  C03E 79               ld a,c                  ; load c into the acc
331+  C03F FE 18            cp 24
332+  C041 CA 5F C0         jp z,control_pl_moveup0 ; are we at the edge of the screen
333+  C044 FE 60            cp 96
334+  C046 CC 13 C1         call z, control_scroll_up
335+  C049 CD BA C2         call movement_checkcanmove_up ; check we can move up, e will be 1 if we can
336+  C04C F5               push af
337+  C04D 7B               ld a,e                  ; put e in a
338+  C04E FE 00            cp 0
339+  C050 CA 5E C0         jp z,control_pl_moveup1 ; don't move if we can't
340+  C053 F1               pop af
341+  C054 D6 01            sub 1                   ; subtract 1
342+  C056                  ;sub 1                   ; subtract 1
343+  C056 4F               ld c,a                  ; load back to c
344+  C057 ED 43 88 C3      ld (player),bc          ; load back to player
345+  C05B C3 5F C0         jp control_pl_moveup0
346+  C05E              control_pl_moveup1:
347+  C05E F1               pop af                  ; restore af if needed
348+  C05F              control_pl_moveup0:
349+  C05F 3E 00            ld a,0
350+  C061 32 8A C3         ld (player+2),a        ; set direction to up
351+  C064 C1               pop bc
352+  C065 C9               ret
353+  C066              ;
354+  C066              ; Moves the player down
355+  C066              ;
356+  C066              control_pl_movedown:
357+  C066 C5               push bc
358+  C067 ED 4B 88 C3      ld bc,(player)          ; get the current coords, b horiz, c vert
359+  C06B 79               ld a,c                  ; load c into the acc
360+  C06C FE E0            cp 224
361+  C06E CA 8B C0         jp z,control_pl_movedown0 ; are we at the edge of the screen
362+  C071 FE 80            cp 128
363+  C073 CC 06 C1         call z, control_scroll_down
364+  C076 CD 8E C2         call movement_checkcanmove_down ; check we can move down, e will be 1 if we can
365+  C079 F5               push af
366+  C07A 7B               ld a,e                  ; put e in a
367+  C07B FE 00            cp 0
368+  C07D CA 8A C0         jp z,control_pl_movedown1 ; don't move if we can't
369+  C080 F1               pop af
370+  C081 3C               inc a                   ; add 1
371+  C082                  ;inc a                   ; add 1
372+  C082 4F               ld c,a                  ; load back to c
373+  C083 ED 43 88 C3      ld (player),bc          ; load back to player
374+  C087 C3 8B C0         jp control_pl_movedown0
375+  C08A              control_pl_movedown1:
376+  C08A F1               pop af                  ; restore af if needed
377+  C08B              control_pl_movedown0:
378+  C08B 3E 03            ld a,3
379+  C08D 32 8A C3         ld (player+2),a        ; set direction to down
380+  C090 C1               pop bc
381+  C091 C9               ret
382+  C092              ;
383+  C092              ; Moves the player left
384+  C092              ;
385+  C092              control_pl_moveleft:
386+  C092 C5               push bc
387+  C093 ED 4B 88 C3      ld bc,(player)          ; get the current coords, b horiz, c vert
388+  C097 78               ld a,b                  ; load b into the acc
389+  C098 FE 10            cp 16
390+  C09A CA BB C0         jp z,control_pl_moveleft0 ; are we at the edge of the screen
391+  C09D CD 19 C3         call movement_checkcanmove_left ; check we can move down, e will be 1 if we can
392+  C0A0 F5               push af
393+  C0A1 7B               ld a,e                  ; put e in a
394+  C0A2 FE 00            cp 0
395+  C0A4 CA BA C0         jp z,control_pl_moveleft1 ; don't move if we can't
396+  C0A7 21 8D C3         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
397+  C0AA 3E 03            ld a,3
398+  C0AC 77               ld (hl),a
399+  C0AD F1               pop af
400+  C0AE D6 01            sub 1                    ; subtract 2
401+  C0B0 D6 01            sub 1
402+  C0B2 47               ld b,a                  ; load back to c
403+  C0B3 ED 43 88 C3      ld (player),bc          ; load back to player
404+  C0B7 C3 BB C0         jp control_pl_moveleft0
405+  C0BA              control_pl_moveleft1:
406+  C0BA F1               pop af
407+  C0BB              control_pl_moveleft0:
408+  C0BB 3E 01            ld a,1
409+  C0BD 32 8A C3         ld (player+2),a        ; set direction to left
410+  C0C0 C1               pop bc
411+  C0C1 C9               ret
412+  C0C2              ;
413+  C0C2              ; Moves the player right
414+  C0C2              ;
415+  C0C2              control_pl_moveright:
416+  C0C2 C5               push bc
417+  C0C3 ED 4B 88 C3      ld bc,(player)          ; get the current coords, b horiz, c vert
418+  C0C7 78               ld a,b                  ; load b into the acc
419+  C0C8 FE F0            cp 240
420+  C0CA CA E9 C0         jp z,control_pl_moveright0 ; are we at the edge of the screen
421+  C0CD CD ED C2         call movement_checkcanmove_right ; check we can move down, e will be 1 if we can
422+  C0D0 F5               push af
423+  C0D1 7B               ld a,e                  ; put e in a
424+  C0D2 FE 00            cp 0
425+  C0D4 CA E8 C0         jp z,control_pl_moveright1 ; don't move if we can't
426+  C0D7 21 8D C3         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
427+  C0DA 3E 03            ld a,3
428+  C0DC 77               ld (hl),a
429+  C0DD F1               pop af
430+  C0DE 3C               inc a                   ; add 2
431+  C0DF 3C               inc a
432+  C0E0 47               ld b,a                  ; load back to b
433+  C0E1 ED 43 88 C3      ld (player),bc          ; load back to player
434+  C0E5 C3 E9 C0         jp control_pl_moveright0
435+  C0E8              control_pl_moveright1:
436+  C0E8 F1               pop af                  ; restore af if needed
437+  C0E9              control_pl_moveright0:
438+  C0E9 3E 02            ld a,2
439+  C0EB 32 8A C3         ld (player+2),a        ; set direction to right
440+  C0EE C1               pop bc
441+  C0EF C9               ret
442+  C0F0
443+  C0F0              ;
444+  C0F0              ; Player fires
445+  C0F0              ;
446+  C0F0              control_pl_fire:
447+  C0F0 3A 8A C3         ld a,(player+2)         ; get player direction
448+  C0F3 FE 00            cp 0
449+  C0F5 C8               ret z
450+  C0F6 FE 03            cp 3
451+  C0F8 C8               ret z                   ; if up or down, don't fire
452+  C0F9 3A A7 D3         ld a,(bullet_state+3)       ; get the state
453+  C0FC FE 01            cp 1
454+  C0FE C8               ret z                   ; if currently firing, don't fire
455+  C0FF CD A8 D3         call bullet_init        ; initialise the bullet
456+  C102 CD BD D3         call bullet_shoot       ; shoot the bullet
457+  C105 C9               ret
458+  C106
459+  C106              ;
460+  C106              ; Scrolls the screen down
461+  C106              ;
462+  C106              control_scroll_down:
463+  C106 F5               push af
464+  C107 3E 08            ld a,8
465+  C109 32 D7 A8         ld (screen_offset),a
466+  C10C F1               pop af
467+  C10D 21 24 A7         ld hl,buffer_updateall
468+  C110 36 01            ld (hl),1         ; flag as screen needing update
469+  C112 C9               ret
470+  C113
471+  C113              ;
472+  C113              ; Scrolls the screen up
473+  C113              ;
474+  C113              control_scroll_up:
475+  C113 F5               push af
476+  C114 3E 00            ld a,0
477+  C116 32 D7 A8         ld (screen_offset),a
478+  C119 F1               pop af
479+  C11A 21 24 A7         ld hl,buffer_updateall
480+  C11D 36 01            ld (hl),1         ; flag as screen needing update
481+  C11F C9               ret
482+  C120
483+  C120
484+  C120
485+  C120
# file closed: game/control.asm
151   C120                  include "game\movement.asm"
# file opened: game/movement.asm
  1+  C120              ;
  2+  C120              ; The number of frames to dig for
  3+  C120              ;
  4+  C120              movement_numberdigframes:
  5+  C120 0A               defb 10
  6+  C121
  7+  C121              ;
  8+  C121              ; Checks the contents of a cell are empty - ie, all pixel rows are zero
  9+  C121              ; Inputs:
 10+  C121              ; hl - memory location of top pixel row
 11+  C121              ; bc - screen coords, b horiz, c vert
 12+  C121              ; Outputs:
 13+  C121              ; e - 0 if not empty, 1 if empty
 14+  C121              ;
 15+  C121              movement_spaceisempty:
 16+  C121 C5               push bc
 17+  C122 E5               push hl
 18+  C123 CD 4B C1         call movement_spaceisgem        ; check if space is a gem
 19+  C126 E1               pop hl
 20+  C127 C1               pop bc
 21+  C128 7B               ld a,e
 22+  C129 FE 01            cp 1
 23+  C12B C8               ret z                           ; if e is 1, space is a gem so can move here, return
 24+  C12C 3E 08            ld a,8                          ; 8 rows to check
 25+  C12E              movement_spaceisempty0:
 26+  C12E 08               ex af,af'                       ; store the loop counter
 27+  C12F 7E               ld a,(hl)                       ; get current pixel row
 28+  C130 FE 00            cp 0
 29+  C132 C2 46 C1         jp nz, movement_spaceisempty1    ; row is not empty, can't move here
 30+  C135 79               ld a,c                          ; load the vertical coord
 31+  C136 3C               inc a                           ; next row down
 32+  C137 11 20 00         ld de,32
 33+  C13A 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 34+  C13B 4F               ld c,a                          ; copy vert coord back to c
 35+  C13C 08               ex af,af'                       ; get loop counter back
 36+  C13D 3D               dec a                           ; decrease loop counter
 37+  C13E C2 2E C1         jp nz, movement_spaceisempty0
 38+  C141 16 00            ld d,0
 39+  C143 1E 01            ld e,1                          ; got to end, so space is empty
 40+  C145 C9               ret
 41+  C146              movement_spaceisempty1:
 42+  C146 16 00            ld d,0
 43+  C148 1E 00            ld e,0                          ; returning false, ie space not empty
 44+  C14A C9               ret
 45+  C14B
 46+  C14B              ;
 47+  C14B              ; Check if a space contains a gem
 48+  C14B              ; Inputs:
 49+  C14B              ; bc - screen coords
 50+  C14B              ; Outputs:
 51+  C14B              ; e = 1 if gem
 52+  C14B              movement_spaceisgem:
 53+  C14B CD 37 AA         call screen_getcharcoordsfromscreencoords   ; get the char coords we're checking into bc
 54+  C14E 21 1A B7         ld hl,level_diamonds           ; check diamonds first
 55+  C151              movement_spaceisgem0:
 56+  C151 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 57+  C155 7B               ld a,e                          ; check for end of data
 58+  C156 FE FF            cp 255
 59+  C158 CA 73 C1         jp z,movement_spaceisgem1       ; if yes, done with diamonds
 60+  C15B 23               inc hl
 61+  C15C 23               inc hl                          ; move to state
 62+  C15D 7E               ld a,(hl)
 63+  C15E 23               inc hl
 64+  C15F 23               inc hl
 65+  C160 23               inc hl                          ; get to next
 66+  C161 FE 01            cp 1                            ; check if collected
 67+  C163 CA 51 C1         jp z,movement_spaceisgem0       ; if yes, move to next diamond
 68+  C166 7B               ld a,e                          ; load e again
 69+  C167 B9               cp c                            ; otherwise, compare c with e
 70+  C168 C2 51 C1         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 71+  C16B 7A               ld a,d                          ; get d coord
 72+  C16C B8               cp b                            ; compare b with d
 73+  C16D C2 51 C1         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 74+  C170 1E 01            ld e,1                          ; otherwise, exit with e = 1
 75+  C172 C9               ret
 76+  C173              movement_spaceisgem1:
 77+  C173 21 2A B7         ld hl,level_gems              ; check gems
 78+  C176              movement_spaceisgem2:
 79+  C176 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 80+  C17A 7B               ld a,e                          ; check for end of data
 81+  C17B FE FF            cp 255
 82+  C17D CA 98 C1         jp z,movement_spaceisgem3       ; if yes, done with gems
 83+  C180 23               inc hl
 84+  C181 23               inc hl                          ; move to state
 85+  C182 7E               ld a,(hl)
 86+  C183 23               inc hl
 87+  C184 23               inc hl
 88+  C185 23               inc hl                          ; get to next
 89+  C186 FE 01            cp 1                            ; check if collected
 90+  C188 CA 76 C1         jp z,movement_spaceisgem2       ; if yes, move to next diamond
 91+  C18B 7B               ld a,e                          ; load e again
 92+  C18C B9               cp c                            ; otherwise, compare c with e
 93+  C18D C2 76 C1         jp nz,movement_spaceisgem2      ; if different, move to next gem
 94+  C190 7A               ld a,d                          ; get d coord
 95+  C191 B8               cp b                            ; compare b with d
 96+  C192 C2 76 C1         jp nz,movement_spaceisgem2      ; if different, move to next gem
 97+  C195 1E 01            ld e,1                          ; otherwise, exit with e = 1
 98+  C197 C9               ret
 99+  C198              movement_spaceisgem3:
100+  C198 1E 00            ld e,0                          ; nothing found, return e = 0
101+  C19A C9               ret
102+  C19B
103+  C19B              ;
104+  C19B              ; Checks the line of a cell below is empty - ie, first pixel rows is zero
105+  C19B              ; Inputs:
106+  C19B              ; hl - memory location of top pixel row
107+  C19B              ; bc - screen coords, b horiz, c vert
108+  C19B              ; Outputs:
109+  C19B              ; e - 0 if not empty, 1 if empty
110+  C19B              ;
111+  C19B              movement_linebelowisempty:
112+  C19B C5               push bc
113+  C19C E5               push hl
114+  C19D CD 4B C1         call movement_spaceisgem        ; check if space is a gem
115+  C1A0 E1               pop hl
116+  C1A1 C1               pop bc
117+  C1A2 7B               ld a,e
118+  C1A3 FE 01            cp 1
119+  C1A5 C8               ret z                           ; if e is 1, space is a gem so can move here, return
120+  C1A6 7E               ld a,(hl)                       ; get current pixel row
121+  C1A7 FE 00            cp 0
122+  C1A9 C2 B1 C1         jp nz, movement_linebelowisempty1    ; row is not empty, can't move here
123+  C1AC 16 00            ld d,0
124+  C1AE 1E 01            ld e,1                          ; got to end, so space is empty
125+  C1B0 C9               ret
126+  C1B1              movement_linebelowisempty1:
127+  C1B1 16 00            ld d,0
128+  C1B3 1E 00            ld e,0                          ; returning false, ie space not empty
129+  C1B5 C9               ret
130+  C1B6
131+  C1B6              ;
132+  C1B6              ; Checks the line of a cell above is empty - ie, last pixel rows are zero
133+  C1B6              ; Inputs:
134+  C1B6              ; hl - memory location of top pixel row
135+  C1B6              ; bc - screen coords, b horiz, c vert
136+  C1B6              ; Outputs:
137+  C1B6              ; e - 0 if not empty, 1 if empty
138+  C1B6              ;
139+  C1B6              movement_lineaboveisempty:
140+  C1B6 C5               push bc
141+  C1B7 E5               push hl
142+  C1B8 CD 4B C1         call movement_spaceisgem        ; check if space is a gem
143+  C1BB E1               pop hl
144+  C1BC C1               pop bc
145+  C1BD 7B               ld a,e
146+  C1BE FE 01            cp 1
147+  C1C0 C8               ret z
148+  C1C1 7E               ld a,(hl)                       ; get current pixel row
149+  C1C2 FE 00            cp 0
150+  C1C4 C2 CC C1         jp nz, movement_lineaboveisempty1    ; row is not empty, can't move here
151+  C1C7 16 00            ld d,0
152+  C1C9 1E 01            ld e,1                          ; got to end, so space is empty
153+  C1CB C9               ret
154+  C1CC              movement_lineaboveisempty1:
155+  C1CC 16 00            ld d,0
156+  C1CE 1E 00            ld e,0                          ; returning false, ie space not empty
157+  C1D0 C9               ret
158+  C1D1
159+  C1D1              ;
160+  C1D1              ; Checks the contents of a cell are diggable - ie, all pixel rows are dirt or empty
161+  C1D1              ; Inputs:
162+  C1D1              ; hl - memory location of top pixel row
163+  C1D1              ; bc - screen coords, b horiz, c vert
164+  C1D1              ; Outputs:
165+  C1D1              ; none - puts player into digging mode
166+  C1D1              ;
167+  C1D1              movement_spaceisdiggable:
168+  C1D1 3E 08            ld a,8                          ; 8 rows to check
169+  C1D3              movement_spaceisdiggable0:
170+  C1D3 08               ex af,af'                       ; store the loop counter
171+  C1D4 7E               ld a,(hl)                       ; get current pixel row
172+  C1D5 FE 00            cp 0
173+  C1D7 CA E7 C1         jp z, movement_spaceisdiggable2  ; row is empty, can dig here
174+  C1DA FE 55            cp 85
175+  C1DC CA E7 C1         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
176+  C1DF FE AA            cp 170
177+  C1E1 CA E7 C1         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
178+  C1E4 C3 01 C2         jp movement_spaceisdiggable1     ; otherwise, stop checking
179+  C1E7              movement_spaceisdiggable2:
180+  C1E7 79               ld a,c                          ; load the vertical coord
181+  C1E8 3C               inc a                           ; next row down
182+  C1E9 11 20 00         ld de,32
183+  C1EC 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
184+  C1ED 4F               ld c,a                          ; copy vert coord back to c
185+  C1EE 08               ex af,af'                       ; get loop counter back
186+  C1EF 3D               dec a                           ; decrease loop counter
187+  C1F0 C2 D3 C1         jp nz, movement_spaceisdiggable0
188+  C1F3 21 8E C3         ld hl,player+6
189+  C1F6 36 01            ld (hl),1                       ; set the player into digging mode
190+  C1F8 23               inc hl
191+  C1F9 3A 20 C1         ld a,(movement_numberdigframes)
192+  C1FC 77               ld (hl),a                       ; set the number of frame to dig for
193+  C1FD 23               inc hl
194+  C1FE 36 08            ld (hl),8                       ; set the number of pixels to dig
195+  C200 C9               ret
196+  C201              movement_spaceisdiggable1:
197+  C201 21 8E C3         ld hl,player+6
198+  C204 36 00            ld (hl),0                       ; set the player out of digging mode
199+  C206 C9               ret
200+  C207
201+  C207              ;
202+  C207              ; Checks the contents of a cell below are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
203+  C207              ; Inputs:
204+  C207              ; hl - memory location of top pixel row
205+  C207              ; bc - screen coords, b horiz, c vert
206+  C207              ; Outputs:
207+  C207              ; none - puts player into digging mode
208+  C207              ;
209+  C207              movement_spacebelowisdiggable:
210+  C207 7E               ld a,(hl)                       ; get first pixel row
211+  C208 FE 55            cp 85
212+  C20A CA 15 C2         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
213+  C20D FE AA            cp 170
214+  C20F CA 15 C2         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
215+  C212 C3 01 C2         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
216+  C215              movement_spacebelowisdiggable3:
217+  C215 3E 08            ld a,8                          ; rows to check
218+  C217 1E 00            ld e,0                          ; count of rows to dig
219+  C219              movement_spacebelowisdiggable0:
220+  C219 08               ex af,af'                       ; store the loop counter
221+  C21A 7E               ld a,(hl)                       ; get current pixel row
222+  C21B FE 55            cp 85
223+  C21D CA 28 C2         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
224+  C220 FE AA            cp 170
225+  C222 CA 28 C2         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
226+  C225 C3 37 C2         jp movement_spacebelowisdiggable5     ; don't count this row and stop counting
227+  C228              movement_spacebelowisdiggable4:
228+  C228 1C               inc e                           ; inc count of rows to dig
229+  C229              movement_spacebelowisdiggable2:
230+  C229 79               ld a,c                          ; load the vertical coord
231+  C22A 3C               inc a                           ; next row down
232+  C22B D5               push de                         ; need e for later
233+  C22C 11 20 00         ld de,32
234+  C22F 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
235+  C230 4F               ld c,a                          ; copy vert coord back to c
236+  C231 D1               pop de                          ; get e back
237+  C232 08               ex af,af'                       ; get loop counter back
238+  C233 3D               dec a                           ; incease loop counter
239+  C234 C2 19 C2         jp nz, movement_spacebelowisdiggable0
240+  C237              movement_spacebelowisdiggable5:
241+  C237 21 8E C3         ld hl,player+6
242+  C23A 36 01            ld (hl),1                       ; set the player into digging mode
243+  C23C 23               inc hl
244+  C23D 3A 20 C1         ld a,(movement_numberdigframes)
245+  C240 77               ld (hl),a                       ; set the number of frame to dig for
246+  C241 23               inc hl
247+  C242 73               ld (hl),e                       ; set the number of pixels to dig
248+  C243 C9               ret
249+  C244              movement_spacebelowisdiggable1:
250+  C244 21 8E C3         ld hl,player+6
251+  C247 36 00            ld (hl),0                       ; set the player out of digging mode
252+  C249 C9               ret
253+  C24A
254+  C24A              ;
255+  C24A              ; Checks the contents of a cell above are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
256+  C24A              ; Inputs:
257+  C24A              ; hl - memory location of top pixel row
258+  C24A              ; bc - screen coords, b horiz, c vert
259+  C24A              ; Outputs:
260+  C24A              ; none - puts player into digging mode
261+  C24A              ;
262+  C24A              movement_spaceaboveisdiggable:
263+  C24A 7E               ld a,(hl)                       ; get first pixel row
264+  C24B FE 55            cp 85
265+  C24D CA 58 C2         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
266+  C250 FE AA            cp 170
267+  C252 CA 58 C2         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
268+  C255 C3 01 C2         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
269+  C258              movement_spaceaboveisdiggable3:
270+  C258 3E 08            ld a,8                          ; rows to check
271+  C25A 1E 00            ld e,0                          ; count of rows to dig
272+  C25C              movement_spaceaboveisdiggable0:
273+  C25C 08               ex af,af'                       ; store the loop counter
274+  C25D 7E               ld a,(hl)                       ; get current pixel row
275+  C25E FE 55            cp 85
276+  C260 CA 6B C2         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
277+  C263 FE AA            cp 170
278+  C265 CA 6B C2         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
279+  C268 C3 7B C2         jp movement_spaceaboveisdiggable5     ; don't count this row and stop counting
280+  C26B              movement_spaceaboveisdiggable4:
281+  C26B 1C               inc e                           ; inc count of rows to dig
282+  C26C              movement_spaceaboveisdiggable2:
283+  C26C 79               ld a,c                          ; load the vertical coord
284+  C26D 3D               dec a                           ; next row up
285+  C26E D5               push de                         ; need e for later
286+  C26F 11 20 00         ld de,32
287+  C272 ED 52            sbc hl,de                       ; otherwise, just go one up for hl, which means sub 32, because of course
288+  C274 4F               ld c,a                          ; copy vert coord back to c
289+  C275 D1               pop de                          ; get e back
290+  C276 08               ex af,af'                       ; get loop counter back
291+  C277 3D               dec a                           ; incease loop counter
292+  C278 C2 5C C2         jp nz, movement_spaceaboveisdiggable0
293+  C27B              movement_spaceaboveisdiggable5:
294+  C27B 21 8E C3         ld hl,player+6
295+  C27E 36 01            ld (hl),1                       ; set the player into digging mode
296+  C280 23               inc hl
297+  C281 3A 20 C1         ld a,(movement_numberdigframes)
298+  C284 77               ld (hl),a                       ; set the number of frame to dig for
299+  C285 23               inc hl
300+  C286 73               ld (hl),e                       ; set the number of pixels to dig
301+  C287 C9               ret
302+  C288              movement_spaceaboveisdiggable1:
303+  C288 21 8E C3         ld hl,player+6
304+  C28B 36 00            ld (hl),0                       ; set the player out of digging mode
305+  C28D C9               ret
306+  C28E
307+  C28E              ;
308+  C28E              ; Checks if the player can move down
309+  C28E              ; Inputs:
310+  C28E              ; bc - player coords, b horiz, c vert
311+  C28E              ; Outputs:
312+  C28E              ; de - 1 can move
313+  C28E              movement_checkcanmove_down:
314+  C28E F5               push af
315+  C28F C5               push bc
316+  C290 CD FE AB         call sprites_scadd              ; get the memory location of cell into de
317+  C293 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
318+  C295 24               inc h                       ; memory location of cell beneath now in hl
319+  C296 3E 08            ld a,8                       ; look below
320+  C298 81               add c
321+  C299 4F               ld c,a
322+  C29A CD 9B C1         call movement_linebelowisempty       ; check space is empty
323+  C29D 7B               ld a,e                          ; check space empty flag
324+  C29E FE 00            cp 0
325+  C2A0 CA A9 C2         jp z, movement_checkcanmove_down1 ; can't move
326+  C2A3 CD 93 C5         call player_justmoved
327+  C2A6 C1               pop bc
328+  C2A7 F1               pop af
329+  C2A8 C9               ret
330+  C2A9              movement_checkcanmove_down1:
331+  C2A9 C1               pop bc
332+  C2AA CD FE AB         call sprites_scadd              ; get the memory location of cell into de
333+  C2AD 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
334+  C2AF 24               inc h
335+  C2B0 C5               push bc
336+  C2B1 CD 07 C2         call movement_spacebelowisdiggable    ; can't move here, but can we dig
337+  C2B4 11 00 00         ld de,0
338+  C2B7 C1               pop bc
339+  C2B8 F1               pop af
340+  C2B9 C9               ret
341+  C2BA
342+  C2BA              ;
343+  C2BA              ; Checks if the player can move up
344+  C2BA              ; Inputs:
345+  C2BA              ; bc - player coords, b horiz, c vert
346+  C2BA              ; Outputs:
347+  C2BA              ; de - 1 can move
348+  C2BA              movement_checkcanmove_up:
349+  C2BA F5               push af
350+  C2BB C5               push bc
351+  C2BC CD FE AB         call sprites_scadd              ; get the memory location of cell into de
352+  C2BF 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
353+  C2C1 11 20 00         ld de,32
354+  C2C4 ED 52            sbc hl,de                       ; memory location of line above now in hl
355+  C2C6 0D               dec c                           ; look above
356+  C2C7 CD B6 C1         call movement_lineaboveisempty       ; check space is empty
357+  C2CA 7B               ld a,e                          ; check space empty flag
358+  C2CB FE 00            cp 0
359+  C2CD CA D8 C2         jp z, movement_checkcanmove_up1 ; can't move
360+  C2D0 1E 01            ld e,1
361+  C2D2 CD 93 C5         call player_justmoved
362+  C2D5 C1               pop bc
363+  C2D6 F1               pop af
364+  C2D7 C9               ret
365+  C2D8              movement_checkcanmove_up1:
366+  C2D8 C1               pop bc
367+  C2D9 CD FE AB         call sprites_scadd              ; get the memory location of cell into de
368+  C2DC 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
369+  C2DE 11 20 00         ld de,32
370+  C2E1 ED 52            sbc hl,de                       ; memory location of line above now in hl
371+  C2E3 C5               push bc
372+  C2E4 CD 4A C2         call movement_spaceaboveisdiggable    ; can't move here, but can we dig
373+  C2E7 11 00 00         ld de,0
374+  C2EA C1               pop bc
375+  C2EB F1               pop af
376+  C2EC C9               ret
377+  C2ED
378+  C2ED              ;
379+  C2ED              ; Checks if the player can move right
380+  C2ED              ; Inputs:
381+  C2ED              ; bc - player coords, b horiz, c vert
382+  C2ED              ; Outputs:
383+  C2ED              ; de - 1 can move
384+  C2ED              movement_checkcanmove_right:
385+  C2ED F5               push af
386+  C2EE C5               push bc
387+  C2EF CD FE AB         call sprites_scadd              ; get the memory location of cell into de
388+  C2F2 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
389+  C2F4 3E 08            ld a,8
390+  C2F6 80               add b                           ; move one cell right
391+  C2F7 47               ld b,a
392+  C2F8 23               inc hl                          ; memory location of cell to the right now in hl
393+  C2F9 CD 21 C1         call movement_spaceisempty       ; check space is empty
394+  C2FC 7B               ld a,e                          ; check space empty flag
395+  C2FD FE 00            cp 0
396+  C2FF CA 08 C3         jp z, movement_checkcanmove_right1 ; can't move
397+  C302 CD 93 C5         call player_justmoved
398+  C305 C1               pop bc
399+  C306 F1               pop af
400+  C307 C9               ret
401+  C308              movement_checkcanmove_right1:
402+  C308 C1               pop bc
403+  C309 CD FE AB         call sprites_scadd              ; get the memory location of cell into de
404+  C30C 62 6B            ld hl,de
405+  C30E 23               inc hl                          ; memory location of cell to the right now in hl
406+  C30F C5               push bc
407+  C310 CD D1 C1         call movement_spaceisdiggable    ; can't move here, but can we dig
408+  C313 11 00 00         ld de,0
409+  C316 C1               pop bc
410+  C317 F1               pop af
411+  C318 C9               ret
412+  C319
413+  C319              ;
414+  C319              ; Checks if the player can move left
415+  C319              ; Inputs:
416+  C319              ; bc - player coords, b horiz, c vert
417+  C319              ; Outputs:
418+  C319              ; de - 1 can move
419+  C319              movement_checkcanmove_left:
420+  C319 F5               push af
421+  C31A C5               push bc
422+  C31B CD FE AB         call sprites_scadd              ; get the memory location of cell into de
423+  C31E 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
424+  C320 78               ld a,b
425+  C321 06 08            ld b,8
426+  C323 90               sub b                           ; move one cell left
427+  C324 47               ld b,a
428+  C325 2B               dec hl                          ; memory location of cell to the right now in hl
429+  C326 CD 21 C1         call movement_spaceisempty       ; check space is empty
430+  C329 7B               ld a,e                          ; check space empty flag
431+  C32A FE 00            cp 0
432+  C32C CA 35 C3         jp z, movement_checkcanmove_left1 ; can't move
433+  C32F CD 93 C5         call player_justmoved
434+  C332 C1               pop bc
435+  C333 F1               pop af
436+  C334 C9               ret
437+  C335              movement_checkcanmove_left1:
438+  C335 C1               pop bc
439+  C336 CD FE AB         call sprites_scadd              ; get the memory location of cell into de
440+  C339 62 6B            ld hl,de
441+  C33B 2B               dec hl                          ; memory location of cell to the right now in hl
442+  C33C C5               push bc
443+  C33D CD D1 C1         call movement_spaceisdiggable    ; can't move here, but can we dig
444+  C340 11 00 00         ld de,0
445+  C343 C1               pop bc
446+  C344 F1               pop af
447+  C345 C9               ret
# file closed: game/movement.asm
152   C346                  include "game\game.asm"
# file opened: game/game.asm
  1+  C346              ;
  2+  C346              ; The current frame count, incremented each frame
  3+  C346              ;
  4+  C346              game_framenumber:
  5+  C346 00               defb    0
  6+  C347
  7+  C347              ;
  8+  C347              ; The number of players
  9+  C347              ;
 10+  C347              game_numberplayers:
 11+  C347 01               defb 1
 12+  C348
 13+  C348              ;
 14+  C348              ; The current player
 15+  C348              ;
 16+  C348              game_currentplayer:
 17+  C348 01               defb 1
 18+  C349
 19+  C349              ;
 20+  C349              ; The default number of lives
 21+  C349              ;
 22+  C349              game_numberlives:
 23+  C349 04               defb 4
 24+  C34A
 25+  C34A              ;
 26+  C34A              ; The current difficulty
 27+  C34A              ;
 28+  C34A              game_difficulty:
 29+  C34A 00               defb 0
 30+  C34B
 31+  C34B              ;
 32+  C34B              ; Control method: 0 for keyboard, 1 for kempston
 33+  C34B              ;
 34+  C34B              game_control:
 35+  C34B 00               defb 0
 36+  C34C
 37+  C34C              ;
 38+  C34C              ; Moves to the next player
 39+  C34C              ;
 40+  C34C              game_changeplayer:
 41+  C34C 3A 47 C3         ld a,(game_numberplayers)
 42+  C34F FE 01            cp 1
 43+  C351 C8               ret z                       ; if just one player, no need to change
 44+  C352 3A 48 C3         ld a,(game_currentplayer)   ; get current player
 45+  C355 3D               dec a                       ; otherwise decrease by one
 46+  C356 EE 01            xor 1                       ; xor with one to flip
 47+  C358 3C               inc a                       ; increment
 48+  C359 21 48 C3         ld hl,game_currentplayer
 49+  C35C 77               ld (hl),a                   ; store
 50+  C35D C9               ret
 51+  C35E
 52+  C35E              ;
 53+  C35E              ; Sets the number of players at the start of the game
 54+  C35E              ; Inputs:
 55+  C35E              ; a - number of players
 56+  C35E              game_setnumberofplayers:
 57+  C35E 21 47 C3         ld hl,game_numberplayers
 58+  C361 77               ld (hl),a
 59+  C362
 60+  C362              ;
 61+  C362              ; Starts a game
 62+  C362              ;
 63+  C362              game_init:
 64+  C362 3E 01            ld a,1
 65+  C364 32 48 C3         ld (game_currentplayer),a
 66+  C367 C9               ret
 67+  C368
 68+  C368
 69+  C368              ;
 70+  C368              ; Increment frame number by 1
 71+  C368              ;
 72+  C368              game_incrementframe:
 73+  C368 3A 46 C3         ld a,(game_framenumber)
 74+  C36B FE FF            cp 255
 75+  C36D C2 72 C3         jp nz,game_incrementframe0
 76+  C370 3E 00            ld a,0
 77+  C372              game_incrementframe0:
 78+  C372 3C               inc a
 79+  C373 32 46 C3         ld (game_framenumber),a
 80+  C376 C9               ret
 81+  C377
 82+  C377              ;
 83+  C377              ; Returns current frame
 84+  C377              ; Outputs:
 85+  C377              ; a - current frame
 86+  C377              ;
 87+  C377              game_getcurrentframe:
 88+  C377 3A 46 C3         ld a,(game_framenumber)
 89+  C37A C9               ret
 90+  C37B
 91+  C37B              ;
 92+  C37B              ; Resets current frame
 93+  C37B              ;
 94+  C37B              game_resetcurrentframe:
 95+  C37B 21 46 C3         ld hl,game_framenumber
 96+  C37E 36 00            ld (hl),0
 97+  C380 C9               ret
 98+  C381
 99+  C381              ;
100+  C381              ; Increases the current difficulty
101+  C381              ;
102+  C381              game_increasedifficulty:
103+  C381 3A 4A C3         ld a,(game_difficulty)
104+  C384 3C               inc a
105+  C385 32 4A C3         ld (game_difficulty),a
# file closed: game/game.asm
153   C388                  include "game\player.asm"
# file opened: game/player.asm
  1+  C388              ;
  2+  C388              ;   Data for current player
  3+  C388              ;
  4+  C388              player:
  5+  C388 00 00            defb    0,0                 ; horiz,vert (+0,+1)
  6+  C38A 02 00 01         defb    2,0,1               ; dir (0 up, 1 left, 2 right, 3 down), frame, frame transition count (+2,+3,+4)
  7+  C38D 00               defb    0                   ; auto move remaining (+5)
  8+  C38E 00 00 00         defb    0,0,0               ; is digging (0 no), digging count, pixels to di (+6,+7,+8)
  9+  C391 00               defb    0                   ; lives remaining (+9)
 10+  C392 00               defb    0                   ; died this life (+10)
 11+  C393 00 00            defb    0,0                 ; dying (+11), frames (+12)
 12+  C395 00               defb    0                   ; can finish level, whether can finish level or not (+13)
 13+  C396 00               defb    0                   ; difficulty (+14)
 14+  C397
 15+  C397              player_location:
 16+  C397 00               defb 0                      ; 0 normal, 1 diamond cavern, 2 the pit
 17+  C398
 18+  C398              ;
 19+  C398              ; Works out which part of the screen the player is in
 20+  C398              ; Pit is between 3,9 and 8,9
 21+  C398              ; Diamond cavern is between 11,22 and 22,28
 22+  C398              ;
 23+  C398              player_getlocation:
 24+  C398 ED 4B 88 C3      ld bc,(player)              ; get screen coords
 25+  C39C CD 37 AA         call screen_getcharcoordsfromscreencoords ; get char coords, c horiz
 26+  C39F 78               ld a,b                      ; check for pit first
 27+  C3A0 FE 09            cp 9                        ; if not on this row, not in the pit
 28+  C3A2 C2 B1 C3         jp nz,player_getlocation0
 29+  C3A5 79               ld a,c                      ; check horizontal
 30+  C3A6 FE 09            cp 9
 31+  C3A8 D2 B1 C3         jp nc, player_getlocation0  ; if more than 9, not in the pit
 32+  C3AB 21 97 C3         ld hl,player_location
 33+  C3AE 36 02            ld (hl),2                   ; load location with 2, the pit
 34+  C3B0 C9               ret                         ; done
 35+  C3B1              player_getlocation0:            ; check for diamond cavern
 36+  C3B1 78               ld a,b                      ; first check vertical
 37+  C3B2 FE 16            cp 22                       ; if above row 22, then not in cavern
 38+  C3B4 DA C8 C3         jp c,player_getlocation1
 39+  C3B7 79               ld a,c                      ; get the horizontal next
 40+  C3B8 FE 0B            cp 11
 41+  C3BA DA C8 C3         jp c,player_getlocation1    ; if less than 11 not in diamond cave
 42+  C3BD FE 16            cp 22
 43+  C3BF D2 C8 C3         jp nc,player_getlocation1    ; if less than 11 not in diamond cave
 44+  C3C2 21 97 C3         ld hl,player_location
 45+  C3C5 36 01            ld (hl),1                   ; load location with 1, the cavern
 46+  C3C7 C9               ret
 47+  C3C8              player_getlocation1:
 48+  C3C8 21 97 C3         ld hl,player_location
 49+  C3CB 36 00            ld (hl),0                   ; load location with 2, the pit
 50+  C3CD C9               ret                         ; done
 51+  C3CE
 52+  C3CE
 53+  C3CE              ;
 54+  C3CE              ; Initializes a player at start of game
 55+  C3CE              ; Copy initial coords, copy lives, copy score
 56+  C3CE              ;
 57+  C3CE              player_init_gamestart:
 58+  C3CE 3A 49 C3         ld a,(game_numberlives)
 59+  C3D1 32 8F C4         ld (player1_lives),a
 60+  C3D4 32 90 C4         ld (player2_lives),a                        ; set the initial number of lives at game start
 61+  C3D7
 62+  C3D7 21 93 C4         ld hl,player1_score+2
 63+  C3DA 06 06            ld b,6
 64+  C3DC              player_init_gamestart0:
 65+  C3DC 36 30            ld (hl),48
 66+  C3DE 23               inc hl
 67+  C3DF 10 FB            djnz player_init_gamestart0                 ; zero out player 1 score
 68+  C3E1 21 9C C4         ld hl,player2_score+2
 69+  C3E4 06 06            ld b,6
 70+  C3E6              player_init_gamestart1:
 71+  C3E6 36 30            ld (hl),48
 72+  C3E8 23               inc hl
 73+  C3E9 10 FB            djnz player_init_gamestart1                 ; zero out player 2 score
 74+  C3EB 3E 00            ld a,0
 75+  C3ED 32 A3 C4         ld (player1_difficulty),a
 76+  C3F0 32 A4 C4         ld (player2_difficulty),a                   ; set player difficulties to zero
 77+  C3F3 C9               ret
 78+  C3F4
 79+  C3F4              ;
 80+  C3F4              ; Initializes a player at start of a life
 81+  C3F4              ; Copy initial coords, copy lives, copy score
 82+  C3F4              ;
 83+  C3F4              player_init_lifestart:
 84+  C3F4 21 8D C3         ld hl,player+5
 85+  C3F7 06 09            ld b,9                      ; initialise 9 properties
 86+  C3F9              player_init_lifestart2:
 87+  C3F9 36 00            ld (hl),0
 88+  C3FB 23               inc hl
 89+  C3FC 10 FB            djnz player_init_lifestart2
 90+  C3FE
 91+  C3FE 21 8A C3         ld hl,player+2              ; initialise some properties
 92+  C401 36 02            ld (hl),2
 93+  C403 23               inc hl
 94+  C404 36 00            ld (hl),0
 95+  C406 23               inc hl
 96+  C407 36 01            ld (hl),1
 97+  C409
 98+  C409 ED 4B E5 80      ld bc,(init_coord)
 99+  C40D ED 43 88 C3      ld (player),bc
100+  C411
101+  C411 3A 48 C3         ld a,(game_currentplayer)
102+  C414 FE 01            cp 1
103+  C416 C2 23 C4         jp nz,player_init_lifestart4
104+  C419 01 91 C3         ld bc,player+9
105+  C41C 3A 8F C4         ld a,(player1_lives)
106+  C41F 02               ld (bc),a
107+  C420 C3 2A C4         jp player_init_lifestart3
108+  C423              player_init_lifestart4:
109+  C423 01 91 C3         ld bc,player+9
110+  C426 3A 90 C4         ld a,(player2_lives)
111+  C429 02               ld (bc),a
112+  C42A              player_init_lifestart3:
113+  C42A
114+  C42A CD BD CC         call diamonds_init      ; initialise gems
115+  C42D
116+  C42D 01 06 00         ld bc,6
117+  C430 11 69 CA         ld de,scores_current+2
118+  C433 3A 48 C3         ld a,(game_currentplayer)
119+  C436 FE 01            cp 1
120+  C438 C2 47 C4         jp nz,player_init_lifestart0
121+  C43B 3A A3 C4         ld a,(player1_difficulty)       ; initialise player 1 difficulty
122+  C43E 32 4A C3         ld (game_difficulty),a
123+  C441 21 93 C4         ld hl,player1_score+2           ; itialise player 1 scores
124+  C444 C3 50 C4         jp player_init_lifestart1
125+  C447              player_init_lifestart0:
126+  C447 3A A4 C4         ld a,(player2_difficulty)       ; initialise player 2 difficulty
127+  C44A 32 4A C3         ld (game_difficulty),a
128+  C44D 21 9C C4         ld hl,player2_score+2           ; initialise player 2 scores
129+  C450              player_init_lifestart1:
130+  C450 ED B0            ldir
131+  C452 C9               ret
132+  C453
133+  C453
134+  C453              ;
135+  C453              ; Copies the current score and difficulty in the current player
136+  C453              ;
137+  C453              player_recordcurrentstate:
138+  C453 01 06 00         ld bc,6                  ; copy current score back to correct player
139+  C456 21 69 CA         ld hl,scores_current+2
140+  C459 3A 48 C3         ld a,(game_currentplayer)
141+  C45C FE 01            cp 1
142+  C45E C2 73 C4         jp nz,player_recordcurrentstate0
143+  C461 3A 4A C3         ld a,(game_difficulty)
144+  C464 32 A3 C4         ld (player1_difficulty),a       ; store difficulty
145+  C467 11 93 C4         ld de,player1_score+2
146+  C46A 3A 91 C3         ld a,(player+9)
147+  C46D 32 8F C4         ld (player1_lives),a              ; record lives
148+  C470 C3 82 C4         jp player_recordcurrentstate1
149+  C473              player_recordcurrentstate0:         ; do player 2
150+  C473 3A 4A C3         ld a,(game_difficulty)
151+  C476 32 A4 C4         ld (player2_difficulty),a       ; store difficulty
152+  C479 3A 91 C3         ld a,(player+9)
153+  C47C 32 90 C4         ld (player2_lives),a              ; record lives
154+  C47F 11 9C C4         ld de,player2_score+2
155+  C482              player_recordcurrentstate1:
156+  C482 ED B0            ldir
157+  C484 C9               ret
158+  C485
159+  C485              ;
160+  C485              ; Player just died, subtract a life
161+  C485              ;
162+  C485              player_died:
163+  C485 01 91 C3         ld bc,player+9
164+  C488 0A               ld a,(bc)
165+  C489 3D               dec a
166+  C48A 02               ld (bc),a
167+  C48B CD 53 C4         call player_recordcurrentstate
168+  C48E C9               ret
169+  C48F
170+  C48F              ;
171+  C48F              ; Player lives
172+  C48F              ;
173+  C48F              player1_lives:
174+  C48F 03               defb 3
175+  C490              player2_lives:
176+  C490 03               defb 3
177+  C491
178+  C491              ;
179+  C491              ; Player scores
180+  C491              ;
181+  C491              player1_score:
182+  C491 04 01 30 30      defb 4,1,'000000',255
182+  C495 30 30 30 30
182+  C499 FF
183+  C49A              player2_score:
184+  C49A 16 01 30 30      defb 22,1,'000000',255
184+  C49E 30 30 30 30
184+  C4A2 FF
185+  C4A3
186+  C4A3              ;
187+  C4A3              ; Player difficulties
188+  C4A3              ;
189+  C4A3              player1_difficulty:
190+  C4A3 00               defb 0
191+  C4A4              player2_difficulty:
192+  C4A4 00               defb 0
193+  C4A5
194+  C4A5              ;
195+  C4A5              ; Kills a player this life
196+  C4A5              ;
197+  C4A5              player_killplayer:
198+  C4A5 21 92 C3         ld hl,player+10
199+  C4A8 36 01            ld (hl),1
200+  C4AA C9               ret
201+  C4AB
202+  C4AB              ;
203+  C4AB              ; Crush a player this life
204+  C4AB              ;
205+  C4AB              player_crushplayer:
206+  C4AB 21 93 C3         ld hl,player+11             ; mark as crushed
207+  C4AE 36 01            ld (hl),1
208+  C4B0 C9               ret
209+  C4B1
210+  C4B1              player_tankkillplayer
211+  C4B1 21 93 C3         ld hl,player+11             ; mark as tanked
212+  C4B4 36 02            ld (hl),2
213+  C4B6 C9               ret
214+  C4B7
215+  C4B7              player_zonkplayer
216+  C4B7 21 93 C3         ld hl,player+11             ; mark as zonked (missile)
217+  C4BA 36 03            ld (hl),3
218+  C4BC C9               ret
219+  C4BD
220+  C4BD              player_pitkillplayer
221+  C4BD 21 93 C3         ld hl,player+11             ; mark as pit killed
222+  C4C0 36 04            ld (hl),4
223+  C4C2 C9               ret
224+  C4C3
225+  C4C3              player_robotkillplayer
226+  C4C3 21 93 C3         ld hl,player+11             ; mark as robot killed
227+  C4C6 36 05            ld (hl),5
228+  C4C8 C9               ret
229+  C4C9
230+  C4C9              ;
231+  C4C9              ; Draws the player at the current position or deletes them
232+  C4C9              ;
233+  C4C9              player_drawplayer:
234+  C4C9 3A 8A C3         ld a,(player+2)             ; get the current direction
235+  C4CC FE 03            cp 3
236+  C4CE C2 D3 C4         jp nz,player_drawplayer0
237+  C4D1 3E 00            ld a,0                      ; if 3, then down, so set the direction to 0 since the sprite is the same as up
238+  C4D3              player_drawplayer0:             ; DYING CHECKS
239+  C4D3 5F               ld e,a                      ; store in e
240+  C4D4 3A 93 C3         ld a,(player+11)             ; get the dying flag
241+  C4D7 FE 01            cp 1
242+  C4D9 CA 13 C5         jp z,player_drawplayer3     ; if it's one, we're being crushed
243+  C4DC FE 04            cp 4
244+  C4DE CA 5B C5         jp z,player_drawplayer9     ; player is falling into the pit
245+  C4E1 FE 05            cp 5
246+  C4E3 CA 77 C5         jp z,player_drawplayer12    ; player has been killed by a robot
247+  C4E6              player_drawplayer4:             ; CHECK FOR DIGGING
248+  C4E6 3A 8E C3         ld a,(player+6)             ; get the dig flag
249+  C4E9 FE 01            cp 1
250+  C4EB CA FC C4         jp z,player_drawplayer1    ; get dig frame
251+  C4EE 3A 8B C3         ld a,(player+3)             ; this is normal movement so get the current frame
252+  C4F1 83               add a,e
253+  C4F2 C3 01 C5         jp player_drawplayer2
254+  C4F5              player_drawplayer6:             ; GETTING THE DIG FRAM
255+  C4F5 E6 01            and 1                       ; check for odd
256+  C4F7 C6 0A            add 10                      ; add 10, to get either 10 or 11
257+  C4F9 C3 01 C5         jp player_drawplayer2
258+  C4FC              player_drawplayer1:             ; GET THE NORMAL FRAME
259+  C4FC 3A 8A C3         ld a,(player+2)             ; digging, get the current direction again, because want all four
260+  C4FF C6 06            add a,6                     ; add direction to 6 to get frame
261+  C501              player_drawplayer2:             ; WORK OUT THE FRAME
262+  C501 07               rlca
263+  C502 07               rlca
264+  C503 07               rlca                        ; multiply by eight
265+  C504 6F               ld l,a
266+  C505 26 00            ld h,0
267+  C507 11 9B BC         ld de,player_sprite
268+  C50A 19               add hl,de                   ; load hl with the location of the player sprite data
269+  C50B              player_drawplayer7:             ; DRAW THE PlAYER
270+  C50B ED 4B 88 C3      ld bc,(player)              ; load bc with the start coords
271+  C50F CD 09 AB         call sprites_drawsprite     ; call the routine to draw the sprite
272+  C512                  ;call player_storeupdatedlines ; log updated rows
273+  C512 C9               ret
274+  C513              ;
275+  C513              ; CRUSHING
276+  C513              ;
277+  C513              player_drawplayer3:
278+  C513 21 94 C3         ld hl,player+12
279+  C516 7E               ld a,(hl)                  ; crushing, so get the current anim flag
280+  C517 FE 00            cp 0
281+  C519 C2 22 C5         jp nz,player_drawplayer5    ; if this isn't zero, then this isn't the first time round, so do the crush anim
282+  C51C 3E 64            ld a,100
283+  C51E 77               ld (hl),a                   ; otherwise, load up the anim frames
284+  C51F C3 E6 C4         jp player_drawplayer4       ; and return to the main loop to remove the current frame
285+  C522              player_drawplayer5:
286+  C522 3D               dec a
287+  C523 77               ld (hl),a
288+  C524 FE 00            cp 0
289+  C526 CC A5 C4         call z,player_killplayer     ; final animation, so kill the player
290+  C529 FE 0A            cp 10                         ; play the sound
291+  C52B CC E9 B0         call z, sound_rockfell
292+  C52E FE 14            cp 20                        ; check if we should move the rock
293+  C530 C2 44 C5         jp nz,player_drawplayer8
294+  C533 D9               exx
295+  C534 F5               push af
296+  C535 ED 4B 07 C9      ld bc,(rocks_killerrock)    ; get the coords of the rock that killed us
297+  C539 21 E7 BB         ld hl,sprites+72
298+  C53C CD 09 AB         call sprites_drawsprite     ; draw a rock over current
299+  C53F F1               pop af
300+  C540 D9               exx
301+  C541 C3 F5 C4         jp player_drawplayer6       ; continue drawing player
302+  C544              player_drawplayer8:
303+  C544 FE 14            cp 20
304+  C546 D2 F5 C4         jp nc,player_drawplayer6    ; if not in last 10 frames, draw as normal
305+  C549 ED 4B 88 C3      ld bc,(player)
306+  C54D CD 37 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
307+  C550 3E 42            ld a,66             ; load red
308+  C552 CD 8F AA         call screen_setattr
309+  C555 21 E7 BB         ld hl,sprites+72            ; otherwise, player is rock
310+  C558 C3 0B C5         jp player_drawplayer7
311+  C55B              ;
312+  C55B              ; FALLING
313+  C55B              ;
314+  C55B              player_drawplayer9:             ; player is falling into the pit
315+  C55B 21 94 C3         ld hl,player+12
316+  C55E 7E               ld a,(hl)                   ; get the frames
317+  C55F FE 00            cp 0
318+  C561 C2 6A C5         jp nz,player_drawplayer10    ; if this isn't zero, then this isn't the first time round, so do the crush anim
319+  C564 3E 50            ld a,80
320+  C566 77               ld (hl),a                   ; otherwise, load up the anim frames
321+  C567 C3 E6 C4         jp player_drawplayer4       ; and return to the main loop to remove the current frame
322+  C56A              player_drawplayer10:
323+  C56A 3D               dec a
324+  C56B 77               ld (hl),a
325+  C56C FE 00            cp 0
326+  C56E CC A5 C4         call z,player_killplayer     ; final frame, so kill the player
327+  C571 3A 8B C3         ld a,(player+3)
328+  C574 C3 01 C5         jp player_drawplayer2
329+  C577              ;
330+  C577              ; ROBOT KILLED
331+  C577              ;
332+  C577              player_drawplayer12:
333+  C577 21 94 C3         ld hl,player+12
334+  C57A 7E               ld a,(hl)                   ; get the frames
335+  C57B FE 00            cp 0
336+  C57D C2 86 C5         jp nz,player_drawplayer13    ; if this isn't zero, then this isn't the first time round, so do the crush anim
337+  C580 3E C8            ld a,200
338+  C582 77               ld (hl),a                   ; otherwise, load up the anim frames
339+  C583 C3 E6 C4         jp player_drawplayer4       ; and return to the main loop to remove the current frame
340+  C586              player_drawplayer13:
341+  C586 3D               dec a
342+  C587 77               ld (hl),a
343+  C588 FE 00            cp 0
344+  C58A CC A5 C4         call z,player_killplayer     ; final frame, so kill the player
345+  C58D 3A 8B C3         ld a,(player+3)
346+  C590 C3 01 C5         jp player_drawplayer2
347+  C593
348+  C593              ;
349+  C593              ; Runs after the player just moved. Changes animation frame if required
350+  C593              ;
351+  C593              player_justmoved:
352+  C593 D9               exx
353+  C594 3A 8C C3         ld a,(player+4)             ; get the transition count
354+  C597 FE 00            cp 0
355+  C599 CA 9F C5         jp z, player_justmoved2     ; if zero reset and change the frame
356+  C59C C3 B9 C5         jp player_justmoved1       ; otherwise decrease and continue
357+  C59F              player_justmoved2:
358+  C59F                  ; reset and change frame in here
359+  C59F 3E 01            ld a,1
360+  C5A1 32 8C C3         ld (player+4),a            ; reset back to whatever
361+  C5A4 3A 8B C3         ld a,(player+3)             ; load the frame
362+  C5A7 FE 03            cp 3                       ; flip between 3 and 0
363+  C5A9 C2 B1 C5         jp nz, player_justmoved4
364+  C5AC 3E 00            ld a,0
365+  C5AE C3 B3 C5         jp player_justmoved5
366+  C5B1              player_justmoved4:
367+  C5B1 3E 03            ld a,3
368+  C5B3              player_justmoved5:
369+  C5B3 32 8B C3         ld (player+3),a           ; save back
370+  C5B6 C3 BD C5         jp player_justmoved3
371+  C5B9              player_justmoved1:
372+  C5B9                  ; decrease count
373+  C5B9 3D               dec a
374+  C5BA 32 8C C3         ld (player+4),a
375+  C5BD              player_justmoved3:
376+  C5BD D9               exx;
377+  C5BE C9               ret
378+  C5BF
379+  C5BF              ;
380+  C5BF              ; Called if the player has collected a diamond. Checks the current coord. If it is the start coord, then return complete
381+  C5BF              ; Outputs:
382+  C5BF              ; a - 1 for completed level
383+  C5BF              player_checkforexit:
384+  C5BF ED 4B 88 C3      ld bc,(player)                 ; get player coords
385+  C5C3 ED 5B E5 80      ld de,(init_coord)             ; get start coords
386+  C5C7 78               ld a,b
387+  C5C8 BA               cp d                         ; compare horiz
388+  C5C9 C2 D4 C5         jp nz,player_checkforexit1
389+  C5CC 79               ld a,c
390+  C5CD BB               cp e                        ; compare vert
391+  C5CE C2 D4 C5         jp nz,player_checkforexit1
392+  C5D1              player_checkforexit0:
393+  C5D1 3E 01            ld a,1                       ; hasn't completed
394+  C5D3 C9               ret
395+  C5D4              player_checkforexit1:
396+  C5D4 3E 00            ld a,0                       ; has completed
397+  C5D6 C9               ret
# file closed: game/player.asm
154   C5D7                  include "game\ship.asm"
# file opened: game/ship.asm
  1+  C5D7              ;
  2+  C5D7              ; Ship initial position: vert,horiz
  3+  C5D7              ;
  4+  C5D7              ship_initpos:
  5+  C5D7 00 24            defb 0,36
  6+  C5D9              ship_initpos2:
  7+  C5D9 00 00            defb 0,0
  8+  C5DB              ship_frame:
  9+  C5DB 00               defb 0
 10+  C5DC              ;
 11+  C5DC              ; The current memory location
 12+  C5DC              ;
 13+  C5DC              ship_current_sprite:
 14+  C5DC 00 00            defb 0,0
 15+  C5DE
 16+  C5DE              ship_current_coords:
 17+  C5DE 00 00            defb 0,0
 18+  C5E0
 19+  C5E0              ship_process:
 20+  C5E0 3A 93 C3         ld a,(player+11)
 21+  C5E3 FE 02            cp 2                        ; has the player been killed by tank?
 22+  C5E5 C0               ret nz                      ; do nothing if not
 23+  C5E6 CD 13 C1         call control_scroll_up           ; make sure the screen is on the top screen
 24+  C5E9 CD 58 C6         call ship_takeoff           ; bye bye
 25+  C5EC CD A5 C4         call player_killplayer      ; killed
 26+  C5EF 06 32            ld b,50
 27+  C5F1 CD 5E 81         call utilities_pauseforframes
 28+  C5F4 C9               ret
 29+  C5F5
 30+  C5F5              ;
 31+  C5F5              ;   Draw and land the ship - first move the ship down, then across, drawing the player in the middle
 32+  C5F5              ;
 33+  C5F5              ship_land:
 34+  C5F5 ED 4B D7 C5      ld bc,(ship_initpos)
 35+  C5F9 ED 43 D9 C5      ld (ship_initpos2),bc        ; save the initial position for later use
 36+  C5FD 1E 00            ld e,0                      ; store a flag to track first time round
 37+  C5FF 06 09            ld b,9                      ; move down 8 pixels
 38+  C601              ship_land0:
 39+  C601 C5               push bc
 40+  C602 7B               ld a,e
 41+  C603 D5               push de                     ; store de for next time round
 42+  C604 FE 01            cp 1                        ; check first time flag
 43+  C606 C2 1B C6         jp nz,ship_land1             ; don't draw over previous one if first time
 44+  C609 CD A0 C6         call ship_draw_full         ; delete old one
 45+  C60C CD 84 C6         call ship_change_frame      ; increment the frame
 46+  C60F ED 4B D9 C5      ld bc,(ship_initpos2)       ; get the current coords
 47+  C613 81 C6 01         add c,1                     ; move down one pixels
 48+  C616 4F               ld c,a
 49+  C617 ED 43 D9 C5      ld (ship_initpos2),bc
 50+  C61B              ship_land1:
 51+  C61B CD A0 C6         call ship_draw_full         ; draw the ship
 52+  C61E CD 99 C6         call ship_draw_screen
 53+  C621 D1               pop de
 54+  C622 1E 01            ld e,1
 55+  C624 C1               pop bc
 56+  C625 10 DA            djnz ship_land0             ; repeat for downward movement
 57+  C627                  ; done moving down
 58+  C627                  ; now move across
 59+  C627 CD C9 C4         call player_drawplayer      ; draw player
 60+  C62A CD A0 C6         call ship_draw_full         ; delete old one
 61+  C62D 1E 00            ld e,0                      ; store a flag to track first time round
 62+  C62F 06 14            ld b,20                      ; move back 20 pixels pixels
 63+  C631              ship_land3:
 64+  C631 C5               push bc
 65+  C632 7B               ld a,e
 66+  C633 D5               push de                     ; store de for next time round
 67+  C634 FE 01            cp 1                        ; check first time flag
 68+  C636 C2 4B C6         jp nz,ship_land2             ; don't draw over previous one if first time
 69+  C639 CD A0 C6         call ship_draw_full         ; delete old one
 70+  C63C CD 84 C6         call ship_change_frame      ; increment the frame
 71+  C63F ED 4B D9 C5      ld bc,(ship_initpos2)       ; get the current coords
 72+  C643 78               ld a,b
 73+  C644 D6 01            sub 1                       ; move back one pixels
 74+  C646 47               ld b,a
 75+  C647 ED 43 D9 C5      ld (ship_initpos2),bc
 76+  C64B              ship_land2:
 77+  C64B CD A0 C6         call ship_draw_full         ; draw the ship
 78+  C64E CD 99 C6         call ship_draw_screen       ; draw the frame to screen by clearing the buffer
 79+  C651 D1               pop de
 80+  C652 1E 01            ld e,1                      ; set e to 1 to indicate >1 time
 81+  C654 C1               pop bc
 82+  C655 10 DA            djnz ship_land3             ; repeat for vertical movement
 83+  C657 C9               ret
 84+  C658
 85+  C658              ;
 86+  C658              ;   Take off the ship
 87+  C658              ;
 88+  C658              ship_takeoff:
 89+  C658 1E 01            ld e,1                      ; store a flag to track first time round
 90+  C65A 06 08            ld b,8                      ; move up 8 pixels
 91+  C65C              ship_takeoff0:
 92+  C65C C5               push bc
 93+  C65D 7B               ld a,e
 94+  C65E D5               push de                     ; store de for next time round
 95+  C65F FE 01            cp 1                        ; check first time flag
 96+  C661 C2 77 C6         jp nz,ship_takeoff1             ; don't draw over previous one if first time
 97+  C664 ED 4B D9 C5      ld bc,(ship_initpos2)       ; get the current coords
 98+  C668 CD A0 C6         call ship_draw_full         ; delete old one
 99+  C66B CD 84 C6         call ship_change_frame      ; increment the frame
100+  C66E ED 4B D9 C5      ld bc,(ship_initpos2)       ; get the current coords
101+  C672 0D               dec c                       ; move up one pixels
102+  C673 ED 43 D9 C5      ld (ship_initpos2),bc
103+  C677              ship_takeoff1:
104+  C677 CD A0 C6         call ship_draw_full         ; draw the ship
105+  C67A CD 99 C6         call ship_draw_screen
106+  C67D D1               pop de
107+  C67E 1E 01            ld e,1
108+  C680 C1               pop bc
109+  C681 10 D9            djnz ship_takeoff0             ; repeat for upward movement
110+  C683                  ; done moving up
111+  C683 C9               ret
112+  C684
113+  C684              ;
114+  C684              ; Swap the animation frame between 0 and 32. This will be added to the memory location later
115+  C684              ;
116+  C684              ship_change_frame:
117+  C684 F5               push af
118+  C685 3A DB C5         ld a,(ship_frame)
119+  C688 FE 00            cp 0
120+  C68A CA 92 C6         jp z,ship_change_frame0
121+  C68D 3E 00            ld a,0                      ; flip to 0
122+  C68F C3 94 C6         jp ship_change_frame1
123+  C692              ship_change_frame0:
124+  C692 3E 20            ld a,32                      ; flip to 32
125+  C694              ship_change_frame1:
126+  C694 32 DB C5         ld (ship_frame),a            ; save the frame
127+  C697 F1               pop af
128+  C698 C9               ret
129+  C699
130+  C699              ship_draw_screen:
131+  C699 76               halt
132+  C69A F3               di
133+  C69B CD 00 A8         call buffer_buffertoscreen  ; copy buffer to screen
134+  C69E FB               ei                          ; enable interupts
135+  C69F C9               ret
136+  C6A0
137+  C6A0              ship_draw_full:
138+  C6A0 21 0B BD         ld hl,ship_sprite
139+  C6A3 ED 4B D9 C5      ld bc,(ship_initpos2)         ; load bc with the start coords
140+  C6A7 22 DC C5         ld (ship_current_sprite),hl  ; put into memory
141+  C6AA ED 43 DE C5      ld (ship_current_coords),bc  ; put into memory
142+  C6AE CD CD C6         call ship_draw
143+  C6B1 08               ex af,af'
144+  C6B2 3A DB C5         ld a,(ship_frame)            ; get the animation frame
145+  C6B5 16 00            ld d,0
146+  C6B7 5F               ld e,a
147+  C6B8 19               add hl,de
148+  C6B9 22 DC C5         ld (ship_current_sprite),hl  ; put into memory
149+  C6BC 08               ex af,af'
150+  C6BD ED 4B D9 C5      ld bc,(ship_initpos2)         ; load bc with the start coords
151+  C6C1 81 C6 08         add c,8                      ; move one line down
152+  C6C4 4F               ld c,a
153+  C6C5 ED 43 DE C5      ld (ship_current_coords),bc  ; put into memory
154+  C6C9 CD CD C6         call ship_draw
155+  C6CC C9               ret
156+  C6CD
157+  C6CD              ;
158+  C6CD              ; Draw the ship
159+  C6CD              ; Inputs:
160+  C6CD              ; None, all in memory
161+  C6CD              ;
162+  C6CD              ship_draw:
163+  C6CD 3E 04            ld a,4                              ; 4 pieces per half
164+  C6CF              ship_draw0:
165+  C6CF F5               push af
166+  C6D0 2A DC C5         ld hl,(ship_current_sprite)
167+  C6D3 ED 4B DE C5      ld bc,(ship_current_coords)         ; load bc with the start coords
168+  C6D7 CD 09 AB         call sprites_drawsprite
169+  C6DA 2A DC C5         ld hl,(ship_current_sprite)
170+  C6DD ED 4B DE C5      ld bc,(ship_current_coords)         ; load bc with the start coords
171+  C6E1 11 08 00         ld de,8
172+  C6E4 19               add hl,de
173+  C6E5 80 C6 08         add b,8
174+  C6E8 47               ld b,a
175+  C6E9 22 DC C5         ld (ship_current_sprite),hl         ; put into memory
176+  C6EC ED 43 DE C5      ld (ship_current_coords),bc         ; put into memory
177+  C6F0 F1               pop af
178+  C6F1 3D               dec a
179+  C6F2 FE 00            cp 0
180+  C6F4 C2 CF C6         jp nz,ship_draw0
181+  C6F7
182+  C6F7 C9               ret
183+  C6F8
# file closed: game/ship.asm
155   C6F8                  include "game\tank.asm"
# file opened: game/tank.asm
  1+  C6F8              ;
  2+  C6F8              ; tank initial position: vert,horiz
  3+  C6F8              ;
  4+  C6F8              tank_initpos:
  5+  C6F8 10 D0            defb 16,208
  6+  C6FA              tank_initpos2:
  7+  C6FA 00 00            defb 0,0
  8+  C6FC              tank_frame:
  9+  C6FC 00               defb 0
 10+  C6FD              tank_anim:
 11+  C6FD 11               defb 17
 12+  C6FE
 13+  C6FE              ;
 14+  C6FE              ; The damage countdown
 15+  C6FE              ;
 16+  C6FE              tank_currentdamage:
 17+  C6FE F0               defb 240
 18+  C6FF
 19+  C6FF              ;
 20+  C6FF              ; The damage coordinate
 21+  C6FF              ;
 22+  C6FF              tank_currentdamagecoord:
 23+  C6FF 16 02            defb 22,2
 24+  C701
 25+  C701              ;
 26+  C701              ; Controls when the tank shoots
 27+  C701              ;
 28+  C701              tank_count:
 29+  C701 00               defb 0
 30+  C702
 31+  C702              ;
 32+  C702              ; Holds the block number of the current damage sprite
 33+  C702              ;
 34+  C702              tank_damageframe:
 35+  C702 00               defb 0
 36+  C703
 37+  C703              ;
 38+  C703              ; The current memory location
 39+  C703              ;
 40+  C703              tank_current_sprite:
 41+  C703 00 00            defb 0,0
 42+  C705
 43+  C705              tank_current_coords:
 44+  C705 00 00            defb 0,0
 45+  C707
 46+  C707              ;
 47+  C707              ; Is the missile displayed - will be 19 if so, 0 if not
 48+  C707              ;
 49+  C707              tank_missile_displayed:
 50+  C707 00               defb 0
 51+  C708
 52+  C708              ;
 53+  C708              ; Initialise the tank
 54+  C708              ;
 55+  C708              tank_init:
 56+  C708 ED 4B F8 C6      ld bc,(tank_initpos)
 57+  C70C ED 43 FA C6      ld (tank_initpos2),bc       ; save the initial position for later use
 58+  C710 21 FC C6         ld hl,tank_frame
 59+  C713 36 00            ld (hl),0
 60+  C715 21 FD C6         ld hl,tank_anim
 61+  C718 36 11            ld (hl),17
 62+  C71A 21 02 C7         ld hl,tank_damageframe              ; reset tank
 63+  C71D 36 00            ld (hl),0
 64+  C71F 21 01 C7         ld hl,tank_count
 65+  C722 36 00            ld (hl),0
 66+  C724 21 FE C6         ld hl,tank_currentdamage
 67+  C727 36 F0            ld (hl),240
 68+  C729 21 FF C6         ld hl,tank_currentdamagecoord
 69+  C72C 36 16            ld (hl),22
 70+  C72E 23               inc hl
 71+  C72F 36 02            ld (hl),2
 72+  C731 21 07 C7         ld hl,tank_missile_displayed
 73+  C734 36 00            ld (hl),0
 74+  C736
 75+  C736 C9               ret
 76+  C737
 77+  C737              ;
 78+  C737              ;   Draw and move the tank
 79+  C737              ;   Start processing at frame 200
 80+  C737              ;   Don't move if anim is zero
 81+  C737              ;   Decrement frame if moved
 82+  C737              ;
 83+  C737              tank_process:
 84+  C737 3A FD C6         ld a,(tank_anim)
 85+  C73A FE 00            cp 0
 86+  C73C C2 43 C7         jp nz,tank_process0         ; fire the tank if we've already moved, or jump to movement
 87+  C73F CD 54 C7         call tank_fire
 88+  C742 C9               ret
 89+  C743              tank_process0:
 90+  C743 CD 77 C3         call game_getcurrentframe   ; get the current frame number into a
 91+  C746 FE 4B            cp 75
 92+  C748 D8               ret c                       ; return if the frame number is below 100
 93+  C749 CD 7A C8         call tank_move              ; move tank if not
 94+  C74C 3A FD C6         ld a,(tank_anim)
 95+  C74F 3D               dec a
 96+  C750 32 FD C6         ld (tank_anim),a            ; decrease the anim count
 97+  C753 C9               ret
 98+  C754
 99+  C754              ;
100+  C754              ; Fires the tank
101+  C754              ;
102+  C754              tank_fire:
103+  C754 3A 01 C7         ld a,(tank_count)            ; if not, don't do anything
104+  C757 3C               inc a                        ; increment
105+  C758 FE 32            cp 50                        ; have we reached fifty
106+  C75A C2 5F C7         jp nz,tank_fire0
107+  C75D 3E 00            ld a,0                       ; reset if reached fifty
108+  C75F              tank_fire0:                      ; DEALING WITH A NEW BLOCK
109+  C75F 32 01 C7         ld (tank_count),a            ; store tank count
110+  C762 FE 00            cp 0
111+  C764 CA 85 C7         jp z,tank_fire7              ; If this is zero, fire
112+  C767 3A 07 C7         ld a,(tank_missile_displayed) ; is the missile displaying?
113+  C76A FE 00            cp 0
114+  C76C C8               ret z                       ; don't do anything if not
115+  C76D CD 34 C8         call tank_missilegraphic     ; if not, overwrite the previous tank missile
116+  C770 3E 00            ld a,0                       ; reset the flag
117+  C772 32 07 C7         ld (tank_missile_displayed),a
118+  C775 3E 02            ld a,2
119+  C777 ED 4B FF C6      ld bc,(tank_currentdamagecoord)
120+  C77B 0C               inc c
121+  C77C 0C               inc c
122+  C77D ED 43 20 AC      ld (origcoords),bc
123+  C781 CD 25 A7         call buffer_marklineforupdate
124+  C784 C9               ret                        ; only shoot if we're on 0
125+  C785              tank_fire7:
126+  C785 3A FE C6         ld a,(tank_currentdamage)    ; get the damage countdown
127+  C788 E6 07            and 7                       ; check if multiple of 8 - house keeping when moving onto a new block
128+  C78A C2 C0 C7         jp nz,tank_fire1            ; not, so just do a normal frame
129+  C78D ED 4B FF C6      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
130+  C791 79               ld a,c
131+  C792 FE 0A            cp 10
132+  C794 C2 9B C7         jp nz, tank_fire6
133+  C797 CD 6C C8         call tank_killedbytank      ; we're through, so the player has died. Kill them.
134+  C79A C9               ret                         ; return if we're through the mountain
135+  C79B              tank_fire6:
136+  C79B 3E 0F            ld a,15
137+  C79D 32 02 C7         ld (tank_damageframe),a     ; reset the damage frame
138+  C7A0 21 9F BB         ld hl,sprites               ; location of the empty block
139+  C7A3 CD 61 AA         call screen_showchar        ; show this character here
140+  C7A6 ED 4B FF C6      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
141+  C7AA 05               dec b                       ; look one above
142+  C7AB CD C5 AA         call screen_ischarempty     ; check if it is empty
143+  C7AE ED 4B FF C6      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc again
144+  C7B2 FE 01            cp 1
145+  C7B4 C2 F7 C7         jp nz,tank_fire2             ; block above isn't empty, so can't move on, copy down above blocks
146+  C7B7 ED 4B FF C6      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
147+  C7BB 0D               dec c
148+  C7BC ED 43 FF C6      ld (tank_currentdamagecoord),bc ; store the coord
149+  C7C0              tank_fire1:                         ; DEALING WITH NORMAL DAMAGE
150+  C7C0 ED 4B FF C6      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
151+  C7C4 3A FE C6         ld a,(tank_currentdamage)    ; get the damage countdown
152+  C7C7 E6 07            and 7                       ; is it a multiple of 8? only want to do the first line check then
153+  C7C9 C2 D4 C7         jp nz, tank_fire5
154+  C7CC CD F5 AA         call screen_getcharfirstbyte    ; get the first byte to check if this is a slope
155+  C7CF FE FF            cp 255                      ; if it's a full line, it will be 255 and not a slope
156+  C7D1 C2 15 C8         jp nz,tank_fire3            ; if it's a slope, handle this differently
157+  C7D4              tank_fire5:
158+  C7D4 3A 02 C7         ld a,(tank_damageframe)
159+  C7D7 CD 84 AA         call screen_getblock        ; get the block data into hl
160+  C7DA CD 61 AA         call screen_showchar        ; show this character here
161+  C7DD 3A 02 C7         ld a,(tank_damageframe)
162+  C7E0 3C               inc a
163+  C7E1 32 02 C7         ld (tank_damageframe),a     ; increment the damage block and store
164+  C7E4 3A FE C6         ld a,(tank_currentdamage)    ; get the damage countdown
165+  C7E7 3D               dec a
166+  C7E8 3D               dec a
167+  C7E9 32 FE C6         ld (tank_currentdamage),a     ; decrease current damage by 2 and store
168+  C7EC 3A 07 C7         ld a,(tank_missile_displayed) ; is the missile displaying?
169+  C7EF FE 00            cp 0
170+  C7F1 CC 34 C8         call z, tank_missilegraphic
171+  C7F4 C3 1E C8         jp tank_fire4
172+  C7F7              tank_fire2:                     ; DEALING WITH COPYING BLOCKS FROM ABOVE
173+  C7F7 05               dec b
174+  C7F8 C5               push bc
175+  C7F9 CD DE AA         call screen_copyblockdown       ; copy the block down
176+  C7FC ED 4B FF C6      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
177+  C800 C1               pop bc                      ; get the coord we just checked back
178+  C801 78               ld a,b
179+  C802 FE 00            cp 0
180+  C804 CA C0 C7         jp z,tank_fire1             ; if we're at the top of the screen, don't check any more
181+  C807 C5               push bc
182+  C808 05               dec b
183+  C809 CD C5 AA         call screen_ischarempty     ; check if it is empty
184+  C80C C1               pop bc
185+  C80D FE 01            cp 1                        ; if empty
186+  C80F C2 F7 C7         jp nz, tank_fire2            ; copy another one down
187+  C812 C3 C0 C7         jp tank_fire1               ; otherwise, return to main thread
188+  C815              tank_fire3:                      ; dealing with slopes
189+  C815 3A FE C6         ld a,(tank_currentdamage)    ; get the damage countdown
190+  C818 06 08            ld b,8
191+  C81A 90               sub b                        ; special case for slopes
192+  C81B 32 FE C6         ld (tank_currentdamage),a    ; decrease the damage countdown by 8, so that next time, we get rid of this block without eroding it
193+  C81E              tank_fire4:                     ; TIDY UP
194+  C81E ED 4B FF C6      ld bc,(tank_currentdamagecoord)
195+  C822 ED 43 20 AC      ld (origcoords),bc
196+  C826 CD 25 A7         call buffer_marklineforupdate
197+  C829 3E 01            ld a,1
198+  C82B CD 25 A7         call buffer_marklineforupdate
199+  C82E 3E 02            ld a,2
200+  C830 CD 25 A7         call buffer_marklineforupdate
201+  C833 C9               ret
202+  C834
203+  C834              ;
204+  C834              ; Displays or hides the missile graphic, and changes the gun
205+  C834              ;
206+  C834              tank_missilegraphic:
207+  C834 3A 07 C7         ld a,(tank_missile_displayed)
208+  C837 FE 00            cp 0
209+  C839 C2 41 C8         jp nz,tank_missilegraphic0
210+  C83C 3E 13            ld a,19
211+  C83E C3 43 C8         jp tank_missilegraphic1
212+  C841              tank_missilegraphic0:
213+  C841 3E 00            ld a,0
214+  C843              tank_missilegraphic1:
215+  C843 32 07 C7         ld (tank_missile_displayed),a ; store the flipped graphic
216+  C846 ED 4B FF C6      ld bc,(tank_currentdamagecoord)
217+  C84A 0C               inc c
218+  C84B 0C               inc c                   ; print the graphic 2 spaces right
219+  C84C CD 84 AA         call screen_getblock        ; get the block data into hl
220+  C84F CD 61 AA         call screen_showchar        ; show this character here
221+  C852 06 02            ld b,2
222+  C854 0E 18            ld c,24                     ; set gunbarrel coords
223+  C856 11 00 00         ld de,0
224+  C859 21 6B BD         ld hl,tank_sprite           ; set hl to gunbarrel gfx, shooting is +64
225+  C85C 3A 07 C7         ld a,(tank_missile_displayed)
226+  C85F FE 00            cp 0
227+  C861 CA 67 C8         jp z,tank_missilegraphic2
228+  C864 11 40 00         ld de,64
229+  C867              tank_missilegraphic2:
230+  C867 19               add hl,de                   ; work out missile graphic
231+  C868 CD 61 AA         call screen_showchar        ; show this character here
232+  C86B C9               ret
233+  C86C
234+  C86C              ;
235+  C86C              ; Deal with the player being killed by the tank
236+  C86C              ;
237+  C86C              tank_killedbytank:
238+  C86C ED 4B FF C6      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
239+  C870 21 9F BB         ld hl,sprites                   ; empty sprite
240+  C873 CD 61 AA         call screen_showchar            ; hide the last piece of dirt
241+  C876 CD B1 C4         call player_tankkillplayer
242+  C879 C9               ret
243+  C87A
244+  C87A              tank_move:
245+  C87A ED 4B FA C6      ld bc,(tank_initpos2)
246+  C87E C5               push bc
247+  C87F 3A FD C6         ld a,(tank_anim)
248+  C882 FE 11            cp 17                       ; check first time flag
249+  C884 CA 96 C8         jp z,tank_move1             ; don't draw over previous one if first time
250+  C887 CD 9B C8         call tank_draw_full         ; delete old one
251+  C88A ED 4B FA C6      ld bc,(tank_initpos2)       ; get the current coords
252+  C88E 78               ld a,b
253+  C88F D6 01            sub 1                       ; move back one pixels
254+  C891 47               ld b,a
255+  C892 ED 43 FA C6      ld (tank_initpos2),bc
256+  C896              tank_move1:
257+  C896 CD 9B C8         call tank_draw_full         ; draw the tank
258+  C899 C1               pop bc
259+  C89A C9               ret
260+  C89B
261+  C89B              tank_draw_full:
262+  C89B 21 6B BD         ld hl,tank_sprite
263+  C89E ED 4B FA C6      ld bc,(tank_initpos2)         ; load bc with the start coords
264+  C8A2 22 03 C7         ld (tank_current_sprite),hl  ; put into memory
265+  C8A5 ED 43 05 C7      ld (tank_current_coords),bc  ; put into memory
266+  C8A9 CD C8 C8         call tank_draw
267+  C8AC 08               ex af,af'
268+  C8AD 3A FC C6         ld a,(tank_frame)            ; get the animation frame
269+  C8B0 16 00            ld d,0
270+  C8B2 5F               ld e,a
271+  C8B3 19               add hl,de
272+  C8B4 22 03 C7         ld (tank_current_sprite),hl  ; put into memory
273+  C8B7 08               ex af,af'
274+  C8B8 ED 4B FA C6      ld bc,(tank_initpos2)         ; load bc with the start coords
275+  C8BC 81 C6 08         add c,8                      ; move one line down
276+  C8BF 4F               ld c,a
277+  C8C0 ED 43 05 C7      ld (tank_current_coords),bc  ; put into memory
278+  C8C4 CD C8 C8         call tank_draw
279+  C8C7 C9               ret
280+  C8C8
281+  C8C8              ;
282+  C8C8              ; Draw the tank
283+  C8C8              ; Inputs:
284+  C8C8              ; None, all in memory
285+  C8C8              ;
286+  C8C8              tank_draw:
287+  C8C8 3E 04            ld a,4                              ; 4 pieces per half
288+  C8CA              tank_draw0:
289+  C8CA F5               push af
290+  C8CB 2A 03 C7         ld hl,(tank_current_sprite)
291+  C8CE ED 4B 05 C7      ld bc,(tank_current_coords)         ; load bc with the start coords
292+  C8D2 CD 09 AB         call sprites_drawsprite
293+  C8D5 2A 03 C7         ld hl,(tank_current_sprite)
294+  C8D8 ED 4B 05 C7      ld bc,(tank_current_coords)         ; load bc with the start coords
295+  C8DC 11 08 00         ld de,8
296+  C8DF 19               add hl,de
297+  C8E0 80 C6 08         add b,8
298+  C8E3 47               ld b,a
299+  C8E4 22 03 C7         ld (tank_current_sprite),hl         ; put into memory
300+  C8E7 ED 43 05 C7      ld (tank_current_coords),bc         ; put into memory
301+  C8EB F1               pop af
302+  C8EC 3D               dec a
303+  C8ED FE 00            cp 0
304+  C8EF C2 CA C8         jp nz,tank_draw0
305+  C8F2
306+  C8F2 C9               ret
307+  C8F3
# file closed: game/tank.asm
156   C8F3                  include "game\rocks.asm"
# file opened: game/rocks.asm
  1+  C8F3              ;
  2+  C8F3              ; A structure of falling rocks
  3+  C8F3              ; Assume we'll never have more than 4 falling at any one time
  4+  C8F3              ; (1,2 - 16 bit memory location for rock graphic),state (0 fell, 1 falling, 2 wobbling), countdown
  5+  C8F3              ;
  6+  C8F3              rocks_falling:
  7+  C8F3 00 00 00 00      defb 0,0,0,0
  8+  C8F7 00 00 00 00      defb 0,0,0,0
  9+  C8FB 00 00 00 00      defb 0,0,0,0
 10+  C8FF 00 00 00 00      defb 0,0,0,0
 11+  C903
 12+  C903              rocks_tmp:
 13+  C903 00               defb 0
 14+  C904
 15+  C904              rocks_tmp2:
 16+  C904 00 00            defb 0,0
 17+  C906
 18+  C906              ;
 19+  C906              ; The number of frames to wobble for
 20+  C906              ; Must always be 10 more than the number of frames a player digs
 21+  C906              ;
 22+  C906              rocks_numberofframestowobble:
 23+  C906 14               defb 20
 24+  C907
 25+  C907              ;
 26+  C907              ; Coords of the rock that killed us
 27+  C907              ;
 28+  C907              rocks_killerrock:
 29+  C907 00 00            defb 0,0
 30+  C909
 31+  C909              ;
 32+  C909              ; Checks for a rock that needs to start falling. Takes a memory location of the first line at the bottom of the space.
 33+  C909              ; Checks to see if the pixel row in that location is a rock bottom. If it is, mark this rock as ready to fall.
 34+  C909              ; If the pixel row is not the rock bottom, stop checking.
 35+  C909              ; Inputs:
 36+  C909              ; hl- memory location
 37+  C909              ;
 38+  C909              rocks_checkforfalling:
 39+  C909 7E               ld a,(hl)           ; get the pixel row in this memory location
 40+  C90A FE 7E            cp 126              ; check against the bottom pixel row of the rock graphic
 41+  C90C C2 12 C9         jp nz,rocks_checkforfalling2 ; not a rock, stop
 42+  C90F CD 13 C9         call rocks_addrocktofalling ; mark the rock as falling
 43+  C912              rocks_checkforfalling2:
 44+  C912 C9               ret
 45+  C913
 46+  C913              ;
 47+  C913              ; Adds the rock to the structure that tracks falling rocks
 48+  C913              ; Inputs:
 49+  C913              ; hl - memory location of falling rock graphic
 50+  C913              ; bc - coords of rock, c vert
 51+  C913              rocks_addrocktofalling:
 52+  C913 C5               push bc             ; store the coords
 53+  C914 11 F3 C8         ld de,rocks_falling
 54+  C917 06 04            ld b,4              ; number of possible falling rocks
 55+  C919              rocks_addrocktofalling0:
 56+  C919 13               inc de
 57+  C91A                  ;inc de
 58+  C91A 13               inc de              ; move three along to get the state
 59+  C91B 1A               ld a,(de)           ; load the state
 60+  C91C FE 00            cp 0                ; check if this is not falling
 61+  C91E C2 35 C9         jp nz,rocks_addrocktofalling1 ; continue the loop if not 0
 62+  C921 13               inc de              ; move to frame
 63+  C922 3A 06 C9         ld a,(rocks_numberofframestowobble) ; load the number of frames to wobble
 64+  C925 12               ld (de),a
 65+  C926 1B               dec de              ; move de back to state
 66+  C927 3E 02            ld a,2
 67+  C929 12               ld (de),a           ; set the state to wobbling
 68+  C92A 1B               dec de              ; move back coords
 69+  C92B C1               pop bc              ; get back coords
 70+  C92C 78               ld a,b
 71+  C92D 12               ld (de),a           ; store the vertical
 72+  C92E 1B               dec de
 73+  C92F 79               ld a,c
 74+  C930 12               ld (de),a           ; store the horizontal
 75+  C931 C5               push bc
 76+  C932 C3 39 C9         jp rocks_addrocktofalling2 ; done
 77+  C935              rocks_addrocktofalling1:
 78+  C935 13               inc de
 79+  C936 13               inc de              ; move memory along to next rock
 80+  C937 10 E0            djnz rocks_addrocktofalling0 ; try the next rock
 81+  C939              rocks_addrocktofalling2: ; done, return
 82+  C939 C1               pop bc              ; to tidy up
 83+  C93A C9               ret
 84+  C93B
 85+  C93B              ;
 86+  C93B              ; Processes any falling rocks
 87+  C93B              ;
 88+  C93B              rocks_processrocks:
 89+  C93B DD 21 F3 C8      ld ix,rocks_falling
 90+  C93F 06 04            ld b,4              ; the number of rocks to check
 91+  C941              rocks_processrocks0:
 92+  C941 C5               push bc             ; store loop count
 93+  C942 DD 4E 00 DD      ld bc,(ix)          ; load the coords for this rock into bc
 93+  C946 46 01
 94+  C948 DD 23            inc ix
 95+  C94A DD 23            inc ix              ; move to the state
 96+  C94C DD 7E 00         ld a,(ix)           ; load the state into a
 97+  C94F FE 00            cp 0
 98+  C951 CA 72 C9         jp z,rocks_processrocks3 ; if not falling, check next
 99+  C954 FE 02            cp 2
100+  C956 C2 66 C9         jp nz, rocks_processrocks2
101+  C959                  ; we're wobbling
102+  C959 DD 23            inc ix              ; get frame number for wobble
103+  C95B DD 7E 00         ld a,(ix)           ; get wobble frame into a
104+  C95E CD 35 CA         call rocks_wobble
105+  C961 DD 23            inc ix              ; increment for next
106+  C963 C3 76 C9         jp rocks_processrocks1  ; do next rock
107+  C966              rocks_processrocks2:
108+  C966                  ; we're falling
109+  C966 C5               push bc
110+  C967 CD 7A C9         call rocks_fall
111+  C96A C1               pop bc
112+  C96B DD 23            inc ix
113+  C96D DD 23            inc ix              ; inc ix to get to next
114+  C96F C3 76 C9         jp rocks_processrocks1
115+  C972              rocks_processrocks3:
116+  C972 DD 23            inc ix
117+  C974 DD 23            inc ix
118+  C976              rocks_processrocks1:
119+  C976 C1               pop bc              ; get loop count back
120+  C977 10 C8            djnz rocks_processrocks0
121+  C979 C9               ret
122+  C97A
123+  C97A              ;
124+  C97A              ; Falls a rock one pixel, checks the next square down to see if it is empty, if not, stop falling
125+  C97A              ; bc - coord of current rock graphic on screen
126+  C97A              ; ix - memory location of current rock in rock list, currently at the 3rd position (rock state)
127+  C97A              ;
128+  C97A              rocks_fall:
129+  C97A DD 2B            dec ix
130+  C97C DD 2B            dec ix              ; decrease ix back to coords
131+  C97E ED 43 04 C9      ld (rocks_tmp2),bc  ; store original coords
132+  C982 3E 03            ld a,3              ; move this number of pixels
133+  C984              rocks_fall1:
134+  C984 32 03 C9         ld (rocks_tmp),a    ; store loop counter
135+  C987 DD 4E 00 DD      ld bc,(ix)          ; get current coords
135+  C98B 46 01
136+  C98D CD FE AB         call sprites_scadd  ; get the memory of the coords into de
137+  C990 14               inc d               ; add 256 to get next row
138+  C991 1A               ld a,(de)           ; get the contents of the next row
139+  C992 FE 00            cp 0
140+  C994 C2 F4 C9         jp nz,rocks_fall3    ; move the rock if the row is empty
141+  C997 0C               inc c               ; increment the vertical
142+  C998 DD 71 00 DD      ld (ix),bc          ; store the new coords
142+  C99C 70 01
143+  C99E 79               ld a,c              ; get the vertical coord into a
144+  C99F E6 07            and 7               ; divisible by 8?
145+  C9A1 FE 00            cp 0
146+  C9A3 C2 C0 C9         jp nz,rocks_fall4   ; if not, carry on
147+  C9A6 CD 37 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
148+  C9A9 3E 42            ld a,66             ; load red
149+  C9AB CD 8F AA         call screen_setattr
150+  C9AE DD 4E 00 DD      ld bc,(ix)
150+  C9B2 46 01
151+  C9B4 79               ld a,c              ; get vertical
152+  C9B5 D6 08            sub 8               ; look up one square
153+  C9B7 4F               ld c,a              ; put a back in c
154+  C9B8 CD 37 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
155+  C9BB 3E 46            ld a,70             ; load yellow
156+  C9BD CD 8F AA         call screen_setattr
157+  C9C0              rocks_fall4:
158+  C9C0 3A 03 C9         ld a,(rocks_tmp)    ; get the loop counter
159+  C9C3 3D               dec a
160+  C9C4 FE 00            cp 0
161+  C9C6 C2 84 C9         jp nz,rocks_fall1   ; do another pixel if needed
162+  C9C9              rocks_fall2:
163+  C9C9 3E 09            ld a,9              ; rock graphic
164+  C9CB ED 4B 04 C9      ld bc,(rocks_tmp2)  ; get the original coords
165+  C9CF CD 84 AA         call screen_getblock     ; get the memory into hl
166+  C9D2 CD 09 AB         call sprites_drawsprite  ; draw the sprite - over the top of the current one
167+  C9D5 3E 09            ld a,9
168+  C9D7 DD 4E 00 DD      ld bc,(ix)          ; get the new coords
168+  C9DB 46 01
169+  C9DD CD 84 AA         call screen_getblock     ; get the memory into hl
170+  C9E0 CD 09 AB         call sprites_drawsprite  ; draw the sprite - over the top of the current one
171+  C9E3 DD 4E 00 DD      ld bc,(ix)          ; get the coords again
171+  C9E7 46 01
172+  C9E9 CD 1A CA         call rocks_checkforplayer ; check to see if we hit a player
173+  C9EC DD 23            inc ix
174+  C9EE DD 23            inc ix                  ; get ix back to state
175+  C9F0 CD 0A CA         call rocks_makesound
176+  C9F3 C9               ret
177+  C9F4              rocks_fall3:
178+  C9F4 3E 00            ld a,0              ; set the state to fell
179+  C9F6 DD 77 02         ld (ix+2),a           ; store the falling state
180+  C9F9 DD 4E 00 DD      ld bc,(ix)          ; get the coords
180+  C9FD 46 01
181+  C9FF CD 37 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
182+  CA02 3E 42            ld a,66             ; load magenta
183+  CA04 CD 8F AA         call screen_setattr
184+  CA07 C3 C9 C9         jp rocks_fall2      ; rejoin main loop
185+  CA0A
186+  CA0A              ;
187+  CA0A              ; Makes the rock sound if we're no longer falling, and if we didn't hit a player
188+  CA0A              ;
189+  CA0A              rocks_makesound:
190+  CA0A DD 7E 00         ld a,(ix)           ; get the state
191+  CA0D FE 00            cp 0
192+  CA0F C0               ret nz              ; if we haven't fallen, don't do anything
193+  CA10 21 93 C3         ld hl,player+11
194+  CA13 7E               ld a,(hl)
195+  CA14 FE 01            cp 1
196+  CA16 C4 E9 B0         call nz, sound_rockfell ; only make sound if didn't kill player
197+  CA19 C9               ret
198+  CA1A
199+  CA1A              ;
200+  CA1A              ; Checks to see if the rock is hitting a player
201+  CA1A              ; Inputs:
202+  CA1A              ; bc - coords of rock we're checking
203+  CA1A              rocks_checkforplayer:
204+  CA1A ED 5B 88 C3      ld de,(player)       ; get the player coords
205+  CA1E 7B               ld a,e               ; get the vert coord first
206+  CA1F 91               sub c                ; subtract the rock vertical coord from players
207+  CA20 FE 08            cp 8                 ; the rock will only hit a player if the player is directly underneath, so this must be 8
208+  CA22 C0               ret nz               ; if not, hasn't hit
209+  CA23 7A               ld a,d               ; get the player horiz coord
210+  CA24 90               sub b                ; subtract rock coord
211+  CA25 C6 07            add 7                ; add max distance
212+  CA27 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
213+  CA29 DA 2D CA         jp c,rocks_checkforplayer0
214+  CA2C C9               ret
215+  CA2D              rocks_checkforplayer0:
216+  CA2D ED 43 07 C9      ld (rocks_killerrock),bc; store the coords of the killer rock
217+  CA31 CD AB C4         call player_crushplayer ; if so, jump out
218+  CA34 C9               ret
219+  CA35
220+  CA35              ;
221+  CA35              ; Wobbles a rocks
222+  CA35              ; Inputs:
223+  CA35              ; bc - coord of current rock graphic on screen
224+  CA35              ; ix - memory location of current rock in rock list, currently at the 4th position (wobble count)
225+  CA35              ; a - wobble frame
226+  CA35              rocks_wobble:
227+  CA35 DD 7E 00         ld a,(ix)           ; get the wobble count, which we'll use as frame toggle
228+  CA38 E6 01            and 1               ; is it odd or even, gets 1 or 0
229+  CA3A 1E 09            ld e,9              ; this is the rock frame
230+  CA3C 83               add a,e             ; add the frame toggle
231+  CA3D C5               push bc
232+  CA3E CD 84 AA         call screen_getblock     ; get the memory into hl
233+  CA41 CD 09 AB         call sprites_drawsprite  ; draw the sprite - over the top of the current one
234+  CA44 DD 7E 00         ld a,(ix)           ; get the frame toggle again
235+  CA47 3D               dec a               ; decrease
236+  CA48 DD 77 00         ld (ix),a           ; store
237+  CA4B E6 01            and 1
238+  CA4D 1E 09            ld e,9              ; this is the rock frame
239+  CA4F 83               add a,e             ; add the frame toggle
240+  CA50 CD 84 AA         call screen_getblock     ; get the memory into hl
241+  CA53 C1               pop bc
242+  CA54 CD 09 AB         call sprites_drawsprite  ; draw the sprite again with the new frame - next time it will do the opposite
243+  CA57 DD 7E 00         ld a,(ix)           ; get the wobble count back
244+  CA5A FE 00            cp 0
245+  CA5C C0               ret nz              ; if we're not at zero, return
246+  CA5D DD 2B            dec ix              ; otherwise look to state location
247+  CA5F 3E 01            ld a,1              ; set the state to falling
248+  CA61 DD 77 00         ld (ix),a           ; store the falling state
249+  CA64 DD 23            inc ix              ; set ix back to location of wobble count, and we're done
250+  CA66 C9               ret
251+  CA67
# file closed: game/rocks.asm
157   CA67                  include "game\scores.asm"
# file opened: game/scores.asm
  1+  CA67              ;
  2+  CA67              ; The score of the current player
  3+  CA67              ;
  4+  CA67              scores_current:
  5+  CA67 04 01 30 30      defb 4,1,'000000',255       ;+2
  5+  CA6B 30 30 30 30
  5+  CA6F FF
  6+  CA70
  7+  CA70              scores_defaultname:
  8+  CA70 2D 2D 2D         defb '---'
  9+  CA73
 10+  CA73              ;
 11+  CA73              ; The current high score table
 12+  CA73              ;
 13+  CA73              scores_table:
 14+  CA73 03 17 47 41      defb 03,23,'GAM000000',255         ;+0, +2, +5
 14+  CA77 4D 30 30 30
 14+  CA7B 30 30 30 FF
 15+  CA7F 0C 17 47 41      defb 12,23,'GAM000000',255        ;+12, +14, +17
 15+  CA83 4D 30 30 30
 15+  CA87 30 30 30 FF
 16+  CA8B 15 17 47 41      defb 21,23,'GAM000000',255        ;+24, +26, +29
 16+  CA8F 4D 30 30 30
 16+  CA93 30 30 30 FF
 17+  CA97
 18+  CA97              ;
 19+  CA97              ; Add thousands to the score
 20+  CA97              ; Inputs:
 21+  CA97              ; b - number to add
 22+  CA97              ;
 23+  CA97              scores_addthousands:
 24+  CA97 21 6B CA         ld hl,scores_current+4
 25+  CA9A CD FB CA         call scores_update
 26+  CA9D C9               ret
 27+  CA9E
 28+  CA9E              ;
 29+  CA9E              ; Add hundreds to the score
 30+  CA9E              ; Inputs:
 31+  CA9E              ; b - number to add
 32+  CA9E              ;
 33+  CA9E              scores_addhundreds:
 34+  CA9E 21 6C CA         ld hl,scores_current+5
 35+  CAA1 CD FB CA         call scores_update
 36+  CAA4 C9               ret
 37+  CAA5
 38+  CAA5              ;
 39+  CAA5              ; Temporary area for printing scores
 40+  CAA5              ;
 41+  CAA5              scores_printscore_tmp:
 42+  CAA5 00 00 00 00      defb 0,0,0,0,0,0,0,0,255
 42+  CAA9 00 00 00 00
 42+  CAAD FF
 43+  CAAE
 44+  CAAE              ;
 45+  CAAE              ; Prints the score to screen
 46+  CAAE              ;
 47+  CAAE              scores_printscore:
 48+  CAAE 3A 48 C3         ld a,(game_currentplayer)   ; get current player
 49+  CAB1 21 67 CA         ld hl,scores_current
 50+  CAB4 FE 01            cp 1
 51+  CAB6 C2 BE CA         jp nz, score_printscore0    ; if not player 1
 52+  CAB9 36 04            ld (hl),4       ; set position for player 1
 53+  CABB C3 C0 CA         jp score_printscore1
 54+  CABE              score_printscore0:
 55+  CABE 36 16            ld (hl),22       ; set position for player 2
 56+  CAC0              score_printscore1:
 57+  CAC0 CD C4 CA         call score_printscoreformatted
 58+  CAC3 C9               ret
 59+  CAC4
 60+  CAC4              ;
 61+  CAC4              ; Formats a score and prints to the top screen
 62+  CAC4              ; Inputs:
 63+  CAC4              ; hl - where is the score
 64+  CAC4              score_printscoreformatted:
 65+  CAC4 01 08 00         ld bc,8
 66+  CAC7 11 A5 CA         ld de,scores_printscore_tmp
 67+  CACA ED B0            ldir                        ; copy to temp
 68+  CACC 21 A5 CA         ld hl,scores_printscore_tmp
 69+  CACF E5 DD E1         ld ix,hl
 70+  CAD2 DD 7E 02         ld a,(ix+2)
 71+  CAD5 FE 30            cp 48                   ; is it a leading zero?
 72+  CAD7 C2 EA CA         jp nz,score_printscore2
 73+  CADA DD 36 02 20      ld (ix+2),32              ; load it with a space
 74+  CADE DD 7E 03         ld a,(ix+3)
 75+  CAE1 FE 30            cp 48                   ; is it a leading zero?
 76+  CAE3 C2 EA CA         jp nz,score_printscore2
 77+  CAE6 DD 36 03 20      ld (ix+3),32              ; load it with a space
 78+  CAEA              score_printscore2:
 79+  CAEA CD 25 86         call string_print
 80+  CAED C9               ret
 81+  CAEE
 82+  CAEE              ;
 83+  CAEE              ; Prints both scores to screen
 84+  CAEE              ;
 85+  CAEE              scores_printscores:
 86+  CAEE 21 91 C4         ld hl,player1_score
 87+  CAF1 CD C4 CA         call score_printscoreformatted
 88+  CAF4 21 9A C4         ld hl,player2_score
 89+  CAF7 CD C4 CA         call score_printscoreformatted
 90+  CAFA C9               ret
 91+  CAFB
 92+  CAFB              ;
 93+  CAFB              ; Updates the current score.
 94+  CAFB              ; Inputs:
 95+  CAFB              ; hl - memory location of the score column
 96+  CAFB              ; b - number to add
 97+  CAFB              ;
 98+  CAFB              scores_update:
 99+  CAFB 7E               ld a,(hl)           ; current value of digit.
100+  CAFC 80               add a,b             ; add points to this digit.
101+  CAFD 77               ld (hl),a           ; place new digit back in string.
102+  CAFE FE 3A            cp 58               ; more than ASCII value '9'?
103+  CB00 D8               ret c               ; no - relax.
104+  CB01 D6 0A            sub 10              ; subtract 10.
105+  CB03 77               ld (hl),a           ; put new character back in string.
106+  CB04              scores_update0:
107+  CB04 2B               dec hl              ; previous character in string.
108+  CB05 34               inc (hl)            ; up this by one.
109+  CB06 7E               ld a,(hl)           ; what's the new value?
110+  CB07 FE 3A            cp 58               ; gone past ASCII nine?
111+  CB09 D8               ret c               ; no, scoring done.
112+  CB0A D6 0A            sub 10              ; down by ten.
113+  CB0C 77               ld (hl),a           ; put it back
114+  CB0D C3 04 CB         jp scores_update0   ; go round again.
115+  CB10
116+  CB10
117+  CB10              ;
118+  CB10              ; Temporary area to store score
119+  CB10              ;
120+  CB10              scores_showtable_tmp:
121+  CB10 00 00 00 00      defb 0,0,0,0,0,0,0,0,0,0,0,255
121+  CB14 00 00 00 00
121+  CB18 00 00 00 FF
122+  CB1C
123+  CB1C              ;
124+  CB1C              ; Processes a score
125+  CB1C              ; Inputs:
126+  CB1C              ; hl - location on table
127+  CB1C              ;
128+  CB1C              scores_showtable_process:
129+  CB1C 01 0B 00         ld bc,11                     ; copy this many
130+  CB1F 11 10 CB         ld de,scores_showtable_tmp
131+  CB22 ED B0            ldir
132+  CB24 DD 21 10 CB      ld ix,scores_showtable_tmp   ; decide whether to show five or six numbers
133+  CB28 DD 7E 05         ld a,(ix+5)
134+  CB2B FE 30            cp 48                        ; is this a zero?
135+  CB2D C2 43 CB         jp nz,scores_showtable_process0 ; if not, show the whole thing
136+  CB30 01 05 00         ld bc,5                      ; copy this many
137+  CB33 DD E5 E1         ld hl,ix
138+  CB36 11 06 00         ld de,6
139+  CB39 19               add hl,de                    ; move to second digit
140+  CB3A 54 5D            ld de,hl
141+  CB3C 1B               dec de
142+  CB3D ED B0            ldir
143+  CB3F DD 36 0A 20      ld (ix+10),32                ; stick a space at the end
144+  CB43              scores_showtable_process0:
145+  CB43 21 10 CB         ld hl,scores_showtable_tmp
146+  CB46 CD 25 86         call string_print
147+  CB49 C9               ret
148+  CB4A
149+  CB4A              ;
150+  CB4A              ; Displays the high score table at the bottom of the screen
151+  CB4A              ;
152+  CB4A              scores_showtable:
153+  CB4A 21 73 CA         ld hl, scores_table
154+  CB4D CD 1C CB         call scores_showtable_process
155+  CB50 21 7F CA         ld hl, scores_table+12
156+  CB53 CD 1C CB         call scores_showtable_process
157+  CB56 21 8B CA         ld hl, scores_table+24
158+  CB59 CD 1C CB         call scores_showtable_process
159+  CB5C C9               ret
160+  CB5D
161+  CB5D              ;
162+  CB5D              ; Place to store the current position we're checking
163+  CB5D              ;
164+  CB5D              scores_highscoretmp:
165+  CB5D 00               defb 0
166+  CB5E
167+  CB5E              ;
168+  CB5E              ; Place to store the equal indicator
169+  CB5E              ;
170+  CB5E              scores_highscoretmp2:
171+  CB5E 00               defb 0
172+  CB5F
173+  CB5F              ;
174+  CB5F              ; Updates the highscore table. Start at bottom score. Work way from left. Compare each digit. If current is higher than one we're checking,
175+  CB5F              ; copy checking one down (or erase) then copy current over that one. Then move up one and do the same
176+  CB5F              ;
177+  CB5F              scores_processhighscores:
178+  CB5F 21 5D CB         ld hl,scores_highscoretmp
179+  CB62 36 00            ld (hl),0  ; load up the tracking byte with 0 (ie, not on the table)
180+  CB64 3E 1D            ld a,29
181+  CB66              scores_processhighscores3:
182+  CB66 21 73 CA         ld hl,scores_table          ; position of first score column
183+  CB69 5F               ld e,a
184+  CB6A 16 00            ld d,0
185+  CB6C 19               add hl,de
186+  CB6D 08               ex af,af'                   ; store a for later
187+  CB6E 11 69 CA         ld de,scores_current+2      ; position of current score column
188+  CB71 3E 01            ld a,1
189+  CB73 32 5E CB         ld (scores_highscoretmp2),a ; set the equal indicator to 1 - this will be set to zero if a different number is found
190+  CB76 06 06            ld b,6                      ; times to loop
191+  CB78              scores_processhighscores0:
192+  CB78 7E               ld a,(hl)
193+  CB79 4F               ld c,a                      ; get first score column
194+  CB7A 1A               ld a,(de)                   ; get first current column
195+  CB7B B9               cp c                        ; compare current with first
196+  CB7C DA 9E CB         jp c,scores_processhighscores4  ; if c is bigger, then this is not a higher score, so end
197+  CB7F CA 87 CB         jp z,scores_processhighscores5  ; if c is equal, then this is not a higher score, so end
198+  CB82 3E 00            ld a,0
199+  CB84 32 5E CB         ld (scores_highscoretmp2),a ; zero the equality indicator
200+  CB87              scores_processhighscores5:
201+  CB87 23               inc hl
202+  CB88 13               inc de                      ; move to next column
203+  CB89 10 ED            djnz scores_processhighscores0 ; loop
204+  CB8B 3A 5E CB         ld a,(scores_highscoretmp2)   ; get the equality indicator
205+  CB8E FE 01            cp 1
206+  CB90 CA 9E CB         jp z,scores_processhighscores4 ; if it is equal, not a highscore
207+  CB93 B7               or a                            ; clear the carry flag
208+  CB94 08               ex af,af'                     ; still here, so must be bigger
209+  CB95 32 5D CB         ld (scores_highscoretmp),a  ; store the position indicator in the tracking byte
210+  CB98 0E 0C            ld c,12
211+  CB9A 91               sub c
212+  CB9B D2 66 CB         jp nc,scores_processhighscores3 ; if the place we're looking is less than zero, we've gone to far, so continue, otherwise go again
213+  CB9E              scores_processhighscores4
214+  CB9E CD A2 CB         call scores_updatehighscores
215+  CBA1 C9               ret
216+  CBA2
217+  CBA2              ;
218+  CBA2              ; Update score table
219+  CBA2              ;
220+  CBA2              scores_updatehighscores:
221+  CBA2 3A 5D CB         ld a,(scores_highscoretmp)  ; get the place we want to overwrite
222+  CBA5 FE 00            cp 0
223+  CBA7 C8               ret z                       ; if this is 0, didn't get a high score
224+  CBA8 FE 1D            cp 29                       ; check against 29... if it's equal, we don't want to copy the current score down one
225+  CBAA CA DD CB         jp z, scores_updatehighscores3
226+  CBAD                                              ; copy old score over one below, if not first
227+  CBAD 21 73 CA         ld hl,scores_table
228+  CBB0 11 11 00         ld de,17                    ; start at second score, because this is the first one we'd ever need to copy...
229+  CBB3 19               add hl,de                   ; position of first column
230+  CBB4 2B               dec hl
231+  CBB5 2B               dec hl
232+  CBB6 2B               dec hl
233+  CBB7 E5               push hl
234+  CBB8 11 0C 00         ld de,12
235+  CBBB 19               add hl,de                   ; get position of next score
236+  CBBC 54 5D            ld de,hl
237+  CBBE E1               pop hl                      ; get hl back
238+  CBBF 01 09 00         ld bc,9
239+  CBC2 ED B0            ldir
240+  CBC4 FE 11            cp 17                       ; see if we're copying into the second place slot (17 memory offset). If so, stop copying back the scores
241+  CBC6 CA DD CB         jp z,scores_updatehighscores3
242+  CBC9 21 73 CA         ld hl,scores_table
243+  CBCC 11 02 00         ld de,2                    ; ... otherwise, copy back the first score
244+  CBCF 19               add hl,de                   ; position of first column
245+  CBD0 E5               push hl
246+  CBD1 11 0C 00         ld de,12
247+  CBD4 19               add hl,de                   ; get position of next score
248+  CBD5 54 5D            ld de,hl
249+  CBD7 E1               pop hl                      ; get hl back
250+  CBD8 01 09 00         ld bc,9
251+  CBDB ED B0            ldir
252+  CBDD              scores_updatehighscores3:
253+  CBDD 06 06            ld b,6                      ; now overwrite
254+  CBDF 21 73 CA         ld hl,scores_table
255+  CBE2 16 00            ld d,0
256+  CBE4 5F               ld e,a
257+  CBE5 19               add hl,de                   ; position of first column
258+  CBE6 08               ex af,af'
259+  CBE7 11 69 CA         ld de,scores_current+2      ; position of current score column
260+  CBEA              scores_updatehighscores2:
261+  CBEA 1A               ld a,(de)
262+  CBEB 77               ld (hl),a
263+  CBEC 23               inc hl
264+  CBED 13               inc de
265+  CBEE 10 FA            djnz scores_updatehighscores2
266+  CBF0 11 09 00         ld de,9
267+  CBF3 ED 52            sbc hl,de
268+  CBF5 54 5D            ld de,hl                    ; get back to start of entry
269+  CBF7 21 70 CA         ld hl,scores_defaultname    ; still need to overwrite the name
270+  CBFA 01 03 00         ld bc,3                      ; 3 chars to copy
271+  CBFD ED B0            ldir
272+  CBFF C9               ret
# file closed: game/scores.asm
158   CC00                  include "game\diamonds.asm"
# file opened: game/diamonds.asm
  1+  CC00              diamonds_tmp:
  2+  CC00 00               defb 0
  3+  CC01
  4+  CC01              diamonds_tmp2:
  5+  CC01 00               defb 0
  6+  CC02
  7+  CC02              ;
  8+  CC02              ; Holds the number of thousands for the current gem type
  9+  CC02              ;
 10+  CC02              diamonds_score:
 11+  CC02 00               defb 0
 12+  CC03
 13+  CC03              ;
 14+  CC03              ; Changes the attribute of gem and diamond cells based on the frame count
 15+  CC03              ; Inputs:
 16+  CC03              ; hl - memory location of gem type
 17+  CC03              diamonds_twinkle_type:
 18+  CC03 CD 77 C3         call game_getcurrentframe       ; get current frame number
 19+  CC06 E6 07            and 7                           ; want a number from 0-7
 20+  CC08 C6 40            add 64                          ; add to 60 to get attr colour
 21+  CC0A 32 01 CC         ld (diamonds_tmp2),a             ; store the colour
 22+  CC0D              diamonds_twinkle_type0:
 23+  CC0D 4E 23 46 2B      ld bc,(hl)                      ; get coords into bc
 24+  CC11 79               ld a,c                          ; load c into a
 25+  CC12 FE FF            cp 255                          ; is this the end?
 26+  CC14 CA 3C CC         jp z,diamonds_twinkle_type1           ; step out if so
 27+  CC17 23               inc hl
 28+  CC18 23               inc hl
 29+  CC19 7E               ld a,(hl)                       ; check the state, don't process if collected
 30+  CC1A FE 01            cp 1
 31+  CC1C CA 3D CC         jp z,diamonds_twinkle_type2           ; step out if so
 32+  CC1F CD 7D CC         call diamonds_checkforplayer    ; check to see if we've collided with player
 33+  CC22 DC 44 CC         call c,diamonds_collect     ; we collided
 34+  CC25 23               inc hl
 35+  CC26 E5               push hl
 36+  CC27 E5 DD E1         ld ix,hl
 37+  CC2A DD 4E FD DD      ld bc,(ix-3)                    ; get coords again
 37+  CC2E 46 FE
 38+  CC30 3A 01 CC         ld a,(diamonds_tmp2)
 39+  CC33 CD 8F AA         call screen_setattr
 40+  CC36 E1               pop hl
 41+  CC37 23               inc hl
 42+  CC38 23               inc hl                          ; move to next diamond
 43+  CC39 C3 0D CC         jp diamonds_twinkle_type0
 44+  CC3C              diamonds_twinkle_type1:
 45+  CC3C C9               ret
 46+  CC3D              diamonds_twinkle_type2:
 47+  CC3D 23               inc hl                          ; do stuff the we would have done anyway to get to next gem
 48+  CC3E 23               inc hl
 49+  CC3F 23               inc hl
 50+  CC40 08               ex af,af'
 51+  CC41 C3 0D CC         jp diamonds_twinkle_type0       ; rejoin main loop
 52+  CC44
 53+  CC44              ;
 54+  CC44              ; Collect the diamond we collided with
 55+  CC44              ; Inputs:
 56+  CC44              ; hl - memory location of current diamond, currently on state
 57+  CC44              ; Output:
 58+  CC44              ; a - 70 - for yellow on black
 59+  CC44              diamonds_collect:
 60+  CC44 36 01            ld (hl),1                       ; collected
 61+  CC46 E5               push hl
 62+  CC47 2B               dec hl
 63+  CC48 2B               dec hl
 64+  CC49 4E 23 46 2B      ld bc,(hl)                      ; get the coords
 65+  CC4D CD 47 AA         call screen_getscreencoordsfromcharcoords ; get the screen coords into bc
 66+  CC50 ED 5B 00 CC      ld de,(diamonds_tmp)            ; tmp stores the offset for this type of gem
 67+  CC54 16 00            ld d,0
 68+  CC56 21 9F BB         ld hl,sprites
 69+  CC59 19               add hl,de
 70+  CC5A CD 09 AB         call sprites_drawsprite     ; call the routine to draw the sprite
 71+  CC5D E1               pop hl
 72+  CC5E 3E 46            ld a,70                     ; pass this back to overwrite the attr
 73+  CC60 32 01 CC         ld (diamonds_tmp2),a
 74+  CC63 D9               exx
 75+  CC64 3A 02 CC         ld a,(diamonds_score)
 76+  CC67 47               ld b,a
 77+  CC68 CD 97 CA         call scores_addthousands
 78+  CC6B 3A 00 CC         ld a,(diamonds_tmp)
 79+  CC6E FE 40            cp 64                       ; check the gem type offset, if its 64 this is a diamond, so mark the level as completable
 80+  CC70 C2 78 CC         jp nz,diamonds_collect0
 81+  CC73 21 95 C3         ld hl,player+13
 82+  CC76 36 01            ld (hl),1                   ; mark the player as able to complete the level
 83+  CC78              diamonds_collect0:
 84+  CC78 CD CC B0         call sound_gemcollected
 85+  CC7B D9               exx
 86+  CC7C C9               ret
 87+  CC7D
 88+  CC7D              ;
 89+  CC7D              ; Checks to see if the gem is hitting a player
 90+  CC7D              ; Inputs:
 91+  CC7D              ; bc - coords of diamond we're checking
 92+  CC7D              diamonds_checkforplayer:
 93+  CC7D 78               ld a,b               ; multiply b by 8
 94+  CC7E 07               rlca
 95+  CC7F 07               rlca
 96+  CC80 07               rlca
 97+  CC81 47               ld b,a
 98+  CC82 ED 5B 88 C3      ld de,(player)       ; get the player coords
 99+  CC86 7B               ld a,e               ; get the vert coord first
100+  CC87 90               sub b                ; subtract the diamond vertical coord from players
101+  CC88 C6 04            add 4                ; add the max distance
102+  CC8A FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
103+  CC8C D0               ret nc               ; if not, hasn't hit
104+  CC8D 79               ld a,c               ; multiply c by 8
105+  CC8E 07               rlca
106+  CC8F 07               rlca
107+  CC90 07               rlca
108+  CC91 4F               ld c,a
109+  CC92 7A               ld a,d               ; get the player horiz coord
110+  CC93 91               sub c                ; subtract rock coord
111+  CC94 C6 04            add 4                ; add max distance
112+  CC96 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
113+  CC98 D0               ret nc
114+  CC99 3E 00            ld a,0
115+  CC9B C9               ret
116+  CC9C
117+  CC9C
118+  CC9C              ;
119+  CC9C              ; Initialise diamonds and gems
120+  CC9C              ;
121+  CC9C              diamonds_twinkle
122+  CC9C 21 02 CC         ld hl,diamonds_score
123+  CC9F 36 02            ld (hl),2         ; store the score we'll add
124+  CCA1 21 00 CC         ld hl,diamonds_tmp
125+  CCA4 36 40            ld (hl),64         ; store the location the diamond sprite
126+  CCA6 21 1A B7         ld hl, level_diamonds
127+  CCA9 CD 03 CC         call diamonds_twinkle_type
128+  CCAC 21 02 CC         ld hl,diamonds_score
129+  CCAF 36 01            ld (hl),1         ; store the score we'll add
130+  CCB1 21 00 CC         ld hl,diamonds_tmp
131+  CCB4 36 70            ld (hl),112         ; store the location the gem sprite
132+  CCB6 21 2A B7         ld hl, level_gems
133+  CCB9 CD 03 CC         call diamonds_twinkle_type
134+  CCBC C9               ret
135+  CCBD
136+  CCBD              ;
137+  CCBD              ; Initialise diamonds and gems
138+  CCBD              ;
139+  CCBD              diamonds_init:
140+  CCBD 21 1A B7         ld hl, level_diamonds
141+  CCC0 CD CA CC         call diamonds_init_type
142+  CCC3 21 2A B7         ld hl, level_gems
143+  CCC6 CD CA CC         call diamonds_init_type
144+  CCC9 C9               ret
145+  CCCA
146+  CCCA              ;
147+  CCCA              ; Initialise diamonds or gems, get memory addresses
148+  CCCA              ; Inputs:
149+  CCCA              ; hl - memory location
150+  CCCA              diamonds_init_type:
151+  CCCA 4E               ld c,(hl)                      ; get coords into c
152+  CCCB 79               ld a,c                          ; load c into add
153+  CCCC FE FF            cp 255                          ; is this the end?
154+  CCCE CA E5 CC         jp z,diamonds_init_type1             ; step out if so
155+  CCD1 23               inc hl
156+  CCD2 46               ld b,(hl)                       ; get coords into b
157+  CCD3 E5               push hl
158+  CCD4 CD F8 A9         call screen_getcellattroffset ; get memory of attr for this diamond into de
159+  CCD7 E1               pop hl
160+  CCD8 23               inc hl                          ; move to state
161+  CCD9 36 00            ld (hl),0
162+  CCDB 23               inc hl                          ; move to memory
163+  CCDC 73 23 72 2B      ld (hl),de                      ; store the memory location
164+  CCE0 23               inc hl                          ; move to next diamond
165+  CCE1 23               inc hl
166+  CCE2 C3 CA CC         jp diamonds_init_type
167+  CCE5              diamonds_init_type1:
168+  CCE5 C9               ret
# file closed: game/diamonds.asm
159   CCE6                  include "game\missiles.asm"
# file opened: game/missiles.asm
  1+  CCE6              ;
  2+  CCE6              ; Controls when missiles fall
  3+  CCE6              ;
  4+  CCE6              missiles_count:
  5+  CCE6 00               defb 0
  6+  CCE7
  7+  CCE7              ;
  8+  CCE7              ; A structure of falling missiles
  9+  CCE7              ; Assume we'll never have more than 4 falling at any one time
 10+  CCE7              ; (1,2 - 16 bit memory location for missile graphic),state (0 fell, 1 falling)
 11+  CCE7              ;
 12+  CCE7              missiles_falling:
 13+  CCE7 00 00 00         defb 0,0,0
 14+  CCEA 00 00 00         defb 0,0,0
 15+  CCED 00 00 00         defb 0,0,0
 16+  CCF0 00 00 00         defb 0,0,0
 17+  CCF3
 18+  CCF3              ;
 19+  CCF3              ; The coords of the missile that killed us
 20+  CCF3              ;
 21+  CCF3              missiles_killermissile:
 22+  CCF3 00 00            defb 0,0
 23+  CCF5
 24+  CCF5              ;
 25+  CCF5              ; Zeroes the state of each missile
 26+  CCF5              ;
 27+  CCF5              missiles_init:
 28+  CCF5 06 0C            ld b,12
 29+  CCF7 DD 21 A1 B6      ld ix,level_missiles
 30+  CCFB              missiles_init0:
 31+  CCFB DD 36 02 00      ld (ix+2),0               ; set the state to zero
 32+  CCFF 11 05 00         ld de,5
 33+  CD02 DD 19            add ix,de
 34+  CD04 DD 36 02 00      ld (ix+2),0
 35+  CD08 DD 19            add ix,de
 36+  CD0A 10 EF            djnz missiles_init0
 37+  CD0C 06 04            ld b,4                  ; reset four falling missiles
 38+  CD0E 21 E7 CC         ld hl,missiles_falling
 39+  CD11              missiles_init1:
 40+  CD11 36 00            ld (hl),0
 41+  CD13 23               inc hl
 42+  CD14 36 00            ld (hl),0
 43+  CD16 23               inc hl
 44+  CD17 36 00            ld (hl),0
 45+  CD19 23               inc hl
 46+  CD1A 10 F5            djnz missiles_init1
 47+  CD1C C9               ret
 48+  CD1D
 49+  CD1D              ;
 50+  CD1D              ; Runs each frame and checks if a missile can fall, then selects one at random and adds to the falling missiles
 51+  CD1D              ; Processes any already falling missiles
 52+  CD1D              ;
 53+  CD1D              missiles_process:
 54+  CD1D 3A 93 C3         ld a,(player+11)                        ; check if the player was hit by a missile previously
 55+  CD20 FE 03            cp 3
 56+  CD22 C2 29 CD         jp nz,missiles_process3                 ; if not, continue
 57+  CD25 CD 66 CE         call missiles_zonkplayer
 58+  CD28 C9               ret
 59+  CD29              missiles_process3:
 60+  CD29 3A 97 C3         ld a,(player_location)
 61+  CD2C FE 01            cp 1
 62+  CD2E C2 9C CD         jp nz, missiles_process0                ; if not 1 we're not in the cavern so no need to make any more fall
 63+  CD31 21 95 C3         ld hl,player+13
 64+  CD34 7E               ld a,(hl)                               ; check if player has collected a diamond
 65+  CD35 FE 01            cp 1
 66+  CD37 C2 9C CD         jp nz, missiles_process0                ; don't activate if not
 67+  CD3A 21 E6 CC         ld hl,missiles_count
 68+  CD3D 7E               ld a,(hl)                   ; get the missiles count
 69+  CD3E 3C               inc a
 70+  CD3F FE 32            cp 50                                   ; have we reached the count yet
 71+  CD41 CA 48 CD         jp z,missiles_process2                 ; if not, don't activate a new one
 72+  CD44 77               ld (hl),a                               ; store the updated count, and continue without activating
 73+  CD45 C3 9C CD         jp missiles_process0
 74+  CD48              missiles_process2:
 75+  CD48 36 00            ld (hl),0                               ; zero the counter
 76+  CD4A 1E 0C            ld e,12
 77+  CD4C CD B2 81         call utilities_randomupper              ; get random number from 0 to 11
 78+  CD4F 11 0A 00         ld de,10
 79+  CD52 CD FD 80         call utilities_multiply                 ; multiple random number by 10
 80+  CD55 54 5D            ld de,hl                                ; this is the offset for the random missile
 81+  CD57 DD 21 A1 B6      ld ix,level_missiles                   ; load the location of the missile definitions
 82+  CD5B DD 19            add ix,de                               ; get to location of missile
 83+  CD5D DD 7E 02         ld a,(ix+2)
 84+  CD60 FE 00            cp 0
 85+  CD62 CA 72 CD         jp z,missiles_process1                  ; if this missile isn't active, activate it
 86+  CD65 11 05 00         ld de,5                                 ; otherwise, check the missile above
 87+  CD68 DD 19            add ix,de
 88+  CD6A DD 7E 02         ld a,(ix+2)
 89+  CD6D FE 00            cp 0
 90+  CD6F C2 9C CD         jp nz,missiles_process0                 ; if this is active as well, the player got lucky
 91+  CD72              missiles_process1:                          ; activate a missile
 92+  CD72 DD 36 02 01      ld (ix+2),1                               ; mark this missile as active
 93+  CD76 DD 4E 00 DD      ld bc,(ix)                              ; get char coords from the missile
 93+  CD7A 46 01
 94+  CD7C 78               ld a,b
 95+  CD7D ED 5B D7 A8      ld de,(screen_offset)          ; load the screen offset, this is in rows
 96+  CD81 93               sub e
 97+  CD82 CD 47 AA         call screen_getscreencoordsfromcharcoords ; get screen coords into bc
 98+  CD85 C5               push bc
 99+  CD86 3E 0C            ld a,12                                 ; inactive missile sprite
100+  CD88 CD 84 AA         call screen_getblock
101+  CD8B CD 09 AB         call sprites_drawsprite                 ; draw the sprite over the old one
102+  CD8E C1               pop bc
103+  CD8F C5               push bc
104+  CD90 3E 14            ld a,20                                 ; active missile sprite
105+  CD92 CD 84 AA         call screen_getblock
106+  CD95 CD 09 AB         call sprites_drawsprite                 ; draw the sprite over the old one
107+  CD98 C1               pop bc
108+  CD99 CD 2A CE         call missiles_addmissiletofalling
109+  CD9C              missiles_process0:
110+  CD9C CD A0 CD         call missiles_fall
111+  CD9F C9               ret
112+  CDA0
113+  CDA0              ;
114+  CDA0              ; Processes falling missiles
115+  CDA0              ;
116+  CDA0              missiles_fall:
117+  CDA0 06 04            ld b,4              ; number of possible falling missiles
118+  CDA2 DD 21 E7 CC      ld ix,missiles_falling
119+  CDA6              missiles_fall0:
120+  CDA6 C5               push bc
121+  CDA7 DD 7E 02         ld a,(ix+2)
122+  CDAA FE 00            cp 0
123+  CDAC CA 09 CE         jp z,missiles_fall1 ; not falling move to next
124+  CDAF FE 01            cp 1                ; is this ready to fall
125+  CDB1 CA B7 CD         jp z, missiles_fall3
126+  CDB4 C3 23 CE         jp missiles_fall4   ; if not, decrease the countdown
127+  CDB7              missiles_fall3:
128+  CDB7 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
128+  CDBB 46 01
129+  CDBD CD FE AB         call sprites_scadd  ; get the memory of the coords into de
130+  CDC0 14               inc d               ; add 256 to get next row
131+  CDC1 1A               ld a,(de)           ; get the contents of the next row
132+  CDC2 FE 00            cp 0
133+  CDC4 C2 1C CE         jp nz,missiles_fall2 ; if this is not empty, stop this missile falling
134+  CDC7 3E 14            ld a,20                                 ; active missile sprite
135+  CDC9 CD 84 AA         call screen_getblock
136+  CDCC CD 09 AB         call sprites_drawsprite                 ; draw the sprite over the old one
137+  CDCF DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
137+  CDD3 46 01
138+  CDD5 0C               inc c               ; move down one pixel
139+  CDD6 DD 71 00 DD      ld (ix),bc          ; store the new coords
139+  CDDA 70 01
140+  CDDC 3E 14            ld a,20                                 ; active missile sprite
141+  CDDE CD 84 AA         call screen_getblock
142+  CDE1 CD 09 AB         call sprites_drawsprite                 ; draw the sprite
143+  CDE4 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
143+  CDE8 46 01
144+  CDEA 79               ld a,c              ; get the vertical coord into a
145+  CDEB E6 07            and 7               ; divisible by 8?
146+  CDED FE 00            cp 0
147+  CDEF C2 09 CE         jp nz,missiles_fall1   ; if not, carry on
148+  CDF2 CD 37 AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
149+  CDF5 3E 43            ld a,67             ; load magenta
150+  CDF7 CD 8F AA         call screen_setattr
151+  CDFA DD 4E 00 DD      ld bc,(ix)
151+  CDFE 46 01
152+  CE00 CD 37 AA         call screen_getcharcoordsfromscreencoords ; get the attr address into de
153+  CE03 05               dec b               ; look one square above
154+  CE04 3E 46            ld a,70             ; load yellow
155+  CE06 CD 8F AA         call screen_setattr
156+  CE09              missiles_fall1:         ; hl at state
157+  CE09 DD 4E 00 DD      ld bc,(ix)          ; get coords back
157+  CE0D 46 01
158+  CE0F CD 4B CE         call missiles_checkforplayer ; check for player
159+  CE12 DD 23            inc ix
160+  CE14 DD 23            inc ix
161+  CE16 DD 23            inc ix              ; get to next missile
162+  CE18 C1               pop bc
163+  CE19 10 8B            djnz missiles_fall0
164+  CE1B C9               ret
165+  CE1C              missiles_fall2:
166+  CE1C DD 36 02 00      ld (ix+2),0
167+  CE20 C3 09 CE         jp missiles_fall1   ; rejoin the loop
168+  CE23              missiles_fall4:
169+  CE23 3D               dec a               ; decrease the countdown
170+  CE24 DD 77 02         ld (ix+2),a         ; store back
171+  CE27 C3 09 CE         jp missiles_fall1   ; do next missile
172+  CE2A
173+  CE2A              ;
174+  CE2A              ; Adds the missile to the structure that tracks falling missile
175+  CE2A              ; Inputs:
176+  CE2A              ; bc - coords of missile, c vert
177+  CE2A              missiles_addmissiletofalling:
178+  CE2A C5               push bc             ; store the coords
179+  CE2B 11 E7 CC         ld de,missiles_falling
180+  CE2E 06 04            ld b,4              ; number of possible falling missiles
181+  CE30              missiles_addmissiletofalling0:
182+  CE30 13               inc de
183+  CE31 13               inc de              ; move three along to get the state
184+  CE32 1A               ld a,(de)           ; load the state
185+  CE33 FE 00            cp 0                ; check if this is not falling
186+  CE35 C2 46 CE         jp nz,missiles_addmissiletofalling1 ; continue the loop if not 0
187+  CE38 3E 19            ld a,25
188+  CE3A 12               ld (de),a           ; set the state to pre-falling
189+  CE3B 1B               dec de              ; move back coords
190+  CE3C C1               pop bc              ; get back coords
191+  CE3D 78               ld a,b
192+  CE3E 12               ld (de),a           ; store the vertical
193+  CE3F 1B               dec de
194+  CE40 79               ld a,c
195+  CE41 12               ld (de),a           ; store the horizontal
196+  CE42 C5               push bc
197+  CE43 C3 49 CE         jp missiles_addmissiletofalling2 ; done
198+  CE46              missiles_addmissiletofalling1:
199+  CE46 13               inc de              ; move memory along to next rock
200+  CE47 10 E7            djnz missiles_addmissiletofalling0 ; try the next missile
201+  CE49              missiles_addmissiletofalling2: ; done, return
202+  CE49 C1               pop bc              ; to tidy up
203+  CE4A C9               ret
204+  CE4B
205+  CE4B              ;
206+  CE4B              ; Checks to see if the missile is hitting a player
207+  CE4B              ; Inputs:
208+  CE4B              ; bc - coords of missile we're checking
209+  CE4B              missiles_checkforplayer:
210+  CE4B ED 5B 88 C3      ld de,(player)       ; get the player coords
211+  CE4F 7B               ld a,e               ; get the vert coord first
212+  CE50 91               sub c                ; subtract the missile vertical coord from players
213+  CE51 FE 08            cp 8                 ; the missile will only hit a player if the player is directly underneath, so this must be 8
214+  CE53 C0               ret nz               ; if not, hasn't hit
215+  CE54 7A               ld a,d               ; get the player horiz coord
216+  CE55 90               sub b                ; subtract missile coord
217+  CE56 C6 07            add 7                ; add max distance
218+  CE58 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
219+  CE5A DA 5E CE         jp c,missiles_checkforplayer0
220+  CE5D C9               ret
221+  CE5E              missiles_checkforplayer0:
222+  CE5E ED 43 F3 CC      ld (missiles_killermissile),bc; store the coords of the killer missile
223+  CE62 CD B7 C4         call player_zonkplayer ; if so, jump out
224+  CE65 C9               ret
225+  CE66
226+  CE66              ;
227+  CE66              ; Player has been hit, so draw text over them and mark as dead
228+  CE66              ;
229+  CE66              missiles_zonkplayer:
230+  CE66 CD A5 C4         call player_killplayer      ; mark as dead
231+  CE69 ED 4B 88 C3      ld bc,(player)              ; get player coords
232+  CE6D CD 37 AA         call screen_getcharcoordsfromscreencoords
233+  CE70 0D               dec c
234+  CE71 0D               dec c
235+  CE72 04               inc b
236+  CE73 C5               push bc
237+  CE74 3E 42            ld a,66
238+  CE76 CD 8F AA         call screen_setattr
239+  CE79 0C               inc c
240+  CE7A CD 8F AA         call screen_setattr
241+  CE7D 0C               inc c
242+  CE7E CD 8F AA         call screen_setattr
243+  CE81 0C               inc c
244+  CE82 CD 8F AA         call screen_setattr
245+  CE85 0C               inc c
246+  CE86 CD 8F AA         call screen_setattr
247+  CE89 C1               pop bc
248+  CE8A ED 5B D7 A8      ld de,(screen_offset)
249+  CE8E 78               ld a,b
250+  CE8F 93               sub e
251+  CE90 47               ld b,a                      ; subtract the offset
252+  CE91 04               inc b
253+  CE92 04               inc b                       ; add two for the score rows
254+  CE93 ED 43 9D 85      ld (string_zonk),bc         ; set coords of string
255+  CE97 21 9D 85         ld hl,string_zonk
256+  CE9A CD 25 86         call string_print
257+  CE9D 06 14            ld b,20
258+  CE9F CD 5E 81         call utilities_pauseforframes ; pause
259+  CEA2 C9               ret
260+  CEA3
# file closed: game/missiles.asm
160   CEA3                  include "game\thepit.asm"
# file opened: game/thepit.asm
  1+  CEA3              ;
  2+  CEA3              ; Timer for deciding how fast the trap withdraws
  3+  CEA3              ;
  4+  CEA3              thepit_timer:
  5+  CEA3 00               defb 0
  6+  CEA4
  7+  CEA4              ;
  8+  CEA4              ; Ticks for the trap state. Will count to 3 then reset
  9+  CEA4              ;
 10+  CEA4              thepit_trapcount:
 11+  CEA4 00               defb 0
 12+  CEA5
 13+  CEA5              ;
 14+  CEA5              ; The horizontal coordinate of the current pit trap
 15+  CEA5              ;
 16+  CEA5              thepit_trapcoord:
 17+  CEA5 08               defb 8
 18+  CEA6
 19+  CEA6              ;
 20+  CEA6              ; Initialises the pit
 21+  CEA6              ;
 22+  CEA6              thepit_init:
 23+  CEA6 21 A5 CE         ld hl,thepit_trapcoord
 24+  CEA9 36 08            ld (hl),8
 25+  CEAB 21 A4 CE         ld hl,thepit_trapcount
 26+  CEAE 36 00            ld (hl),0
 27+  CEB0 C9               ret
 28+  CEB1
 29+  CEB1              ;
 30+  CEB1              ; Performs per frame processing on the pit room
 31+  CEB1              ;
 32+  CEB1              thepit_process:
 33+  CEB1 3A 97 C3         ld a,(player_location)
 34+  CEB4 FE 02            cp 2                            ; if two, the player is in the pit, so process the trap
 35+  CEB6 C2 1D CF         jp nz,thepit_process0
 36+  CEB9 ED 4B 88 C3      ld bc,(player)                  ; get the player's coords to check if about to fall
 37+  CEBD 3E 08            ld a,8
 38+  CEBF 81               add a,c
 39+  CEC0 4F               ld c,a                          ; look at the square underneath
 40+  CEC1 CD 37 AA         call screen_getcharcoordsfromscreencoords ; get the cell coords
 41+  CEC4 CD C5 AA         call screen_ischarempty
 42+  CEC7 FE 01            cp 1                            ; check if this is 1=empty
 43+  CEC9 CA 1E CF         jp z,thepit_process2
 44+  CECC 3A A3 CE         ld a,(thepit_timer)             ; get the timer
 45+  CECF 3C               inc a
 46+  CED0 32 A3 CE         ld (thepit_timer),a             ; store
 47+  CED3 FE 02            cp 2                           ; have we reached the trigger?
 48+  CED5 C2 1D CF         jp nz, thepit_process0          ; no need to do anything
 49+  CED8 3E 00            ld a,0
 50+  CEDA 32 A3 CE         ld (thepit_timer),a             ; zero the timer and process
 51+  CEDD 3A A4 CE         ld a,(thepit_trapcount)         ; get the current count
 52+  CEE0 3C               inc a
 53+  CEE1 32 A4 CE         ld (thepit_trapcount),a         ; reset the trap count
 54+  CEE4 FE 04            cp 4                            ; do we need to begin another character?
 55+  CEE6 C2 05 CF         jp nz,thepit_process1           ; if not, draw as normal
 56+  CEE9 3E 00            ld a,0
 57+  CEEB 32 A4 CE         ld (thepit_trapcount),a         ; reset the trap count
 58+  CEEE 3A A5 CE         ld a,(thepit_trapcoord)         ; get the trap horiz coord
 59+  CEF1 FE 02            cp 2
 60+  CEF3 CA 1D CF         jp z,thepit_process0
 61+  CEF6 4F               ld c,a
 62+  CEF7 06 0A            ld b,10
 63+  CEF9 3E 46            ld a,70
 64+  CEFB CD 8F AA         call screen_setattr             ; set the attr of the empty square to yellow on black
 65+  CEFE 3A A5 CE         ld a,(thepit_trapcoord)         ; get the trap horiz coord
 66+  CF01 3D               dec a
 67+  CF02 32 A5 CE         ld (thepit_trapcoord),a         ; store the reduced coord
 68+  CF05
 69+  CF05              thepit_process1:                    ; draw the trapdoor in current position
 70+  CF05 3A A5 CE         ld a,(thepit_trapcoord)
 71+  CF08 FE 02            cp 2
 72+  CF0A CA 1D CF         jp z, thepit_process0           ; don't process outside of the pit
 73+  CF0D 4F               ld c,a
 74+  CF0E 06 0A            ld b,10                         ; vertical coord will always be the same
 75+  CF10 3A A4 CE         ld a,(thepit_trapcount)         ; get the trap count
 76+  CF13 5F               ld e,a                          ; store in e
 77+  CF14 3E 16            ld a,22                         ; 21 is full trapdoor
 78+  CF16 83               add a,e
 79+  CF17 CD 84 AA         call screen_getblock
 80+  CF1A CD 61 AA         call screen_showchar            ; show the char
 81+  CF1D
 82+  CF1D              thepit_process0:
 83+  CF1D C9               ret
 84+  CF1E              thepit_process2:
 85+  CF1E CD BD C4         call player_pitkillplayer
 86+  CF21 C9               ret
 87+  CF22
# file closed: game/thepit.asm
161   CF22                  include "game\monster.asm"
# file opened: game/monster.asm
  1+  CF22
  2+  CF22              ;
  3+  CF22              ; Where the monster currently is
  4+  CF22              ;
  5+  CF22              monster_currentcoords:
  6+  CF22 00 00            defb 0,0
  7+  CF24
  8+  CF24              ;
  9+  CF24              ; The start coords of the monster
 10+  CF24              ;
 11+  CF24              monster_initcoords:
 12+  CF24 70 1B            defb 112,27
 13+  CF26
 14+  CF26              ;
 15+  CF26              ; Store the memory location of the current jump position
 16+  CF26              ;
 17+  CF26              monster_jumppos:
 18+  CF26 00 00            defb 0,0
 19+  CF28
 20+  CF28              ;
 21+  CF28              ; The jump table for the monster.
 22+  CF28              ;
 23+  CF28              monster_jumptable:
 24+  CF28 FF 03 02 02      defb 255,3,2,2,2,2,2,2,2,2,1,1,1,1,1,1,255
 24+  CF2C 02 02 02 02
 24+  CF30 02 02 01 01
 24+  CF34 01 01 01 01
 24+  CF38 FF
 25+  CF39
 26+  CF39              ;
 27+  CF39              ; The vertical direction: 0 up, 1 down
 28+  CF39              ;
 29+  CF39              monster_jumpdirectionvert:
 30+  CF39 00               defb 0
 31+  CF3A
 32+  CF3A              ;
 33+  CF3A              ; The horiz direction: 0 right, 1 left
 34+  CF3A              ;
 35+  CF3A              monster_jumpdirectionhoriz:
 36+  CF3A 00               defb 0
 37+  CF3B
 38+  CF3B              ;
 39+  CF3B              ; Frame offset, 0 or 32
 40+  CF3B              ;
 41+  CF3B              monster_frameoffset:
 42+  CF3B 00               defb 0
 43+  CF3C
 44+  CF3C              ;
 45+  CF3C              ; Monster tick
 46+  CF3C              ;
 47+  CF3C              monster_tick:
 48+  CF3C 00               defb 0
 49+  CF3D
 50+  CF3D              ;
 51+  CF3D              ; Initialises the pit monster
 52+  CF3D              ;
 53+  CF3D              monster_init:
 54+  CF3D ED 4B 24 CF      ld bc,(monster_initcoords)              ; load the initial coords
 55+  CF41 ED 43 22 CF      ld (monster_currentcoords),bc           ; save in current coords
 56+  CF45 21 29 CF         ld hl,monster_jumptable+1
 57+  CF48 22 26 CF         ld (monster_jumppos),hl                 ; store the initial position in the jump table
 58+  CF4B 3E 00            ld a,0
 59+  CF4D 32 39 CF         ld (monster_jumpdirectionvert),a        ; going up
 60+  CF50 32 3B CF         ld (monster_frameoffset),a
 61+  CF53 32 3C CF         ld (monster_tick),a
 62+  CF56 CD D6 CF         call monster_draw                       ; the monster
 63+  CF59 C9               ret
 64+  CF5A
 65+  CF5A              ;
 66+  CF5A              ; Animate the monster
 67+  CF5A              ;
 68+  CF5A              monster_process:
 69+  CF5A 3A 3C CF         ld a,(monster_tick)                     ; check if we should draw this frame
 70+  CF5D FE 01            cp 1
 71+  CF5F CA 67 CF         jp z,monster_process6
 72+  CF62 3C               inc a
 73+  CF63 32 3C CF         ld (monster_tick),a                     ; increase the tick and continue
 74+  CF66 C9               ret
 75+  CF67              monster_process6:
 76+  CF67 3E 00            ld a,0
 77+  CF69 32 3C CF         ld (monster_tick),a                     ; zero the tick
 78+  CF6C CD D6 CF         call monster_draw                       ; overwrite the old sprite
 79+  CF6F 3A 3B CF         ld a,(monster_frameoffset)              ; get the anim frame offset
 80+  CF72 EE 20            xor 32                                  ; flip between 0 and 32
 81+  CF74 32 3B CF         ld (monster_frameoffset),a              ; store
 82+  CF77 ED 4B 22 CF      ld bc,(monster_currentcoords)           ; get the current coords
 83+  CF7B 2A 26 CF         ld hl,(monster_jumppos)                 ; get the position in the jump table
 84+  CF7E 56               ld d,(hl)                               ; get the jump modifier
 85+  CF7F 3A 39 CF         ld a,(monster_jumpdirectionvert)        ; get the vertical direction
 86+  CF82 FE 00            cp 0                                    ; if 0, going up, so dec vert
 87+  CF84 C2 8D CF         jp nz,monster_process0
 88+  CF87 79               ld a,c
 89+  CF88 92               sub d
 90+  CF89 23               inc hl                                  ; move forward a jump pos
 91+  CF8A C3 90 CF         jp monster_process1
 92+  CF8D              monster_process0:
 93+  CF8D 79               ld a,c                                   ; going down so inc c
 94+  CF8E 82               add a,d
 95+  CF8F 2B               dec hl                                  ; move back a jump pos
 96+  CF90              monster_process1:
 97+  CF90 4F               ld c,a                                  ; get the vertical coord back
 98+  CF91 7E               ld a,(hl)                               ; check the next jump pos
 99+  CF92 FE FF            cp 255                                  ; if 255 reverse
100+  CF94 CA 9D CF         jp z,monster_process3
101+  CF97 22 26 CF         ld (monster_jumppos),hl                 ; store the new pos
102+  CF9A C3 A5 CF         jp monster_process2                     ; keep going
103+  CF9D              monster_process3:
104+  CF9D 3A 39 CF         ld a,(monster_jumpdirectionvert)        ; get the direction
105+  CFA0 EE 01            xor 1                                   ; flip it
106+  CFA2 32 39 CF         ld (monster_jumpdirectionvert),a        ; store it
107+  CFA5              monster_process2:
108+  CFA5 3A 3A CF         ld a,(monster_jumpdirectionhoriz)       ; get the horiz direction
109+  CFA8 FE 00            cp 0                                    ; is it right?
110+  CFAA C2 BF CF         jp nz,monster_process4
111+  CFAD 04               inc b                                   ; 1 pixel right
112+  CFAE 78               ld a,b
113+  CFAF FE 38            cp 56                                   ; reached the edge of the pit?
114+  CFB1 C2 CE CF         jp nz,monster_process5
115+  CFB4 3A 3A CF         ld a,(monster_jumpdirectionhoriz)
116+  CFB7 EE 01            xor 1
117+  CFB9 32 3A CF         ld (monster_jumpdirectionhoriz),a       ; flip direction
118+  CFBC C3 CE CF         jp monster_process5
119+  CFBF              monster_process4:
120+  CFBF 05               dec b                                   ; 1 pixel left
121+  CFC0 78               ld a,b
122+  CFC1 FE 18            cp 24                                   ; reached the edge of the pit?
123+  CFC3 C2 CE CF         jp nz,monster_process5
124+  CFC6 3A 3A CF         ld a,(monster_jumpdirectionhoriz)
125+  CFC9 EE 01            xor 1
126+  CFCB 32 3A CF         ld (monster_jumpdirectionhoriz),a       ; flip direction
127+  CFCE              monster_process5:
128+  CFCE ED 43 22 CF      ld (monster_currentcoords),bc           ; store the new vertical coords
129+  CFD2 CD D6 CF         call monster_draw                       ; finally, draw the monster
130+  CFD5 C9               ret
131+  CFD6
132+  CFD6              ;
133+  CFD6              ; Draw the monster at the current location
134+  CFD6              ;
135+  CFD6              monster_draw:
136+  CFD6 ED 4B 22 CF      ld bc,(monster_currentcoords)
137+  CFDA 3A 3B CF         ld a,(monster_frameoffset)
138+  CFDD 11 00 00         ld de,0
139+  CFE0 5F               ld e,a
140+  CFE1 21 B3 BD         ld hl,monster_sprite                    ; load the first frame
141+  CFE4 19               add hl,de
142+  CFE5 CD 67 AB         call sprites_draw2by2sprite
143+  CFE8 C9               ret
# file closed: game/monster.asm
162   CFE9                  include "game\robots.asm"
# file opened: game/robots.asm
  1+  CFE9
  2+  CFE9              ;
  3+  CFE9              ; Array of robot states
  4+  CFE9              ; x,y,state (0 inactive, 1 active), direction (0 left, 1 right), anim offset, automove frames remaining, move direction (0 left, 1 right, 3 up, 4 down)
  5+  CFE9              robots_robots:
  6+  CFE9 00 00 00 00      defb 0,0,0,0,0,0,0
  6+  CFED 00 00 00
  7+  CFF0 00 00 00 00      defb 0,0,0,0,0,0,0
  7+  CFF4 00 00 00
  8+  CFF7 00 00 00 00      defb 0,0,0,0,0,0,0
  8+  CFFB 00 00 00
  9+  CFFE 00 00 00 00      defb 0,0,0,0,0,0,0
  9+  D002 00 00 00
 10+  D005 00 00 00 00      defb 0,0,0,0,0,0,0
 10+  D009 00 00 00
 11+  D00C
 12+  D00C              robots_initcoords:
 13+  D00C 18 E8            defb 24,232
 14+  D00E
 15+  D00E              ;
 16+  D00E              ; When this reaches zero, spawn a new robot
 17+  D00E              ;
 18+  D00E              robots_spawntimer:
 19+  D00E FA               defb 250
 20+  D00F
 21+  D00F              ;
 22+  D00F              ; When this reaches max, change the anim frame
 23+  D00F              ;
 24+  D00F              robots_animtimer:
 25+  D00F 00               defb 0
 26+  D010
 27+  D010              ;
 28+  D010              ; When this reaches max, change move the robot
 29+  D010              ;
 30+  D010              robots_movetimer:
 31+  D010 00               defb 0
 32+  D011
 33+  D011
 34+  D011              ;
 35+  D011              ; The number of robots active
 36+  D011              ;
 37+  D011              robots_numberactive:
 38+  D011 00               defb 0
 39+  D012
 40+  D012              ;
 41+  D012              ; Tracks which directions a robot can move
 42+  D012              ; up,down,left,right
 43+  D012              robots_canmovedirections:
 44+  D012 00 00 00 00      defb 0,0,0,0
 45+  D016
 46+  D016              ;
 47+  D016              ; The current robot speed
 48+  D016              ;
 49+  D016              robots_robotspeed:
 50+  D016 02               defb 2
 51+  D017
 52+  D017              ;
 53+  D017              ; The current max robots
 54+  D017              ;
 55+  D017              robots_robotsmax:
 56+  D017 02               defb 2
 57+  D018
 58+  D018              ;
 59+  D018              ; Initialises the robots
 60+  D018              ;
 61+  D018              robots_init:
 62+  D018 06 23            ld b,35
 63+  D01A DD 21 E9 CF      ld ix,robots_robots
 64+  D01E              robots_init0:
 65+  D01E DD 36 00 00      ld (ix),0                       ; reset robot states back to zero
 66+  D022 DD 23            inc ix
 67+  D024 10 F8            djnz robots_init0
 68+  D026 3E 00            ld a,0
 69+  D028 32 11 D0         ld (robots_numberactive),a
 70+  D02B 3E FA            ld a,250
 71+  D02D 32 0E D0         ld (robots_spawntimer),a
 72+  D030                  ; Self writing code
 73+  D030                  ; Robot speed
 74+  D030 3A 16 D0         ld a,(robots_robotspeed)
 75+  D033 32 CD D0         ld (robots_process7+1),a
 76+  D036 3C               inc a
 77+  D037 32 FD D0         ld (robots_process6+1),a
 78+  D03A                  ; Robots max
 79+  D03A 3A 17 D0         ld a,(robots_robotsmax)
 80+  D03D 32 48 D0         ld (robots_spawn+1),a
 81+  D040 32 9F D0         ld (robots_process8+1),a
 82+  D043 32 BB D0         ld (robots_process0+1),a
 83+  D046 C9               ret
 84+  D047
 85+  D047              ;
 86+  D047              ; Spawns a new robot
 87+  D047              ; Inputs:
 88+  D047              ; ix - pointer to start of robot array entry
 89+  D047              ;
 90+  D047              robots_spawn:
 91+  D047 06 03            ld b,3                      ;(SELF WRITING CODE)
 92+  D049 DD 21 E9 CF      ld ix,robots_robots
 93+  D04D              robots_spawn0:
 94+  D04D DD 7E 02         ld a,(ix+2)                 ; get the state
 95+  D050 FE 00            cp 0
 96+  D052 C2 7E D0         jp nz,robots_spawn1         ; if already active, move on
 97+  D055 ED 4B 0C D0      ld bc,(robots_initcoords)
 98+  D059 DD 71 00 DD      ld (ix),bc
 98+  D05D 70 01
 99+  D05F DD 36 02 01      ld (ix+2),1
100+  D063 DD 36 03 00      ld (ix+3),0
101+  D067 DD 36 04 00      ld (ix+4),0
102+  D06B DD 36 05 00      ld (ix+5),0
103+  D06F DD 36 06 00      ld (ix+6),0
104+  D073 3A 11 D0         ld a,(robots_numberactive)
105+  D076 3C               inc a
106+  D077 32 11 D0         ld (robots_numberactive),a  ; increase the number active
107+  D07A CD 35 D3         call robots_draw            ; draw initial frame
108+  D07D C9               ret
109+  D07E              robots_spawn1:
110+  D07E 11 07 00         ld de,7
111+  D081 DD 19            add ix,de
112+  D083 10 C8            djnz robots_spawn0
113+  D085 C9               ret
114+  D086              ;
115+  D086              ; Kills robot
116+  D086              ; Inputs:
117+  D086              ; ix - pointer to start of robot array entry
118+  D086              ;
119+  D086              robots_kill:
120+  D086 3A 11 D0         ld a,(robots_numberactive)
121+  D089 3D               dec a
122+  D08A 32 11 D0         ld (robots_numberactive),a
123+  D08D DD 36 02 00      ld (ix+2),0                     ; set to inactive
124+  D091 C5               push bc
125+  D092 E5               push hl
126+  D093 06 01            ld b,1
127+  D095 CD 9E CA         call scores_addhundreds
128+  D098 E1               pop hl
129+  D099 C1               pop bc
130+  D09A C9               ret
131+  D09B
132+  D09B              ;
133+  D09B              ; Processes the robots
134+  D09B              ;
135+  D09B              robots_process:
136+  D09B 3A 11 D0         ld a,(robots_numberactive)              ; first, check if we need to spawn a new robot
137+  D09E              robots_process8:
138+  D09E FE 03            cp 3                                    ; 3 is the maximum
139+  D0A0 CA BA D0         jp z,robots_process0                    ; if already three, nothing to do
140+  D0A3 3A 0E D0         ld a,(robots_spawntimer)                ; now check the spawn timer
141+  D0A6 FE 00            cp 0
142+  D0A8 C2 B6 D0         jp nz,robots_process1                   ; if it hasn't reached zero yet, just decrease
143+  D0AB 3E FA            ld a,250
144+  D0AD 32 0E D0         ld (robots_spawntimer),a                ; reset the spawn timer
145+  D0B0 CD 47 D0         call robots_spawn                       ; spawn a robot
146+  D0B3 C3 BA D0         jp robots_process0                      ; carry on
147+  D0B6              robots_process1:
148+  D0B6 3D               dec a
149+  D0B7 32 0E D0         ld (robots_spawntimer),a                ; decrease the spawn timer and store
150+  D0BA              robots_process0:
151+  D0BA 06 03            ld b,3                                  ; max number of robots (SELF WRITING CODE)
152+  D0BC DD 21 E9 CF      ld ix, robots_robots                    ; point ix at the robot array
153+  D0C0              robots_process2:
154+  D0C0 C5               push bc
155+  D0C1 DD 7E 02         ld a,(ix+2)                             ; check the state
156+  D0C4 FE 00            cp 0
157+  D0C6 CA E2 D0         jp z,robots_process3                    ; if not active, move on
158+  D0C9 3A 10 D0         ld a,(robots_movetimer)
159+  D0CC              robots_process7:                            ; self writing code - the number in the comparison will be ovewritten
160+  D0CC FE 04            cp 4
161+  D0CE C2 E2 D0         jp nz,robots_process3                   ; can we move this frame
162+  D0D1 CD 35 D3         call robots_draw                        ; draw over existing
163+  D0D4 CD 07 D1         call robots_move                        ; move the
164+  D0D7 DD 7E 02         ld a,(ix+2)                             ; get the state again
165+  D0DA FE 00            cp 0
166+  D0DC CA E2 D0         jp z,robots_process3                    ; move to next if this robot has become inactive
167+  D0DF CD 35 D3         call robots_draw                        ; draw the new robot
168+  D0E2              robots_process3:
169+  D0E2 C1               pop bc
170+  D0E3 11 07 00         ld de,7
171+  D0E6 DD 19            add ix,de
172+  D0E8 10 D6            djnz robots_process2
173+  D0EA 3A 0F D0         ld a,(robots_animtimer)
174+  D0ED 3C               inc a
175+  D0EE FE 08            cp 8
176+  D0F0 C2 F5 D0         jp nz,robots_process4
177+  D0F3 3E 00            ld a,0                                  ; reset if we reached max
178+  D0F5              robots_process4:
179+  D0F5 32 0F D0         ld (robots_animtimer),a
180+  D0F8 3A 10 D0         ld a,(robots_movetimer)                 ; increment the robot move timer
181+  D0FB 3C               inc a
182+  D0FC              robots_process6:                            ; self writing code - the number in the comparison will be ovewritten
183+  D0FC FE 05            cp 5                                    ; there is another reference to this number above
184+  D0FE C2 03 D1         jp nz,robots_process5
185+  D101 3E 00            ld a,0
186+  D103              robots_process5:
187+  D103 32 10 D0         ld (robots_movetimer),a
188+  D106
189+  D106 C9               ret
190+  D107
191+  D107
192+  D107              ;
193+  D107              ; Moves a robot
194+  D107              ; Inputs:
195+  D107              ; ix - points to first byte of robot in array
196+  D107              robots_move:
197+  D107 DD 7E 02         ld a,(ix+2)                             ; get the state
198+  D10A FE 02            cp 2
199+  D10C CA 3D D1         jp z,robots_move4                       ; don't move if shot, just change the anim
200+  D10F 3A 0F D0         ld a,(robots_animtimer)                 ; get the anim timer
201+  D112 FE 07            cp 7                                    ; compare with 8
202+  D114 C2 27 D1         jp nz,robots_move1                       ; if even, don't increment frame
203+  D117 DD 7E 04         ld a,(ix+4)                             ; get the anim frame
204+  D11A 06 08            ld b,8
205+  D11C 80               add a,b                                 ; add to anim frame
206+  D11D FE 20            cp 32
207+  D11F C2 24 D1         jp nz,robots_move0                      ; if not 32, then just store
208+  D122 3E 00            ld a,0                                  ; otherwise, reset
209+  D124              robots_move0:
210+  D124 DD 77 04         ld (ix+4),a                             ; store
211+  D127              robots_move1:
212+  D127 DD 7E 05         ld a,(ix+5)
213+  D12A FE 00            cp 0                                    ; are we automoving
214+  D12C CA 35 D1         jp z,robots_move2                       ; if not, keep directions
215+  D12F CD 51 D1         call robots_automove
216+  D132 C3 39 D1         jp robots_move3
217+  D135              robots_move2:
218+  D135 CD 86 D1         call robots_checkdirectionsandmove
219+  D138 C9               ret
220+  D139              robots_move3:
221+  D139 CD 7E D3         call robots_checkforplayer              ; check to see if we collided with a player
222+  D13C C9               ret
223+  D13D              robots_move4:
224+  D13D DD 7E 04         ld a,(ix+4)
225+  D140 FE 48            cp 72
226+  D142 C2 4B D1         jp nz,robots_move5
227+  D145 3E 40            ld a,64
228+  D147 DD 77 04         ld (ix+4),a
229+  D14A C9               ret
230+  D14B              robots_move5:
231+  D14B 3E 48            ld a,72
232+  D14D DD 77 04         ld (ix+4),a
233+  D150 C9               ret
234+  D151
235+  D151
236+  D151              ;
237+  D151              ; Processes automove
238+  D151              ; Inputs:
239+  D151              ; ix - points to the current robot
240+  D151              ; a - number of frames left to move
241+  D151              robots_automove:
242+  D151 3D               dec a
243+  D152 DD 77 05         ld (ix+5),a                         ; store the decreased frames
244+  D155 DD 4E 00 DD      ld bc,(ix)                          ; get coords
244+  D159 46 01
245+  D15B DD 7E 06         ld a,(ix+6)                         ; get the direction
246+  D15E FE 00            cp 0                                ; left
247+  D160 CA 71 D1         jp z,robots_automove1
248+  D163 FE 02            cp 2                                ; up
249+  D165 CA 75 D1         jp z,robots_automove3
250+  D168 FE 03            cp 3                                ; down
251+  D16A CA 7A D1         jp z,robots_automove4
252+  D16D 04               inc b                               ; right
253+  D16E C3 7F D1         jp robots_automove2
254+  D171              robots_automove1:
255+  D171 05               dec b
256+  D172 C3 7F D1         jp robots_automove2
257+  D175              robots_automove3:
258+  D175 0D               dec c
259+  D176 0D               dec c
260+  D177 C3 7F D1         jp robots_automove2
261+  D17A              robots_automove4:
262+  D17A 0C               inc c
263+  D17B 0C               inc c
264+  D17C C3 7F D1         jp robots_automove2
265+  D17F              robots_automove2:
266+  D17F DD 71 00 DD      ld (ix),bc
266+  D183 70 01
267+  D185 C9               ret
268+  D186
269+  D186              ;
270+  D186              ; Checks if a robot can move in all directions, then picks one and moves there.
271+  D186              ; This looks complicated, but really what it does is:
272+  D186              ; 1) Look at the current direction
273+  D186              ; 2) Randomly determine which orthoganal direction check first
274+  D186              ; 3) If orthogonal can't be moved, keep going in direction we're going
275+  D186              ; 4) Otherwise, back the way we came
276+  D186              ; Inputs:
277+  D186              ; ix - points to the current robot
278+  D186              ;
279+  D186              robots_checkdirectionsandmove:
280+  D186 DD 7E 06         ld a,(ix+6)                 ; get the direction
281+  D189 FE 00            cp 0                        ; left
282+  D18B C2 B2 D1         jp nz,robots_checkdirectionsandmove0
283+  D18E                  ; random check
284+  D18E CD 77 C3         call game_getcurrentframe
285+  D191 E6 01            and 1                       ; odd or even
286+  D193 CA 9F D1         jp z,robots_checkdirectionsandmove3
287+  D196 CD 38 D2         call robots_checkupthendown ; prefer up over down
288+  D199 FE 01            cp 1
289+  D19B C8               ret z
290+  D19C C3 A5 D1         jp robots_checkdirectionsandmove4
291+  D19F              robots_checkdirectionsandmove3:
292+  D19F CD 2E D2         call robots_checkdownthenup ; prefer down over up
293+  D1A2 FE 01            cp 1
294+  D1A4 C8               ret z
295+  D1A5              robots_checkdirectionsandmove4:
296+  D1A5                  ; check left
297+  D1A5 CD BE D2         call robots_checkleftandmove
298+  D1A8 FE 01            cp 1
299+  D1AA C8               ret z                       ; if we moved, don't check again
300+  D1AB                  ; check right
301+  D1AB CD F7 D2         call robots_checkrightandmove
302+  D1AE FE 01            cp 1
303+  D1B0 C8               ret z                       ; if we moved, don't check again
304+  D1B1                  ; if we're here and haven't moved...
305+  D1B1 C9               ret
306+  D1B2              robots_checkdirectionsandmove0
307+  D1B2 FE 01            cp 1                        ; right
308+  D1B4 C2 DB D1         jp nz,robots_checkdirectionsandmove1
309+  D1B7                  ; ALREADY MOVING RIGHT
310+  D1B7                  ; random check
311+  D1B7 CD 77 C3         call game_getcurrentframe
312+  D1BA E6 01            and 1                       ; odd or even
313+  D1BC CA C8 D1         jp z,robots_checkdirectionsandmove5
314+  D1BF CD 2E D2         call robots_checkdownthenup ; prefer down over up
315+  D1C2 FE 01            cp 1
316+  D1C4 C8               ret z
317+  D1C5 C3 CE D1         jp robots_checkdirectionsandmove6
318+  D1C8              robots_checkdirectionsandmove5:
319+  D1C8 CD 38 D2         call robots_checkupthendown ; prefer down over up
320+  D1CB FE 01            cp 1
321+  D1CD C8               ret z
322+  D1CE              robots_checkdirectionsandmove6:
323+  D1CE                  ; check right
324+  D1CE CD F7 D2         call robots_checkrightandmove
325+  D1D1 FE 01            cp 1
326+  D1D3 C8               ret z                       ; if we moved, don't check again
327+  D1D4                  ; check left
328+  D1D4 CD BE D2         call robots_checkleftandmove
329+  D1D7 FE 01            cp 1
330+  D1D9 C8               ret z                       ; if we moved, don't check again
331+  D1DA                  ; if we're here and haven't moved...
332+  D1DA C9               ret
333+  D1DB              robots_checkdirectionsandmove1
334+  D1DB FE 02            cp 2                        ; up
335+  D1DD C2 04 D2         jp nz,robots_checkdirectionsandmove2
336+  D1E0                  ; ALREADY MOVING UP
337+  D1E0                  ; random check
338+  D1E0 CD 77 C3         call game_getcurrentframe
339+  D1E3 E6 01            and 1                       ; odd or even
340+  D1E5 CA F1 D1         jp z,robots_checkdirectionsandmove7
341+  D1E8 CD 4E D2         call robots_checkleftthenright ; prefer left over right
342+  D1EB FE 01            cp 1
343+  D1ED C8               ret z
344+  D1EE C3 F7 D1         jp robots_checkdirectionsandmove8
345+  D1F1              robots_checkdirectionsandmove7:
346+  D1F1 CD 44 D2         call robots_checkrightthenleft ; prefer right over left
347+  D1F4 FE 01            cp 1
348+  D1F6 C8               ret z
349+  D1F7              robots_checkdirectionsandmove8:
350+  D1F7                  ; check up
351+  D1F7 CD 5A D2         call robots_checkupandmove
352+  D1FA FE 01            cp 1
353+  D1FC C8               ret z                       ; if we moved, don't check again
354+  D1FD                  ; check down
355+  D1FD CD 90 D2         call robots_checkdownandmove
356+  D200 FE 01            cp 1
357+  D202 C8               ret z                       ; if we moved, don't check again
358+  D203                  ; if we're here and haven't moved...
359+  D203 C9               ret
360+  D204              robots_checkdirectionsandmove2
361+  D204                  ; ALREADY MOVING DOWN
362+  D204                  ; random check
363+  D204 CD 77 C3         call game_getcurrentframe
364+  D207 E6 01            and 1                       ; odd or even
365+  D209 CA 15 D2         jp z,robots_checkdirectionsandmove9
366+  D20C CD 44 D2         call robots_checkrightthenleft ; prefer right over left
367+  D20F FE 01            cp 1
368+  D211 C8               ret z
369+  D212 C3 1B D2         jp robots_checkdirectionsandmove10
370+  D215              robots_checkdirectionsandmove9:
371+  D215 CD 4E D2         call robots_checkleftthenright ; prefer left over right
372+  D218 FE 01            cp 1
373+  D21A C8               ret z
374+  D21B              robots_checkdirectionsandmove10:
375+  D21B                  ; check down
376+  D21B CD 90 D2         call robots_checkdownandmove
377+  D21E FE 01            cp 1
378+  D220 C8               ret z                       ; if we moved, don't check again
379+  D221                  ; check right first
380+  D221 CD F7 D2         call robots_checkrightandmove
381+  D224 FE 01            cp 1
382+  D226 C8               ret z                       ; if we moved, don't check again
383+  D227                  ; check up
384+  D227 CD 5A D2         call robots_checkupandmove
385+  D22A FE 01            cp 1
386+  D22C C8               ret z                       ; if we moved, don't check again
387+  D22D                  ; if we're here and haven't moved...
388+  D22D C9               ret
389+  D22E
390+  D22E              ;
391+  D22E              ; Different orders of checking directions, for pseudo random motion
392+  D22E              ;
393+  D22E              robots_checkdownthenup:
394+  D22E                  ; check down
395+  D22E CD 90 D2         call robots_checkdownandmove
396+  D231 FE 01            cp 1
397+  D233 C8               ret z                       ; if we moved, don't check again
398+  D234                  ; check up
399+  D234 CD 5A D2         call robots_checkupandmove
400+  D237 C9               ret
401+  D238
402+  D238              robots_checkupthendown:
403+  D238                  ; check up
404+  D238 CD 5A D2         call robots_checkupandmove
405+  D23B FE 01            cp 1
406+  D23D C8               ret z
407+  D23E                  ; check down
408+  D23E CD 90 D2         call robots_checkdownandmove
409+  D241 FE 01            cp 1
410+  D243 C9               ret
411+  D244              robots_checkrightthenleft:
412+  D244                  ; check right
413+  D244 CD F7 D2         call robots_checkrightandmove
414+  D247 FE 01            cp 1
415+  D249 C8               ret z                       ; if we moved, don't check again
416+  D24A                  ; check left
417+  D24A CD BE D2         call robots_checkleftandmove
418+  D24D C9               ret
419+  D24E
420+  D24E              robots_checkleftthenright:
421+  D24E                  ; check left
422+  D24E CD BE D2         call robots_checkleftandmove
423+  D251 FE 01            cp 1
424+  D253 C8               ret z
425+  D254                  ; check right
426+  D254 CD F7 D2         call robots_checkrightandmove
427+  D257 FE 01            cp 1
428+  D259 C9               ret
429+  D25A
430+  D25A              ;
431+  D25A              ; Checks up for movement
432+  D25A              ; Outputs:
433+  D25A              ; a - 1 if have moved
434+  D25A              robots_checkupandmove:
435+  D25A                  ; check above
436+  D25A DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
436+  D25E 46 01
437+  D260 79               ld a,c
438+  D261 FE 28            cp 40
439+  D263 D8               ret c
440+  D264 CD FE AB         call sprites_scadd              ; get the memory location of cell into de
441+  D267 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
442+  D269 11 20 00         ld de,32
443+  D26C ED 52            sbc hl,de                       ; memory location of line above now in hl
444+  D26E 7E               ld a,(hl)                       ; get the contents of the line
445+  D26F FE 00            cp 0
446+  D271 C2 8D D2         jp nz,robots_checkupandmove0    ; can't move here so return
447+  D274 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
447+  D278 46 01
448+  D27A 0D               dec c                       ; move up
449+  D27B 0D               dec c
450+  D27C DD 71 00 DD      ld (ix),bc
450+  D280 70 01
451+  D282 DD 36 06 02      ld (ix+6),2
452+  D286 DD 36 05 03      ld (ix+5),3                 ; set the auto move frames
453+  D28A 3E 01            ld a,1
454+  D28C C9               ret
455+  D28D              robots_checkupandmove0:
456+  D28D 3E 00            ld a,0
457+  D28F C9               ret
458+  D290
459+  D290              ;
460+  D290              ; Checks down for movement
461+  D290              ; Outputs:
462+  D290              ; a - 1 if have moved
463+  D290              robots_checkdownandmove:
464+  D290                  ; check below
465+  D290 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
465+  D294 46 01
466+  D296 CD FE AB         call sprites_scadd              ; get the memory location of cell into de
467+  D299 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
468+  D29B 24               inc h                       ; memory location of cell beneath now in hl
469+  D29C 7E               ld a,(hl)                       ; get the contents of the line
470+  D29D FE 00            cp 0
471+  D29F C2 BB D2         jp nz,robots_checkdownandmove0    ; can't move here so return
472+  D2A2 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
472+  D2A6 46 01
473+  D2A8 0C               inc c                       ; move up
474+  D2A9 0C               inc c
475+  D2AA DD 71 00 DD      ld (ix),bc
475+  D2AE 70 01
476+  D2B0 DD 36 06 03      ld (ix+6),3
477+  D2B4 DD 36 05 03      ld (ix+5),3                 ; set the auto move frames
478+  D2B8 3E 01            ld a,1
479+  D2BA C9               ret
480+  D2BB              robots_checkdownandmove0:
481+  D2BB 3E 00            ld a,0
482+  D2BD C9               ret
483+  D2BE
484+  D2BE              ;
485+  D2BE              ; Checks left for movement
486+  D2BE              ; Outputs:
487+  D2BE              ; a - 1 if have moved
488+  D2BE              robots_checkleftandmove:
489+  D2BE                  ; check below
490+  D2BE DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
490+  D2C2 46 01
491+  D2C4 CD FE AB         call sprites_scadd              ; get the memory location of cell into de
492+  D2C7 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
493+  D2C9 78               ld a,b
494+  D2CA 06 08            ld b,8
495+  D2CC 90               sub b                           ; move one cell left
496+  D2CD 47               ld b,a
497+  D2CE 2B               dec hl                          ; memory location of cell to the right now in hl
498+  D2CF CD 21 C1         call movement_spaceisempty       ; check space is empty
499+  D2D2 7B               ld a,e                          ; check space empty flag
500+  D2D3 FE 00            cp 0
501+  D2D5 CA F4 D2         jp z,robots_checkleftandmove0    ; if zero can't move
502+  D2D8 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
502+  D2DC 46 01
503+  D2DE 05               dec b
504+  D2DF DD 71 00 DD      ld (ix),bc
504+  D2E3 70 01
505+  D2E5 DD 36 06 00      ld (ix+6),0
506+  D2E9 DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
507+  D2ED DD 36 03 00      ld (ix+3),0                 ; set to right
508+  D2F1 3E 01            ld a,1
509+  D2F3 C9               ret
510+  D2F4              robots_checkleftandmove0:
511+  D2F4 3E 00            ld a,0
512+  D2F6 C9               ret
513+  D2F7
514+  D2F7              ;
515+  D2F7              ; Checks right for movement
516+  D2F7              ; Outputs:
517+  D2F7              ; a - 1 if have moved
518+  D2F7              robots_checkrightandmove:
519+  D2F7                  ; check below
520+  D2F7 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
520+  D2FB 46 01
521+  D2FD 78               ld a,b
522+  D2FE FE E8            cp 232
523+  D300 CA 32 D3         jp z,robots_checkrightandmove0  ; can't move if at edge
524+  D303 CD FE AB         call sprites_scadd              ; get the memory location of cell into de
525+  D306 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
526+  D308 3E 08            ld a,8
527+  D30A 80               add b                           ; move one cell right
528+  D30B 47               ld b,a
529+  D30C 23               inc hl                          ; memory location of cell to the right now in hl
530+  D30D CD 21 C1         call movement_spaceisempty       ; check space is empty
531+  D310 7B               ld a,e                          ; check space empty flag
532+  D311 FE 00            cp 0
533+  D313 CA 32 D3         jp z,robots_checkrightandmove0    ; if zero can't move
534+  D316 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
534+  D31A 46 01
535+  D31C 04               inc b
536+  D31D DD 71 00 DD      ld (ix),bc
536+  D321 70 01
537+  D323 DD 36 06 01      ld (ix+6),1
538+  D327 DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
539+  D32B DD 36 03 01      ld (ix+3),1                 ; set to right
540+  D32F 3E 01            ld a,1
541+  D331 C9               ret
542+  D332              robots_checkrightandmove0:
543+  D332 3E 00            ld a,0
544+  D334 C9               ret
545+  D335
546+  D335              ;
547+  D335              ; Draws a robot
548+  D335              ; Inputs:
549+  D335              ; ix - points to first byte of robot in array
550+  D335              robots_draw:
551+  D335 DD 4E 00 DD      ld bc,(ix)
551+  D339 46 01
552+  D33B 21 F3 BD         ld hl,robot_sprite                      ; set to the robot sprite
553+  D33E DD 7E 02         ld a,(ix+2)                             ; get the state
554+  D341 FE 02            cp 2                                    ; is this dying
555+  D343 CA 5E D3         jp z,robots_draw1
556+  D346              robots_draw3:
557+  D346 DD 7E 03         ld a,(ix+3)                             ; get the direction
558+  D349 FE 00            cp 0
559+  D34B CA 52 D3         jp z,robots_draw0                       ; if left, nothing to do
560+  D34E 11 20 00         ld de,32
561+  D351 19               add hl,de                               ; add four frames to sprite
562+  D352              robots_draw0:
563+  D352 DD 7E 04         ld a,(ix+4)                             ; get the anim frame
564+  D355 11 00 00         ld de,0
565+  D358 5F               ld e,a
566+  D359 19               add hl,de                               ; add to base
567+  D35A CD 09 AB         call sprites_drawsprite
568+  D35D C9               ret
569+  D35E              ;
570+  D35E              ; Dying
571+  D35E              ;
572+  D35E              robots_draw1:
573+  D35E DD 7E 05         ld a,(ix+5)                             ; get anim frames
574+  D361 FE 00            cp 0                                    ; if zero this is the first time around
575+  D363 C2 6E D3         jp nz,robots_draw2
576+  D366 3E 18            ld a,24
577+  D368 DD 77 05         ld (ix+5),a                             ; load up the anim frames
578+  D36B C3 46 D3         jp robots_draw3                         ; return to main loop to draw as normal
579+  D36E              robots_draw2:
580+  D36E 3D               dec a
581+  D36F DD 77 05         ld (ix+5),a
582+  D372 FE 00            cp 0                                    ; have we reached the end yet
583+  D374 C2 7A D3         jp nz, robots_draw4
584+  D377 CD 86 D0         call robots_kill
585+  D37A              robots_draw4:
586+  D37A C3 52 D3         jp robots_draw0
587+  D37D C9               ret
588+  D37E
589+  D37E              ;
590+  D37E              ; Checks to see if the robot is hitting a player
591+  D37E              ; Inputs:
592+  D37E              ; ix - memory location of robot we're checking
593+  D37E              robots_checkforplayer:
594+  D37E 3A 93 C3         ld a,(player+11)     ; get player state
595+  D381 FE 00            cp 0
596+  D383 C0               ret nz               ; if already dying, don't kill again
597+  D384 DD 4E 00 DD      ld bc,(ix)           ; get coords
597+  D388 46 01
598+  D38A ED 5B 88 C3      ld de,(player)       ; get the player coords
599+  D38E 7B               ld a,e               ; get the vert coord first
600+  D38F 91               sub c                ; subtract the diamond vertical coord from players
601+  D390 C6 08            add 8                ; add the max distance
602+  D392 FE 11            cp 17                ; compare to max*2+1? if carry flag set, they've hit
603+  D394 D0               ret nc               ; if not, hasn't hit
604+  D395 7A               ld a,d               ; get the player horiz coord
605+  D396 90               sub b                ; subtract rock coord
606+  D397 C6 08            add 8                ; add max distance
607+  D399 FE 11            cp 17                ; compare to max*2+1? if carry flag set, they've hit
608+  D39B D0               ret nc
609+  D39C DD 36 02 00      ld (ix+2),0          ; mark as inactive
610+  D3A0 CD C3 C4         call player_robotkillplayer ; mark the player as killed
611+  D3A3 C9               ret
# file closed: game/robots.asm
163   D3A4                  include "game\bullet.asm"
# file opened: game/bullet.asm
  1+  D3A4              ;
  2+  D3A4              ; Current state: x & y coords (screen), direction (0 left, 1 right), state
  3+  D3A4              ;
  4+  D3A4              bullet_state:
  5+  D3A4 00 00 00 00      defb 0,0,0,0
  6+  D3A8
  7+  D3A8              ;
  8+  D3A8              ; Initialise a the bullet
  9+  D3A8              ;
 10+  D3A8              bullet_init:
 11+  D3A8 DD 21 A4 D3      ld ix,bullet_state
 12+  D3AC DD 36 00 00      ld (ix),0
 13+  D3B0 DD 36 01 00      ld (ix+1),0
 14+  D3B4 DD 36 02 00      ld (ix+2),0
 15+  D3B8 DD 36 03 00      ld (ix+3),0
 16+  D3BC C9               ret
 17+  D3BD
 18+  D3BD              ;
 19+  D3BD              ; Shoots the bullet
 20+  D3BD              ;
 21+  D3BD              bullet_shoot:
 22+  D3BD DD 21 A4 D3      ld ix,bullet_state
 23+  D3C1 ED 4B 88 C3      ld bc,(player)              ; get the player coords
 24+  D3C5 3A 8A C3         ld a,(player+2)             ; get the player direction
 25+  D3C8 FE 01            cp 1                        ; going left?
 26+  D3CA CA D8 D3         jp z,bullet_shoot0
 27+  D3CD 3E 08            ld a,8
 28+  D3CF 80               add a,b                     ; going right so add eight to start coords
 29+  D3D0 47               ld b,a
 30+  D3D1 DD 36 02 01      ld (ix+2),1                 ; set right
 31+  D3D5 C3 E1 D3         jp bullet_shoot1
 32+  D3D8              bullet_shoot0:
 33+  D3D8 78               ld a,b
 34+  D3D9 06 08            ld b,8
 35+  D3DB 90               sub b
 36+  D3DC 47               ld b,a                      ; going left so subtract eight to start coords
 37+  D3DD DD 36 02 00      ld (ix+2),0                 ; set right
 38+  D3E1              bullet_shoot1:
 39+  D3E1 DD 71 00 DD      ld (ix),bc        ; store coords
 39+  D3E5 70 01
 40+  D3E7 DD 36 03 01      ld (ix+3),1       ; set state to 1
 41+  D3EB CD 41 D4         call bullet_draw ; draw the initial frame
 42+  D3EE C9               ret
 43+  D3EF
 44+  D3EF              ;
 45+  D3EF              ; Performs bullet processing
 46+  D3EF              ;
 47+  D3EF              bullet_process:
 48+  D3EF 3A A7 D3         ld a,(bullet_state+3)       ; get the state
 49+  D3F2 FE 00            cp 0
 50+  D3F4 C8               ret z                       ; don't draw if this has become inactive
 51+  D3F5 CD 41 D4         call bullet_draw            ; delete current frame
 52+  D3F8 CD 05 D4         call bullet_move            ; move the bullet
 53+  D3FB 3A A7 D3         ld a,(bullet_state+3)       ; get the state
 54+  D3FE FE 00            cp 0
 55+  D400 C8               ret z                       ; don't draw if this has become inactive
 56+  D401 CD 41 D4         call bullet_draw            ; draw new frame
 57+  D404 C9               ret
 58+  D405
 59+  D405              ;
 60+  D405              ; Moves the bullet, checking for collisions
 61+  D405              ;
 62+  D405              bullet_move:
 63+  D405 DD 21 A4 D3      ld ix,bullet_state
 64+  D409 DD 4E 00 DD      ld bc,(ix)
 64+  D40D 46 01
 65+  D40F DD 7E 02         ld a,(ix+2)                 ; get the direction
 66+  D412 FE 00            cp 0                        ; going left?
 67+  D414 CA 1E D4         jp z,bullet_move0
 68+  D417 3E 08            ld a,8
 69+  D419 80               add b
 70+  D41A 47               ld b,a                      ; add 8 since going right
 71+  D41B C3 23 D4         jp bullet_move1
 72+  D41E              bullet_move0:
 73+  D41E 78               ld a,b
 74+  D41F 06 08            ld b,8
 75+  D421 90               sub b
 76+  D422 47               ld b,a                      ; subtract 8 since going left
 77+  D423              bullet_move1:
 78+  D423 DD 71 00 DD      ld (ix),bc                  ; store new coords
 78+  D427 70 01
 79+  D429 C5               push bc
 80+  D42A CD 4E D4         call bullets_checkforrobot
 81+  D42D C1               pop bc
 82+  D42E FE 01            cp 1                        ; if we hit a robot, keep moving
 83+  D430 C8               ret z
 84+  D431 CD FE AB         call sprites_scadd          ; get memory loc of this block into de
 85+  D434 21 60 00         ld hl,96
 86+  D437 19               add hl,de
 87+  D438 7E               ld a,(hl)                   ; get the content
 88+  D439 FE 00            cp 0
 89+  D43B C8               ret z                       ; if empty, continue
 90+  D43C DD 36 03 00      ld (ix+3),0                 ; otherwise, mark bullet as inactive
 91+  D440 C9               ret
 92+  D441
 93+  D441              ;
 94+  D441              ; Draw the bullet
 95+  D441              ;
 96+  D441              bullet_draw:
 97+  D441 ED 4B A4 D3      ld bc,(bullet_state)        ; get coords
 98+  D445 3E 1B            ld a,27
 99+  D447 CD 84 AA         call screen_getblock        ; get the block address
100+  D44A CD 09 AB         call sprites_drawsprite     ; draw the sprite
101+  D44D C9               ret
102+  D44E
103+  D44E              ;
104+  D44E              ; Checks to see if the robot is hitting a bullet
105+  D44E              ; Outputs:
106+  D44E              ; a = 0 if not robot hit
107+  D44E              ; a = 1 if robot not hit
108+  D44E              bullets_checkforrobot:
109+  D44E 3E 00            ld a,0
110+  D450 32 A4 D4         ld (bullets_tmp),a
111+  D453 3A 17 D0         ld a,(robots_robotsmax) ; robots to check
112+  D456 47               ld b,a
113+  D457 FD 21 E9 CF      ld iy,robots_robots   ; start of robot array
114+  D45B              bullets_checkforrobot0:
115+  D45B C5               push bc
116+  D45C FD 7E 02         ld a,(iy+2)             ; get the state
117+  D45F FE 01            cp 1
118+  D461 C2 98 D4         jp nz,bullets_checkforrobot1 ; if not active, don't check
119+  D464 FD 5E 00 FD      ld de,(iy)              ; get robot coords
119+  D468 56 01
120+  D46A 7A               ld a,d
121+  D46B E6 F8            and 248                 ; get nearest multiple of 8
122+  D46D 57               ld d,a
123+  D46E ED 4B A4 D3      ld bc,(bullet_state)    ; get bullet coords
124+  D472 7A               ld a,d               ; get the player horiz coord
125+  D473 90               sub b                ; subtract robot coord
126+  D474 FE 00            cp 0                ; should be the same
127+  D476 C2 82 D4         jp nz,bullets_checkforrobot2 ; if not, might have hit, so check the next char along... if matched, check vert
128+  D479 3E 08            ld a,8
129+  D47B 82               add a,d
130+  D47C 90               sub b                ; check again for the next char along
131+  D47D FE 00            cp 0
132+  D47F C2 98 D4         jp nz,bullets_checkforrobot1 ; if not, haven't hit
133+  D482              bullets_checkforrobot2:
134+  D482 7B               ld a,e               ; get the vert coord
135+  D483 91               sub c                ; subtract the bullet vertical coord from robots
136+  D484 C6 04            add 4                ; add the max distance
137+  D486 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
138+  D488 D2 98 D4         jp nc,bullets_checkforrobot1   ; if not, hasn't hit
139+  D48B FD 36 02 02      ld (iy+2),2             ; mark the robot as killed
140+  D48F FD 36 05 00      ld (iy+5),0             ; mark the anim frames as zero
141+  D493 3E 01            ld a,1
142+  D495 32 A4 D4         ld (bullets_tmp),a      ; hit the flag to say we killed a robot
143+  D498              bullets_checkforrobot1:
144+  D498 11 07 00         ld de,7
145+  D49B FD 19            add iy,de              ; move to next robot
146+  D49D C1               pop bc
147+  D49E 10 BB            djnz bullets_checkforrobot0
148+  D4A0 3A A4 D4         ld a,(bullets_tmp)
149+  D4A3 C9               ret
150+  D4A4
151+  D4A4              bullets_tmp:
152+  D4A4 00               defb 0
153+  D4A5
# file closed: game/bullet.asm
164   D4A5
165   D4A5              ;===========================================================================
166   D4A5              ; Stack.
167   D4A5              ;===========================================================================
168   D4A5
169   D4A5              ; Stack: this area is reserved for the stack
170   D4A5              STACK_SIZE: equ 100    ; in words
171   D4A5
172   D4A5              ; Reserve stack space
173   D4A5 00 00            defw 0  ; WPMEM, 2
174   D4A7              stack_bottom:
175   D4A7 00 00 00...      defs    STACK_SIZE*2, 0
176   D56F              stack_top:
177   D56F 00 00            defw 0  ; WPMEM, 2
178   D571
179   D571                     SAVESNA "./dist/ThePit.sna", main
180   D571                     ;SAVETAP "./dist/ThePit.tap", main
# file closed: main.asm
