# file opened: main.asm
  1   0000                  DEVICE ZXSPECTRUM48
  2   0000
  3   0000                  ORG $8000
  4   8000
  5   8000              ;===========================================================================
  6   8000              ; Persistent watchpoint.
  7   8000              ; Change WPMEMx (remove the 'x' from WPMEMx) below to activate.
  8   8000              ; If you do so the program will hit a breakpoint when it tries to
  9   8000              ; write to the first byte of the 3rd line.
 10   8000              ; When program breaks in the fill_memory sub routine please hover over hl
 11   8000              ; to see that it contains 0x5804 or COLOR_SCREEN+64.
 12   8000              ;===========================================================================
 13   8000
 14   8000              ; WPMEMx 0x5840, 1, w
 15   8000
 16   8000
 17   8000              ;===========================================================================
 18   8000              ; main routine - the code execution starts here.
 19   8000              ; Sets up the new interrupt routine, the memory
 20   8000              ; banks and jumps to the start loop.
 21   8000              ;===========================================================================
 22   8000              main:
 23   8000 21 D9 B8         ld hl,font
 24   8003 22 36 5C         ld (23606),hl
 25   8006 CD 64 B0         call options_show
 26   8009
 27   8009                  ; Draw the title screen
 28   8009              main_titlescreen:
 29   8009 CD 2B AC         call titlescreen_show
 30   800C CD BD C5         call player_init_gamestart
 31   800F
 32   800F              main_lifestart:
 33   800F
 34   800F CD E3 C5         call player_init_lifestart
 35   8012 CD F2 C4         call game_setcurrentrocks   ; set the current rocks based on the level
 36   8015                  ;ld a,12
 37   8015                  ;ld (game_difficulty),a
 38   8015 CD 32 C5         call game_setdifficulty     ; set the current difficulty
 39   8018
 40   8018 CD C3 AD         call lifescreen_draw        ; show the lives remaining screen
 41   801B
 42   801B CD C6 80         call init_start
 43   801E CD F5 A8         call screen_draw
 44   8021 CD 44 A8         call buffer_allbuffertoscreen
 45   8024
 46   8024 CD F7 CE         call missiles_init
 47   8027 CD E4 C7         call ship_land              ; land the ship
 48   802A CD 03 C9         call tank_init
 49   802D CD BE CE         call diamonds_init
 50   8030 CD AF D0         call thepit_init
 51   8033 CD 4B D1         call monster_init
 52   8036 CD 9A D2         call robots_init
 53   8039 CD 2A D6         call bullet_init
 54   803C
 55   803C              mloop:
 56   803C                  ;halt
 57   803C CD 83 80         call main_loop_processing
 58   803F
 59   803F                  ;
 60   803F                  ; Check if the player died
 61   803F                  ;
 62   803F 21 81 C5         ld hl,player+10
 63   8042 7E               ld a,(hl)                   ; check if the player died this frame
 64   8043 FE 01            cp 1
 65   8045 C2 6F 80         jp nz,mloop0
 66   8048 CD 74 C6         call player_died        ; do end of life housekeeping
 67   804B 06 28            ld b,40
 68   804D CD 61 81         call utilities_pauseforframes
 69   8050
 70   8050 21 80 C5         ld hl,player+9        ; check lives remaining
 71   8053 7E               ld a,(hl)
 72   8054 FE 00            cp 0
 73   8056 C2 69 80         jp nz,mloop1         ; haven't finished, so keep going
 74   8059
 75   8059 3A 87 C4         ld a,(game_numberplayers) ; get the number of players
 76   805C FE 01            cp 1
 77   805E CA B7 80         jp z,main_gameover   ; if just one player, then this is game over
 78   8061
 79   8061 3A 88 C4         ld a,(game_currentplayer) ; get the current player
 80   8064 FE 02            cp 2                    ; if we're here, we have no lives, and if the current player is 2, then we're done
 81   8066 CA B7 80         jp z,main_gameover            ; if it's  two game over
 82   8069
 83   8069              mloop1:
 84   8069 CD D6 C4         call game_changeplayer ; change player if needed
 85   806C C3 0F 80         jp main_lifestart    ; otherwise, start a new life
 86   806F              mloop0:
 87   806F                  ;
 88   806F                  ; Check if the player completed the level
 89   806F                  ;
 90   806F 21 84 C5         ld hl,player+13
 91   8072 7E               ld a,(hl)
 92   8073 FE 01            cp 1
 93   8075 C2 3C 80         jp nz,mloop
 94   8078 CD AE C7         call player_checkforexit
 95   807B FE 01            cp 1                        ; look at return, if 1, level has been completed
 96   807D CA BD 80         jp z,main_endlevel          ; jump to level transition screen
 97   8080 C3 3C 80         jp mloop                ; start the loop again
 98   8083
 99   8083
100   8083              main_loop_processing:
101   8083
102   8083 CD 03 A8         call buffer_buffertoscreen  ; copy buffer to screen
103   8086 CD 68 A7         call buffer_clearlist       ; zero the updated lines list
104   8089 CD 87 C5         call player_getlocation     ; figure out where the player is
105   808C CD B8 C6         call player_drawplayer      ; delete player
106   808F CD 7D BF         call control_input          ; check input
107   8092 CD B8 C6         call player_drawplayer      ; draw player
108   8095 CD 32 C9         call tank_process           ; prcoess the tank
109   8098 CD CF C7         call ship_process           ; proces the ship
110   809B CD 3C CB         call rocks_processrocks     ; process falling rocks
111   809E CD BB D0         call thepit_process         ; process the pit trap
112   80A1 CD 1F CF         call missiles_process       ; process missiles
113   80A4 CD 68 D1         call monster_process        ; process monster
114   80A7 CD 1D D3         call robots_process         ; process robots
115   80AA CD 71 D6         call bullet_process         ; process the bullet
116   80AD CD 9D CE         call diamonds_twinkle       ; make the diamonds twinkle
117   80B0 CD AF CC         call scores_printscore      ; update the score on screen
118   80B3 CD 12 C5         call game_incrementframe    ; increment the game frame
119   80B6
120   80B6 C9               ret
121   80B7
122   80B7              main_gameover:
123   80B7 CD 26 AE         call gameover_draw          ; show the game over screen
124   80BA C3 09 80         jp main_titlescreen         ; go back to title
125   80BD
126   80BD              main_endlevel:
127   80BD CD 42 C6         call player_recordcurrentstate
128   80C0 CD 56 AF         call endlevel_draw          ; show the end level screen
129   80C3 C3 0F 80         jp main_lifestart           ; start a new life
130   80C6
131   80C6
132   80C6              ;===========================================================================
133   80C6              ; Include modules
134   80C6              ;===========================================================================
135   80C6                  include "init.asm"
# file opened: init.asm
  1+  80C6              ;
  2+  80C6              ; Set up at start up
  3+  80C6              ;
  4+  80C6              init_start:
  5+  80C6              ; We want a black screen.
  6+  80C6
  7+  80C6 3E 47            ld a,71             ; white ink (7) on black paper (0),
  8+  80C8                                      ; bright (64).
  9+  80C8 CD 46 81         call utilities_clearscreen
 10+  80CB 32 8D 5C         ld (23693),a        ; set our screen colours.
 11+  80CE AF               xor a               ; quick way to load accumulator with zero.
 12+  80CF CD 9B 22         call 8859           ; set permanent border colours.
 13+  80D2
 14+  80D2 21 DA A8         ld hl,screen_offset ; reset some temp variables
 15+  80D5 36 00            ld (hl),0
 16+  80D7 21 DB A8         ld hl,screen_tmp
 17+  80DA 36 00            ld (hl),0
 18+  80DC 21 10 A7         ld hl,buffer_tmp
 19+  80DF 36 00            ld (hl),0
 20+  80E1 23               inc hl
 21+  80E2 36 00            ld (hl),0
 22+  80E4
 23+  80E4 CD 25 C5         call game_resetcurrentframe ; reset current frame
 24+  80E7
 25+  80E7 C9               ret
 26+  80E8
 27+  80E8              ;
 28+  80E8              ;   Start coord
 29+  80E8              ;   vert c, horiz b
 30+  80E8              init_coord:
 31+  80E8 18 30            defb 24,48
 32+  80EA
 33+  80EA              ;
 34+  80EA              ; Number of lives to start
 35+  80EA              ;
 36+  80EA              init_lives:
 37+  80EA 03               defb 3
 38+  80EB
 39+  80EB              ;
 40+  80EB              ; Score to start
 41+  80EB              ;
 42+  80EB              init_score:
 43+  80EB 30 30 30 30      defb '000000'
 43+  80EF 30 30
# file closed: init.asm
136   80F1                  include "utilities.asm"
# file opened: utilities.asm
  1+  80F1              ; ##########################################################################
  2+  80F1              ; Print a character
  3+  80F1              ; Inputs:
  4+  80F1              ; b - x coord
  5+  80F1              ; c - y coord
  6+  80F1              ; d - character
  7+  80F1              ; e - colour
  8+  80F1              ; ##########################################################################
  9+  80F1              utilities_print_char:
 10+  80F1 7B               ld a,e
 11+  80F2 32 8F 5C         ld (23695),a        ; set our temporary screen colours.
 12+  80F5 3E 16            ld a,22
 13+  80F7 D7               rst 16              ; Calls the Sinclair PRINT AT routine
 14+  80F8 78               ld a,b              ; Gets the X co-ordinate
 15+  80F9 3D               dec a
 16+  80FA D7               rst 16
 17+  80FB 79               ld a,c              ; and the Y co-ordinate
 18+  80FC D7               rst 16              ; So, essentially PRINT AT X,Y; like in BASIC
 19+  80FD 7A               ld a,d              ; ASCII code for udg.
 20+  80FE D7               rst 16              ; draw block.
 21+  80FF C9               ret
 22+  8100
 23+  8100
 24+  8100              ;Inputs:
 25+  8100              ;     DE and A are factors
 26+  8100              ;Outputs:
 27+  8100              ;     A is not changed
 28+  8100              ;     B is 0
 29+  8100              ;     C is not changed
 30+  8100              ;     DE is not changed
 31+  8100              ;     HL is the product
 32+  8100              ;Time:
 33+  8100              ;     342+6x
 34+  8100              ;
 35+  8100              utilities_multiply:
 36+  8100 06 08            ld b,8          ;7           7
 37+  8102 21 00 00         ld hl,0         ;10         10
 38+  8105 29               add hl,hl     ;11*8       88
 39+  8106 07               rlca          ;4*8        32
 40+  8107 30 01            jr nc,$+3     ;(12|18)*8  96+6x
 41+  8109 19                   add hl,de   ;--         --
 42+  810A 10 F9            djnz $-5      ;13*7+8     99
 43+  810C C9               ret             ;10         10
 44+  810D
 45+  810D              utilities_waitforkey:
 46+  810D 21 08 5C         ld hl,23560         ; LAST K system variable.
 47+  8110 36 00            ld (hl),0           ; put null value there.
 48+  8112              utilities_waitforkey0:
 49+  8112 7E               ld a,(hl)           ; new value of LAST K.
 50+  8113 FE 00            cp 0                ; is it still zero?
 51+  8115 20 0A            jr nz,utilities_waitforkey1           ; yes, so no key pressed.
 52+  8117 01 1F 00         ld bc,31                        ; Kempston joystick port.
 53+  811A ED 78            in a,(c)                        ; read input.
 54+  811C E6 10            and 16
 55+  811E CA 12 81         jp z,utilities_waitforkey0
 56+  8121              utilities_waitforkey1:
 57+  8121 C9               ret                 ; key was pressed.
 58+  8122
 59+  8122              ;
 60+  8122              ; Waits number of frames for keypress. If got, returns 1, if not 0
 61+  8122              ; Inputs:
 62+  8122              ; a - number of frames to waits
 63+  8122              ; Ouputs:
 64+  8122              ; e - 0 not pressed, 1 pressed
 65+  8122              utilities_waitforkey_forframes:
 66+  8122 21 08 5C         ld hl,23560         ; LAST K system variable.
 67+  8125 36 00            ld (hl),0           ; put null value there.
 68+  8127 47               ld b,a              ; number of frames to wait
 69+  8128              utilities_waitforkey_forframes0:
 70+  8128 7E               ld a,(hl)           ; new value of LAST K.
 71+  8129 FE 00            cp 0                ; is it still zero?
 72+  812B 28 03            jr z,utilities_waitforkey_forframes1           ; yes, so no key pressed.
 73+  812D 1E 01            ld e,1              ; set the pressed flag
 74+  812F C9               ret                 ; key was pressed.
 75+  8130              utilities_waitforkey_forframes1:
 76+  8130 C5               push bc
 77+  8131 01 1F 00         ld bc,31                        ; Kempston joystick port.
 78+  8134 ED 78            in a,(c)                        ; read input.
 79+  8136 C1               pop bc
 80+  8137 E6 10            and 16
 81+  8139 CA 3F 81         jp z,utilities_waitforkey_forframes2
 82+  813C 1E 01            ld e,1              ; set the pressed flag
 83+  813E C9               ret                 ; key was pressed.
 84+  813F              utilities_waitforkey_forframes2:
 85+  813F 76               halt                ; wait for frame
 86+  8140 76               halt                ; wait for frame
 87+  8141 10 E5            djnz utilities_waitforkey_forframes0 ; loop again
 88+  8143 1E 00            ld e,0              ; nothing pressed in time
 89+  8145 C9               ret
 90+  8146
 91+  8146              ;
 92+  8146              ; Clears the screen
 93+  8146              ; Inputs:
 94+  8146              ; a - attribute colour
 95+  8146              utilities_clearscreen:
 96+  8146 76               halt
 97+  8147 21 00 58         ld hl,22528         ; attr
 98+  814A 11 01 58         ld de,22529         ; attr+1
 99+  814D 01 FF 02         ld bc,767
100+  8150 77               ld (hl),a
101+  8151 ED B0            ldir
102+  8153
103+  8153 21 00 40         ld hl, 16384        ;pixels
104+  8156 11 01 40         ld de, 16385        ;pixels + 1
105+  8159 01 FF 17         ld bc, 6143         ;pixels area length - 1
106+  815C 36 00            ld (hl), 0          ;set first byte to '0'
107+  815E ED B0            ldir                ;copy bytes
108+  8160
109+  8160 C9               ret
110+  8161
111+  8161              ;
112+  8161              ; Wait for a number of frames
113+  8161              ; Inputs:
114+  8161              ; b - number of frames
115+  8161              utilities_pauseforframes:
116+  8161 76               halt
117+  8162 10 FD            djnz utilities_pauseforframes
118+  8164 C9               ret
119+  8165
120+  8165              utilities_readkey:
121+  8165 21 85 81         LD HL,utilties_keymap              ; Point HL at the keyboard list
122+  8168 16 08            LD D,8                                  ; This is the number of ports (rows) to check
123+  816A 0E FE            LD C,$FE                            ; C is always FEh for reading keyboard ports
124+  816C              utilities_readkey_0:
125+  816C 46               LD B,(HL)                               ; Get the keyboard port address from table
126+  816D 23               INC HL                                  ; Increment to list of keys
127+  816E ED 78            IN A,(C)                                ; Read the row of keys in
128+  8170 E6 1F            AND $1F                                     ; We are only interested in the first five bits
129+  8172 1E 05            LD E,5                                  ; This is the number of keys in the row
130+  8174              utilities_readkey_1:
131+  8174 CB 3F            SRL A                                   ; Shift A right; bit 0 sets carry bit
132+  8176 30 0B            JR NC,utilities_readkey_2   ; If the bit is 0, we've found our key
133+  8178 23               INC HL                                  ; Go to next table address
134+  8179 1D               DEC E                                   ; Decrement key loop counter
135+  817A 20 F8            JR NZ,utilities_readkey_1   ; Loop around until this row finished
136+  817C 15               DEC D                                   ; Decrement row loop counter
137+  817D 20 ED            JR NZ,utilities_readkey_0   ; Loop around until we are done
138+  817F A7               AND A                                   ; Clear A (no key found)
139+  8180 C3 65 81         jp utilities_readkey
140+  8183              utilities_readkey_2:
141+  8183 7E               LD A,(HL)                               ; We've found a key at this point; fetch the character code!
142+  8184 C9               RET
143+  8185
144+  8185              utilties_keymap:
145+  8185 FE 23 5A 58      defb $FE,"#","Z","X","C","V"
145+  8189 43 56
146+  818B FD 41 53 44      defb $FD,"A","S","D","F","G"
146+  818F 46 47
147+  8191 FB 51 57 45      defb $FB,"Q","W","E","R","T"
147+  8195 52 54
148+  8197 F7 31 32 33      defb $F7,"1","2","3","4","5"
148+  819B 34 35
149+  819D EF 30 39 38      defb $EF,"0","9","8","7","6"
149+  81A1 37 36
150+  81A3 DF 50 4F 49      defb $DF,"P","O","I","U","Y"
150+  81A7 55 59
151+  81A9 BF 23 4C 4B      defb $BF,"#","L","K","J","H"
151+  81AD 4A 48
152+  81AF 7F 20 23 4D      defb $7F," ","#","M","N","B"
152+  81B3 4E 42
153+  81B5
154+  81B5
155+  81B5              ;
156+  81B5              ; Generates a randomish number in the range 0 to e
157+  81B5              ; Inputs:
158+  81B5              ; e - upper value
159+  81B5              ; Outputs:
160+  81B5              ; a - random number
161+  81B5              utilities_randomupper
162+  81B5 3A 86 C4         ld a,(game_framenumber)
163+  81B8 6F               ld l,a
164+  81B9 26 00            ld h,0
165+  81BB 16 00            ld d,0
166+  81BD 42 4B            ld bc,de
167+  81BF              utilities_randomupper0:
168+  81BF B7               or a
169+  81C0 ED 42            sbc hl,bc
170+  81C2 F2 BF 81         jp p,utilities_randomupper0
171+  81C5 09               add hl,bc
172+  81C6 01 00 00         ld bc,0
173+  81C9 09               add hl,bc
174+  81CA 7D               ld a,l
175+  81CB C9               ret
176+  81CC
# file closed: utilities.asm
137   81CC                  include "strings.asm"
# file opened: strings.asm
  1+  81CC              string_score1:
  2+  81CC 04 00 53 43      defb 4,0,'SCORE1',255
  2+  81D0 4F 52 45 31
  2+  81D4 FF
  3+  81D5              string_scorenumbers1:
  4+  81D5 04 01 30 30      defb 4,1,'000000',255
  4+  81D9 30 30 30 30
  4+  81DD FF
  5+  81DE              string_company:
  6+  81DE 0C 00 43 45      defb 12,0,'CENTURI',255
  6+  81E2 4E 54 55 52
  6+  81E6 49 FF
  7+  81E8              string_player1:
  8+  81E8 0C 01 50 4C      defb 12,1,'PLAYER 1',255
  8+  81EC 41 59 45 52
  8+  81F0 20 31 FF
  9+  81F3              string_player2:
 10+  81F3 0C 01 50 4C      defb 12,1,'PLAYER 2',255
 10+  81F7 41 59 45 52
 10+  81FB 20 32 FF
 11+  81FE              string_score2:
 12+  81FE 16 00 53 43      defb 22,0,'SCORE2',255
 12+  8202 4F 52 45 32
 12+  8206 FF
 13+  8207              string_scorenumbers2:
 14+  8207 16 01 30 30      defb 22,1,'000000',255
 14+  820B 30 30 30 30
 14+  820F FF
 15+  8210              string_titlescreen_copyright:
 16+  8210 06 15 7F 31      defb 6,21, 127,'1982  CENTURI INC',255
 16+  8214 39 38 32 20
 16+  8218 20 43 45 4E
 16+  821C 54 55 52 49
 16+  8220 20 49 4E 43
 16+  8224 FF
 17+  8225
 18+  8225
 19+  8225              string_alttitlescreen_1:
 20+  8225 0C 00 43 52      defb 12,0,'CREDITS 1',255
 20+  8229 45 44 49 54
 20+  822D 53 20 31 FF
 21+  8231              string_alttitlescreen_2:
 22+  8231 00 02 20 20      defb 0,2,'           THE OBJECT',254
 22+  8235 20 20 20 20
 22+  8239 20 20 20 20
 22+  823D 20 54 48 45
 22+  8241 20 4F 42 4A
 22+  8245 45 43 54 FE
 23+  8249 00 03 20 20      defb 0,3,'          OF THIS GAME',254
 23+  824D 20 20 20 20
 23+  8251 20 20 20 20
 23+  8255 4F 46 20 54
 23+  8259 48 49 53 20
 23+  825D 47 41 4D 45
 23+  8261 FE
 24+  8262 00 04 20 20      defb 0,4,'         IS TO DIG DOWN',254
 24+  8266 20 20 20 20
 24+  826A 20 20 20 49
 24+  826E 53 20 54 4F
 24+  8272 20 44 49 47
 24+  8276 20 44 4F 57
 24+  827A 4E FE
 25+  827C 00 05 20 20      defb 0,5,'        TO THE BOTTOM PIT',254
 25+  8280 20 20 20 20
 25+  8284 20 20 54 4F
 25+  8288 20 54 48 45
 25+  828C 20 42 4F 54
 25+  8290 54 4F 4D 20
 25+  8294 50 49 54 FE
 26+  8298 00 06 20 20      defb 0,6,'               AND',254
 26+  829C 20 20 20 20
 26+  82A0 20 20 20 20
 26+  82A4 20 20 20 20
 26+  82A8 20 41 4E 44
 26+  82AC FE
 27+  82AD 00 07 20 20      defb 0,7,'        COLLECT AT LEAST',254
 27+  82B1 20 20 20 20
 27+  82B5 20 20 43 4F
 27+  82B9 4C 4C 45 43
 27+  82BD 54 20 41 54
 27+  82C1 20 4C 45 41
 27+  82C5 53 54 FE
 28+  82C8 00 08 20 20      defb 0,8,'         ONE LARGE JEWEL',254
 28+  82CC 20 20 20 20
 28+  82D0 20 20 20 4F
 28+  82D4 4E 45 20 4C
 28+  82D8 41 52 47 45
 28+  82DC 20 4A 45 57
 28+  82E0 45 4C FE
 29+  82E3 00 09 20 20      defb 0,9,'              THEN',254
 29+  82E7 20 20 20 20
 29+  82EB 20 20 20 20
 29+  82EF 20 20 20 20
 29+  82F3 54 48 45 4E
 29+  82F7 FE
 30+  82F8 00 0A 20 20      defb 0,10,'         RETURN TO SHIP',254
 30+  82FC 20 20 20 20
 30+  8300 20 20 20 52
 30+  8304 45 54 55 52
 30+  8308 4E 20 54 4F
 30+  830C 20 53 48 49
 30+  8310 50 FE
 31+  8312 00 0B 20 20      defb 0,11,'         THRU UPPER PIT',255
 31+  8316 20 20 20 20
 31+  831A 20 20 20 54
 31+  831E 48 52 55 20
 31+  8322 55 50 50 45
 31+  8326 52 20 50 49
 31+  832A 54 FF
 32+  832C              string_alttitlescreen_3:
 33+  832C 00 0D 20 20      defb 0,13,'    SINGLE BONUS  5000 POINTS',254
 33+  8330 20 20 53 49
 33+  8334 4E 47 4C 45
 33+  8338 20 42 4F 4E
 33+  833C 55 53 20 20
 33+  8340 35 30 30 30
 33+  8344 20 50 4F 49
 33+  8348 4E 54 53 FE
 34+  834C 00 0E 20 20      defb 0,14,'      COLLECT 1 LARGE JEWEL',254
 34+  8350 20 20 20 20
 34+  8354 43 4F 4C 4C
 34+  8358 45 43 54 20
 34+  835C 31 20 4C 41
 34+  8360 52 47 45 20
 34+  8364 4A 45 57 45
 34+  8368 4C FE
 35+  836A 00 0F 20 20      defb 0,15,'       AND RETURN TO SHIP',254
 35+  836E 20 20 20 20
 35+  8372 20 41 4E 44
 35+  8376 20 52 45 54
 35+  837A 55 52 4E 20
 35+  837E 54 4F 20 53
 35+  8382 48 49 50 FE
 36+  8386 00 11 20 20      defb 0,17,'    DOUBLE BONUS  10000 POINTS',254
 36+  838A 20 20 44 4F
 36+  838E 55 42 4C 45
 36+  8392 20 42 4F 4E
 36+  8396 55 53 20 20
 36+  839A 31 30 30 30
 36+  839E 30 20 50 4F
 36+  83A2 49 4E 54 53
 36+  83A6 FE
 37+  83A7 00 12 20 20      defb 0,18,'    COLLECT ALL 3 LARGE JEWELS',254
 37+  83AB 20 20 43 4F
 37+  83AF 4C 4C 45 43
 37+  83B3 54 20 41 4C
 37+  83B7 4C 20 33 20
 37+  83BB 4C 41 52 47
 37+  83BF 45 20 4A 45
 37+  83C3 57 45 4C 53
 37+  83C7 FE
 38+  83C8 00 13 20 20      defb 0,19,'       OR   ALL 4 SMALL JEWELS',254
 38+  83CC 20 20 20 20
 38+  83D0 20 4F 52 20
 38+  83D4 20 20 41 4C
 38+  83D8 4C 20 34 20
 38+  83DC 53 4D 41 4C
 38+  83E0 4C 20 4A 45
 38+  83E4 57 45 4C 53
 38+  83E8 FE
 39+  83E9 00 15 20 20      defb 0,21,'    TRIPLE BONUS  15000 POINTS',254
 39+  83ED 20 20 54 52
 39+  83F1 49 50 4C 45
 39+  83F5 20 42 4F 4E
 39+  83F9 55 53 20 20
 39+  83FD 31 35 30 30
 39+  8401 30 20 50 4F
 39+  8405 49 4E 54 53
 39+  8409 FE
 40+  840A 00 16 20 20      defb 0,22,'       COLLECT ALL 7 JEWELS',255
 40+  840E 20 20 20 20
 40+  8412 20 43 4F 4C
 40+  8416 4C 45 43 54
 40+  841A 20 41 4C 4C
 40+  841E 20 37 20 4A
 40+  8422 45 57 45 4C
 40+  8426 53 FF
 41+  8428
 42+  8428              string_lifescreen_player:
 43+  8428 0B 00 20 50      defb 11,0,' PLAYER 1 ',255
 43+  842C 4C 41 59 45
 43+  8430 52 20 31 20
 43+  8434 FF
 44+  8435              string_lifescreen_lives:
 45+  8435 0B 03 30 20      defb 11,3,48,' MEN LEFT',255
 45+  8439 4D 45 4E 20
 45+  843D 4C 45 46 54
 45+  8441 FF
 46+  8442              string_lifescreen_lastman:
 47+  8442 0C 03 4C 41      defb 12,3,'LAST MAN',255
 47+  8446 53 54 20 4D
 47+  844A 41 4E FF
 48+  844D
 49+  844D              string_gameoverscreen_gameover:
 50+  844D 0B 06 47 41      defb 11,6,'GAME OVER',255
 50+  8451 4D 45 20 4F
 50+  8455 56 45 52 FF
 51+  8459              string_gameoverscreen_copyright:
 52+  8459 07 12 7F 31      defb 7,18,127,'1982 CENTURI INC',255
 52+  845D 39 38 32 20
 52+  8461 43 45 4E 54
 52+  8465 55 52 49 20
 52+  8469 49 4E 43 FF
 53+  846D              string_gameoverscreen_bestscores:
 54+  846D 07 16 42 45      defb 7,22,'BEST SCORES TODAY',255
 54+  8471 53 54 20 53
 54+  8475 43 4F 52 45
 54+  8479 53 20 54 4F
 54+  847D 44 41 59 FF
 55+  8481              string_gameover_credits:
 56+  8481 0C 01 43 52      defb 12,1,'CREDITS 0',255
 56+  8485 45 44 49 54
 56+  8489 53 20 30 FF
 57+  848D
 58+  848D              string_highscore_congratulations:
 59+  848D 08 05 43 4F      defb 8,5,'CONGRATULATIONS',255
 59+  8491 4E 47 52 41
 59+  8495 54 55 4C 41
 59+  8499 54 49 4F 4E
 59+  849D 53 FF
 60+  849F              string_highscore_player1:
 61+  849F 0C 07 50 4C      defb 12,7,'PLAYER 1',255
 61+  84A3 41 59 45 52
 61+  84A7 20 31 FF
 62+  84AA              string_highscore_player2:
 63+  84AA 0C 07 50 4C      defb 12,7,'PLAYER 2',255
 63+  84AE 41 59 45 52
 63+  84B2 20 32 FF
 64+  84B5              string_highscore_youhaveearned:
 65+  84B5 08 0A 59 4F      defb 8,10,'YOU HAVE EARNED',255
 65+  84B9 55 20 48 41
 65+  84BD 56 45 20 45
 65+  84C1 41 52 4E 45
 65+  84C5 44 FF
 66+  84C7              string_highscore_place1:
 67+  84C7 06 0C 54 48      defb 6,12,'THE GREATEST SCORE',255
 67+  84CB 45 20 47 52
 67+  84CF 45 41 54 45
 67+  84D3 53 54 20 53
 67+  84D7 43 4F 52 45
 67+  84DB FF
 68+  84DC              string_highscore_place2:
 69+  84DC 06 0C 54 48      defb 6,12,'THE 2ND BEST SCORE',255
 69+  84E0 45 20 32 4E
 69+  84E4 44 20 42 45
 69+  84E8 53 54 20 53
 69+  84EC 43 4F 52 45
 69+  84F0 FF
 70+  84F1              string_highscore_place3:
 71+  84F1 06 0C 54 48      defb 6,12,'THE 3RD BEST SCORE',255
 71+  84F5 45 20 33 52
 71+  84F9 44 20 42 45
 71+  84FD 53 54 20 53
 71+  8501 43 4F 52 45
 71+  8505 FF
 72+  8506              string_highscore_pleaseenter
 73+  8506 03 0F 52 45      defb 3,15,'RECORD YOUR INITIALS BELOW',255
 73+  850A 43 4F 52 44
 73+  850E 20 59 4F 55
 73+  8512 52 20 49 4E
 73+  8516 49 54 49 41
 73+  851A 4C 53 20 42
 73+  851E 45 4C 4F 57
 73+  8522 FF
 74+  8523
 75+  8523              string_endlevel_youhaveearned:
 76+  8523 08 0B 59 4F      defb 8,11,'YOU HAVE EARNED',255
 76+  8527 55 20 48 41
 76+  852B 56 45 20 45
 76+  852F 41 52 4E 45
 76+  8533 44 FF
 77+  8535              string_endlevel_bonus1:
 78+  8535 09 0D 53 49      defb 9,13,'SINGLE BONUS',255
 78+  8539 4E 47 4C 45
 78+  853D 20 42 4F 4E
 78+  8541 55 53 FF
 79+  8544              string_endlevel_bonus2:
 80+  8544 09 0D 44 4F      defb 9,13,'DOUBLE BONUS',255
 80+  8548 55 42 4C 45
 80+  854C 20 42 4F 4E
 80+  8550 55 53 FF
 81+  8553              string_endlevel_bonus3:
 82+  8553 09 0D 54 52      defb 9,13,'TRIPLE BONUS',255
 82+  8557 49 50 4C 45
 82+  855B 20 42 4F 4E
 82+  855F 55 53 FF
 83+  8562              string_endlevel_points1:
 84+  8562 0A 0F 35 30      defb 10,15,'5000 POINTS',255
 84+  8566 30 30 20 50
 84+  856A 4F 49 4E 54
 84+  856E 53 FF
 85+  8570              string_endlevel_points2:
 86+  8570 09 0F 31 30      defb 9,15,'10000 POINTS',255
 86+  8574 30 30 30 20
 86+  8578 50 4F 49 4E
 86+  857C 54 53 FF
 87+  857F              string_endlevel_points3:
 88+  857F 09 0F 31 35      defb 9,15,'15000 POINTS',255
 88+  8583 30 30 30 20
 88+  8587 50 4F 49 4E
 88+  858B 54 53 FF
 89+  858E              string_endlevel_anothergo:
 90+  858E 08 12 48 41      defb 8,18,'HAVE ANOTHER GO',255
 90+  8592 56 45 20 41
 90+  8596 4E 4F 54 48
 90+  859A 45 52 20 47
 90+  859E 4F FF
 91+  85A0
 92+  85A0              string_zonk:
 93+  85A0 00 00 5A 4F      defb 0,0,'ZONK!!',255
 93+  85A4 4E 4B 21 21
 93+  85A8 FF
 94+  85A9
 95+  85A9
 96+  85A9              string_options_title:
 97+  85A9 0D 03 54 48      defb 13,3,'THE PIT',255
 97+  85AD 45 20 50 49
 97+  85B1 54 FF
 98+  85B3              string_options_1player:
 99+  85B3 0A 06 31 2E      defb 10,6,'1. ONE PLAYER',255
 99+  85B7 20 4F 4E 45
 99+  85BB 20 50 4C 41
 99+  85BF 59 45 52 FF
100+  85C3              string_options_2player:
101+  85C3 0A 07 32 2E      defb 10,7,'2. TWO PLAYER',255
101+  85C7 20 54 57 4F
101+  85CB 20 50 4C 41
101+  85CF 59 45 52 FF
102+  85D3              string_options_keyboard:
103+  85D3 0A 08 33 2E      defb 10,8,'3. KEYBOARD',255
103+  85D7 20 4B 45 59
103+  85DB 42 4F 41 52
103+  85DF 44 FF
104+  85E1              string_options_joystick:
105+  85E1 0A 09 34 2E      defb 10,9,'4. KEMPSTON',255
105+  85E5 20 4B 45 4D
105+  85E9 50 53 54 4F
105+  85ED 4E FF
106+  85EF              string_options_start:
107+  85EF 0A 0A 35 2E      defb 10,10,'5. START',255
107+  85F3 20 53 54 41
107+  85F7 52 54 FF
108+  85FA              string_options_vanity:
109+  85FA 08 16 53 70      defb 8,22,'Spectrum Conversion',254
109+  85FE 65 63 74 72
109+  8602 75 6D 20 43
109+  8606 6F 6E 76 65
109+  860A 72 73 69 6F
109+  860E 6E FE
110+  8610 07 17 62 79      defb 7,23,'by Dave Tansley, 2020',255
110+  8614 20 44 61 76
110+  8618 65 20 54 61
110+  861C 6E 73 6C 65
110+  8620 79 2C 20 32
110+  8624 30 32 30 FF
111+  8628
112+  8628              ;
113+  8628              ; Prints specified string
114+  8628              ; Inputs:
115+  8628              ; de: pointer to string
116+  8628              ; bc: length of string
117+  8628              ;
118+  8628              ; Print String Data
119+  8628              ; First two bytes of string contain X and Y char position, then the string
120+  8628              ; Individual strings are terminated with 0xFE
121+  8628              ; End of data is terminated with 0xFF
122+  8628              ; HL: Address of string
123+  8628              ;
124+  8628 5E           string_print:           LD E,(HL)                       ; Fetch the X coordinate
125+  8629 23                                   INC HL                          ; Increase HL to the next memory location
126+  862A 56                                   LD D,(HL)                       ; Fetch the Y coordinate
127+  862B 23                                   INC HL                          ; Increase HL to the next memory location
128+  862C CD 3F 86                             CALL string_getcharaddress           ; Calculate the screen address (in DE)
129+  862F 7E           string_print_0:         LD A,(HL)                       ; Fetch the character to print
130+  8630 23                                   INC HL                          ; Increase HL to the next character
131+  8631 FE FE                                CP 0xFE                         ; Compare with 0xFE
132+  8633 28 F3                                JR Z,string_print               ; If it is equal to 0xFE then loop back to print next string
133+  8635 D0                                   RET NC                          ; If it is greater or equal to (carry bit set) then
134+  8636 E5                                   PUSH HL                         ; Push HL on stack (Print_Char will not preserve HL)
135+  8637 CD 4F 86                             CALL Print_Char                 ; Print the character
136+  863A E1                                   POP HL                          ; Retrieve HL back off the stack
137+  863B 1C                                   INC E                           ; Go to the next screen address
138+  863C 18 F1                                JR string_print_0               ; Loop back to print next character
139+  863E C9                                   RET
140+  863F
141+  863F              ; Get screen address
142+  863F              ; D = Y character position
143+  863F              ; E = X character position
144+  863F              ; Returns address in DE
145+  863F              ;
146+  863F 7A           string_getcharaddress:       LD A,D
147+  8640 E6 07                                AND %00000111
148+  8642 1F                                   RRA
149+  8643 1F                                   RRA
150+  8644 1F                                   RRA
151+  8645 1F                                   RRA
152+  8646 B3                                   OR E
153+  8647 5F                                   LD E,A
154+  8648 7A                                   LD A,D
155+  8649 E6 18                                AND %00011000
156+  864B F6 40                                OR %01000000
157+  864D 57                                   LD D,A
158+  864E C9                                   RET                             ; Returns screen address in DE
159+  864F
160+  864F              ; Print a single character out
161+  864F              ; A:  Character to print
162+  864F              ; DE: Screen address to print character at
163+  864F              ;
164+  864F 2A 36 5C     Print_Char:             LD HL,(23606)                    ; Address of character set table in ROM
165+  8652 06 00                                LD B,0                          ; Set BC to A
166+  8654 4F                                   LD C,A
167+  8655 E6 FF                                AND 0xFF                        ; Clear the carry bit
168+  8657 CB 11                                RL C                            ; Multiply BC by 8 (shift left 3 times)
169+  8659 CB 10                                RL B
170+  865B CB 11                                RL C
171+  865D CB 10                                RL B
172+  865F CB 11                                RL C
173+  8661 CB 10                                RL B
174+  8663 09                                   ADD HL,BC                       ; Get the character address in HL
175+  8664 0E 08                                LD C,8                          ; Loop counter
176+  8666 D5                                   PUSH DE
177+  8667 7E           Print_Char_1:           LD A,(HL)                       ; Get the byte from the ROM into A
178+  8668 12                                   LD (DE),A                       ; Stick A onto the screen
179+  8669 14                                   INC D                           ; Goto next line on screen
180+  866A 23                                   INC HL                           ; Goto next byte of character
181+  866B 0D                                   DEC C                           ; Decrease the loop counter
182+  866C 20 F9                                JR NZ,Print_Char_1              ; Loop around whilst it is Not Zero (NZ)
183+  866E D1                                   POP DE
184+  866F C9                                   RET                             ; Return from the subroutine
# file closed: strings.asm
138   8670                  include "screen\buffer.asm"
# file opened: screen/buffer.asm
  1+  8670              buffer_buffer:
  2+  8670 00 00 00...      defs 7424                   ; area reserved for screen
  3+  A370
  4+  A370              buffer_attr_buffer:
  5+  A370 00 00 00...      defs 928                    ; attrs buffer area
  6+  A710
  7+  A710              buffer_tmp:
  8+  A710 00 00            defb 0,0                    ; temp area
  9+  A712
 10+  A712              ;
 11+  A712              ; This list stores lines to be updated by the buffer.
 12+  A712              ; This is done by half line. Lines are encded with.
 13+  A712              ; 00hlllll
 14+  A712              ; Where h is the half of the screen (0 or 1), lllll is the line number
 15+  A712              buffer_updatedlines:
 16+  A712 FF FF FF...      defs 21,255
 17+  A727
 18+  A727              buffer_updateall:
 19+  A727 00               defb 0
 20+  A728
 21+  A728              ;
 22+  A728              ; Stores a line number in the update list
 23+  A728              ; Inputs:
 24+  A728              ; a - row number
 25+  A728              buffer_marklineforupdate:
 26+  A728 FE 15            cp 21
 27+  A72A D0               ret nc                          ; dont store lines that we shouldn't draw
 28+  A72B 5F               ld e,a                          ; store in e
 29+  A72C ED 4B 23 AC      ld bc,(origcoords)              ; this should hold the coords of what was drawn
 30+  A730 79               ld a,c                          ; get the horiz coord
 31+  A731 FE 0F            cp 15
 32+  A733 CA 4A A7         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 33+  A736 FE 10            cp 16                           ; if this is 15 or less, the first half of screen
 34+  A738 CA 4A A7         jp z,buffer_marklineforupdate3  ; if 15 or 16, store both halves
 35+  A73B DA 46 A7         jp c,buffer_marklineforupdate4  ; if first half, nothing to do
 36+  A73E 78               ld a,b                          ; get the vertical
 37+  A73F 3E 20            ld a,32                         ; set the 6th bit by adding 32
 38+  A741 83               add a,e
 39+  A742 5F               ld e,a                          ; store this value
 40+  A743 C3 51 A7         jp buffer_marklineforupdate2
 41+  A746              buffer_marklineforupdate4:
 42+  A746 78               ld a,b
 43+  A747 C3 51 A7         jp buffer_marklineforupdate2    ; just get the vertical
 44+  A74A              buffer_marklineforupdate3:          ; special case for 15,16 - need to render both halves, since might be between
 45+  A74A CD 55 A7         call buffer_storelineforupdate  ; call store update for e
 46+  A74D 3E 20            ld a,32
 47+  A74F 83               add a,e
 48+  A750 5F               ld e,a
 49+  A751              buffer_marklineforupdate2:
 50+  A751 CD 55 A7         call buffer_storelineforupdate  ; call store update for e
 51+  A754 C9               ret
 52+  A755
 53+  A755
 54+  A755              ;
 55+  A755              ; Stores the calculated line and half if needed
 56+  A755              ; Inputs:
 57+  A755              ; e - half/row
 58+  A755              ;
 59+  A755              buffer_storelineforupdate:
 60+  A755 06 15            ld b,21
 61+  A757 21 12 A7         ld hl,buffer_updatedlines
 62+  A75A              buffer_storelineforupdate0:
 63+  A75A 7E               ld a,(hl)                       ; get the line stored in updated lines
 64+  A75B BB               cp e                            ; is this the same as the row number passed in?
 65+  A75C C8               ret z                           ; if so, don't need to do anything
 66+  A75D FE FF            cp 255                          ; is this 255, ie the end of the buffer
 67+  A75F C2 64 A7         jp nz,buffer_storelineforupdate1 ; if not, move to next
 68+  A762 73               ld (hl),e
 69+  A763 C9               ret
 70+  A764              buffer_storelineforupdate1:
 71+  A764 23               inc hl
 72+  A765 10 F3            djnz buffer_storelineforupdate0
 73+  A767 C9               ret
 74+  A768
 75+  A768              ;
 76+  A768              ; Zeroes the updated lines list
 77+  A768              ;
 78+  A768              buffer_clearlist:
 79+  A768 06 15            ld b,21
 80+  A76A 21 12 A7         ld hl,buffer_updatedlines
 81+  A76D              buffer_clearlist0:
 82+  A76D 36 FF            ld (hl),255
 83+  A76F 23               inc hl
 84+  A770 10 FB            djnz buffer_clearlist0
 85+  A772 C9               ret
 86+  A773
 87+  A773              ;
 88+  A773              ; Which half are we displaying? 0 left 1 right
 89+  A773              ;
 90+  A773              buffer_bufferhalf:
 91+  A773 00               defb 0
 92+  A774
 93+  A774              ;
 94+  A774              ; Copies the buffer to the screen. Use stack.
 95+  A774              ; Inputs:
 96+  A774              ; hl - half/line number to display - 0 is first half, 0 is first line
 97+  A774              ;
 98+  A774              buffer_bufferlinetoscreen:
 99+  A774 7C               ld a,h
100+  A775 32 73 A7         ld (buffer_bufferhalf),a        ; store the half
101+  A778 7D               ld a,l
102+  A779 4F               ld c,a                          ; store a
103+  A77A ED 5B DA A8      ld de,(screen_offset)          ; load the screen offset, this is in rows, want it *256
104+  A77E 83               add a,e                       ; add the row number
105+  A77F 11 00 01         ld de,256
106+  A782 CD 00 81         call utilities_multiply
107+  A785 54 5D            ld de,hl
108+  A787 21 70 86         ld hl,buffer_buffer
109+  A78A 19               add hl,de                   ; add the offset
110+  A78B 79               ld a,c                      ; get original row back
111+  A78C ED 73 FF A7      ld (buffer_bufferlinetoscreen3+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
112+  A790 D9               exx
113+  A791 0E 00            ld c,0                      ; zero horizontal
114+  A793 47               ld b,a                      ; load the row number into vertical coord
115+  A794 04               inc b
116+  A795 04               inc b                       ; move forward 2 to allow for scores
117+  A796 CD D2 A9         call screen_getcelladdress  ; get the memory into de
118+  A799 21 10 00         ld hl,16                    ; offset by 16 chars to get to the centre, since populating stack from right
119+  A79C 19               add hl,de
120+  A79D 3A 73 A7         ld a,(buffer_bufferhalf)    ; get the half
121+  A7A0 FE 01            cp 1
122+  A7A2 CA CF A7         jp z,buffer_bufferlinetoscreen4
123+  A7A5              buffer_bufferlinetoscreen0:     ; PROCESS THE LEFT HALF
124+  A7A5 D9               exx                         ; hl is now buffer
125+  A7A6 23               inc hl
126+  A7A7 23               inc hl                      ; move hl forward 2 to skip first two blocks
127+  A7A8 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
128+  A7A9 F1               pop af
129+  A7AA C1               pop bc
130+  A7AB D1               pop de
131+  A7AC DD E1            pop ix
132+  A7AE D9               exx                         ; hl is now screen
133+  A7AF 08               ex af,af'
134+  A7B0 F1               pop af
135+  A7B1 C1               pop bc
136+  A7B2 D1               pop de
137+  A7B3 F9               ld sp,hl                    ; sp pointing at screen
138+  A7B4 D5               push de
139+  A7B5 C5               push bc
140+  A7B6 F5               push af
141+  A7B7 08               ex af,af'
142+  A7B8 D9               exx                         ; hl is now buffer
143+  A7B9 DD E5            push ix
144+  A7BB D5               push de
145+  A7BC C5               push bc
146+  A7BD F5               push af
147+  A7BE 11 1E 00         ld de,30                    ; add thirty to get to next line
148+  A7C1 19               add hl,de
149+  A7C2 F9               ld sp,hl                    ; sp pointing at buffer
150+  A7C3 D9               exx                         ; hl is now screen
151+  A7C4 08               ex af,af'
152+  A7C5 24               inc h
153+  A7C6 7C               ld a,h
154+  A7C7 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
155+  A7C9 C2 A5 A7         jp nz,buffer_bufferlinetoscreen0 ; next line in cell
156+  A7CC              buffer_bufferlinetoscreen1:
157+  A7CC C3 FE A7         jp buffer_bufferlinetoscreen3
158+  A7CF              buffer_bufferlinetoscreen4:     ; PROCESS THE RIGHT HALF
159+  A7CF D9               exx                         ; hl is buffer
160+  A7D0 11 10 00         ld de,16
161+  A7D3 19               add hl,de                   ; move halfway across
162+  A7D4 D9               exx                         ; hl is screen
163+  A7D5 11 0E 00         ld de,14
164+  A7D8 19               add hl,de
165+  A7D9              buffer_bufferlinetoscreen2:
166+  A7D9 D9               exx                         ; hl is now buffer
167+  A7DA F9               ld sp,hl                    ; do first fourteen for right hand side, sp pointing at buffer
168+  A7DB F1               pop af
169+  A7DC C1               pop bc
170+  A7DD D1               pop de
171+  A7DE DD E1            pop ix
172+  A7E0 D9               exx                         ; hl is now screen
173+  A7E1 08               ex af,af'
174+  A7E2 F1               pop af
175+  A7E3 C1               pop bc
176+  A7E4 D1               pop de
177+  A7E5 F9               ld sp,hl                    ; sp pointing at screen
178+  A7E6 D5               push de
179+  A7E7 C5               push bc
180+  A7E8 F5               push af
181+  A7E9 08               ex af,af'
182+  A7EA D9               exx                         ; hl is now buffer
183+  A7EB DD E5            push ix
184+  A7ED D5               push de
185+  A7EE C5               push bc
186+  A7EF F5               push af
187+  A7F0 11 20 00         ld de,32                    ; add thirty two to get to next line
188+  A7F3 19               add hl,de
189+  A7F4 F9               ld sp,hl                    ; sp pointing at buffer
190+  A7F5 D9               exx                         ; hl is now screen
191+  A7F6 08               ex af,af'
192+  A7F7 24               inc h
193+  A7F8 7C               ld a,h
194+  A7F9 E6 07            and 0x07                    ; check if this is multiple of 8, if so, end of cell line
195+  A7FB C2 D9 A7         jp nz,buffer_bufferlinetoscreen2 ; next line in cell
196+  A7FE              buffer_bufferlinetoscreen3:
197+  A7FE 31 00 00         ld sp,0
198+  A801 D9               exx
199+  A802 C9               ret
200+  A803
201+  A803              ;
202+  A803              ; Copies the buffer to the screen for updated lines. Use stack.
203+  A803              ; Inputs: none
204+  A803              ;
205+  A803              buffer_buffertoscreen:
206+  A803 3A 27 A7         ld a,(buffer_updateall)      ; get the all update flag
207+  A806 FE 00            cp 0
208+  A808 CA 14 A8         jp z,buffer_buffertoscreen2  ; if not set, draw only updated
209+  A80B CD 44 A8         call buffer_allbuffertoscreen ; otherwise, draw whole screen
210+  A80E 21 27 A7         ld hl,buffer_updateall
211+  A811 36 00            ld (hl),0                    ; reset flag
212+  A813 C9               ret
213+  A814              buffer_buffertoscreen2:
214+  A814 06 15            ld b,21
215+  A816 FD 21 12 A7      ld iy,buffer_updatedlines    ; the location of the updated lines
216+  A81A              buffer_buffertoscreen0:
217+  A81A FD 7E 00         ld a,(iy)
218+  A81D FE FF            cp 255
219+  A81F CA 43 A8         jp z,buffer_buffertoscreen1                       ; if this is 255, then we're at the end of the updated list
220+  A822 6F               ld l,a
221+  A823 26 00            ld h,0
222+  A825 E6 20            and 32                      ; and with 32 to see if 6th bit is set
223+  A827 FE 20            cp 32                       ; if so, second half of screen
224+  A829 C2 34 A8         jp nz,buffer_buffertoscreen3
225+  A82C 26 01            ld h,1                      ; store half in h
226+  A82E FD 7E 00         ld a,(iy)
227+  A831 D6 20            sub 32                      ; remove 32
228+  A833 6F               ld l,a                      ; stor in line number
229+  A834              buffer_buffertoscreen3:
230+  A834 C5               push bc
231+  A835 FD E5            push iy
232+  A837 F3               di
233+  A838 CD 74 A7         call buffer_bufferlinetoscreen      ; hl has h=half (0 or 1), l=line
234+  A83B FB               ei
235+  A83C FD E1            pop iy
236+  A83E C1               pop bc
237+  A83F FD 23            inc iy
238+  A841 10 D7            djnz buffer_buffertoscreen0
239+  A843              buffer_buffertoscreen1:
240+  A843                  ;call buffer_buffertoattrsfast
241+  A843 C9               ret
242+  A844
243+  A844              ;
244+  A844              ; Copies the buffer to the screen. Use stack.
245+  A844              ; Inputs: none
246+  A844              ;
247+  A844              buffer_allbuffertoscreen:
248+  A844 06 15            ld b,21
249+  A846 3E 00            ld a,0
250+  A848              buffer_allbuffertoscreen0:
251+  A848 C5               push bc
252+  A849 F5               push af
253+  A84A F3               di
254+  A84B 26 00            ld h,0
255+  A84D 6F               ld l,a
256+  A84E CD 74 A7         call buffer_bufferlinetoscreen
257+  A851 FB               ei
258+  A852 F1               pop af
259+  A853 F5               push af
260+  A854 F3               di
261+  A855 26 01            ld h,1
262+  A857 6F               ld l,a
263+  A858 CD 74 A7         call buffer_bufferlinetoscreen
264+  A85B FB               ei
265+  A85C F1               pop af
266+  A85D C1               pop bc
267+  A85E 3C               inc a
268+  A85F 10 E7            djnz buffer_allbuffertoscreen0
269+  A861 F3               di
270+  A862 CD 67 A8         call buffer_buffertoattrsfast
271+  A865 FB               ei
272+  A866 C9               ret
273+  A867
274+  A867              ;
275+  A867              ; Copies the attrs buffer to screen with the stack
276+  A867              ;
277+  A867              buffer_buffertoattrsfast:
278+  A867 ED 73 D6 A8      ld (buffer_buffertoattrsfast1+1),sp ; this is some self-modifying code; stores the stack pointer in an ld sp,nn instruction at the end
279+  A86B 3A DA A8         ld a,(screen_offset)            ; get the screen offset in rows, so want *32
280+  A86E 11 20 00         ld de,32
281+  A871 CD 00 81         call utilities_multiply
282+  A874 54 5D            ld de,hl
283+  A876 21 70 A3         ld hl,buffer_attr_buffer
284+  A879 19               add hl,de                       ; add the offset, start of attr buffer now in hl
285+  A87A D9               exx
286+  A87B 21 50 58         ld hl,22528+80                  ; start of attr memory + 2 lines for score + 16 to start at right side
287+  A87E FD 21 10 A7      ld iy,buffer_tmp
288+  A882 FD 36 00 15      ld (iy),21              ; number of times to loop
289+  A886              buffer_buffertoattrsfast0:
290+  A886 D9               exx                         ; hl is now buffer
291+  A887 23               inc hl
292+  A888 23               inc hl                      ; move hl forward 2 to skip first two blocks
293+  A889 F9               ld sp,hl                    ; do first fourteen for left hand side, sp pointing at buffer
294+  A88A F1               pop af
295+  A88B C1               pop bc
296+  A88C D1               pop de
297+  A88D DD E1            pop ix
298+  A88F D9               exx                         ; hl is now screen
299+  A890 08               ex af,af'
300+  A891 F1               pop af
301+  A892 C1               pop bc
302+  A893 D1               pop de
303+  A894 F9               ld sp,hl                    ; sp pointing at screen
304+  A895 D5               push de
305+  A896 C5               push bc
306+  A897 F5               push af
307+  A898 08               ex af,af'
308+  A899 D9               exx                         ; hl is now buffer
309+  A89A DD E5            push ix
310+  A89C D5               push de
311+  A89D C5               push bc
312+  A89E F5               push af
313+  A89F 1E 0E            ld e,14                    ; do another fourteen for right hand side
314+  A8A1 16 00            ld d,0
315+  A8A3 19               add hl,de
316+  A8A4 F9               ld sp,hl                    ; sp pointing at buffer
317+  A8A5 F1               pop af
318+  A8A6 C1               pop bc
319+  A8A7 D1               pop de
320+  A8A8 DD E1            pop ix
321+  A8AA D9               exx                         ; hl is now screen
322+  A8AB 08               ex af,af'
323+  A8AC 1E 0E            ld e,14
324+  A8AE 16 00            ld d,0
325+  A8B0 19               add hl,de
326+  A8B1 F1               pop af
327+  A8B2 C1               pop bc
328+  A8B3 D1               pop de
329+  A8B4 F9               ld sp,hl                    ; sp pointing at screen
330+  A8B5 D5               push de
331+  A8B6 C5               push bc
332+  A8B7 F5               push af
333+  A8B8 08               ex af,af'
334+  A8B9 D9               exx                         ; hl is now buffer
335+  A8BA DD E5            push ix
336+  A8BC D5               push de
337+  A8BD C5               push bc
338+  A8BE F5               push af
339+  A8BF 1E 10            ld e,16
340+  A8C1 16 00            ld d,0
341+  A8C3 19               add hl,de
342+  A8C4 D9               exx                         ; hl is now screen
343+  A8C5 11 12 00         ld de,18
344+  A8C8 19               add hl,de
345+  A8C9 FD 7E 00         ld a,(iy)
346+  A8CC 3D               dec a
347+  A8CD FE 00            cp 0
348+  A8CF FD 77 00         ld (iy),a
349+  A8D2 C2 86 A8         jp nz,buffer_buffertoattrsfast0 ; do another row
350+  A8D5              buffer_buffertoattrsfast1:
351+  A8D5 31 00 00         ld sp,0
352+  A8D8 D9               exx
353+  A8D9 C9               ret
# file closed: screen/buffer.asm
139   A8DA                  include "screen\screen.asm"
# file opened: screen/screen.asm
  1+  A8DA              screen_offset:
  2+  A8DA 00               defb 0                      ; offset from top of screen in lines
  3+  A8DB
  4+  A8DB              screen_tmp:
  5+  A8DB 00 00            defb 0,0                      ; temporary memory
  6+  A8DD
  7+  A8DD              screen_setscorecolours:
  8+  A8DD 21 79 B8         ld hl,score_colours
  9+  A8E0 11 00 58         ld de,22528                     ; attrs here
 10+  A8E3 01 40 00         ld bc,64
 11+  A8E6 ED B0            ldir
 12+  A8E8 C9               ret
 13+  A8E9
 14+  A8E9              screen_sethighscorecolours:
 15+  A8E9 21 B9 B8         ld hl,high_score_colours
 16+  A8EC 11 E0 5A         ld de,22528+736                 ; attrs here
 17+  A8EF 01 20 00         ld bc,32
 18+  A8F2 ED B0            ldir
 19+  A8F4 C9               ret
 20+  A8F5
 21+  A8F5              ; Draw the screen
 22+  A8F5              ; Inputs:
 23+  A8F5              ; none
 24+  A8F5              ; Notes:
 25+  A8F5              ; The value held at screen_offset tells the screen how many rows to scroll down. Set to five to bottom out.
 26+  A8F5              screen_draw:
 27+  A8F5                  ;call clear_screen
 28+  A8F5 0E 00            ld c,0                      ; horiz
 29+  A8F7 06 00            ld b,0                      ; vert, 0 at top
 30+  A8F9 DD 21 54 B2      ld ix,level_layout               ; point ix at level data
 31+  A8FD FD 21 70 A3      ld iy,buffer_attr_buffer    ; point iy at attr data
 32+  A901              screen_draw0:
 33+  A901 DD 7E 00         ld a,(ix)                   ; load the block number
 34+  A904 C5               push bc                     ; store bc, contains loop count
 35+  A905 CD C0 AA         call screen_getattr         ; get the memory location for this cell's attr into hl
 36+  A908 7E               ld a,(hl)                   ; get the attr value at the address
 37+  A909 FD 77 00         ld (iy),a                   ; load the attr into memory
 38+  A90C DD 7E 00         ld a,(ix)                   ; load the block number
 39+  A90F CD 87 AA         call screen_getblock        ; get the block data into hl
 40+  A912 CD 64 AA         call screen_showchar        ; show this character here
 41+  A915 C1               pop bc                      ; get the loop counter back
 42+  A916 DD 23            inc ix                      ; increment level location
 43+  A918 FD 23            inc iy                      ; increment attr location
 44+  A91A 0C               inc c                       ; increment horiz
 45+  A91B 79               ld a,c
 46+  A91C FE 20            cp 32                       ; check if horiz has reach edge of screen
 47+  A91E C2 01 A9         jp nz,screen_draw0          ; if not, loop
 48+  A921 0E 00            ld c,0                      ; if so, reset horiz
 49+  A923 04               inc b                       ; increment vertical
 50+  A924 78               ld a,b
 51+  A925 FE 1D            cp 29                       ; check if at bottom
 52+  A927 C2 01 A9         jp nz,screen_draw0          ; if not, loop
 53+  A92A 21 DB A8         ld hl, screen_tmp
 54+  A92D 36 09            ld (hl),9                   ; load the block number into memory
 55+  A92F DD 2A 8C C4      ld ix,(game_current_rocks)  ; current rock memory
 56+  A933 CD A2 A9         call screen_initobjects     ; draw rocks
 57+  A936 21 DB A8         ld hl, screen_tmp
 58+  A939 36 0C            ld (hl),12                  ; load the block number into memory
 59+  A93B DD 21 DB B7      ld ix,level_missiles       ; missile memory
 60+  A93F CD A2 A9         call screen_initobjects     ; draw missiles
 61+  A942 21 DB A8         ld hl, screen_tmp
 62+  A945 36 08            ld (hl),08                  ; load the block number into memory
 63+  A947 DD 21 54 B8      ld ix,level_diamonds       ; diamond memory
 64+  A94B CD A2 A9         call screen_initobjects     ; draw diamonds
 65+  A94E 21 DB A8         ld hl, screen_tmp
 66+  A951 36 0E            ld (hl),14                  ; load the block number into memory
 67+  A953 DD 21 64 B8      ld ix,level_gems           ; gems memory
 68+  A957 CD A2 A9         call screen_initobjects     ; draw gems
 69+  A95A CD 61 A9         call screen_setuptext       ; draws text on the screen
 70+  A95D CD EF CC         call scores_printscores     ; print the current scores
 71+  A960 C9               ret
 72+  A961
 73+  A961              ;
 74+  A961              ; Sets up text on the screen
 75+  A961              ;
 76+  A961              screen_setuptext:
 77+  A961 CD 4B CD         call scores_showtable
 78+  A964 CD E9 A8         call screen_sethighscorecolours
 79+  A967 21 CC 81         ld hl, string_score1
 80+  A96A CD 28 86         call string_print
 81+  A96D 21 D5 81         ld hl, string_scorenumbers1
 82+  A970 CD 28 86         call string_print
 83+  A973 21 DE 81         ld hl, string_company
 84+  A976 CD 28 86         call string_print
 85+  A979 21 FE 81         ld hl, string_score2
 86+  A97C CD 28 86         call string_print
 87+  A97F 21 07 82         ld hl, string_scorenumbers2
 88+  A982 CD 28 86         call string_print
 89+  A985 3A 88 C4         ld a,(game_currentplayer)
 90+  A988 FE 01            cp 1
 91+  A98A C2 93 A9         jp nz,screen_setuptext0
 92+  A98D 21 E8 81         ld hl, string_player1
 93+  A990 C3 96 A9         jp screen_setuptext1
 94+  A993              screen_setuptext0:
 95+  A993 21 F3 81         ld hl, string_player2
 96+  A996              screen_setuptext1:
 97+  A996 CD 28 86         call string_print
 98+  A999 CD DD A8         call screen_setscorecolours
 99+  A99C C9               ret
100+  A99D
101+  A99D              ;
102+  A99D              ; Sets a line of colours
103+  A99D              ; Inputs:
104+  A99D              ; a - colour to set
105+  A99D              ; b - number to set
106+  A99D              ; de - start memory location
107+  A99D              ;
108+  A99D              screen_setcolours:
109+  A99D 12               ld (de),a
110+  A99E 13               inc de
111+  A99F 10 FC            djnz screen_setcolours
112+  A9A1 C9               ret
113+  A9A2
114+  A9A2              ;
115+  A9A2              ; Draw initial object positions
116+  A9A2              ; Inputs:
117+  A9A2              ; ix - memory location of objects
118+  A9A2              ; a - graphic
119+  A9A2              screen_initobjects:
120+  A9A2 DD 4E 00         ld c,(ix)                   ; get the horiz coord
121+  A9A5 79               ld a,c
122+  A9A6 FE FF            cp 255
123+  A9A8 CA D1 A9         jp z,screen_initobjects2
124+  A9AB DD 23            inc ix                      ; move to next
125+  A9AD DD 46 00         ld b,(ix)                   ; get the vert coord
126+  A9B0 DD 23            inc ix
127+  A9B2 CD E3 A9         call screen_getcellattradress ; get the memory address of b,c attr into de
128+  A9B5 D5               push de
129+  A9B6 3A DB A8         ld a,(screen_tmp)                  ; get the block number back
130+  A9B9 CD C0 AA         call screen_getattr         ; get the memory location for this cell's attr into hl
131+  A9BC D1               pop de
132+  A9BD 7E               ld a,(hl)                   ; get the attr value at the address
133+  A9BE 12               ld (de),a                   ; load the attr into memory
134+  A9BF 3A DB A8         ld a,(screen_tmp)                  ; get the block number back
135+  A9C2 CD 87 AA         call screen_getblock        ; get the block data into hl
136+  A9C5 CD 64 AA         call screen_showchar        ; show this character here
137+  A9C8
138+  A9C8              screen_initobjects1:
139+  A9C8 DD 23            inc ix                      ; move past state
140+  A9CA DD 23            inc ix
141+  A9CC DD 23            inc ix                      ; move past mem
142+  A9CE C3 A2 A9         jp screen_initobjects
143+  A9D1              screen_initobjects2:
144+  A9D1 C9               ret
145+  A9D2
146+  A9D2
147+  A9D2              ;
148+  A9D2              ; Return character cell address offset of block at (b, c) ready for addition to screen  memory.
149+  A9D2              ; Inputs:
150+  A9D2              ; bc: coords
151+  A9D2              ; Outputs:
152+  A9D2              ; de: memory location
153+  A9D2              ;
154+  A9D2              screen_getcelladdress:
155+  A9D2 78               ld a,b      ; vertical position.
156+  A9D3 E6 18            and 24      ; which segment, 0, 1 or 2?
157+  A9D5 C6 40            add a,64    ; 64*256 = 16384, Spectrum's screen memory.
158+  A9D7 57               ld d,a      ; this is our high byte.
159+  A9D8 78               ld a,b      ; what was that vertical position again?
160+  A9D9 E6 07            and 7       ; which row within segment?
161+  A9DB 0F               rrca        ; multiply row by 32.
162+  A9DC 0F               rrca
163+  A9DD 0F               rrca
164+  A9DE 5F               ld e,a      ; low byte.
165+  A9DF 79               ld a,c      ; add on y coordinate.
166+  A9E0 83               add a,e     ; mix with low byte.
167+  A9E1 5F               ld e,a      ; address of screen position in de.
168+  A9E2 C9               ret
169+  A9E3
170+  A9E3              ;
171+  A9E3              ; Calculate buffer address of attribute for character at (b, c).
172+  A9E3              ; Inputs:
173+  A9E3              ; bc: coords
174+  A9E3              ; Outputs:
175+  A9E3              ; de: memory location
176+  A9E3              ;
177+  A9E3              screen_getcellattradress:
178+  A9E3 11 70 A3         ld de,buffer_attr_buffer ; memory is at base + horiz (c) + vert*32 (b)
179+  A9E6 69               ld l,c      ; x position.
180+  A9E7 26 00            ld h,0      ; 0 h
181+  A9E9 19               add hl,de
182+  A9EA 54 5D            ld de,hl    ; horiz done
183+  A9EC 78               ld a,b      ; do vert
184+  A9ED D5               push de
185+  A9EE C5               push bc
186+  A9EF 11 20 00         ld de,32
187+  A9F2 CD 00 81         call utilities_multiply
188+  A9F5 C1               pop bc
189+  A9F6 D1               pop de
190+  A9F7 19               add hl,de
191+  A9F8 54 5D            ld de,hl    ; vert done
192+  A9FA C9               ret
193+  A9FB
194+  A9FB              ;
195+  A9FB              ; Calculate buffer address offset of attribute for character at (b, c).
196+  A9FB              ; Inputs:
197+  A9FB              ; bc: coords
198+  A9FB              ; Outputs:
199+  A9FB              ; de: memory location
200+  A9FB              ;
201+  A9FB              screen_getcellattroffset:
202+  A9FB 69               ld l,c      ; x position.
203+  A9FC 26 00            ld h,0      ; 0 h
204+  A9FE 54 5D            ld de,hl    ; horiz done
205+  AA00 78               ld a,b      ; do vert
206+  AA01 D5               push de
207+  AA02 C5               push bc
208+  AA03 11 20 00         ld de,32
209+  AA06 CD 00 81         call utilities_multiply
210+  AA09 C1               pop bc
211+  AA0A D1               pop de
212+  AA0B 19               add hl,de
213+  AA0C 54 5D            ld de,hl    ; vert done
214+  AA0E C9               ret
215+  AA0F
216+  AA0F              ;
217+  AA0F              ; Calculate buffer address of attribute for character at (b, c).
218+  AA0F              ; Inputs:
219+  AA0F              ; bc: coords
220+  AA0F              ; Outputs:
221+  AA0F              ; de: memory location
222+  AA0F              ;
223+  AA0F              screen_getscreenattradress:
224+  AA0F 11 00 58         ld de,22528 ; memory is at base + horiz (c) + vert*32 (b)
225+  AA12 69               ld l,c      ; x position.
226+  AA13 26 00            ld h,0      ; 0 h
227+  AA15 19               add hl,de
228+  AA16 54 5D            ld de,hl    ; horiz done
229+  AA18 78               ld a,b      ; do vert
230+  AA19 D5               push de
231+  AA1A C5               push bc
232+  AA1B 11 20 00         ld de,32
233+  AA1E CD 00 81         call utilities_multiply
234+  AA21 C1               pop bc
235+  AA22 D1               pop de
236+  AA23 19               add hl,de
237+  AA24 54 5D            ld de,hl    ; vert done
238+  AA26 C9               ret
239+  AA27
240+  AA27              ;
241+  AA27              ; Gets the attr memory location for a screen coord
242+  AA27              ; Will overwrite bc
243+  AA27              ; Inputs:
244+  AA27              ; bc - screen coords
245+  AA27              ; Outputs:
246+  AA27              ; de - memory location
247+  AA27              ; bc - character coords
248+  AA27              ;
249+  AA27              screen_getattraddressfromscreencoords:
250+  AA27 78               ld a,b                          ; get the player block coords of current block
251+  AA28 E6 F8            and 248                         ; find closest multiple of eight
252+  AA2A 0F               rrca
253+  AA2B 0F               rrca
254+  AA2C 0F               rrca                ; divide by 8
255+  AA2D 47               ld b,a
256+  AA2E 79               ld a,c
257+  AA2F 48               ld c,b                         ; swap b and c
258+  AA30 E6 F8            and 248
259+  AA32 0F               rrca
260+  AA33 0F               rrca
261+  AA34 0F               rrca                ; divide by 8
262+  AA35 47               ld b,a
263+  AA36 CD E3 A9         call screen_getcellattradress   ; work out memory location of current block attributes, memory in de
264+  AA39 C9               ret
265+  AA3A
266+  AA3A
267+  AA3A              ; Gets the nearest cell coords for a screen coord
268+  AA3A              ; Will overwrite bc
269+  AA3A              ; Inputs:
270+  AA3A              ; bc - screen coords
271+  AA3A              ; Outputs:
272+  AA3A              ; bc - character coords
273+  AA3A              ;
274+  AA3A              screen_getcharcoordsfromscreencoords:
275+  AA3A 78               ld a,b                          ; get the player block coords of current block
276+  AA3B E6 F8            and 248                         ; find closest multiple of eight
277+  AA3D 0F               rrca
278+  AA3E 0F               rrca
279+  AA3F 0F               rrca                ; divide by 8
280+  AA40 47               ld b,a
281+  AA41 79               ld a,c
282+  AA42 48               ld c,b                         ; swap b and c
283+  AA43 E6 F8            and 248
284+  AA45 0F               rrca
285+  AA46 0F               rrca
286+  AA47 0F               rrca                ; divide by 8
287+  AA48 47               ld b,a
288+  AA49 C9               ret
289+  AA4A
290+  AA4A              ; Gets the screen coords for a cell coord
291+  AA4A              ; Will overwrite bc
292+  AA4A              ; Inputs:
293+  AA4A              ; bc - char coords
294+  AA4A              ; Outputs:
295+  AA4A              ; bc - screen coords
296+  AA4A              ;
297+  AA4A              screen_getscreencoordsfromcharcoords:
298+  AA4A 78               ld a,b                          ; get the player block coords of current block
299+  AA4B 07               rlca
300+  AA4C 07               rlca
301+  AA4D 07               rlca                ; multiply by 8
302+  AA4E 47               ld b,a
303+  AA4F 79               ld a,c
304+  AA50 48               ld c,b                         ; swap b and c
305+  AA51 07               rlca
306+  AA52 07               rlca
307+  AA53 07               rlca                ; divide by 8
308+  AA54 47               ld b,a
309+  AA55 C9               ret
310+  AA56
311+  AA56              ;
312+  AA56              ; Get buffer address for a character at b,c - b vert
313+  AA56              ; Buffer memory is stored as sequential block
314+  AA56              ; Char at 0,0 is stored 0,32,64...; 0,1 is stored at 1,33,65
315+  AA56              ; Inputs:
316+  AA56              ; bc - coords
317+  AA56              ; Outputs:
318+  AA56              ; de - memory location of first byte
319+  AA56              screen_getbufferaddress:
320+  AA56 21 70 86         ld hl, buffer_buffer    ; first get screen buffer start
321+  AA59 50               ld d,b                  ; then work out vertical offset
322+  AA5A 1E 00            ld e,0                  ; mult by 256, low byte becomes high byte, de now holds result
323+  AA5C 19               add hl,de               ; add to base
324+  AA5D 59               ld e,c                  ; then add horizontal offset (c)
325+  AA5E 16 00            ld d,0
326+  AA60 19               add hl,de               ; add to base
327+  AA61 54 5D            ld de,hl
328+  AA63 C9               ret
329+  AA64
330+  AA64              ;
331+  AA64              ; Display character hl at (b, c) to buffer.
332+  AA64              ; Stored sequentially
333+  AA64              ; Inputs:
334+  AA64              ; hl: block address
335+  AA64              ; bc: coords
336+  AA64              ;
337+  AA64              screen_showchar:
338+  AA64 ED 43 23 AC      ld (origcoords),bc   ; store char coords
339+  AA68 3E 00            ld a,0
340+  AA6A E5               push hl
341+  AA6B CD 56 AA         call screen_getbufferaddress ; get the current screen buffer pointer
342+  AA6E E1               pop hl
343+  AA6F 06 08            ld b,8              ; number of pixels high.
344+  AA71              screen_showchar0:
345+  AA71 7E               ld a,(hl)           ; source graphic.
346+  AA72 12               ld (de),a           ; transfer to screen.
347+  AA73 23               inc hl              ; next piece of data.
348+  AA74 E5               push hl             ; store hl
349+  AA75 62 6B            ld hl,de            ; put de in hl
350+  AA77 1E 20            ld e,32            ; inc memory by 32, so load 32 into de
351+  AA79 16 00            ld d,0
352+  AA7B 19               add hl,de              ; add de to hl
353+  AA7C 54 5D            ld de,hl            ; load back to de
354+  AA7E E1               pop hl              ; restore hl
355+  AA7F
356+  AA7F 10 F0            djnz screen_showchar0 ; repeat
357+  AA81 2E 01            ld l,1
358+  AA83 CD D4 AB         call sprites_marklinesforupdatechar
359+  AA86
360+  AA86 C9               ret
361+  AA87
362+  AA87
363+  AA87              ;
364+  AA87              ; Get cell graphic.
365+  AA87              ; Inputs:
366+  AA87              ; a: block
367+  AA87              ; Outputs:
368+  AA87              ; hl: memory
369+  AA87              ;
370+  AA87              screen_getblock:
371+  AA87 07               rlca                        ; multiply block number by eight.
372+  AA88 07               rlca
373+  AA89 07               rlca
374+  AA8A 5F               ld e,a                      ; displacement to graphic address.
375+  AA8B 16 00            ld d,0                      ; no high byte.
376+  AA8D 21 D9 BC         ld hl,sprites               ; address of character blocks.
377+  AA90 19               add hl,de                   ; point to block.
378+  AA91 C9               ret
379+  AA92
380+  AA92              ;
381+  AA92              ; Set a the attr of a coord
382+  AA92              ; Inputs:
383+  AA92              ; bc - char coords
384+  AA92              ; a - attr
385+  AA92              ;
386+  AA92              screen_setattr:
387+  AA92 DD E5            push ix
388+  AA94 C5               push bc
389+  AA95 08               ex af, af'
390+  AA96 CD FB A9         call screen_getcellattroffset   ; get offset into de
391+  AA99 21 70 A3         ld hl,buffer_attr_buffer
392+  AA9C 19               add hl,de                       ; get the memory location
393+  AA9D 08               ex af, af'                      ; get attr back
394+  AA9E 77               ld (hl),a                         ; set the attr
395+  AA9F 08               ex af, af'                      ; get attr back
396+  AAA0 ED 5B DA A8      ld de,(screen_offset)           ; get the offset
397+  AAA4 78               ld a,b                          ; get the vertical
398+  AAA5 93               sub e                           ; subtract the offset
399+  AAA6 DA BC AA         jp c,screen_setattr0            ; if less than zero, don't update the attr on screen
400+  AAA9 FE 15            cp 21
401+  AAAB D2 BC AA         jp nc,screen_setattr0           ; if more than 21, don't update the attr on screen
402+  AAAE 47               ld b,a                          ; put the coord back in b
403+  AAAF CD 0F AA         call screen_getscreenattradress ; screen attr address in de
404+  AAB2 21 40 00         ld hl,64                        ; attr memory + two rows for scores
405+  AAB5 19               add hl,de
406+  AAB6 08               ex af, af'                      ; get attr back
407+  AAB7 77               ld (hl),a
408+  AAB8 C1               pop bc
409+  AAB9 DD E1            pop ix
410+  AABB C9               ret
411+  AABC              screen_setattr0:
412+  AABC C1               pop bc
413+  AABD DD E1            pop ix
414+  AABF C9               ret
415+  AAC0
416+  AAC0              ;
417+  AAC0              ; Get cell attribute.
418+  AAC0              ; Inputs:
419+  AAC0              ; a: block
420+  AAC0              ; Outputs:
421+  AAC0              ; hl: memory
422+  AAC0              ;
423+  AAC0              screen_getattr:
424+  AAC0 5F               ld e,a                      ; displacement to attribute address.
425+  AAC1 16 00            ld d,0                      ; no high byte.
426+  AAC3 21 B9 BD         ld hl,sprite_attrs          ; address of block attributes.
427+  AAC6 19               add hl,de                   ; point to attribute.
428+  AAC7 C9               ret
429+  AAC8
430+  AAC8              ;
431+  AAC8              ; Checks whether a character block has anything in it
432+  AAC8              ; Inputs:
433+  AAC8              ; bc - char coords
434+  AAC8              ; Outputs:
435+  AAC8              ; a - 1, empty
436+  AAC8              screen_ischarempty:
437+  AAC8 CD 56 AA         call screen_getbufferaddress ; get the current screen buffer pointer
438+  AACB 06 08            ld b,8                      ; check 8 rows
439+  AACD              screen_ischarempty2:
440+  AACD 1A               ld a,(de)                   ; check line
441+  AACE FE 00            cp 0
442+  AAD0 C2 DE AA         jp nz,screen_ischarempty1   ; if not zero, jump out with false
443+  AAD3 21 20 00         ld hl,32
444+  AAD6 19               add hl,de
445+  AAD7 54 5D            ld de,hl                    ; move to next row
446+  AAD9 10 F2            djnz screen_ischarempty2
447+  AADB              screen_ischarempty0:
448+  AADB 3E 01            ld a,1
449+  AADD C9               ret
450+  AADE              screen_ischarempty1:
451+  AADE 3E 00            ld a,0
452+  AAE0 C9               ret
453+  AAE1
454+  AAE1              ;
455+  AAE1              ; Copies a block from one place to another directly underneath, leaves the original empty
456+  AAE1              ; Inputs:
457+  AAE1              ; bc - coords of block to copy from
458+  AAE1              screen_copyblockdown
459+  AAE1 CD 56 AA         call screen_getbufferaddress ; get the current screen buffer pointer for source
460+  AAE4 06 08            ld b,8                      ; copy 8 rows
461+  AAE6              screen_copyblock0:
462+  AAE6 1A               ld a,(de)                    ; get what we're copying
463+  AAE7 08               ex af,af'
464+  AAE8 3E 00            ld a,0
465+  AAEA 12               ld (de),a                    ; replace with empty
466+  AAEB 08               ex af,af'
467+  AAEC 14               inc d                        ; add 256 to get to the next row
468+  AAED 12               ld (de),a                    ; copy to the next row
469+  AAEE 15               dec d
470+  AAEF 21 20 00         ld hl,32
471+  AAF2 19               add hl,de                       ; return back to source, next row down
472+  AAF3 54 5D            ld de,hl
473+  AAF5 10 EF            djnz screen_copyblock0
474+  AAF7 C9               ret
475+  AAF8
476+  AAF8              ;
477+  AAF8              ; Returns the first byte of a character. Useful for figuring out what's there
478+  AAF8              ; Inputs:
479+  AAF8              ; bc - coords
480+  AAF8              ; Outputs:
481+  AAF8              ; a - first byte
482+  AAF8              ;
483+  AAF8              screen_getcharfirstbyte:
484+  AAF8 CD 56 AA         call screen_getbufferaddress ; get the current screen buffer pointer for source
485+  AAFB 1A               ld a,(de)
486+  AAFC C9               ret
487+  AAFD
# file closed: screen/screen.asm
140   AAFD                  include "screen\sprites.asm"
# file opened: screen/sprites.asm
  1+  AAFD              ;
  2+  AAFD              ; This is the sprite routine and expects coordinates in (c ,b) form,
  3+  AAFD              ; where c is the vertical coord from the top of the screen (0-176), and
  4+  AAFD              ; b is the horizontal coord from the left of the screen (0 to 240).
  5+  AAFD              ; Sprite data is stored as you'd expect in its unshifted form as this
  6+  AAFD              ; routine takes care of all the shifting itself. This means that sprite
  7+  AAFD              ; handling isn't particularly fast but the graphics only take 1/8th of the
  8+  AAFD              ; space they would require in pre-shifted form.
  9+  AAFD              ; Inputs:
 10+  AAFD              ; hl - sprite data
 11+  AAFD              ; bc - screen coords
 12+  AAFD              ;
 13+  AAFD              sprites_drawsprite7:
 14+  AAFD EE 07            xor 7               ; complement last 3 bits.
 15+  AAFF 3C               inc a               ; add one for luck!
 16+  AB00              sprites_drawsprite3:
 17+  AB00 CB 11            rl c                ; ...into middle byte...
 18+  AB02 CB 12            rl d                ; ...and finally into left character cell.
 19+  AB04 3D               dec a               ; count shifts we've done.
 20+  AB05 20 F9            jr nz,sprites_drawsprite3 ; return until all shifts complete.
 21+  AB07                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 22+  AB07 79               ld a,c              ; left edge of image is currently in e.
 23+  AB08 4A               ld c,d              ; put right edge there instead.
 24+  AB09 57               ld d,a              ; and the left edge back into c.
 25+  AB0A 18 29            jr sprites_drawsprite0   ; we've done the switch so transfer to screen.
 26+  AB0C              sprites_drawsprite:
 27+  AB0C ED 43 23 AC      ld (origcoords),bc  ; store coords
 28+  AB10 ED 43 25 AC      ld (dispx),bc       ; store coords in dispx for now.
 29+  AB14 E5               push hl
 30+  AB15 CD 01 AC         call sprites_scadd  ; calculate screen address.
 31+  AB18 E1               pop hl
 32+  AB19 3E 08            ld a,8              ; height of sprite in pixels.
 33+  AB1B              sprites_drawsprite1:
 34+  AB1B 08               ex af,af'           ; store loop counter.
 35+  AB1C D5               push de             ; store screen address.
 36+  AB1D 4E               ld c,(hl)           ; first sprite graphic.
 37+  AB1E 23               inc hl              ; increment poiinter to sprite data.
 38+  AB1F 22 27 AC         ld (sprtmp),hl      ; store it for later.
 39+  AB22 16 00            ld d,0              ; blank right byte for now.
 40+  AB24 78               ld a,b              ; b holds y position.
 41+  AB25 E6 07            and 7               ; how are we straddling character cells?
 42+  AB27 28 0C            jr z,sprites_drawsprite0 ; we're not straddling them, don't bother shifting.
 43+  AB29 FE 05            cp 5                ; 5 or more right shifts needed?
 44+  AB2B 30 D0            jr nc,sprites_drawsprite7 ; yes, shift from left as it's quicker.
 45+  AB2D A7               and a               ; oops, carry flag is set so clear it.
 46+  AB2E              sprites_drawsprite2:
 47+  AB2E CB 19            rr c                ; rotate left byte right...
 48+  AB30 CB 1A            rr d                ; ...into right byte.
 49+  AB32 3D               dec a               ; one less shift to do.
 50+  AB33 20 F9            jr nz,sprites_drawsprite2 ; return until all shifts complete.
 51+  AB35              sprites_drawsprite0:
 52+  AB35 E1               pop hl              ; pop screen address from stack.
 53+  AB36 7E               ld a,(hl)           ; what's there already.
 54+  AB37 A9               xor c               ; merge in image data.
 55+  AB38 77               ld (hl),a           ; place onto screen.
 56+  AB39 23               inc hl
 57+  AB3A 7E               ld a,(hl)           ; what's already there.
 58+  AB3B AA               xor d               ; right edge of sprite image data.
 59+  AB3C 77               ld (hl),a           ; plonk it on screen.
 60+  AB3D 3A 25 AC         ld a,(dispx)        ; vertical coordinate.
 61+  AB40 3C               inc a               ; next line down.
 62+  AB41 32 25 AC         ld (dispx),a        ; store new position.
 63+  AB44 2B               dec hl
 64+  AB45 11 20 00         ld de,32            ; add 32 to get to the next row
 65+  AB48 19               add hl,de           ; add 32
 66+  AB49              sprites_drawsprite6:
 67+  AB49 EB               ex de,hl            ; screen address in de.
 68+  AB4A 2A 27 AC         ld hl,(sprtmp)      ; restore graphic address.
 69+  AB4D 08               ex af,af'           ; restore loop counter.
 70+  AB4E 3D               dec a               ; decrement it.
 71+  AB4F C2 1B AB         jp nz,sprites_drawsprite1 ; not reached bottom of sprite yet to repeat.
 72+  AB52 2E 02            ld l,2
 73+  AB54 CD C3 AB         call sprites_marklinesforupdatescreen
 74+  AB57 C9               ret                 ; job done.
 75+  AB58
 76+  AB58              ; Inputs:
 77+  AB58              ; hl - sprite data
 78+  AB58              ; bc - screen coords
 79+  AB58              ;
 80+  AB58              sprites_draw2by2sprite7
 81+  AB58 EE 07            xor 7               ; complement last 3 bits.
 82+  AB5A 3C               inc a               ; add one for luck!
 83+  AB5B              sprites_draw2by2sprite3
 84+  AB5B CB 12            rl d                ; rotate left...
 85+  AB5D CB 11            rl c                ; ...into middle byte...
 86+  AB5F CB 13            rl e                ; ...and finally into left character cell.
 87+  AB61 3D               dec a               ; count shifts we've done.
 88+  AB62 20 F7            jr nz,sprites_draw2by2sprite3 ; return until all shifts complete.
 89+  AB64                                      ; Line of sprite image is now in e + c + d, we need it in form c + d + e.
 90+  AB64 7B               ld a,e              ; left edge of image is currently in e.
 91+  AB65 5A               ld e,d              ; put right edge there instead.
 92+  AB66 51               ld d,c              ; middle bit goes in d.
 93+  AB67 4F               ld c,a              ; and the left edge back into c.
 94+  AB68 18 31            jr sprites_draw2by2sprite0 ; we've done the switch so transfer to screen.
 95+  AB6A              sprites_draw2by2sprite
 96+  AB6A ED 43 23 AC      ld (origcoords),bc  ; store coords
 97+  AB6E ED 43 25 AC      ld (dispx),bc       ; store coords in dispx for now.
 98+  AB72 79               ld a,c
 99+  AB73 32 29 AC         ld (sprtmp0),a         ; store vertical.
100+  AB76 E5               push hl
101+  AB77 CD 01 AC         call sprites_scadd          ; calculate screen address.
102+  AB7A E1               pop hl
103+  AB7B 3E 10            ld a,16             ; height of sprite in pixels.
104+  AB7D              sprites_draw2by2sprite1
105+  AB7D 08               ex af,af'           ; store loop counter.
106+  AB7E D5               push de             ; store screen address.
107+  AB7F 4E               ld c,(hl)           ; first sprite graphic.
108+  AB80 23               inc hl              ; increment poiinter to sprite data.
109+  AB81 56               ld d,(hl)           ; next bit of sprite image.
110+  AB82 23               inc hl              ; point to next row of sprite data.
111+  AB83 22 27 AC         ld (sprtmp),hl        ; store in tmp0 for later.
112+  AB86 1E 00            ld e,0              ; blank right byte for now.
113+  AB88 78               ld a,b              ; b holds y position.
114+  AB89 E6 07            and 7               ; how are we straddling character cells?
115+  AB8B 28 0E            jr z,sprites_draw2by2sprite0 ; we're not straddling them, don't bother shifting.
116+  AB8D FE 05            cp 5                ; 5 or more right shifts needed?
117+  AB8F 30 C7            jr nc,sprites_draw2by2sprite7 ; yes, shift from left as it's quicker.
118+  AB91 A7               and a               ; oops, carry flag is set so clear it.
119+  AB92              sprites_draw2by2sprite2
120+  AB92 CB 19            rr c                ; rotate left byte right...
121+  AB94 CB 1A            rr d                ; ...through middle byte...
122+  AB96 CB 1B            rr e                ; ...into right byte.
123+  AB98 3D               dec a               ; one less shift to do.
124+  AB99 20 F7            jr nz,sprites_draw2by2sprite2 ; return until all shifts complete.
125+  AB9B              sprites_draw2by2sprite0
126+  AB9B E1               pop hl              ; pop screen address from stack.
127+  AB9C 7E               ld a,(hl)           ; what's there already.
128+  AB9D A9               xor c               ; merge in image data.
129+  AB9E 77               ld (hl),a           ; place onto screen.
130+  AB9F 23               inc hl               ; next character cell to right please.
131+  ABA0 7E               ld a,(hl)           ; what's there already.
132+  ABA1 AA               xor d               ; merge with middle bit of image.
133+  ABA2 77               ld (hl),a           ; put back onto screen.
134+  ABA3 23               inc hl              ; next bit of screen area.
135+  ABA4 7E               ld a,(hl)           ; what's already there.
136+  ABA5 AB               xor e               ; right edge of sprite image data.
137+  ABA6 77               ld (hl),a           ; plonk it on screen.
138+  ABA7 3A 29 AC         ld a,(sprtmp0)         ; temporary vertical coordinate.
139+  ABAA 3C               inc a               ; next line down.
140+  ABAB 32 29 AC         ld (sprtmp0),a         ; store new position.
141+  ABAE 2B               dec hl
142+  ABAF 2B               dec hl
143+  ABB0 11 20 00         ld de,32            ; add 32 to get to the next row
144+  ABB3 19               add hl,de           ; add 32
145+  ABB4              sprites_draw2by2sprite6
146+  ABB4 EB               ex de,hl            ; screen address in de.
147+  ABB5 2A 27 AC         ld hl,(sprtmp)        ; restore graphic address.
148+  ABB8 08               ex af,af'           ; restore loop counter.
149+  ABB9 3D               dec a               ; decrement it.
150+  ABBA C2 7D AB         jp nz,sprites_draw2by2sprite1 ; not reached bottom of sprite yet to repeat.
151+  ABBD 2E 03            ld l,3
152+  ABBF CD C3 AB         call sprites_marklinesforupdatescreen
153+  ABC2 C9               ret                 ; job done.
154+  ABC3
155+  ABC3              ;
156+  ABC3              ; Marks lines for update with screen coords
157+  ABC3              ; Inputs:
158+  ABC3              ; l - number to update
159+  ABC3              ;
160+  ABC3              sprites_marklinesforupdatescreen:
161+  ABC3 F5               push af
162+  ABC4 ED 4B 23 AC      ld bc,(origcoords)
163+  ABC8 CD 3A AA         call screen_getcharcoordsfromscreencoords
164+  ABCB ED 43 23 AC      ld (origcoords),bc
165+  ABCF CD DE AB         call sprites_marklinesforupdate
166+  ABD2 F1               pop af
167+  ABD3 C9               ret
168+  ABD4
169+  ABD4              ;
170+  ABD4              ; Marks lines for update with char coords
171+  ABD4              ; Inputs:
172+  ABD4              ; l - number to update
173+  ABD4              ;
174+  ABD4              sprites_marklinesforupdatechar:
175+  ABD4 F5               push af
176+  ABD5 ED 43 23 AC      ld (origcoords),bc
177+  ABD9 CD DE AB         call sprites_marklinesforupdate
178+  ABDC F1               pop af
179+  ABDD C9               ret
180+  ABDE
181+  ABDE              ;
182+  ABDE              ; Marks lines for update
183+  ABDE              ; Inputs:
184+  ABDE              ; l - number to update
185+  ABDE              ;
186+  ABDE              sprites_marklinesforupdate:
187+  ABDE ED 4B 23 AC      ld bc,(origcoords)
188+  ABE2 ED 5B DA A8      ld de,(screen_offset)          ; load the screen offset, this is in rows
189+  ABE6 78               ld a,b
190+  ABE7 93               sub e
191+  ABE8 47               ld b,a
192+  ABE9 7D               ld a,l                          ; get loop counter
193+  ABEA              sprites_marklinesforupdate0:
194+  ABEA C5               push bc
195+  ABEB 08               ex af,af'                     ; store loop counter
196+  ABEC 78               ld a,b
197+  ABED CD 28 A7         call buffer_marklineforupdate ; mark this line for update
198+  ABF0 ED 4B 23 AC      ld bc,(origcoords)            ; move the coords for the next line
199+  ABF4 04               inc b
200+  ABF5 ED 43 23 AC      ld (origcoords),bc
201+  ABF9 C1               pop bc
202+  ABFA 04               inc b
203+  ABFB 08               ex af,af'                     ; restore loop counter
204+  ABFC 3D               dec a
205+  ABFD C2 EA AB         jp nz,sprites_marklinesforupdate0
206+  AC00 C9               ret
207+  AC01
208+  AC01              ;
209+  AC01              ; This routine returns a buffer address for (c, b) in de (c vert).
210+  AC01              ; For example: 0,0 will be at memory offset 0
211+  AC01              ; 1,0 (1 down) will be at memory offset 1
212+  AC01              ; 0,7 will be at memory offset 0
213+  AC01              ; 9,1 will be at memory offset 8+1
214+  AC01              ; 8,0 will be at memory offset 256
215+  AC01              ; 9,0 will be at memory offset 257
216+  AC01              ; Outputs:
217+  AC01              ; de - coords
218+  AC01              ;
219+  AC01              sprites_scadd:
220+  AC01 79               ld a,c               ; calculate vertical offset
221+  AC02 E6 F8            and 248             ;  to get nearest multiple of 8
222+  AC04 0F               rrca
223+  AC05 0F               rrca
224+  AC06 0F               rrca                ; divide by 8
225+  AC07 67               ld h,a
226+  AC08 78               ld a,b               ; calculate horizontal offset
227+  AC09 E6 F8            and 248             ;  to get nearest multiple of 8
228+  AC0B 0F               rrca
229+  AC0C 0F               rrca
230+  AC0D 0F               rrca                ; divide by 8
231+  AC0E 6F               ld l,a
232+  AC0F C5               push bc             ; store the screen coords
233+  AC10 44 4D            ld bc,hl            ; load bc with the character coords
234+  AC12 CD 56 AA         call screen_getbufferaddress
235+  AC15 C1               pop bc              ; get back screen coords, de is now memory of character
236+  AC16 79               ld a,c              ; now add the vertical within the cell
237+  AC17 E6 07            and 7
238+  AC19 0F               rrca                ; multiply by 32.
239+  AC1A 0F               rrca
240+  AC1B 0F               rrca
241+  AC1C 6F               ld l,a
242+  AC1D 26 00            ld h,0
243+  AC1F 19               add hl,de
244+  AC20 54 5D            ld de,hl
245+  AC22 C9               ret
246+  AC23
247+  AC23 00 00        origcoords   defb 0,0           ; general-use coordinates.
248+  AC25
249+  AC25 00           dispx   defb 0           ; general-use coordinates.
250+  AC26 00           dispy   defb 0
251+  AC27 00 00        sprtmp  defb 0,0           ; sprite temporary address.
252+  AC29 00 00        sprtmp0  defb 0,0           ; sprite temporary address.
253+  AC2B
# file closed: screen/sprites.asm
141   AC2B                  include "screen\titlescreen.asm"
# file opened: screen/titlescreen.asm
  1+  AC2B              ;
  2+  AC2B              ; Draws the title screen
  3+  AC2B              ;
  4+  AC2B              titlescreen_show:
  5+  AC2B CD DB AC         call titlescreen_preinit
  6+  AC2E CD 24 B1         call sound_gamestart
  7+  AC31 06 3C            ld b,60
  8+  AC33 CD 61 81         call utilities_pauseforframes         ; pause for a second
  9+  AC36              titlescreen_show2:
 10+  AC36 CD C8 AC         call titlescreen_init
 11+  AC39 CD 71 AC         call titlescreen_drawtitle
 12+  AC3C 3A 8B C4         ld a,(game_control)
 13+  AC3F FE 00            cp 0
 14+  AC41 CA 49 AC         jp z,titlescreen_show1
 15+  AC44 06 32            ld b,50
 16+  AC46 CD 61 81         call utilities_pauseforframes         ; pause for a second
 17+  AC49              titlescreen_show1:
 18+  AC49 3E FA            ld a,250                              ; wait for 200 frames
 19+  AC4B CD 22 81         call utilities_waitforkey_forframes   ; wait for keypress
 20+  AC4E 7B               ld a,e
 21+  AC4F FE 01            cp 1                                  ; was anything pressed?
 22+  AC51 C8               ret z                                 ; end titlescreen if so
 23+  AC52
 24+  AC52 CD E8 AC         call titlescreen_alt_init             ; otherwise, draw alt screen
 25+  AC55 CD 8D AC         call titlescreen_alt_drawtitle
 26+  AC58 3A 8B C4         ld a,(game_control)
 27+  AC5B FE 00            cp 0
 28+  AC5D CA 65 AC         jp z,titlescreen_show0
 29+  AC60 06 32            ld b,50
 30+  AC62 CD 61 81         call utilities_pauseforframes         ; pause for a second if joystick
 31+  AC65              titlescreen_show0:
 32+  AC65 3E FA            ld a,250                              ; wait for 200 frames
 33+  AC67 CD 22 81         call utilities_waitforkey_forframes   ; wait for keypress
 34+  AC6A 7B               ld a,e
 35+  AC6B FE 01            cp 1                                  ; was anything pressed?
 36+  AC6D C2 36 AC         jp nz,titlescreen_show2               ; start again if not
 37+  AC70 C9               ret
 38+  AC71
 39+  AC71              ;
 40+  AC71              ; Draws the iconic logo
 41+  AC71              ;
 42+  AC71              titlescreen_drawtitle:
 43+  AC71 06 67            ld b,103              ; number of points
 44+  AC73 DD 21 F5 AC      ld ix,titlescreen_logo_data
 45+  AC77              titlescreen_drawtitle0:
 46+  AC77 C5               push bc
 47+  AC78 DD 4E 00         ld c,(ix)                   ; got horiz
 48+  AC7B DD 23            inc ix
 49+  AC7D DD 46 00         ld b,(ix)                   ; got vert
 50+  AC80 DD 23            inc ix
 51+  AC82 CD 0F AA         call screen_getscreenattradress ; memory in de
 52+  AC85 13               inc de                      ; slide one to the right, since I'm too lazy to change the data
 53+  AC86 3E 13            ld a,19
 54+  AC88 12               ld (de),a
 55+  AC89 C1               pop bc
 56+  AC8A 10 EB            djnz titlescreen_drawtitle0 ; loop if we're not at the end
 57+  AC8C C9               ret
 58+  AC8D
 59+  AC8D              ;
 60+  AC8D              ; Draws the alternate title screen
 61+  AC8D              ;
 62+  AC8D              titlescreen_alt_drawtitle:
 63+  AC8D 21 25 82         ld hl,string_alttitlescreen_1
 64+  AC90 CD 28 86         call string_print
 65+  AC93 21 31 82         ld hl,string_alttitlescreen_2
 66+  AC96 CD 28 86         call string_print
 67+  AC99 21 2C 83         ld hl,string_alttitlescreen_3
 68+  AC9C CD 28 86         call string_print
 69+  AC9F 06 20            ld b,32
 70+  ACA1 3E 43            ld a,67
 71+  ACA3 11 00 58         ld de,22528                         ; top row attrs here
 72+  ACA6 CD 9D A9         call screen_setcolours
 73+  ACA9 06 20            ld b,32
 74+  ACAB 3E 46            ld a,70
 75+  ACAD 11 A0 59         ld de,22528+416                     ; 13th row attrs here
 76+  ACB0 CD 9D A9         call screen_setcolours
 77+  ACB3 06 20            ld b,32
 78+  ACB5 3E 43            ld a,67
 79+  ACB7 11 20 5A         ld de,22528+544                         ; 17th row attrs here
 80+  ACBA CD 9D A9         call screen_setcolours
 81+  ACBD 06 20            ld b,32
 82+  ACBF 3E 42            ld a,66
 83+  ACC1 11 A0 5A         ld de,22528+672                         ; 21st row attrs here
 84+  ACC4 CD 9D A9         call screen_setcolours
 85+  ACC7 C9               ret
 86+  ACC8
 87+  ACC8              ;
 88+  ACC8              ; Initialises the screen
 89+  ACC8              ;
 90+  ACC8              titlescreen_init:
 91+  ACC8              ; We want a black screen.
 92+  ACC8 3E 0B            ld a,11             ; magenta ink (7) on blue paper (0),
 93+  ACCA                                      ; bright (64).
 94+  ACCA CD 46 81         call utilities_clearscreen
 95+  ACCD 32 8D 5C         ld (23693),a        ; set our screen colours.
 96+  ACD0 3E 01            ld a,1              ; 2 is the code for red.
 97+  ACD2 D3 FE            out (254),a         ; write to port 254.
 98+  ACD4
 99+  ACD4 21 10 82         ld hl,string_titlescreen_copyright
100+  ACD7 CD 28 86         call string_print
101+  ACDA
102+  ACDA C9               ret
103+  ACDB
104+  ACDB              ;
105+  ACDB              ; Initialises the pre-screen
106+  ACDB              ;
107+  ACDB              titlescreen_preinit:
108+  ACDB              ; We want a red screen.
109+  ACDB 3E 10            ld a,16             ; magenta ink (7) on blue paper (0),
110+  ACDD                                      ; bright (64).
111+  ACDD CD 46 81         call utilities_clearscreen
112+  ACE0 32 8D 5C         ld (23693),a        ; set our screen colours.
113+  ACE3 3E 02            ld a,2              ; 2 is the code for red.
114+  ACE5 D3 FE            out (254),a         ; write to port 254.
115+  ACE7 C9               ret
116+  ACE8
117+  ACE8              ;
118+  ACE8              ; Initialises the screen
119+  ACE8              ;
120+  ACE8              titlescreen_alt_init:
121+  ACE8              ; We want a black screen.
122+  ACE8 3E 47            ld a,71             ; white ink (7) on black paper (0),
123+  ACEA                                      ; bright (64).
124+  ACEA CD 46 81         call utilities_clearscreen
125+  ACED 32 8D 5C         ld (23693),a        ; set our screen colours.
126+  ACF0 3E 00            ld a,0              ; 2 is the code for red.
127+  ACF2 D3 FE            out (254),a         ; write to port 254.
128+  ACF4
129+  ACF4 C9               ret
130+  ACF5
131+  ACF5              ;
132+  ACF5              ; Horiz, vert
133+  ACF5              ;
134+  ACF5              titlescreen_logo_data:
135+  ACF5 08 00 09 00      defb 8,0,9,0,10,0,12,0,15,0,17,0,18,0,19,0
135+  ACF9 0A 00 0C 00
135+  ACFD 0F 00 11 00
135+  AD01 12 00 13 00
136+  AD05 09 01 0C 01      defb 9,1,12,1,15,1,17,1
136+  AD09 0F 01 11 01
137+  AD0D 09 02 0C 02      defb 9,2,12,2,13,2,14,2,15,2,17,2,18,2,19,2
137+  AD11 0D 02 0E 02
137+  AD15 0F 02 11 02
137+  AD19 12 02 13 02
138+  AD1D 09 03 0C 03      defb 9,3,12,3,15,3,17,3
138+  AD21 0F 03 11 03
139+  AD25 09 04 0C 04      defb 9,4,12,4,15,4,17,4,18,4,19,4
139+  AD29 0F 04 11 04
139+  AD2D 12 04 13 04
140+  AD31 00 06 01 06      defb 0,6,1,6,2,6,3,6,4,6,5,6,6,6,7,6,8,6,9,6,10,6,11,6
140+  AD35 02 06 03 06
140+  AD39 04 06 05 06
140+  AD3D 06 06 07 06
140+  AD41 08 06 09 06
140+  AD45 0A 06 0B 06
141+  AD49 10 06 11 06      defb 16,6,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6
141+  AD4D 12 06 13 06
141+  AD51 14 06 15 06
141+  AD55 16 06 17 06
141+  AD59 18 06 19 06
141+  AD5D 1A 06 1B 06
142+  AD61 02 07 02 08      defb 2,7,2,8,2,9,2,10,2,11,2,12,2,13,2,14,2,15,2,16,2,17,2,18,2,19,2,20,2,21
142+  AD65 02 09 02 0A
142+  AD69 02 0B 02 0C
142+  AD6D 02 0D 02 0E
142+  AD71 02 0F 02 10
142+  AD75 02 11 02 12
142+  AD79 02 13 02 14
142+  AD7D 02 15
143+  AD7F 19 07 19 08      defb 25,7,25,8,25,9,25,10,25,11,25,12,25,13,25,14,25,15,25,16,25,17,25,18,25,19,25,20,25,21
143+  AD83 19 09 19 0A
143+  AD87 19 0B 19 0C
143+  AD8B 19 0D 19 0E
143+  AD8F 19 0F 19 10
143+  AD93 19 11 19 12
143+  AD97 19 13 19 14
143+  AD9B 19 15
144+  AD9D 03 0B 04 0B      defb 3,11,4,11,5,11,6,11,7,11,8,11,9,11,10,11,11,11
144+  ADA1 05 0B 06 0B
144+  ADA5 07 0B 08 0B
144+  ADA9 09 0B 0A 0B
144+  ADAD 0B 0B
145+  ADAF 0B 07 0B 08      defb 11,7,11,8,11,9,11,10
145+  ADB3 0B 09 0B 0A
146+  ADB7 10 0D 10 0F      defb 16,13,16,15,16,16,16,17,16,18,16,19
146+  ADBB 10 10 10 11
146+  ADBF 10 12 10 13
147+  ADC3
# file closed: screen/titlescreen.asm
142   ADC3                  include "screen\lifescreen.asm"
# file opened: screen/lifescreen.asm
  1+  ADC3              ;
  2+  ADC3              ; Draws the life remaining screen
  3+  ADC3              ;
  4+  ADC3              lifescreen_draw:
  5+  ADC3 CD 19 AE         call lifescreen_init
  6+  ADC6
  7+  ADC6 3A 88 C4         ld a,(game_currentplayer)             ; get the current player
  8+  ADC9 C6 30            add 48                                ; add 48 to get char
  9+  ADCB 21 32 84         ld hl,string_lifescreen_player+10
 10+  ADCE 77               ld (hl),a                             ; load this to the string we're about to show
 11+  ADCF
 12+  ADCF 21 28 84         ld hl,string_lifescreen_player
 13+  ADD2 CD 28 86         call string_print
 14+  ADD5
 15+  ADD5 3A 80 C5         ld a,(player+9)                       ; get the current player lives
 16+  ADD8 C6 30            add 48                                ; add 48 to get the character
 17+  ADDA FE 31            cp 49
 18+  ADDC C2 EF AD         jp nz,lifescreen_draw0
 19+  ADDF 21 42 84         ld hl,string_lifescreen_lastman
 20+  ADE2
 21+  ADE2 06 08            ld b,8
 22+  ADE4 3E 0A            ld a,10                                ; set red
 23+  ADE6 11 6C 58         ld de,22528+108                        ; attrs here
 24+  ADE9 CD 9D A9         call screen_setcolours
 25+  ADEC
 26+  ADEC C3 F6 AD         jp lifescreen_draw1
 27+  ADEF              lifescreen_draw0:
 28+  ADEF 21 37 84         ld hl,string_lifescreen_lives+2       ; not last man, so use the normal view
 29+  ADF2 77               ld (hl),a                             ; load this to the string we're about to show
 30+  ADF3 21 35 84         ld hl,string_lifescreen_lives
 31+  ADF6              lifescreen_draw1:
 32+  ADF6 CD 28 86         call string_print
 33+  ADF9
 34+  ADF9 3E 86            ld a,134
 35+  ADFB 11 0B 58         ld de, 22528+11     ; get the colour for the top text
 36+  ADFE 06 0A            ld b,10
 37+  AE00 CD 9D A9         call screen_setcolours
 38+  AE03 3A 8B C4         ld a,(game_control)
 39+  AE06 FE 00            cp 0
 40+  AE08 CA 10 AE         jp z,lifescreen_draw2
 41+  AE0B 06 32            ld b,50
 42+  AE0D CD 61 81         call utilities_pauseforframes         ; pause for a second if joystick
 43+  AE10              lifescreen_draw2:
 44+  AE10 CD 41 B1         call sound_lifestart
 45+  AE13 3E 64            ld a,100                              ; wait for 200 frames
 46+  AE15 CD 22 81         call utilities_waitforkey_forframes   ; wait for keypress
 47+  AE18
 48+  AE18 C9               ret
 49+  AE19
 50+  AE19              ;
 51+  AE19              ; Initialises the screen
 52+  AE19              ;
 53+  AE19              lifescreen_init:
 54+  AE19              ; We want a blue screen.
 55+  AE19                  ;call $0D6B
 56+  AE19 3E 0E            ld a,14             ; yellow ink (6) on blue paper (1),
 57+  AE1B                                      ; bright (64).
 58+  AE1B CD 46 81         call utilities_clearscreen
 59+  AE1E 32 8D 5C         ld (23693),a        ; set our screen colours.
 60+  AE21 3E 01            ld a,1              ; 1 is the code for blue.
 61+  AE23 D3 FE            out (254),a         ; write to port 254.
 62+  AE25                  ;call 3503           ; ROM routine - clears screen, opens chan 2.
 63+  AE25
 64+  AE25 C9               ret
# file closed: screen/lifescreen.asm
143   AE26                  include "screen\gameover.asm"
# file opened: screen/gameover.asm
  1+  AE26              ;
  2+  AE26              ; Draws the game over screen
  3+  AE26              ;
  4+  AE26              gameover_draw:
  5+  AE26 3E 01            ld a,1
  6+  AE28 32 88 C4         ld (game_currentplayer),a               ; do the first player first
  7+  AE2B CD E3 C5         call player_init_lifestart              ; get the player config
  8+  AE2E CD 81 AE         call gameover_enterhighscores
  9+  AE31
 10+  AE31 3A 87 C4         ld a,(game_numberplayers)               ; check if we need to do player 2
 11+  AE34 FE 02            cp 2
 12+  AE36 C2 44 AE         jp nz,gameover_draw0
 13+  AE39 3E 02            ld a,2
 14+  AE3B 32 88 C4         ld (game_currentplayer),a               ; do the second player
 15+  AE3E CD E3 C5         call player_init_lifestart              ; get the player config
 16+  AE41 CD 81 AE         call gameover_enterhighscores
 17+  AE44              gameover_draw0:
 18+  AE44 CD 49 AF         call gameover_init
 19+  AE47
 20+  AE47 21 4D 84         ld hl,string_gameoverscreen_gameover
 21+  AE4A CD 28 86         call string_print
 22+  AE4D
 23+  AE4D 21 59 84         ld hl,string_gameoverscreen_copyright
 24+  AE50 CD 28 86         call string_print
 25+  AE53
 26+  AE53 CD 64 AE         call gameover_commontext
 27+  AE56
 28+  AE56 06 0B            ld b,11
 29+  AE58 3E 42            ld a,66
 30+  AE5A 11 2B 58         ld de,22528+43                         ; attrs here
 31+  AE5D CD 9D A9         call screen_setcolours
 32+  AE60 CD 0D 81         call utilities_waitforkey   ; wait for keypress
 33+  AE63
 34+  AE63 C9               ret
 35+  AE64
 36+  AE64              ;
 37+  AE64              ; Draws text shared by the game over and high score screens
 38+  AE64              ;
 39+  AE64              gameover_commontext:
 40+  AE64 CD 61 A9         call screen_setuptext       ; show scores
 41+  AE67 CD EF CC         call scores_printscores     ; print the current scores
 42+  AE6A
 43+  AE6A 21 81 84         ld hl,string_gameover_credits
 44+  AE6D CD 28 86         call string_print
 45+  AE70
 46+  AE70 21 6D 84         ld hl,string_gameoverscreen_bestscores
 47+  AE73 CD 28 86         call string_print
 48+  AE76
 49+  AE76 06 20            ld b,32
 50+  AE78 3E 45            ld a,69
 51+  AE7A 11 C0 5A         ld de,22528+704                         ; attrs here
 52+  AE7D CD 9D A9         call screen_setcolours
 53+  AE80
 54+  AE80 C9               ret
 55+  AE81
 56+  AE81              ;
 57+  AE81              ; If required, enter highscore
 58+  AE81              ;
 59+  AE81              gameover_enterhighscores:
 60+  AE81                  ; check if we need to enter initial
 61+  AE81 CD 60 CD         call scores_processhighscores
 62+  AE84
 63+  AE84 3A 5E CD         ld a,(scores_highscoretmp)
 64+  AE87 FE 00            cp 0
 65+  AE89 C8               ret z
 66+  AE8A CD DF AE         call gameover_enterhighscores_init
 67+  AE8D                  ; Set the flash
 68+  AE8D 3A 5E CD         ld a,(scores_highscoretmp)              ; scoretmp has the memory offset of the start of the number
 69+  AE90 1E 05            ld e,5
 70+  AE92 93               sub e                                   ; get the score position back to coords
 71+  AE93 11 00 00         ld de,0
 72+  AE96 5F               ld e,a                                  ; load into de
 73+  AE97 21 74 CC         ld hl,scores_table
 74+  AE9A 19               add hl,de                               ; get the memory location
 75+  AE9B 4E 23 46 2B      ld bc,(hl)                              ; get the coords
 76+  AE9F CD 0F AA         call screen_getscreenattradress         ; get the memory location of the cell attr into de
 77+  AEA2 1A               ld a,(de)                               ; get the current attr
 78+  AEA3 F6 80            or 128                                  ; make it flash
 79+  AEA5 12               ld (de),a
 80+  AEA6 13               inc de
 81+  AEA7 12               ld (de),a
 82+  AEA8 13               inc de
 83+  AEA9 12               ld (de),a                               ; make all three flash
 84+  AEAA 3A 5E CD         ld a,(scores_highscoretmp)              ; get the score back again
 85+  AEAD 3D               dec a
 86+  AEAE 3D               dec a
 87+  AEAF 3D               dec a                                   ; get high score location back to position of name
 88+  AEB0 16 00            ld d,0
 89+  AEB2 5F               ld e,a
 90+  AEB3 21 74 CC         ld hl,scores_table
 91+  AEB6 19               add hl,de                               ; load memory into hl
 92+  AEB7 08               ex af,af'
 93+  AEB8 06 0F            ld b,15
 94+  AEBA CD 61 81         call utilities_pauseforframes           ; pause for a little bit
 95+  AEBD 06 03            ld b,3                                  ; collect three chars
 96+  AEBF              gameover_enterhighscores2:
 97+  AEBF C5               push bc
 98+  AEC0 E5               push hl
 99+  AEC1              gameover_enterhighscores3:
100+  AEC1 CD 65 81         call utilities_readkey               ; get key into a
101+  AEC4 FE 41            cp 65
102+  AEC6 DA C1 AE         jp c,gameover_enterhighscores3
103+  AEC9 FE 5B            cp 91
104+  AECB D2 C1 AE         jp nc,gameover_enterhighscores3      ; if not a letter, get another
105+  AECE E1               pop hl
106+  AECF 77               ld (hl),a
107+  AED0 23               inc hl
108+  AED1 E5               push hl
109+  AED2 CD 4B CD         call scores_showtable
110+  AED5 E1               pop hl
111+  AED6 06 0F            ld b,15
112+  AED8 CD 61 81         call utilities_pauseforframes
113+  AEDB C1               pop bc
114+  AEDC 10 E1            djnz gameover_enterhighscores2
115+  AEDE C9               ret
116+  AEDF
117+  AEDF              ;
118+  AEDF              ; Displays the screen text for high score entry
119+  AEDF              ;
120+  AEDF              gameover_enterhighscores_init:
121+  AEDF
122+  AEDF CD 49 AF         call gameover_init
123+  AEE2 CD 64 AE         call gameover_commontext
124+  AEE5
125+  AEE5 21 8D 84         ld hl,string_highscore_congratulations
126+  AEE8 CD 28 86         call string_print
127+  AEEB
128+  AEEB 3A 88 C4         ld a,(game_currentplayer)
129+  AEEE FE 01            cp 1
130+  AEF0 21 9F 84         ld hl,string_highscore_player1
131+  AEF3 C3 F9 AE         jp gameover_enterhighscores_init1
132+  AEF6              gameover_enterhighscores_init0:
133+  AEF6 21 AA 84         ld hl,string_highscore_player2
134+  AEF9              gameover_enterhighscores_init1:
135+  AEF9 CD 28 86         call string_print
136+  AEFC 06 60            ld b,96
137+  AEFE 3E 43            ld a,67
138+  AF00 11 A0 58         ld de,22528+160                         ; attrs here
139+  AF03 CD 9D A9         call screen_setcolours
140+  AF06
141+  AF06 21 B5 84         ld hl,string_highscore_youhaveearned
142+  AF09 CD 28 86         call string_print
143+  AF0C
144+  AF0C 3A 5E CD         ld a,(scores_highscoretmp)
145+  AF0F FE 05            cp 5
146+  AF11 CA 1F AF         jp z, gameover_enterhighscores_init2    ; first place
147+  AF14 FE 11            cp 17
148+  AF16 CA 25 AF         jp z, gameover_enterhighscores_init3    ; 2nd place
149+  AF19 21 F1 84         ld hl,string_highscore_place3           ; 3rd place
150+  AF1C C3 2B AF         jp gameover_enterhighscores_init4
151+  AF1F              gameover_enterhighscores_init2
152+  AF1F 21 C7 84         ld hl,string_highscore_place1
153+  AF22 C3 2B AF         jp gameover_enterhighscores_init4
154+  AF25              gameover_enterhighscores_init3
155+  AF25 21 DC 84         ld hl,string_highscore_place2
156+  AF28 C3 2B AF         jp gameover_enterhighscores_init4
157+  AF2B              gameover_enterhighscores_init4
158+  AF2B CD 28 86         call string_print
159+  AF2E
160+  AF2E 06 60            ld b,96
161+  AF30 3E 42            ld a,66
162+  AF32 11 40 59         ld de,22528+320                         ; attrs here
163+  AF35 CD 9D A9         call screen_setcolours
164+  AF38
165+  AF38 21 06 85         ld hl,string_highscore_pleaseenter
166+  AF3B CD 28 86         call string_print
167+  AF3E
168+  AF3E 06 60            ld b,96
169+  AF40 3E 46            ld a,70
170+  AF42 11 E0 59         ld de,22528+480                         ; attrs here
171+  AF45 CD 9D A9         call screen_setcolours
172+  AF48 C9               ret
173+  AF49
174+  AF49              ;
175+  AF49              ; Initialises the screen
176+  AF49              ;
177+  AF49              gameover_init:
178+  AF49              ; We want a black screen.
179+  AF49 3E 47            ld a,71             ; white ink (7) on black paper (0),
180+  AF4B                                      ; bright (64).
181+  AF4B CD 46 81         call utilities_clearscreen
182+  AF4E 32 8D 5C         ld (23693),a        ; set our screen colours.
183+  AF51 3E 00            ld a,0              ; 2 is the code for red.
184+  AF53 D3 FE            out (254),a         ; write to port 254.
185+  AF55 C9               ret
# file closed: screen/gameover.asm
144   AF56                  include "screen\endlevel.asm"
# file opened: screen/endlevel.asm
  1+  AF56              ;
  2+  AF56              ; Draws the level transition screen
  3+  AF56              ;
  4+  AF56              endlevel_draw:
  5+  AF56 CD 57 B0         call endlevel_init
  6+  AF59 CD 40 B0         call endlevel_commontext
  7+  AF5C
  8+  AF5C 21 8D 84         ld hl,string_highscore_congratulations
  9+  AF5F CD 28 86         call string_print
 10+  AF62
 11+  AF62 3A 88 C4         ld a,(game_currentplayer)
 12+  AF65 FE 01            cp 1
 13+  AF67 21 9F 84         ld hl,string_highscore_player1
 14+  AF6A C3 70 AF         jp endlevel_init1
 15+  AF6D              endlevel_init0:
 16+  AF6D 21 AA 84         ld hl,string_highscore_player2
 17+  AF70              endlevel_init1:
 18+  AF70 CD 28 86         call string_print
 19+  AF73
 20+  AF73 21 23 85         ld hl,string_endlevel_youhaveearned
 21+  AF76 CD 28 86         call string_print
 22+  AF79
 23+  AF79 CD DF AF         call endlevel_workoutbonus
 24+  AF7C D5               push de
 25+  AF7D 08               ex af,af'                               ; store the a value for later
 26+  AF7E CD 28 86         call string_print
 27+  AF81 D1               pop de
 28+  AF82 62 6B            ld hl,de                                ; get the points text into de
 29+  AF84 CD 28 86         call string_print
 30+  AF87
 31+  AF87 21 8E 85         ld hl, string_endlevel_anothergo
 32+  AF8A CD 28 86         call string_print
 33+  AF8D
 34+  AF8D 06 20            ld b,32
 35+  AF8F 3E 23            ld a,35
 36+  AF91 11 60 59         ld de,22528+352                         ; attrs here
 37+  AF94 CD 9D A9         call screen_setcolours
 38+  AF97
 39+  AF97 06 20            ld b,32
 40+  AF99 3E 25            ld a,37
 41+  AF9B 11 A0 59         ld de,22528+416                         ; attrs here
 42+  AF9E CD 9D A9         call screen_setcolours
 43+  AFA1
 44+  AFA1 06 20            ld b,32
 45+  AFA3 3E 23            ld a,35
 46+  AFA5 11 E0 59         ld de,22528+480                         ; attrs here
 47+  AFA8 CD 9D A9         call screen_setcolours
 48+  AFAB
 49+  AFAB 06 20            ld b,32
 50+  AFAD 3E 22            ld a,34
 51+  AFAF 11 40 5A         ld de,22528+576                         ; attrs here
 52+  AFB2 CD 9D A9         call screen_setcolours
 53+  AFB5
 54+  AFB5 08               ex af,af'                               ; get back a value with bonus type
 55+  AFB6 06 14            ld b,20
 56+  AFB8 CD 61 81         call utilities_pauseforframes
 57+  AFBB
 58+  AFBB 47               ld b,a                      ; put the bonus count in b
 59+  AFBC              endlevel_init2:
 60+  AFBC C5               push bc
 61+  AFBD 06 01            ld b,1
 62+  AFBF CD 98 CC         call scores_addthousands
 63+  AFC2 CD 6E B1         call sound_scoretick
 64+  AFC5 CD 42 C6         call player_recordcurrentstate
 65+  AFC8 CD AF CC         call scores_printscore     ; print the current scores
 66+  AFCB 06 0A            ld b,10
 67+  AFCD CD 61 81         call utilities_pauseforframes
 68+  AFD0 C1               pop bc
 69+  AFD1 10 E9            djnz endlevel_init2
 70+  AFD3
 71+  AFD3 CD 2B C5         call game_increasedifficulty ; move the difficulty up a level
 72+  AFD6 CD 42 C6         call player_recordcurrentstate
 73+  AFD9
 74+  AFD9 3E 64            ld a,100                              ; wait for 200 frames
 75+  AFDB CD 22 81         call utilities_waitforkey_forframes   ; wait for keypress
 76+  AFDE
 77+  AFDE C9               ret
 78+  AFDF
 79+  AFDF              ;
 80+  AFDF              ; Works out the bonus
 81+  AFDF              ; Outputs:
 82+  AFDF              ; a = 15 (all seven)
 83+  AFDF              ; a = 10 (3 large or 4 small)
 84+  AFDF              ; a = 5 (1 large diamond)
 85+  AFDF              ; hl - pointer to bonus text
 86+  AFDF              ; de - pointer to points text
 87+  AFDF              ;
 88+  AFDF              endlevel_workoutbonus:
 89+  AFDF 21 56 B8         ld hl,level_diamonds+2     ; location of state of first diamond
 90+  AFE2 06 03            ld b,3                      ; number to check
 91+  AFE4 16 00            ld d,0                      ; zero diamond count
 92+  AFE6              endlevel_workoutbonus0:
 93+  AFE6 7E               ld a,(hl)                   ; get state
 94+  AFE7 FE 01            cp 1
 95+  AFE9 C2 ED AF         jp nz,endlevel_workoutbonus1 ; if not, move on
 96+  AFEC 14               inc d                       ; increment diamond count
 97+  AFED              endlevel_workoutbonus1:
 98+  AFED 23               inc hl
 99+  AFEE 23               inc hl
100+  AFEF 23               inc hl
101+  AFF0 23               inc hl
102+  AFF1 23               inc hl                      ; get to next state
103+  AFF2 10 F2            djnz endlevel_workoutbonus0
104+  AFF4
105+  AFF4 21 66 B8         ld hl,level_gems+2     ; location of state of first gem
106+  AFF7 06 04            ld b,4                      ; number to check
107+  AFF9 1E 00            ld e,0                      ; zero gem count
108+  AFFB              endlevel_workoutbonus2:
109+  AFFB 7E               ld a,(hl)                   ; get state
110+  AFFC FE 01            cp 1
111+  AFFE C2 02 B0         jp nz,endlevel_workoutbonus3 ; if not, move on
112+  B001 1C               inc e                       ; increment diamond count
113+  B002              endlevel_workoutbonus3:
114+  B002 23               inc hl
115+  B003 23               inc hl
116+  B004 23               inc hl
117+  B005 23               inc hl
118+  B006 23               inc hl                     ; get to next state
119+  B007 10 F2            djnz endlevel_workoutbonus2
120+  B009
121+  B009 7A               ld a,d
122+  B00A 83               add e
123+  B00B FE 07            cp 7                        ; check for max bonus
124+  B00D C2 19 B0         jp nz,endlevel_workoutbonus4 ;
125+  B010 3E 0F            ld a,15
126+  B012 21 53 85         ld hl, string_endlevel_bonus3
127+  B015 11 7F 85         ld de, string_endlevel_points3
128+  B018 C9               ret                         ; return with bonus of 15
129+  B019              endlevel_workoutbonus4:
130+  B019 7A               ld a,d                      ; check for for diamonds
131+  B01A FE 03            cp 3
132+  B01C C2 28 B0         jp nz,endlevel_workoutbonus5
133+  B01F 3E 0A            ld a,10
134+  B021 21 44 85         ld hl, string_endlevel_bonus2
135+  B024 11 70 85         ld de, string_endlevel_points2
136+  B027 C9               ret                         ; return with bonus of ten
137+  B028              endlevel_workoutbonus5:
138+  B028 7B               ld a,e                      ; check for four gems
139+  B029 FE 04            cp 4
140+  B02B C2 37 B0         jp nz,endlevel_workoutbonus6
141+  B02E 3E 0A            ld a,10
142+  B030 21 44 85         ld hl, string_endlevel_bonus2
143+  B033 11 70 85         ld de, string_endlevel_points2
144+  B036 C9               ret                         ; return with bonus of 10
145+  B037              endlevel_workoutbonus6:
146+  B037 3E 05            ld a,5                      ; otherwise, bonus is 5
147+  B039 21 35 85         ld hl, string_endlevel_bonus1
148+  B03C 11 62 85         ld de, string_endlevel_points1
149+  B03F C9               ret
150+  B040
151+  B040              ;
152+  B040              ; Draws text shared by the game over and high score screens
153+  B040              ;
154+  B040              endlevel_commontext:
155+  B040 CD 61 A9         call screen_setuptext       ; show scores
156+  B043 CD EF CC         call scores_printscores     ; print the current scores
157+  B046
158+  B046 21 6D 84         ld hl,string_gameoverscreen_bestscores
159+  B049 CD 28 86         call string_print
160+  B04C
161+  B04C 06 20            ld b,32
162+  B04E 3E 45            ld a,69
163+  B050 11 C0 5A         ld de,22528+704                         ; attrs here
164+  B053 CD 9D A9         call screen_setcolours
165+  B056
166+  B056 C9               ret
167+  B057
168+  B057              ;
169+  B057              ; Initialises the screen
170+  B057              ;
171+  B057              endlevel_init:
172+  B057              ; We want a green screen.
173+  B057 3E 21            ld a,33             ; white ink (7) on black paper (0),
174+  B059                                      ; bright (64).
175+  B059 CD 46 81         call utilities_clearscreen
176+  B05C 32 8D 5C         ld (23693),a        ; set our screen colours.
177+  B05F 3E 00            ld a,0              ; 2 is the code for red.
178+  B061 D3 FE            out (254),a         ; write to port 254.
179+  B063 C9               ret
# file closed: screen/endlevel.asm
145   B064                  include "screen\options.asm"
# file opened: screen/options.asm
  1+  B064              ;
  2+  B064              ; Show the options screen
  3+  B064              ;
  4+  B064              options_show:
  5+  B064 CD FF B0         call options_init
  6+  B067
  7+  B067 21 A9 85         ld hl,string_options_title
  8+  B06A CD 28 86         call string_print
  9+  B06D 21 B3 85         ld hl,string_options_1player
 10+  B070 CD 28 86         call string_print
 11+  B073 21 C3 85         ld hl,string_options_2player
 12+  B076 CD 28 86         call string_print
 13+  B079 21 D3 85         ld hl,string_options_keyboard
 14+  B07C CD 28 86         call string_print
 15+  B07F 21 E1 85         ld hl,string_options_joystick
 16+  B082 CD 28 86         call string_print
 17+  B085 21 EF 85         ld hl,string_options_start
 18+  B088 CD 28 86         call string_print
 19+  B08B 21 FA 85         ld hl,string_options_vanity
 20+  B08E CD 28 86         call string_print
 21+  B091
 22+  B091 3A 87 C4         ld a,(game_numberplayers)
 23+  B094 FE 01            cp 1
 24+  B096 C2 9F B0         jp nz,options_show0
 25+  B099 11 CA 58         ld de,22528+202                         ; top row attrs here
 26+  B09C C3 A2 B0         jp options_show1
 27+  B09F              options_show0:
 28+  B09F 11 EA 58         ld de,22528+234                         ; top row attrs here
 29+  B0A2              options_show1:
 30+  B0A2 06 0D            ld b,13
 31+  B0A4 3E C7            ld a,199
 32+  B0A6 CD 9D A9         call screen_setcolours                  ; highlight current player
 33+  B0A9
 34+  B0A9 3A 8B C4         ld a,(game_control)
 35+  B0AC FE 00            cp 0
 36+  B0AE C2 B7 B0         jp nz,options_show6
 37+  B0B1 11 0A 59         ld de,22528+266                         ; top row attrs here
 38+  B0B4 C3 BA B0         jp options_show7
 39+  B0B7              options_show6:
 40+  B0B7 11 2A 59         ld de,22528+298                         ; top row attrs here
 41+  B0BA              options_show7:
 42+  B0BA 06 0D            ld b,13
 43+  B0BC 3E C7            ld a,199
 44+  B0BE CD 9D A9         call screen_setcolours                  ; highlight current control
 45+  B0C1              options_show8:
 46+  B0C1 CD 65 81         call utilities_readkey
 47+  B0C4 FE 31            cp 49                                   ; was 1 pressed
 48+  B0C6 C2 D1 B0         jp nz,options_show2
 49+  B0C9 21 87 C4         ld hl,game_numberplayers
 50+  B0CC 36 01            ld (hl),1
 51+  B0CE C3 64 B0         jp options_show
 52+  B0D1              options_show2:
 53+  B0D1 FE 32            cp 50                                   ; was 2 pressed
 54+  B0D3 C2 DE B0         jp nz,options_show3
 55+  B0D6 21 87 C4         ld hl,game_numberplayers
 56+  B0D9 36 02            ld (hl),2
 57+  B0DB C3 64 B0         jp options_show
 58+  B0DE              options_show3:
 59+  B0DE FE 33            cp 51                                   ; was 3 pressed
 60+  B0E0 C2 EB B0         jp nz,options_show4
 61+  B0E3 21 8B C4         ld hl,game_control
 62+  B0E6 36 00            ld (hl),0
 63+  B0E8 C3 64 B0         jp options_show
 64+  B0EB              options_show4:
 65+  B0EB FE 34            cp 52                                   ; was 4 pressed
 66+  B0ED C2 F8 B0         jp nz,options_show5
 67+  B0F0 21 8B C4         ld hl,game_control
 68+  B0F3 36 01            ld (hl),1
 69+  B0F5 C3 64 B0         jp options_show
 70+  B0F8              options_show5:
 71+  B0F8 FE 35            cp 53                                   ; was 5 pressed
 72+  B0FA C8               ret z                                   ; exit if so
 73+  B0FB C3 C1 B0         jp options_show8                         ; otherwise, jump to top
 74+  B0FE C9               ret
 75+  B0FF
 76+  B0FF              ;
 77+  B0FF              ; Initialise the options screen
 78+  B0FF              ;
 79+  B0FF              options_init:
 80+  B0FF 3E 47            ld a,71             ; white ink (7) on black paper (0),
 81+  B101                                      ; bright (64).
 82+  B101 CD 46 81         call utilities_clearscreen
 83+  B104 32 8D 5C         ld (23693),a        ; set our screen colours.
 84+  B107 3E 00            ld a,0              ; 2 is the code for red.
 85+  B109 D3 FE            out (254),a         ; write to port 254.
 86+  B10B
 87+  B10B C9               ret
 88+  B10C C9               ret
# file closed: screen/options.asm
146   B10D
147   B10D                  include "sound\sound.asm"
# file opened: sound/sound.asm
  1+  B10D
  2+  B10D
  3+  B10D              ;
  4+  B10D              ; Plays a note
  5+  B10D              ; Inputs:
  6+  B10D              ; d - border
  7+  B10D              ; e - pitch
  8+  B10D              ; bc - duration
  9+  B10D              sound_play:
 10+  B10D 7B               ld a,e
 11+  B10E 32 18 B1         ld (sound_play2+1),a
 12+  B111 7A           	ld a,d
 13+  B112              sound_play0:
 14+  B112 D3 FE            out (254),a
 15+  B114 1D               dec e
 16+  B115 20 04            jr nz,sound_play1
 17+  B117              sound_play2:
 18+  B117 1E 00            ld e,0
 19+  B119 EE 18            xor 24
 20+  B11B              sound_play1:
 21+  B11B 10 F5            djnz sound_play0
 22+  B11D 0D               dec c
 23+  B11E 20 F2            jr nz,sound_play0
 24+  B120 C9               ret
 25+  B121
 26+  B121              sound_dig:
 27+  B121 D9               exx
 28+  B122
 29+  B122 D9               exx
 30+  B123 C9           	ret
 31+  B124
 32+  B124              sound_gamestart:
 33+  B124 F3               di
 34+  B125 06 03            ld b,3
 35+  B127              sound_gamestart0:
 36+  B127 C5               push bc
 37+  B128 1E 36            ld e,54
 38+  B12A 01 4B 00         ld bc,75
 39+  B12D 16 02            ld d,2
 40+  B12F CD 0D B1         call sound_play
 41+  B132 1E 4C            ld e,76
 42+  B134 01 4B 00         ld bc,75
 43+  B137 16 02            ld d,2
 44+  B139 CD 0D B1         call sound_play
 45+  B13C C1               pop bc
 46+  B13D 10 E8            djnz sound_gamestart0
 47+  B13F FB               ei
 48+  B140 C9               ret
 49+  B141
 50+  B141              sound_lifestart:
 51+  B141 F3               di
 52+  B142 06 03            ld b,3
 53+  B144              sound_lifestart0:
 54+  B144 C5               push bc
 55+  B145 1E 36            ld e,54
 56+  B147 01 20 00         ld bc,32
 57+  B14A 16 01            ld d,1
 58+  B14C CD 0D B1         call sound_play
 59+  B14F 1E 4C            ld e,76
 60+  B151 01 20 00         ld bc,32
 61+  B154 16 01            ld d,1
 62+  B156 CD 0D B1         call sound_play
 63+  B159 1E 36            ld e,54
 64+  B15B 01 20 00         ld bc,32
 65+  B15E CD 0D B1         call sound_play
 66+  B161 1E 4C            ld e,76
 67+  B163 01 20 00         ld bc,32
 68+  B166 CD 0D B1         call sound_play
 69+  B169 C1               pop bc
 70+  B16A 10 D8            djnz sound_lifestart0
 71+  B16C FB               ei
 72+  B16D C9               ret
 73+  B16E
 74+  B16E              sound_scoretick:
 75+  B16E F3               di
 76+  B16F 1E 23            ld e,35
 77+  B171 01 18 00         ld bc,24
 78+  B174 16 00            ld d,0
 79+  B176 CD 0D B1         call sound_play
 80+  B179 FB               ei
 81+  B17A C9               ret
 82+  B17B
 83+  B17B              sound_laser:
 84+  B17B 16 10        	ld d,16		            ;speaker = bit 4
 85+  B17D 1E 00        	ld e,0		            ;distance between speaker move counter
 86+  B17F 06 80        	ld b,128	            ;overall length counter
 87+  B181              sound_laser0:
 88+  B181 7A               ld a,d
 89+  B182 E6 F8        	and 248		            ;keep border colour the same
 90+  B184 D3 FE        	out (254),a	            ;move the speaker in or out depending on bit 4
 91+  B186 2F           	cpl		                ;toggle, so we alternative between speaker in and out to make sound
 92+  B187 57           	ld d,a		            ;store it
 93+  B188 4B           	ld c,e		            ;now a pause
 94+  B189              sound_laser1:
 95+  B189 0D               dec c
 96+  B18A 20 FD        	jr nz,sound_laser1
 97+  B18C 1D           	dec e		            ;change to inc e to reverse the sound, or remove to make it a note
 98+  B18D 10 F2        	djnz sound_laser0	;repeat B=255 times
 99+  B18F C9           	ret
100+  B190
101+  B190              sound_gemcollected:
102+  B190 16 10        	ld d,16		            ;speaker = bit 4
103+  B192 1E 00        	ld e,0		            ;distance between speaker move counter
104+  B194 06 80        	ld b,128	            ;overall length counter
105+  B196              sound_gemcollected0:
106+  B196 7A               ld a,d
107+  B197 E6 F8        	and 248		            ;keep border colour the same
108+  B199 D3 FE        	out (254),a	            ;move the speaker in or out depending on bit 4
109+  B19B 2F           	cpl		                ;toggle, so we alternative between speaker in and out to make sound
110+  B19C 57           	ld d,a		            ;store it
111+  B19D 4B           	ld c,e		            ;now a pause
112+  B19E              sound_gemcollected1:
113+  B19E 0D               dec c
114+  B19F 20 FD        	jr nz,sound_gemcollected1
115+  B1A1 1C           	inc e		            ;change to inc e to reverse the sound, or remove to make it a note
116+  B1A2 10 F2        	djnz sound_gemcollected0	;repeat B=255 times
117+  B1A4 C9           	ret
118+  B1A5
119+  B1A5              sound_pitchbend:
120+  B1A5 21 F4 01         ld hl,500 ; starting pitch.
121+  B1A8 06 FA            ld b,250 ; length of pitch bend.
122+  B1AA              sound_pitchbend0:
123+  B1AA C5                push bc
124+  B1AB E5               push hl ; store pitch.
125+  B1AC 11 01 00         ld de,1 ; very short duration.
126+  B1AF CD B5 03         call 949 ; ROM beeper routine.
127+  B1B2 E1               pop hl ; restore pitch.
128+  B1B3 23               inc hl ; pitch going up.
129+  B1B4 C1               pop bc
130+  B1B5 10 F3            djnz sound_pitchbend0 ; repeat.
131+  B1B7 C9               ret
132+  B1B8
133+  B1B8              sound_rockfell:
134+  B1B8 08               ex af,af'
135+  B1B9 1E 32            ld e,50 ; repeat 250 times.
136+  B1BB 21 00 00         ld hl,0 ; start pointer in ROM.
137+  B1BE              sound_rockfell2
138+  B1BE D5               push de
139+  B1BF 06 20            ld b,32 ; length of step.
140+  B1C1 C5           sound_rockfell0 push bc
141+  B1C2 7E               ld a,(hl) ; next "random" number.
142+  B1C3 23               inc hl ; pointer.
143+  B1C4 E6 F8            and 248 ; we want a black border.
144+  B1C6 D3 FE            out (254),a ; write to speaker.
145+  B1C8 7B               ld a,e ; as e gets smaller...
146+  B1C9 2F               cpl ; ...we increase the delay.
147+  B1CA 3D           sound_rockfell1 dec a ; decrement loop counter.
148+  B1CB 20 FD            jr nz,sound_rockfell1 ; delay loop.
149+  B1CD C1               pop bc
150+  B1CE 10 F1            djnz sound_rockfell0 ; next step.
151+  B1D0 D1               pop de
152+  B1D1 7B               ld a,e
153+  B1D2 D6 18            sub 24 ; size of step.
154+  B1D4 FE 1E            cp 30 ; end of range.
155+  B1D6 CA E7 B1         jp z,sound_rockfell5
156+  B1D9 DA E7 B1         jp c, sound_rockfell5
157+  B1DC 5F               ld e,a
158+  B1DD 2F               cpl
159+  B1DE 06 28        sound_rockfell3 ld b,40 ; silent period.
160+  B1E0 10 FE        sound_rockfell4 djnz sound_rockfell4
161+  B1E2 3D               dec a
162+  B1E3 20 F9            jr nz,sound_rockfell3
163+  B1E5 18 D7            jr sound_rockfell2
164+  B1E7              sound_rockfell5
165+  B1E7 08               ex af,af'
166+  B1E8 C9               ret
167+  B1E9
168+  B1E9              sound_tankshoot:
169+  B1E9 08               ex af,af'
170+  B1EA 1E 32            ld e,50 ; repeat 250 times.
171+  B1EC 21 00 00         ld hl,0 ; start pointer in ROM.
172+  B1EF              sound_tankshoot2
173+  B1EF D5               push de
174+  B1F0 06 10            ld b,16 ; length of step.
175+  B1F2 C5           sound_tankshoot0 push bc
176+  B1F3 7E               ld a,(hl) ; next "random" number.
177+  B1F4 23               inc hl ; pointer.
178+  B1F5 E6 F8            and 248 ; we want a black border.
179+  B1F7 D3 FE            out (254),a ; write to speaker.
180+  B1F9 7B               ld a,e ; as e gets smaller...
181+  B1FA 2F               cpl ; ...we increase the delay.
182+  B1FB 3D           sound_tankshoot1 dec a ; decrement loop counter.
183+  B1FC 20 FD            jr nz,sound_tankshoot1 ; delay loop.
184+  B1FE C1               pop bc
185+  B1FF 10 F1            djnz sound_tankshoot0 ; next step.
186+  B201 D1               pop de
187+  B202 7B               ld a,e
188+  B203 D6 18            sub 24 ; size of step.
189+  B205 FE 1E            cp 30 ; end of range.
190+  B207 CA 18 B2         jp z,sound_tankshoot5
191+  B20A DA 18 B2         jp c, sound_tankshoot5
192+  B20D 5F               ld e,a
193+  B20E 2F               cpl
194+  B20F 06 28        sound_tankshoot3 ld b,40 ; silent period.
195+  B211 10 FE        sound_tankshoot4 djnz sound_tankshoot4
196+  B213 3D               dec a
197+  B214 20 F9            jr nz,sound_tankshoot3
198+  B216 18 D7            jr sound_tankshoot2
199+  B218              sound_tankshoot5
200+  B218 08               ex af,af'
201+  B219 C9               ret
202+  B21A
203+  B21A              ; Call this every time you want to initialise a sound effect
204+  B21A              ; A = Variable 1
205+  B21A              ; B = Variable 2
206+  B21A              ; C = Duration of overall sound effect
207+  B21A              ; D = Duration of each step of the sound effect
208+  B21A              ;
209+  B21A              soundfx_a_init:
210+  B21A 32 41 B2         ld (soundfx_a_v2+1),a
211+  B21D 78               ld a,b
212+  B21E 32 4A B2         ld (soundfx_a_v3+1),a
213+  B221 79               ld a,c
214+  B222 32 2F B2         ld (soundfx_a_main+1),a
215+  B225 7A               ld a,d
216+  B226 32 36 B2         ld (soundfx_a_v1+1),a
217+  B229 AF               xor a
218+  B22A 32 53 B2         ld (soundfx_a_v4),a
219+  B22D C9               ret
220+  B22E
221+  B22E              ; Call this during your main loop
222+  B22E              ; It will play one step of the sound effect each pass
223+  B22E              ; until the complete sound effect has finished
224+  B22E              ;
225+  B22E              soundfx_a_main:
226+  B22E 3E 00            ld a,0
227+  B230 3D               dec a
228+  B231 C8               ret z
229+  B232 32 2F B2         ld (soundfx_a_main+1),a
230+  B235              soundfx_a_v1:
231+  B235 06 00            ld b,0
232+  B237 21 53 B2         ld hl,soundfx_a_v4
233+  B23A              soundfx_a_l1:
234+  B23A 48               ld c,b
235+  B23B 3E 08            ld a,%00001000
236+  B23D D3 FE            out (254),a
237+  B23F 7E               ld a,(hl)
238+  B240              soundfx_a_v2:
239+  B240 EE 00            xor 0
240+  B242 47               ld b,a
241+  B243 10 FE            djnz $
242+  B245 AF               xor a
243+  B246 D3 FE            out (254),a
244+  B248 7E               ld a,(hl)
245+  B249              soundfx_a_v3:
246+  B249 EE 00            xor 0
247+  B24B 47               ld b,a
248+  B24C 10 FE            djnz $
249+  B24E 35               dec (hl)
250+  B24F 41               ld b,c
251+  B250 10 E8            djnz soundfx_a_l1
252+  B252 C9               ret
253+  B253
254+  B253              soundfx_a_v4:
255+  B253 00               defb 0
# file closed: sound/sound.asm
148   B254
149   B254                  include "leveldata\level.asm"
# file opened: leveldata/level.asm
  1+  B254              ; ###############################################################
  2+  B254              ; Data for level 1
  3+  B254              ; ###############################################################
  4+  B254              level_layout:
  5+  B254
  6+  B254                  ;defb 09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09,09,04,04,04,04,04,04,04,04,04,04,04,04,04,04,09
  7+  B254
  8+  B254 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,05,05,02,01,01,01,03,05,05,05,05,05,05,05,05,05,05,05,00,00
  8+  B258 05 05 05 05
  8+  B25C 05 05 05 05
  8+  B260 05 05 02 01
  8+  B264 01 01 03 05
  8+  B268 05 05 05 05
  8+  B26C 05 05 05 05
  8+  B270 05 05 00 00
  9+  B274 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,03,05,05,05,05,05,05,05,05,05,00,00
  9+  B278 05 05 05 05
  9+  B27C 05 05 05 05
  9+  B280 02 01 01 01
  9+  B284 01 01 01 01
  9+  B288 03 05 05 05
  9+  B28C 05 05 05 05
  9+  B290 05 05 00 00
 10+  B294 00 00 05 05      defb 00,00,05,05,05,05,05,05,05,05,02,01,01,01,01,01,01,01,01,01,01,01,03,05,13,13,13,13,13,13,00,00
 10+  B298 05 05 05 05
 10+  B29C 05 05 02 01
 10+  B2A0 01 01 01 01
 10+  B2A4 01 01 01 01
 10+  B2A8 01 01 03 05
 10+  B2AC 0D 0D 0D 0D
 10+  B2B0 0D 0D 00 00
 11+  B2B4 00 00 01 01      defb 00,00,01,01,01,01,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,03,05,05,05,05,05,05,00,00
 11+  B2B8 01 01 00 01
 11+  B2BC 01 01 01 01
 11+  B2C0 01 01 01 01
 11+  B2C4 01 01 01 01
 11+  B2C8 01 01 01 03
 11+  B2CC 05 05 05 05
 11+  B2D0 05 05 00 00
 12+  B2D4 00 00 01 01      defb 00,00,01,01,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,01,00,00
 12+  B2D8 04 04 04 04
 12+  B2DC 04 04 01 01
 12+  B2E0 01 01 01 01
 12+  B2E4 01 01 01 01
 12+  B2E8 01 01 01 01
 12+  B2EC 01 01 01 01
 12+  B2F0 00 01 00 00
 13+  B2F4 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,01,00,00
 13+  B2F8 04 04 04 04
 13+  B2FC 04 04 04 04
 13+  B300 01 01 01 01
 13+  B304 01 01 01 01
 13+  B308 01 01 01 01
 13+  B30C 00 00 00 00
 13+  B310 00 01 00 00
 14+  B314 00 00 01 04      defb 00,00,01,04,04,01,01,01,01,01,04,04,04,04,01,01,01,01,01,01,01,00,00,00,00,01,01,01,01,01,00,00
 14+  B318 04 01 01 01
 14+  B31C 01 01 04 04
 14+  B320 04 04 01 01
 14+  B324 01 01 01 01
 14+  B328 01 00 00 00
 14+  B32C 00 01 01 01
 14+  B330 01 01 00 00
 15+  B334 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,01,04,04,04,04,04,04,04,04,00,00,00,00,04,04,04,04,04,04,04,01,00,00
 15+  B338 04 04 04 04
 15+  B33C 04 01 04 04
 15+  B340 04 04 04 04
 15+  B344 04 04 00 00
 15+  B348 00 00 04 04
 15+  B34C 04 04 04 04
 15+  B350 04 01 00 00
 16+  B354 00 00 01 01      defb 00,00,01,01,01,04,01,01,01,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 16+  B358 01 04 01 01
 16+  B35C 01 01 04 04
 16+  B360 04 04 04 04
 16+  B364 04 04 00 04
 16+  B368 04 04 04 04
 16+  B36C 04 04 04 04
 16+  B370 04 01 00 00
 17+  B374 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 17+  B378 00 00 00 00
 17+  B37C 00 04 04 04
 17+  B380 04 04 04 04
 17+  B384 04 04 00 04
 17+  B388 04 04 04 04
 17+  B38C 04 04 04 04
 17+  B390 04 01 00 00
 18+  B394 00 00 01 15      defb 00,00,01,21,21,21,21,21,21,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,04,04,04,04,01,00,00
 18+  B398 15 15 15 15
 18+  B39C 15 01 04 04
 18+  B3A0 04 04 04 04
 18+  B3A4 04 04 00 04
 18+  B3A8 04 04 04 04
 18+  B3AC 04 04 04 04
 18+  B3B0 04 01 00 00
 19+  B3B4 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,00,00,00,01,00,00
 19+  B3B8 00 00 00 00
 19+  B3BC 00 01 04 04
 19+  B3C0 04 04 04 04
 19+  B3C4 04 04 00 04
 19+  B3C8 04 04 04 04
 19+  B3CC 04 00 00 00
 19+  B3D0 00 01 00 00
 20+  B3D4 00 00 01 00      defb 00,00,01,00,00,00,00,00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 20+  B3D8 00 00 00 00
 20+  B3DC 00 01 04 04
 20+  B3E0 04 04 04 04
 20+  B3E4 04 04 00 04
 20+  B3E8 04 04 04 04
 20+  B3EC 04 00 04 04
 20+  B3F0 00 01 00 00
 21+  B3F4 00 00 01 06      defb 00,00,01,06,06,06,06,06,06,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,00,01,00,00
 21+  B3F8 06 06 06 06
 21+  B3FC 06 01 04 04
 21+  B400 04 04 04 04
 21+  B404 04 04 00 04
 21+  B408 04 04 04 04
 21+  B40C 04 00 04 04
 21+  B410 00 01 00 00
 22+  B414 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,04,00,01,00,00
 22+  B418 1A 1A 1A 1A
 22+  B41C 1A 01 04 00
 22+  B420 00 00 00 00
 22+  B424 00 00 00 00
 22+  B428 00 00 00 00
 22+  B42C 00 00 04 04
 22+  B430 00 01 00 00
 23+  B434 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 23+  B438 1A 1A 1A 1A
 23+  B43C 1A 01 04 00
 23+  B440 04 04 04 04
 23+  B444 04 04 00 04
 23+  B448 04 04 00 04
 23+  B44C 04 04 04 04
 23+  B450 00 01 00 00
 24+  B454 00 00 01 1A      defb 00,00,01,26,26,26,26,26,26,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 24+  B458 1A 1A 1A 1A
 24+  B45C 1A 01 04 00
 24+  B460 04 04 04 04
 24+  B464 04 04 00 04
 24+  B468 04 04 00 04
 24+  B46C 04 04 04 04
 24+  B470 00 01 00 00
 25+  B474 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,04,00,04,04,04,04,04,04,00,04,04,04,00,04,04,04,04,04,00,01,00,00
 25+  B478 01 01 01 01
 25+  B47C 01 01 04 00
 25+  B480 04 04 04 04
 25+  B484 04 04 00 04
 25+  B488 04 04 00 04
 25+  B48C 04 04 04 04
 25+  B490 00 01 00 00
 26+  B494 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,00,00,00,00,04,04,04,01,00,00
 26+  B498 04 04 04 04
 26+  B49C 04 04 04 00
 26+  B4A0 04 04 04 04
 26+  B4A4 04 04 00 04
 26+  B4A8 04 04 00 00
 26+  B4AC 00 00 04 04
 26+  B4B0 04 01 00 00
 27+  B4B4 00 00 01 04      defb 00,00,01,04,04,04,00,00,00,00,00,00,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 27+  B4B8 04 04 00 00
 27+  B4BC 00 00 00 00
 27+  B4C0 04 04 04 04
 27+  B4C4 04 04 00 04
 27+  B4C8 04 04 04 04
 27+  B4CC 04 00 04 04
 27+  B4D0 04 01 00 00
 28+  B4D4 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,04,04,04,04,04,04,04,00,04,04,04,04,04,04,00,04,04,04,01,00,00
 28+  B4D8 04 04 00 04
 28+  B4DC 04 04 04 04
 28+  B4E0 04 04 04 04
 28+  B4E4 04 04 00 04
 28+  B4E8 04 04 04 04
 28+  B4EC 04 00 04 04
 28+  B4F0 04 01 00 00
 29+  B4F4 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,01,01,01,01,01,01,01,01,01,01,01,01,01,04,00,04,04,04,01,00,00
 29+  B4F8 04 04 00 04
 29+  B4FC 04 04 01 01
 29+  B500 01 01 01 01
 29+  B504 01 01 01 01
 29+  B508 01 01 01 01
 29+  B50C 04 00 04 04
 29+  B510 04 01 00 00
 30+  B514 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 30+  B518 04 04 00 04
 30+  B51C 04 04 01 00
 30+  B520 00 00 00 00
 30+  B524 00 00 00 00
 30+  B528 00 00 00 01
 30+  B52C 04 00 04 04
 30+  B530 04 01 00 00
 31+  B534 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 31+  B538 04 04 00 04
 31+  B53C 04 04 01 00
 31+  B540 00 00 00 00
 31+  B544 00 00 00 00
 31+  B548 00 00 00 01
 31+  B54C 04 00 04 04
 31+  B550 04 01 00 00
 32+  B554 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,00,04,04,04,01,00,00
 32+  B558 04 04 00 04
 32+  B55C 04 04 01 00
 32+  B560 00 00 00 00
 32+  B564 00 00 00 00
 32+  B568 00 00 00 01
 32+  B56C 04 00 04 04
 32+  B570 04 01 00 00
 33+  B574 00 00 01 04      defb 00,00,01,04,04,04,00,04,04,04,04,00,00,00,00,00,00,00,00,00,00,00,00,04,04,04,04,04,04,01,00,00
 33+  B578 04 04 00 04
 33+  B57C 04 04 04 00
 33+  B580 00 00 00 00
 33+  B584 00 00 00 00
 33+  B588 00 00 00 04
 33+  B58C 04 04 04 04
 33+  B590 04 01 00 00
 34+  B594 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,00,00,00,00,00,00,00,00,00,01,04,04,04,04,04,01,00,00
 34+  B598 04 04 04 04
 34+  B59C 04 04 01 00
 34+  B5A0 00 00 00 00
 34+  B5A4 00 00 00 00
 34+  B5A8 00 00 00 01
 34+  B5AC 04 04 04 04
 34+  B5B0 04 01 00 00
 35+  B5B4 00 00 01 04      defb 00,00,01,04,04,04,04,04,04,04,01,00,00,00,01,00,00,00,00,01,00,00,00,01,04,04,04,04,04,01,00,00
 35+  B5B8 04 04 04 04
 35+  B5BC 04 04 01 00
 35+  B5C0 00 00 01 00
 35+  B5C4 00 00 00 01
 35+  B5C8 00 00 00 01
 35+  B5CC 04 04 04 04
 35+  B5D0 04 01 00 00
 36+  B5D4 00 00 01 01      defb 00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00
 36+  B5D8 01 01 01 01
 36+  B5DC 01 01 01 01
 36+  B5E0 01 01 01 01
 36+  B5E4 01 01 01 01
 36+  B5E8 01 01 01 01
 36+  B5EC 01 01 01 01
 36+  B5F0 01 01 00 00
 37+  B5F4
 38+  B5F4              ; ###############################################################
 39+  B5F4              ; Object data: horiz, vert, state, memh, meml
 40+  B5F4              ; ###############################################################
 41+  B5F4              level_rocks:
 42+  B5F4 09 04 00 00      defb 9,4,0,0,0
 42+  B5F8 00
 43+  B5F9 0C 07 00 00      defb 12,7,0,0,0
 43+  B5FD 00
 44+  B5FE 10 07 00 00      defb 16,7,0,0,0
 44+  B602 00
 45+  B603 0B 08 00 00      defb 11,8,0,0,0
 45+  B607 00
 46+  B608 0A 0A 00 00      defb 10,10,0,0,0
 46+  B60C 00
 47+  B60D 0C 0A 00 00      defb 12,10,0,0,0
 47+  B611 00
 48+  B612 0D 09 00 00      defb 13,9,0,0,0
 48+  B616 00
 49+  B617 0E 08 00 00      defb 14,8,0,0,0
 49+  B61B 00
 50+  B61C 0F 0B 00 00      defb 15,11,0,0,0
 50+  B620 00
 51+  B621 0B 0C 00 00      defb 11,12,0,0,0
 51+  B625 00
 52+  B626 11 0C 00 00      defb 17,12,0,0,0
 52+  B62A 00
 53+  B62B 13 08 00 00      defb 19,8,0,0,0
 53+  B62F 00
 54+  B630 16 09 00 00      defb 22,9,0,0,0
 54+  B634 00
 55+  B635 13 0A 00 00      defb 19,10,0,0,0
 55+  B639 00
 56+  B63A 15 0A 00 00      defb 21,10,0,0,0
 56+  B63E 00
 57+  B63F 15 0C 00 00      defb 21,12,0,0,0
 57+  B643 00
 58+  B644 16 0C 00 00      defb 22,12,0,0,0
 58+  B648 00
 59+  B649 18 0A 00 00      defb 24,10,0,0,0
 59+  B64D 00
 60+  B64E 19 09 00 00      defb 25,9,0,0,0
 60+  B652 00
 61+  B653 1C 09 00 00      defb 28,9,0,0,0
 61+  B657 00
 62+  B658 1B 0C 00 00      defb 27,12,0,0,0
 62+  B65C 00
 63+  B65D 1A 0D 00 00      defb 26,13,0,0,0
 63+  B661 00
 64+  B662 19 0E 00 00      defb 25,14,0,0,0
 64+  B666 00
 65+  B667 19 10 00 00      defb 25,16,0,0,0
 65+  B66B 00
 66+  B66C 1A 11 00 00      defb 26,17,0,0,0
 66+  B670 00
 67+  B671 1B 11 00 00      defb 27,17,0,0,0
 67+  B675 00
 68+  B676 1C 12 00 00      defb 28,18,0,0,0
 68+  B67A 00
 69+  B67B 1A 13 00 00      defb 26,19,0,0,0
 69+  B67F 00
 70+  B680 1B 15 00 00      defb 27,21,0,0,0
 70+  B684 00
 71+  B685 1A 17 00 00      defb 26,23,0,0,0
 71+  B689 00
 72+  B68A 1B 18 00 00      defb 27,24,0,0,0
 72+  B68E 00
 73+  B68F 19 18 00 00      defb 25,24,0,0,0
 73+  B693 00
 74+  B694 18 17 00 00      defb 24,23,0,0,0
 74+  B698 00
 75+  B699 13 14 00 00      defb 19,20,0,0,0
 75+  B69D 00
 76+  B69E 14 12 00 00      defb 20,18,0,0,0
 76+  B6A2 00
 77+  B6A3 14 10 00 00      defb 20,16,0,0,0
 77+  B6A7 00
 78+  B6A8 15 10 00 00      defb 21,16,0,0,0
 78+  B6AC 00
 79+  B6AD 16 12 00 00      defb 22,18,0,0,0
 79+  B6B1 00
 80+  B6B2 11 14 00 00      defb 17,20,0,0,0
 80+  B6B6 00
 81+  B6B7 0D 11 00 00      defb 13,17,0,0,0
 81+  B6BB 00
 82+  B6BC 0C 13 00 00      defb 12,19,0,0,0
 82+  B6C0 00
 83+  B6C1 0B 13 00 00      defb 11,19,0,0,0
 83+  B6C5 00
 84+  B6C6 0A 11 00 00      defb 10,17,0,0,0
 84+  B6CA 00
 85+  B6CB 05 12 00 00      defb 5,18,0,0,0
 85+  B6CF 00
 86+  B6D0 07 16 00 00      defb 7,22,0,0,0
 86+  B6D4 00
 87+  B6D5 09 16 00 00      defb 9,22,0,0,0
 87+  B6D9 00
 88+  B6DA 07 18 00 00      defb 7,24,0,0,0
 88+  B6DE 00
 89+  B6DF 05 18 00 00      defb 5,24,0,0,0
 89+  B6E3 00
 90+  B6E4 06 19 00 00      defb 6,25,0,0,0
 90+  B6E8 00
 91+  B6E9 08 19 00 00      defb 8,25,0,0,0
 91+  B6ED 00
 92+  B6EE 04 17 00 00      defb 4,23,0,0,0
 92+  B6F2 00
 93+  B6F3 FF               defb 255
 94+  B6F4
 95+  B6F4              level_rocks_alt:
 96+  B6F4 09 04 00 00      defb 9,4,0,0,0
 96+  B6F8 00
 97+  B6F9 0C 07 00 00      defb 12,7,0,0,0
 97+  B6FD 00
 98+  B6FE 0B 07 00 00      defb 11,7,0,0,0
 98+  B702 00
 99+  B703 0A 08 00 00      defb 10,8,0,0,0
 99+  B707 00
100+  B708 10 07 00 00      defb 16,7,0,0,0
100+  B70C 00
101+  B70D 0E 08 00 00      defb 14,8,0,0,0
101+  B711 00
102+  B712 0D 09 00 00      defb 13,9,0,0,0
102+  B716 00
103+  B717 0C 0A 00 00      defb 12,10,0,0,0
103+  B71B 00
104+  B71C 0A 0B 00 00      defb 10,11,0,0,0
104+  B720 00
105+  B721 0B 0C 00 00      defb 11,12,0,0,0
105+  B725 00
106+  B726 0F 0B 00 00      defb 15,11,0,0,0
106+  B72A 00
107+  B72B 11 0C 00 00      defb 17,12,0,0,0
107+  B72F 00
108+  B730 15 0B 00 00      defb 21,11,0,0,0
108+  B734 00
109+  B735 16 0C 00 00      defb 22,12,0,0,0
109+  B739 00
110+  B73A 19 09 00 00      defb 25,9,0,0,0
110+  B73E 00
111+  B73F 1C 09 00 00      defb 28,9,0,0,0
111+  B743 00
112+  B744 1B 0C 00 00      defb 27,12,0,0,0
112+  B748 00
113+  B749 1B 0E 00 00      defb 27,14,0,0,0
113+  B74D 00
114+  B74E 1A 0F 00 00      defb 26,15,0,0,0
114+  B752 00
115+  B753 1B 10 00 00      defb 27,16,0,0,0
115+  B757 00
116+  B758 1C 12 00 00      defb 28,18,0,0,0
116+  B75C 00
117+  B75D 1A 13 00 00      defb 26,19,0,0,0
117+  B761 00
118+  B762 1A 15 00 00      defb 26,21,0,0,0
118+  B766 00
119+  B767 1B 17 00 00      defb 27,23,0,0,0
119+  B76B 00
120+  B76C 1A 17 00 00      defb 26,23,0,0,0
120+  B770 00
121+  B771 19 18 00 00      defb 25,24,0,0,0
121+  B775 00
122+  B776 18 17 00 00      defb 24,23,0,0,0
122+  B77A 00
123+  B77B 17 10 00 00      defb 23,16,0,0,0
123+  B77F 00
124+  B780 15 10 00 00      defb 21,16,0,0,0
124+  B784 00
125+  B785 14 12 00 00      defb 20,18,0,0,0
125+  B789 00
126+  B78A 13 14 00 00      defb 19,20,0,0,0
126+  B78E 00
127+  B78F 10 13 00 00      defb 16,19,0,0,0
127+  B793 00
128+  B794 0D 14 00 00      defb 13,20,0,0,0
128+  B798 00
129+  B799 0E 11 00 00      defb 14,17,0,0,0
129+  B79D 00
130+  B79E 0C 12 00 00      defb 12,18,0,0,0
130+  B7A2 00
131+  B7A3 0A 11 00 00      defb 10,17,0,0,0
131+  B7A7 00
132+  B7A8 05 12 00 00      defb 5,18,0,0,0
132+  B7AC 00
133+  B7AD 09 14 00 00      defb 9,20,0,0,0
133+  B7B1 00
134+  B7B2 08 15 00 00      defb 8,21,0,0,0
134+  B7B6 00
135+  B7B7 07 16 00 00      defb 7,22,0,0,0
135+  B7BB 00
136+  B7BC 08 17 00 00      defb 8,23,0,0,0
136+  B7C0 00
137+  B7C1 07 18 00 00      defb 7,24,0,0,0
137+  B7C5 00
138+  B7C6 08 1A 00 00      defb 8,26,0,0,0
138+  B7CA 00
139+  B7CB 06 19 00 00      defb 6,25,0,0,0
139+  B7CF 00
140+  B7D0 05 18 00 00      defb 5,24,0,0,0
140+  B7D4 00
141+  B7D5 04 17 00 00      defb 4,23,0,0,0
141+  B7D9 00
142+  B7DA FF               defb 255
143+  B7DB
144+  B7DB              level_missiles:
145+  B7DB 0B 17 00 00      defb 11,23,0,0,0
145+  B7DF 00
146+  B7E0 0B 16 00 00      defb 11,22,0,0,0
146+  B7E4 00
147+  B7E5 0C 17 00 00      defb 12,23,0,0,0
147+  B7E9 00
148+  B7EA 0C 16 00 00      defb 12,22,0,0,0
148+  B7EE 00
149+  B7EF 0D 17 00 00      defb 13,23,0,0,0
149+  B7F3 00
150+  B7F4 0D 16 00 00      defb 13,22,0,0,0
150+  B7F8 00
151+  B7F9 0E 17 00 00      defb 14,23,0,0,0
151+  B7FD 00
152+  B7FE 0E 16 00 00      defb 14,22,0,0,0
152+  B802 00
153+  B803 0F 17 00 00      defb 15,23,0,0,0
153+  B807 00
154+  B808 0F 16 00 00      defb 15,22,0,0,0
154+  B80C 00
155+  B80D 10 17 00 00      defb 16,23,0,0,0
155+  B811 00
156+  B812 10 16 00 00      defb 16,22,0,0,0
156+  B816 00
157+  B817 11 17 00 00      defb 17,23,0,0,0
157+  B81B 00
158+  B81C 11 16 00 00      defb 17,22,0,0,0
158+  B820 00
159+  B821 12 17 00 00      defb 18,23,0,0,0
159+  B825 00
160+  B826 12 16 00 00      defb 18,22,0,0,0
160+  B82A 00
161+  B82B 13 17 00 00      defb 19,23,0,0,0
161+  B82F 00
162+  B830 13 16 00 00      defb 19,22,0,0,0
162+  B834 00
163+  B835 14 17 00 00      defb 20,23,0,0,0
163+  B839 00
164+  B83A 14 16 00 00      defb 20,22,0,0,0
164+  B83E 00
165+  B83F 15 17 00 00      defb 21,23,0,0,0
165+  B843 00
166+  B844 15 16 00 00      defb 21,22,0,0,0
166+  B848 00
167+  B849 16 17 00 00      defb 22,23,0,0,0
167+  B84D 00
168+  B84E 16 16 00 00      defb 22,22,0,0,0
168+  B852 00
169+  B853 FF               defb 255
170+  B854
171+  B854              ;
172+  B854              ; Diamonds: x,y,state,mem1+mem2
173+  B854              ;
174+  B854              level_diamonds:
175+  B854 0C 1B 00 00      defb 12,27,0,0,0
175+  B858 00
176+  B859 10 1B 00 00      defb 16,27,0,0,0
176+  B85D 00
177+  B85E 15 1B 00 00      defb 21,27,0,0,0
177+  B862 00
178+  B863 FF               defb 255
179+  B864
180+  B864              level_gems:
181+  B864 12 14 00 00      defb 18,20,0,0,0
181+  B868 00
182+  B869 06 18 00 00      defb 6,24,0,0,0
182+  B86D 00
183+  B86E 19 17 00 00      defb 25,23,0,0,0
183+  B872 00
184+  B873 1C 11 00 00      defb 28,17,0,0,0
184+  B877 00
185+  B878 FF               defb 255
186+  B879              ;
187+  B879              ; Score area colours
188+  B879              ;
189+  B879              score_colours:
190+  B879 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,66,67,67,67,67,67,67,67,67,66,71,71,71,71,71,71,71,71,71,71,71
190+  B87D 47 47 47 47
190+  B881 47 47 47 42
190+  B885 43 43 43 43
190+  B889 43 43 43 43
190+  B88D 42 47 47 47
190+  B891 47 47 47 47
190+  B895 47 47 47 47
191+  B899 47 47 47 47      defb 71,71,71,71,71,71,71,71,71,71,71,70,70,70,70,70,70,70,70,70,70,71,71,71,71,71,71,71,71,71,71,71
191+  B89D 47 47 47 47
191+  B8A1 47 47 47 46
191+  B8A5 46 46 46 46
191+  B8A9 46 46 46 46
191+  B8AD 46 47 47 47
191+  B8B1 47 47 47 47
191+  B8B5 47 47 47 47
192+  B8B9
193+  B8B9              high_score_colours:
194+  B8B9 00 00 00 42      defb  0, 0, 0,66,66,66,71,71,71,71,71,71,67,67,67,71,71,71,71,71,71,70,70,70,71,71,71,71,71,71,0,0
194+  B8BD 42 42 47 47
194+  B8C1 47 47 47 47
194+  B8C5 43 43 43 47
194+  B8C9 47 47 47 47
194+  B8CD 47 46 46 46
194+  B8D1 47 47 47 47
194+  B8D5 47 47 00 00
# file closed: leveldata/level.asm
150   B8D9                  include "graphics\font.asm"
# file opened: graphics/font.asm
  1+  B8D9              font:
  2+  B8D9 00 00 00...  	defs 256
  3+  B9D9              	; end 1
  4+  B9D9 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; space
  4+  B9DD 00 00 00 00
  5+  B9E1 18 18 18 18  	defb	  24, 24, 24, 24, 24,  0, 24, 0 ;!
  5+  B9E5 18 00 18 00
  6+  B9E9 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; "
  6+  B9ED 00 00 00 00
  7+  B9F1 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; #
  7+  B9F5 00 00 00 00
  8+  B9F9 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; $
  8+  B9FD 00 00 00 00
  9+  BA01 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; %
  9+  BA05 00 00 00 00
 10+  BA09 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; &
 10+  BA0D 00 00 00 00
 11+  BA11 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; '
 11+  BA15 00 00 00 00
 12+  BA19 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; (
 12+  BA1D 00 00 00 00
 13+  BA21 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; )
 13+  BA25 00 00 00 00
 14+  BA29 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; *
 14+  BA2D 00 00 00 00
 15+  BA31 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; +
 15+  BA35 00 00 00 00
 16+  BA39 00 00 00 00  	defb	  0,  0,  0,  0,  0,  32, 96,  0 ; ,
 16+  BA3D 00 20 60 00
 17+  BA41 00 00 00 3C  	defb	  0,  0,  0, 60,  0,  0,  0,  0 ; -
 17+  BA45 00 00 00 00
 18+  BA49 00 00 00 00  	defb	  0,  0,  0,  0,  0,  96,96,  0 ; .
 18+  BA4D 00 60 60 00
 19+  BA51 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; /
 19+  BA55 00 00 00 00
 20+  BA59 1C 26 63 63  	defb	 28, 38, 99, 99, 99, 50, 28,  0 ; 0
 20+  BA5D 63 32 1C 00
 21+  BA61 0C 1C 0C 0C  	defb	   12, 28, 12, 12, 12, 12, 63,0 ; 1
 21+  BA65 0C 0C 3F 00
 22+  BA69 3E 63 07 1E  	defb	  62, 99,  7, 30, 60, 96,127, 0 ; 2
 22+  BA6D 3C 60 7F 00
 23+  BA71 3F 06 0C 1E  	defb	  63,  6, 12, 30,  3, 51, 30, 0 ; 3
 23+  BA75 03 33 1E 00
 24+  BA79 0E 1E 36 66  	defb	  14, 30, 54,102,127,  6,  6, 0 ; 4
 24+  BA7D 7F 06 06 00
 25+  BA81 7E 40 7E 03  	defb	 126, 64,126,  3,  3, 99, 62, 0 ; 5
 25+  BA85 03 63 3E 00
 26+  BA89 1E 30 60 7E  	defb	 30, 48, 96,126, 99, 99, 62,  0 ; 6
 26+  BA8D 63 63 3E 00
 27+  BA91 7F 63 06 0C  	defb	  127, 99,  6, 12, 24, 24, 24,0 ; 7
 27+  BA95 18 18 18 00
 28+  BA99 3C 62 72 3C  	defb	  60, 98,114, 60, 79, 67,62,0   ; 8
 28+  BA9D 4F 43 3E 00
 29+  BAA1 3E 63 63 3F  	defb	  62, 99, 99, 63,  3,  6, 60, 0 ; 9
 29+  BAA5 03 06 3C 00
 30+  BAA9 00 00 18 18  	defb	  0,  0, 24, 24,  0,  24,24,  0 ; :
 30+  BAAD 00 18 18 00
 31+  BAB1 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ;
 31+  BAB5 00 00 00 00
 32+  BAB9 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; <
 32+  BABD 00 00 00 00
 33+  BAC1 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; =
 33+  BAC5 00 00 00 00
 34+  BAC9 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; >
 34+  BACD 00 00 00 00
 35+  BAD1 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ?
 35+  BAD5 00 00 00 00
 36+  BAD9              	; end 2
 37+  BAD9 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; @
 37+  BADD 00 00 00 00
 38+  BAE1 1C 36 63 63  	defb	  28, 54, 99, 99,127, 99, 99, 0 ; A
 38+  BAE5 7F 63 63 00
 39+  BAE9 7E 63 63 7E  	defb	  126, 99, 99,126, 99, 99,126,0 ; B
 39+  BAED 63 63 7E 00
 40+  BAF1 1E 33 60 60  	defb	  30, 51, 96, 96, 96, 51, 30, 0 ; C
 40+  BAF5 60 33 1E 00
 41+  BAF9 7C 66 63 63  	defb	  124,102, 99, 99, 99,102,124,0 ; D
 41+  BAFD 63 66 7C 00
 42+  BB01 7F 60 60 7E  	defb	  127, 96, 96,126, 96, 96,127,0 ; E
 42+  BB05 60 60 7F 00
 43+  BB09 7F 60 60 7E  	defb	  127, 96, 96,126, 96, 96, 96,0 ; F
 43+  BB0D 60 60 60 00
 44+  BB11 1F 30 60 67  	defb	  31, 48, 96,103, 99, 51, 31, 0 ; G
 44+  BB15 63 33 1F 00
 45+  BB19 63 63 63 7F  	defb	  99, 99, 99,127, 99, 99, 99, 0 ; H
 45+  BB1D 63 63 63 00
 46+  BB21 3F 0C 0C 0C  	defb	  63, 12, 12, 12, 12, 12, 63, 0 ; I
 46+  BB25 0C 0C 3F 00
 47+  BB29 03 03 03 03  	defb	  3,  3,  3,  3,  3, 99, 62,  0 ; J
 47+  BB2D 03 63 3E 00
 48+  BB31 63 66 6C 78  	defb	  99,102,108,120,124,110,103, 0 ; K
 48+  BB35 7C 6E 67 00
 49+  BB39 30 30 30 30  	defb	  48, 48, 48, 48, 48, 48, 63, 0 ; L
 49+  BB3D 30 30 3F 00
 50+  BB41 63 77 7F 7F  	defb	  99,119,127,127,107, 99, 99, 0 ; M
 50+  BB45 6B 63 63 00
 51+  BB49 63 73 7B 7F  	defb	  99,115,123,127,111,103, 99, 0 ; N
 51+  BB4D 6F 67 63 00
 52+  BB51 3E 63 63 63  	defb	  62, 99, 99, 99, 99, 99, 62, 0 ; O
 52+  BB55 63 63 3E 00
 53+  BB59 7E 61 61 61  	defb	  126, 97, 97, 97,126, 96, 96,0 ; P
 53+  BB5D 7E 60 60 00
 54+  BB61 3E 63 63 63  	defb	  62, 99, 99, 99,111,102, 61, 0 ; Q
 54+  BB65 6F 66 3D 00
 55+  BB69 7E 63 63 67  	defb	  126, 99, 99,103,124,110,103,0 ; R
 55+  BB6D 7C 6E 67 00
 56+  BB71 3C 66 60 3E  	defb	  60,102, 96, 62,  3, 99, 62, 0 ; S
 56+  BB75 03 63 3E 00
 57+  BB79 7E 18 18 18  	defb	  126, 24, 24, 24, 24, 24, 24,0 ; T
 57+  BB7D 18 18 18 00
 58+  BB81 63 63 63 63  	defb	  99, 99, 99, 99, 99, 99, 62, 0 ; U
 58+  BB85 63 63 3E 00
 59+  BB89 63 63 63 77  	defb	  99, 99, 99,119, 62, 28,  8, 0 ; V
 59+  BB8D 3E 1C 08 00
 60+  BB91 63 63 6B 7F  	defb	  99, 99,107,127,127, 54, 34, 0 ; W
 60+  BB95 7F 36 22 00
 61+  BB99 63 77 3E 1C  	defb	  99,119, 62, 28, 62,119, 99, 0 ; X
 61+  BB9D 3E 77 63 00
 62+  BBA1 33 33 12 1E  	defb	  51, 51, 18, 30, 12, 12, 12, 0 ; Y
 62+  BBA5 0C 0C 0C 00
 63+  BBA9 7F 07 0E 1C  	defb	  127,  7, 14, 28, 56,112,127,0 ; Z
 63+  BBAD 38 70 7F 00
 64+  BBB1 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; [
 64+  BBB5 00 00 00 00
 65+  BBB9 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; \
 65+  BBBD 00 00 00 00
 66+  BBC1 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ]
 66+  BBC5 00 00 00 00
 67+  BBC9 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; ^
 67+  BBCD 00 00 00 00
 68+  BBD1 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; _
 68+  BBD5 00 00 00 00
 69+  BBD9              	; end 3
 70+  BBD9 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0 ; 
 70+  BBDD 00 00 00 00
 71+  BBE1 1C 36 63 63  	defb	  28, 54, 99, 99,127, 99, 99, 0 ; A
 71+  BBE5 7F 63 63 00
 72+  BBE9 7E 63 63 7E  	defb	  126, 99, 99,126, 99, 99,126,0 ; B
 72+  BBED 63 63 7E 00
 73+  BBF1 1E 33 60 60  	defb	  30, 51, 96, 96, 96, 51, 30, 0 ; C
 73+  BBF5 60 33 1E 00
 74+  BBF9 7C 66 63 63  	defb	  124,102, 99, 99, 99,102,124,0 ; D
 74+  BBFD 63 66 7C 00
 75+  BC01 7F 60 60 7E  	defb	  127, 96, 96,126, 96, 96,127,0 ; E
 75+  BC05 60 60 7F 00
 76+  BC09 7F 60 60 7E  	defb	  127, 96, 96,126, 96, 96, 96,0 ; F
 76+  BC0D 60 60 60 00
 77+  BC11 1F 30 60 67  	defb	  31, 48, 96,103, 99, 51, 31, 0 ; G
 77+  BC15 63 33 1F 00
 78+  BC19 63 63 63 7F  	defb	  99, 99, 99,127, 99, 99, 99, 0 ; H
 78+  BC1D 63 63 63 00
 79+  BC21 3F 0C 0C 0C  	defb	  63, 12, 12, 12, 12, 12, 63, 0 ; I
 79+  BC25 0C 0C 3F 00
 80+  BC29 03 03 03 03  	defb	  3,  3,  3,  3,  3, 99, 62,  0 ; J
 80+  BC2D 03 63 3E 00
 81+  BC31 63 66 6C 78  	defb	  99,102,108,120,124,110,103, 0 ; K
 81+  BC35 7C 6E 67 00
 82+  BC39 30 30 30 30  	defb	  48, 48, 48, 48, 48, 48, 63, 0 ; L
 82+  BC3D 30 30 3F 00
 83+  BC41 63 77 7F 7F  	defb	  99,119,127,127,107, 99, 99, 0 ; M
 83+  BC45 6B 63 63 00
 84+  BC49 63 73 7B 7F  	defb	  99,115,123,127,111,103, 99, 0 ; N
 84+  BC4D 6F 67 63 00
 85+  BC51 3E 63 63 63  	defb	  62, 99, 99, 99, 99, 99, 62, 0 ; O
 85+  BC55 63 63 3E 00
 86+  BC59 7E 61 61 61  	defb	  126, 97, 97, 97,126, 96, 96,0 ; P
 86+  BC5D 7E 60 60 00
 87+  BC61 3E 63 63 63  	defb	  62, 99, 99, 99,111,102, 61, 0 ; Q
 87+  BC65 6F 66 3D 00
 88+  BC69 7E 63 63 67  	defb	  126, 99, 99,103,124,110,103,0 ; R
 88+  BC6D 7C 6E 67 00
 89+  BC71 3C 66 60 3E  	defb	  60,102, 96, 62,  3, 99, 62, 0 ; S
 89+  BC75 03 63 3E 00
 90+  BC79 7E 18 18 18  	defb	  126, 24, 24, 24, 24, 24, 24,0 ; T
 90+  BC7D 18 18 18 00
 91+  BC81 63 63 63 63  	defb	  99, 99, 99, 99, 99, 99, 62, 0 ; U
 91+  BC85 63 63 3E 00
 92+  BC89 63 63 63 77  	defb	  99, 99, 99,119, 62, 28,  8, 0 ; V
 92+  BC8D 3E 1C 08 00
 93+  BC91 63 63 6B 7F  	defb	  99, 99,107,127,127, 54, 34, 0 ; W
 93+  BC95 7F 36 22 00
 94+  BC99 63 77 3E 1C  	defb	  99,119, 62, 28, 62,119, 99, 0 ; X
 94+  BC9D 3E 77 63 00
 95+  BCA1 33 33 12 1E  	defb	  51, 51, 18, 30, 12, 12, 12, 0 ; Y
 95+  BCA5 0C 0C 0C 00
 96+  BCA9 7F 07 0E 1C  	defb	  127,  7, 14, 28, 56,112,127,0 ; Z
 96+  BCAD 38 70 7F 00
 97+  BCB1 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0
 97+  BCB5 00 00 00 00
 98+  BCB9 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0
 98+  BCBD 00 00 00 00
 99+  BCC1 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0
 99+  BCC5 00 00 00 00
100+  BCC9 00 00 00 00  	defb	  0,  0,  0,  0,  0,  0,  0,  0
100+  BCCD 00 00 00 00
101+  BCD1 3C 42 99 A1  	defb	  60, 66,153,161,161,153, 66, 60 ; 	
101+  BCD5 A1 99 42 3C
# file closed: graphics/font.asm
151   BCD9                  include "graphics\graphics.asm"
# file opened: graphics/graphics.asm
  1+  BCD9              ; Tiles graphics.
  2+  BCD9              sprites:
  3+  BCD9 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 0, space
  3+  BCDD 00 00 00 00
  4+  BCE1 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 1, cyan block
  4+  BCE5 FF FF FF FF
  5+  BCE9 01 03 07 0F      defb	  1,  3,  7, 15, 31, 63,127,255   ; 2, slope left
  5+  BCED 1F 3F 7F FF
  6+  BCF1 80 C0 E0 F0      defb    128,192,224,240,248,252,254,255   ; 3, slope right
  6+  BCF5 F8 FC FE FF
  7+  BCF9 55 AA 55 AA      defb    85,170, 85,170, 85,170, 85,170    ; 4, dirt
  7+  BCFD 55 AA 55 AA
  8+  BD01 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 5, sky block
  8+  BD05 00 00 00 00
  9+  BD09 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 6, slime block
  9+  BD0D 00 00 00 00
 10+  BD11 00 00 00 00      defb    0  ,0  ,  0,  0,  0,  0,  0,  0   ; 7, for reuse
 10+  BD15 00 00 00 00
 11+  BD19 18 2C 4E 8F      defb    24, 44, 78,143,241,114, 52,  24    ; 8, diamond
 11+  BD1D F1 72 34 18
 12+  BD21 3C 7E FF 7F      defb    60,126,255,127,254,254,255,126    ; 9, rock
 12+  BD25 FE FE FF 7E
 13+  BD29 7E FF 7F 7F  	defb	126,255,127,127,254,255,126, 60    ; 10, rock 2
 13+  BD2D FE FF 7E 3C
 14+  BD31 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,255,255   ; 11, sky block, pixel trapdoor
 14+  BD35 00 00 FF FF
 15+  BD39 99 DB 7E 24  	defb    153,219,126, 36,255, 66, 36, 24   ; 12, missile
 15+  BD3D FF 42 24 18
 16+  BD41 00 00 00 00      defb    0  ,  0,  0,  0,  0,  0,  0,  0   ; 13, sky block, tank background
 16+  BD45 00 00 00 00
 17+  BD49 00 00 00 00  	defb    0,  0,  0,  0,  0, 60, 90, 52     ; 14, gem
 17+  BD4D 00 3C 5A 34
 18+  BD51 FD FE FD FE  	defb	253,254,253,254,253,254,253,254   ; 15, damaged mountain
 18+  BD55 FD FE FD FE
 19+  BD59 F4 F8 F4 F8  	defb	244,248,244,248,244,248,244,248   ; 16, damaged mountain 2
 19+  BD5D F4 F8 F4 F8
 20+  BD61 D0 E0 D0 E0  	defb	208,224,208,224,208,224,208,224   ; 17, damaged mountain 3
 20+  BD65 D0 E0 D0 E0
 21+  BD69 40 80 40 80  	defb	 64,128, 64,128, 64,128, 64,128   ; 18, damaged mountain 4
 21+  BD6D 40 80 40 80
 22+  BD71 00 00 00 ED  	defb	0,  0,  0,237,237,  0,  0,  0	  ; 19, tank missile
 22+  BD75 ED 00 00 00
 23+  BD79 99 DB 7E 24  	defb    153,219,126, 36,255,126, 60, 24   ; 20, missile active
 23+  BD7D FF 7E 3C 18
 24+  BD81 FF FF 00 00      defb	255,255,  0,  0,  0,  0,  0,  0	  ; 21, the pit 1
 24+  BD85 00 00 00 00
 25+  BD89 FC FC 00 00  	defb	252,252,  0,  0,  0,  0,  0,  0	  ; 22, the pit 2
 25+  BD8D 00 00 00 00
 26+  BD91 F0 F0 00 00  	defb	240,240,  0,  0,  0,  0,  0,  0	  ; 23, the pit 3
 26+  BD95 00 00 00 00
 27+  BD99 C0 C0 00 00  	defb	192,192,  0,  0,  0,  0,  0,  0	  ; 24, the pit 4
 27+  BD9D 00 00 00 00
 28+  BDA1 00 00 00 00  	defb	0,0,  0,  0,  0,  0,  0,  0	  	  ; 25, the pit 5
 28+  BDA5 00 00 00 00
 29+  BDA9 FF FF FF FF      defb    255,255,255,255,255,255,255,255   ; 26, slime block, green on green
 29+  BDAD FF FF FF FF
 30+  BDB1 00 00 00 66  	defb    0,  0,  0,102,  0,  0,  0,  0     ; 27, bullet
 30+  BDB5 00 00 00 00
 31+  BDB9
 32+  BDB9
 33+  BDB9              sprite_attrs:
 34+  BDB9 46               defb    070 ; 0, space
 35+  BDBA 4D               defb    077 ; 1, cyan block
 36+  BDBB 4D               defb    077 ; 2, slope left
 37+  BDBC 4D               defb    077 ; 3, slope right
 38+  BDBD 46               defb    070 ; 4, dirt
 39+  BDBE 4E               defb    078 ; 5, sky
 40+  BDBF 66               defb    102 ; 6, slime
 41+  BDC0 42               defb    066 ; 7, trapdoor
 42+  BDC1 46               defb    070 ; 8, diamond
 43+  BDC2 42               defb    066 ; 9, rock
 44+  BDC3 42               defb    066 ; 10, rock 2
 45+  BDC4 49           	defb    073 ; 11, sky, trapdoor
 46+  BDC5 43           	defb    067 ; 12, missile
 47+  BDC6 4A               defb    074 ; 13, sky, red ink (tank)
 48+  BDC7 46               defb    070 ; 14, gem
 49+  BDC8 4D               defb    077 ; 15, damaged mountain
 50+  BDC9 4D               defb    077 ; 16, damaged mountain 2
 51+  BDCA 4D               defb    077 ; 17, damaged mountain 3
 52+  BDCB 4D               defb    077 ; 18, damaged mountain 4
 53+  BDCC 00           	defb 	000 ; 19, tank missile (not used
 54+  BDCD 43           	defb    067 ; 20, missile active
 55+  BDCE 42           	defb	066	; 21, the pit 1
 56+  BDCF 42           	defb	066	; 22, the pit 2
 57+  BDD0 42           	defb	066	; 23, the pit 3
 58+  BDD1 42           	defb	066	; 24, the pit 4
 59+  BDD2 42           	defb	066	; 25, the pit 5
 60+  BDD3 64           	defb    100 ; 26, slime, green on green
 61+  BDD4 46           	defb 	070 ; 27, bullet
 62+  BDD5
 63+  BDD5
 64+  BDD5              player_sprite:
 65+  BDD5 10 39 92 FC  	defb	 16, 57,146,252, 56, 61,195,128 ; 0 up/down 1
 65+  BDD9 38 3D C3 80
 66+  BDDD 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 28, 22, 50 ; 1 left 1
 66+  BDE1 3C 1C 16 32
 67+  BDE5 10 38 10 3F      defb   	 16, 56, 16, 63, 60, 56,104, 76 ; 2 right 1
 67+  BDE9 3C 38 68 4C
 68+  BDED 08 9C 49 3F  	defb	  8,156, 73, 63, 28,188,195,  1 ; 3 up/down 2
 68+  BDF1 1C BC C3 01
 69+  BDF5 08 1C 08 FC  	defb	  8, 28,  8,252, 60, 60,100, 12; 4 left 2
 69+  BDF9 3C 3C 64 0C
 70+  BDFD 10 38 10 3F  	defb	 16, 56, 16, 63, 60, 60, 38, 48 ; 5 right 2
 70+  BE01 3C 3C 26 30
 71+  BE05 54 28 10 12  	defb	 84, 40, 16, 18, 30, 92,253, 95 ; 6 shoot up
 71+  BE09 1E 5C FD 5F
 72+  BE0D 02 87 42 BF  	defb	 2,135, 66,191, 79,143, 25,  3  ; 7 shoot left
 72+  BE11 4F 8F 19 03
 73+  BE15 40 E1 42 FD  	defb	 64,225, 66,253,242,241,152,192 ; 8 shoot right
 73+  BE19 F2 F1 98 C0
 74+  BE1D FA BF 3A 78  	defb	 250,191, 58,120, 72,  8, 20, 42 ; 9 shoot down
 74+  BE21 48 08 14 2A
 75+  BE25 92 BA 94 78  	defb 	 146,186,148,120, 56,120, 68,195 ; 10 crushed 1
 75+  BE29 38 78 44 C3
 76+  BE2D 49 5D 29 1E  	defb	  73, 93, 41, 30, 28, 30, 34,195 ; 11 crushed 2
 76+  BE31 1C 1E 22 C3
 77+  BE35 72 57 72 67  	defb	114, 87,114,103,111, 69,225,155  ; 12 fight 1
 77+  BE39 6F 45 E1 9B
 78+  BE3D 4E EA 4E E6  	defb	 78,234, 78,230,246,162,135,217  ; 13 fight 2
 78+  BE41 F6 A2 87 D9
 79+  BE45
 80+  BE45              ;
 81+  BE45              ; First 4 top half, next 4 bottom 1, next 4 bottom 2
 82+  BE45              ;
 83+  BE45              ship_sprite:
 84+  BE45 00 00 00 01  	defb	  0,  0,  0,  1,  3, 31,127,255
 84+  BE49 03 1F 7F FF
 85+  BE4D 1F 01 7F FF  	defb	 31,  1,127,255,255,255,255,255
 85+  BE51 FF FF FF FF
 86+  BE55 F8 80 FE FF  	defb	248,128,254,255,255,255,255,255
 86+  BE59 FF FF FF FF
 87+  BE5D 00 00 00 80  	defb	  0,  0,  0,128,192,248,254,255
 87+  BE61 C0 F8 FE FF
 88+  BE65 B3 B3 7F 1F  	defb	179,179,127, 31,  3,  3,  2,  7
 88+  BE69 03 03 02 07
 89+  BE6D 8F 8F FF FF  	defb	143,143,255,255,255, 15,  7,131
 89+  BE71 FF 0F 07 83
 90+  BE75 0F 0F FF FF  	defb	 15, 15,255,255,255, 16, 32,193
 90+  BE79 FF 10 20 C1
 91+  BE7D 19 19 FE F8  	defb	 25, 25,254,248,192,192, 64,224
 91+  BE81 C0 C0 40 E0
 92+  BE85 98 98 7F 1F  	defb	152,152,127, 31,  3,  3,  2,  7
 92+  BE89 03 03 02 07
 93+  BE8D F0 F0 FF FF  	defb	240,240,255,255,255,  8,  4,131
 93+  BE91 FF 08 04 83
 94+  BE95 F1 F1 FF FF  	defb	241,241,255,255,255,240,224,193
 94+  BE99 FF F0 E0 C1
 95+  BE9D CD CD FE F8  	defb	205,205,254,248,192,192, 64,224
 95+  BEA1 C0 C0 40 E0
 96+  BEA5
 97+  BEA5              ;
 98+  BEA5              ;  First 8 frames are tank, last frame is the gun barrel
 99+  BEA5              ;
100+  BEA5              tank_sprite:
101+  BEA5 00 00 00 7F  	defb	  0,  0,  0,127,127,  0,  0,  0
101+  BEA9 7F 00 00 00
102+  BEAD 01 03 FE FC  	defb	  1,  3,254,252,254,255,127, 64
102+  BEB1 FE FF 7F 40
103+  BEB5 FF FF 03 F9  	defb	255,255,  3,249,  3,255,255,  1
103+  BEB9 03 FF FF 01
104+  BEBD 00 00 C0 E0  	defb	  0,  0,192,224,224,192,  0,  0
104+  BEC1 E0 C0 00 00
105+  BEC5 3F 7F E1 FB  	defb	 63,127,225,251,247,225,127, 63
105+  BEC9 F7 E1 7F 3F
106+  BECD FF FF 16 52  	defb	255,255, 22, 82, 84, 22,255,255
106+  BED1 54 16 FF FF
107+  BED5 FF FF A8 A9  	defb	255,255,168,169,155,168,255,255
107+  BED9 9B A8 FF FF
108+  BEDD FC FE 8F AF  	defb	252,254,143,175,159,175,254,252
108+  BEE1 9F AF FE FC
109+  BEE5 00 00 00 1F  	defb	  0,  0,  0, 31, 31,  0,  0,  0 ; +64
109+  BEE9 1F 00 00 00
110+  BEED
111+  BEED              monster_sprite:
112+  BEED 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
112+  BEF1 0B D0 16 68
113+  BEF5 19 98 17 E8  	defb	 25,152, 23,232, 53,172,127,254
113+  BEF9 35 AC 7F FE
114+  BEFD FE 7F EC 37  	defb	254,127,236, 55,143,241,143,241
114+  BF01 8F F1 8F F1
115+  BF05 08 10 08 10  	defb	  8, 16,  8, 16, 24, 24,  0,  0		; frame 1
115+  BF09 18 18 00 00
116+  BF0D 02 40 06 60  	defb	  2, 64,  6, 96, 11,208, 22,104
116+  BF11 0B D0 16 68
117+  BF15 19 98 17 E8  	defb	 25,152, 23,232,245,175,255,255
117+  BF19 F5 AF FF FF
118+  BF1D BC 3D 0E 70  	defb	188, 61, 14,112, 15,240, 15,240
118+  BF21 0F F0 0F F0
119+  BF25 10 08 30 0C  	defb	 16,  8, 48, 12,  0,  0,  0,  0		; frame 2
119+  BF29 00 00 00 00
120+  BF2D
121+  BF2D              robot_sprite:
122+  BF2D 0E 0A CE 3E  	defb	 14, 10,206, 62,206, 18, 34,102		; left 1
122+  BF31 CE 12 22 66
123+  BF35 0E 0A 4E FE  	defb	 14, 10, 78,254, 78, 18, 36,108		; 2
123+  BF39 4E 12 24 6C
124+  BF3D 0E 0A 4E FE  	defb	 14, 10, 78,254, 78, 50, 99,  3		; 3
124+  BF41 4E 32 63 03
125+  BF45 0E 0A CE 3E  	defb	 14, 10,206, 62,206, 10,  9, 27		; 4
125+  BF49 CE 0A 09 1B
126+  BF4D 70 50 73 7C  	defb	112, 80,115,124,115, 72, 68,102		; right 1
126+  BF51 73 48 44 66
127+  BF55 70 50 72 7F  	defb	112, 80,114,127,114, 72, 36, 54		; 2
127+  BF59 72 48 24 36
128+  BF5D 70 50 72 7F  	defb	112, 80,114,127,114, 76,198,192		; 3
128+  BF61 72 4C C6 C0
129+  BF65 70 50 73 7C  	defb	112, 80,115,124,115, 80,144,216		; 4
129+  BF69 73 50 90 D8
130+  BF6D 38 A9 BA 7C  	defb     56,169,186,124, 56, 42, 38, 96     ; dead 1
130+  BF71 38 2A 26 60
131+  BF75 1C 95 5D 3E  	defb	 28,149, 93, 62, 28, 84,100,  6		; dead 2
131+  BF79 1C 54 64 06
132+  BF7D
# file closed: graphics/graphics.asm
152   BF7D
153   BF7D                  include "game\control.asm"
# file opened: game/control.asm
  1+  BF7D              ;
  2+  BF7D              ; Check the preferred input method then move
  3+  BF7D              ;
  4+  BF7D              control_input:
  5+  BF7D 3A 82 C5         ld a,(player+11)    ; first, check if player is dying
  6+  BF80 FE 04            cp 4                ; is the player falling
  7+  BF82 CC 4C C0         call z, control_fall
  8+  BF85 FE 05            cp 5                ; is the player fighting
  9+  BF87 CC 39 C0         call z, control_fight
 10+  BF8A 3A 82 C5         ld a,(player+11)    ; first, check if player is dying
 11+  BF8D FE 00            cp 0
 12+  BF8F C0               ret nz               ; if so, can't move
 13+  BF90 3A 7C C5         ld a,(player+5)      ; next, check if the player has pixels left to move
 14+  BF93 FE 00            cp 0
 15+  BF95 CA 9C BF         jp z, control_input0
 16+  BF98 CD 2A C1         call control_automove
 17+  BF9B C9               ret
 18+  BF9C              control_input0:
 19+  BF9C 3A 7D C5         ld a,(player+6)      ; next, check if the player is digging
 20+  BF9F FE 00            cp 0
 21+  BFA1 CA A8 BF         jp z, control_input1
 22+  BFA4 CD 68 C0         call control_dig
 23+  BFA7 C9               ret
 24+  BFA8              control_input1:
 25+  BFA8 3A 8B C4         ld a,(game_control)
 26+  BFAB FE 00            cp 0                ; is this keyboard
 27+  BFAD C2 B4 BF         jp nz,control_input2
 28+  BFB0 CD B8 BF         call control_keyboard
 29+  BFB3 C9               ret
 30+  BFB4              control_input2:
 31+  BFB4                  ; do joystick
 32+  BFB4 CD FE BF         call control_joystick
 33+  BFB7 C9               ret
 34+  BFB8
 35+  BFB8              ;
 36+  BFB8              ; Check the keyboard
 37+  BFB8              ;
 38+  BFB8              control_keyboard:
 39+  BFB8 01 FE FB         ld bc,64510         ; port for keyboard row q-t.
 40+  BFBB ED 78            in a,(c)            ; read keyboard.
 41+  BFBD 47               ld b,a              ; store result in b register.
 42+  BFBE CB 18            rr b                ; check outermost key (q).
 43+  BFC0 D2 EA BF         jp nc,control_keyboard1
 44+  BFC3 01 FE FD         ld bc,65022         ; port for keyboard row a-f.
 45+  BFC6 ED 78            in a,(c)            ; read keyboard.
 46+  BFC8 47               ld b,a              ; store result in b register.
 47+  BFC9 CB 18            rr b                ; check outermost key (a).
 48+  BFCB D2 EE BF         jp nc,control_keyboard2
 49+  BFCE 01 FE DF         ld bc,57342         ; port for keyboard row y-p.
 50+  BFD1 ED 78            in a,(c)            ; read keyboard.
 51+  BFD3 47               ld b,a              ; store result in b register.
 52+  BFD4 CB 18            rr b                ; check outermost key (p).
 53+  BFD6 D2 F2 BF         jp nc,control_keyboard3
 54+  BFD9 CB 18            rr b                ; check next key.
 55+  BFDB D2 F6 BF         jp nc,control_keyboard4
 56+  BFDE 01 FE 7F         ld bc,32766         ; port for keyboard row b-space.
 57+  BFE1 ED 78            in a,(c)            ; read keyboard.
 58+  BFE3 47               ld b,a              ; store result in b register.
 59+  BFE4 CB 18            rr b                ; check outermost key (space).
 60+  BFE6 D2 FA BF         jp nc,control_keyboard5
 61+  BFE9 C9               ret
 62+  BFEA              control_keyboard1:
 63+  BFEA CD 73 C1         call control_pl_moveup         ; player up.
 64+  BFED C9               ret
 65+  BFEE              control_keyboard2:
 66+  BFEE CD A0 C1         call control_pl_movedown       ; player down.
 67+  BFF1 C9               ret
 68+  BFF2              control_keyboard3:
 69+  BFF2 CD FC C1         call control_pl_moveright       ; player left.
 70+  BFF5 C9               ret
 71+  BFF6              control_keyboard4:
 72+  BFF6 CD CC C1         call control_pl_moveleft       ; player right.
 73+  BFF9 C9               ret
 74+  BFFA              control_keyboard5:
 75+  BFFA CD 2A C2         call control_pl_fire       ; player fire.
 76+  BFFD C9               ret
 77+  BFFE
 78+  BFFE              ;
 79+  BFFE              ; Check the joystick
 80+  BFFE              ;
 81+  BFFE              control_joystick:
 82+  BFFE 01 1F 00         ld bc,31                        ; Kempston joystick port.
 83+  C001 ED 78            in a,(c)                        ; read input.
 84+  C003 E6 02            and 2                           ; check "left" bit.
 85+  C005 C2 2D C0         jp nz,control_joystick3       ; move left.
 86+  C008 ED 78            in a,(c)                        ; read input.
 87+  C00A E6 01            and 1                           ; test "right" bit.
 88+  C00C C2 31 C0         jp nz,control_joystick4       ; move right.
 89+  C00F ED 78            in a,(c)                        ; read input.
 90+  C011 E6 08            and 8                           ; check "up" bit.
 91+  C013 C2 25 C0         jp nz,control_joystick1       ; move up.
 92+  C016 ED 78            in a,(c)                        ; read input.
 93+  C018 E6 04            and 4                           ; check "down" bit.
 94+  C01A C2 29 C0         jp nz,control_joystick2       ; move down.
 95+  C01D ED 78            in a,(c)                        ; read input.
 96+  C01F E6 10            and 16                          ; try the fire bit.
 97+  C021 C2 35 C0         jp nz,control_joystick5       ; fire pressed.
 98+  C024 C9               ret
 99+  C025              control_joystick1:
100+  C025 CD 73 C1         call control_pl_moveup         ; player up.
101+  C028 C9               ret
102+  C029              control_joystick2:
103+  C029 CD A0 C1         call control_pl_movedown       ; player down.
104+  C02C C9               ret
105+  C02D              control_joystick3:
106+  C02D CD CC C1         call control_pl_moveleft       ; player left.
107+  C030 C9               ret
108+  C031              control_joystick4:
109+  C031 CD FC C1         call control_pl_moveright       ; player right.
110+  C034 C9               ret
111+  C035              control_joystick5:
112+  C035 CD 2A C2         call control_pl_fire
113+  C038 C9               ret
114+  C039
115+  C039              ;
116+  C039              ; Fights the player - just flips the players anim frame
117+  C039              ;
118+  C039              control_fight:
119+  C039 3A 7A C5         ld a,(player+3)             ; load the frame
120+  C03C FE 0C            cp 12                       ; flip between 12 and 13
121+  C03E CA 46 C0         jp z,control_fight0
122+  C041 3E 0C            ld a,12
123+  C043 C3 48 C0         jp control_fight1
124+  C046              control_fight0:
125+  C046 3E 0D            ld a,13
126+  C048              control_fight1:
127+  C048 32 7A C5         ld (player+3),a           ; save back
128+  C04B C9               ret
129+  C04C
130+  C04C              ;
131+  C04C              ; Falls the player
132+  C04C              ;
133+  C04C              control_fall:
134+  C04C ED 4B 77 C5      ld bc,(player)              ; get coords
135+  C050 0C               inc c
136+  C051 ED 43 77 C5      ld (player),bc
137+  C055 3A 7A C5         ld a,(player+3)             ; load the frame
138+  C058 FE 03            cp 3                       ; flip between 3 and 0
139+  C05A C2 62 C0         jp nz, control_fall0
140+  C05D 3E 00            ld a,0
141+  C05F C3 64 C0         jp control_fall1
142+  C062              control_fall0:
143+  C062 3E 03            ld a,3
144+  C064              control_fall1:
145+  C064 32 7A C5         ld (player+3),a           ; save back
146+  C067 C9               ret
147+  C068
148+  C068              ;
149+  C068              ; Performs a dig if the counter has reset, otherwise, messes with the graphics
150+  C068              ;
151+  C068              control_dig:
152+  C068 ED 4B 77 C5      ld bc,(player)      ; load the current coords into bc
153+  C06C C5               push bc
154+  C06D 3A 79 C5         ld a,(player+2)     ; get the direction
155+  C070 FE 01            cp 1                ; left
156+  C072 CA 8A C0         jp z,control_dig0
157+  C075 FE 02            cp 2                ; right
158+  C077 CA 9F C0         jp z,control_dig1
159+  C07A FE 03            cp 3                ; down
160+  C07C CA C3 C0         jp z,control_dig5
161+  C07F FE 00            cp 0                ; up
162+  C081 CA B3 C0         jp z,control_dig4
163+  C084 21 7D C5         ld hl,player+6
164+  C087 36 00            ld (hl),0           ; turn off digging
165+  C089 C9               ret                 ; return
166+  C08A              control_dig0:           ; going left
167+  C08A CD 01 AC         call sprites_scadd  ; get the current coord
168+  C08D 62 6B            ld hl,de
169+  C08F 2B               dec hl              ; move one left
170+  C090 C1               pop bc              ; get the coords back, subtract 8 from horiz, 8 from vert, store (will be coords of space above dug dirt)
171+  C091 78               ld a,b
172+  C092 06 08            ld b,8
173+  C094 90               sub b
174+  C095 47               ld b,a
175+  C096 79               ld a,c
176+  C097 0E 08            ld c,8
177+  C099 91               sub c
178+  C09A 4F               ld c,a
179+  C09B C5               push bc
180+  C09C C3 CC C0         jp control_dig2
181+  C09F              control_dig1:
182+  C09F CD 01 AC         call sprites_scadd  ; get the current coord
183+  C0A2 62 6B            ld hl,de
184+  C0A4 23               inc hl              ; move one right
185+  C0A5 C1               pop bc              ; get the coords back, add 8 to horiz, subtract 8 from vert store (will be coords of space above dug dirt)
186+  C0A6 3E 08            ld a,8
187+  C0A8 80               add a,b
188+  C0A9 47               ld b,a
189+  C0AA 79               ld a,c
190+  C0AB 0E 08            ld c,8
191+  C0AD 91               sub c
192+  C0AE 4F               ld c,a
193+  C0AF C5               push bc
194+  C0B0 C3 CC C0         jp control_dig2
195+  C0B3              control_dig4:
196+  C0B3 CD 01 AC         call sprites_scadd  ; get the current coord
197+  C0B6 62 6B            ld hl,de
198+  C0B8 11 20 00         ld de,32
199+  C0BB ED 52            sbc hl,de             ; move one up
200+  C0BD C1               pop bc              ; get the coords back, 1 from vert, store, then we'll sub 1 from c for each row later
201+  C0BE 0D               dec c
202+  C0BF C5               push bc
203+  C0C0 C3 E4 C0         jp control_dig6
204+  C0C3              control_dig5:
205+  C0C3 CD 01 AC         call sprites_scadd  ; get the current coord
206+  C0C6 62 6B            ld hl,de
207+  C0C8 24               inc h              ; move one down
208+  C0C9                                     ; not bothered about working out bc here, since rock will never fall if digging down
209+  C0C9 C3 CC C0         jp control_dig2
210+  C0CC              ; Normal (not up) digging
211+  C0CC              control_dig2:
212+  C0CC 3A 7F C5         ld a,(player+8)     ; get the number of rows we need to overwrite
213+  C0CF 47               ld b,a              ; rows to copy over
214+  C0D0 E5               push hl             ; store the memory location of the first row for later
215+  C0D1              control_dig3:
216+  C0D1 CD 13 C1         call control_getpixelrow
217+  C0D4 77               ld (hl),a           ; load contents into row
218+  C0D5 11 20 00         ld de,32
219+  C0D8 19               add hl,de           ; move to next row
220+  C0D9 10 F6            djnz control_dig3
221+  C0DB E1               pop hl              ; get the original memory location back
222+  C0DC 11 20 00         ld de,32
223+  C0DF ED 52            sbc hl,de           ; move to above row, ready for checking for rock
224+  C0E1 C3 FA C0         jp control_dig10
225+  C0E4              ; Special case for going up
226+  C0E4              control_dig6:
227+  C0E4 3A 7F C5         ld a,(player+8)     ; get the number of rows we need to overwrite
228+  C0E7 47               ld b,a              ; rows to copy over
229+  C0E8              control_dig7:
230+  C0E8 CD 13 C1         call control_getpixelrow
231+  C0EB              control_dig12:
232+  C0EB 77               ld (hl),a           ; load empty into row
233+  C0EC 11 20 00         ld de,32
234+  C0EF ED 52            sbc hl,de           ; move up to next row
235+  C0F1 0D               dec c               ; decrease c to track rows
236+  C0F2 10 F4            djnz control_dig7
237+  C0F4 79               ld a,c
238+  C0F5 D6 07            sub 7
239+  C0F7 C1               pop bc
240+  C0F8 4F               ld c,a
241+  C0F9 C5               push bc             ; store the decreased c coord
242+  C0FA              control_dig10:
243+  C0FA DD 21 7E C5      ld ix,player+7
244+  C0FE DD 7E 00         ld a,(ix)     ; get the dig frame number
245+  C101 3D               dec a
246+  C102 DD 77 00         ld (ix),a
247+  C105                  ; call the check for rocks above the removed dirt
248+  C105 DD 21 7D C5      ld ix,player+6
249+  C109 DD 7E 00         ld a,(ix)     ; get the dig state
250+  C10C FE 00            cp 0
251+  C10E C1               pop bc
252+  C10F CC 0A CB         call z, rocks_checkforfalling ; make the check if we're no longer digging
253+  C112 C9               ret
254+  C113
255+  C113              ;
256+  C113              ; Gets a modified pixel row to overwrite dirt - if this is the last dig, overwrite with nothing, otherwise xor to flip the dirt
257+  C113              ; Inputs:
258+  C113              ; hl - memory of pixel row
259+  C113              ; Outputs:
260+  C113              ; a - modified row to write
261+  C113              ;
262+  C113              control_getpixelrow:
263+  C113 3A 7E C5         ld a,(player+7)     ; get the dig frame number
264+  C116 FE 00            cp 0                ; is this the last dig
265+  C118 CA 1F C1         jp z,control_getpixelrow1
266+  C11B 7E               ld a,(hl)           ; if not, xor with 255 to flip it
267+  C11C EE FF            xor 255
268+  C11E C9               ret
269+  C11F              control_getpixelrow1:
270+  C11F DD 21 7D C5      ld ix,player+6
271+  C123 DD 36 00 00      ld (ix),0           ; turn off digging
272+  C127 3E 00            ld a,0              ; if it is, load with empty
273+  C129 C9               ret
274+  C12A
275+  C12A              ;
276+  C12A              ; Auto move the player until pixels is zero
277+  C12A              ;
278+  C12A              control_automove:
279+  C12A 5F               ld e,a              ; store the number of pixels left to move in e
280+  C12B ED 4B 77 C5      ld bc,(player)      ; load the current coords into bc
281+  C12F 21 79 C5         ld hl,player+2      ; get the direction
282+  C132 7E               ld a,(hl)
283+  C133 FE 03            cp 3                ; down
284+  C135 CA 49 C1         jp z,control_automove3  ; don't need to do anything
285+  C138 FE 00            cp 0                ; going up
286+  C13A CA 55 C1         jp z,control_automove2
287+  C13D FE 01            cp 1                ; going left?
288+  C13F CA 61 C1         jp z,control_automove0
289+  C142 78               ld a,b
290+  C143 3C               inc a               ; if we're going right, increment a twice for two pixels
291+  C144 3C               inc a
292+  C145 47               ld b,a
293+  C146 C3 65 C1         jp control_automove1
294+  C149              control_automove3:
295+  C149 79               ld a,c
296+  C14A 3C               inc a
297+  C14B 3C               inc a               ; if we're going down, increment twice
298+  C14C 4F               ld c,a
299+  C14D FE 90            cp 144
300+  C14F CC 43 C2         call z, control_scroll_down
301+  C152 C3 65 C1         jp control_automove1
302+  C155              control_automove2:
303+  C155 79               ld a,c
304+  C156 3D               dec a
305+  C157 3D               dec a               ; if we're going up, decrement twice
306+  C158 4F               ld c,a
307+  C159 FE 60            cp 96
308+  C15B CC 50 C2         call z, control_scroll_up
309+  C15E C3 65 C1         jp control_automove1
310+  C161              control_automove0:
311+  C161 78               ld a,b
312+  C162 3D               dec a               ; if we're going left, decrement a twice
313+  C163 3D               dec a
314+  C164 47               ld b,a
315+  C165              control_automove1:
316+  C165 ED 43 77 C5      ld (player),bc      ; and back to player
317+  C169 7B               ld a,e              ; now get the pixel count back
318+  C16A 3D               dec a               ; decrease by one
319+  C16B 21 7C C5         ld hl,player+5
320+  C16E 77               ld (hl),a           ; copy back
321+  C16F CD 82 C7         call player_justmoved
322+  C172 C9               ret
323+  C173
324+  C173              ;
325+  C173              ; Moves the player up
326+  C173              ;
327+  C173              control_pl_moveup:
328+  C173 C5               push bc
329+  C174 ED 4B 77 C5      ld bc,(player)          ; get the current coords, b horiz, c vert
330+  C178 79               ld a,c                  ; load c into the acc
331+  C179 FE 18            cp 24
332+  C17B CA 99 C1         jp z,control_pl_moveup0 ; are we at the edge of the screen
333+  C17E FE 60            cp 96
334+  C180 CC 50 C2         call z, control_scroll_up
335+  C183 CD FA C3         call movement_checkcanmove_up ; check we can move up, e will be 1 if we can
336+  C186 F5               push af
337+  C187 7B               ld a,e                  ; put e in a
338+  C188 FE 00            cp 0
339+  C18A CA 98 C1         jp z,control_pl_moveup1 ; don't move if we can't
340+  C18D F1               pop af
341+  C18E D6 01            sub 1                   ; subtract 1
342+  C190                  ;sub 1                   ; subtract 1
343+  C190 4F               ld c,a                  ; load back to c
344+  C191 ED 43 77 C5      ld (player),bc          ; load back to player
345+  C195 C3 99 C1         jp control_pl_moveup0
346+  C198              control_pl_moveup1:
347+  C198 F1               pop af                  ; restore af if needed
348+  C199              control_pl_moveup0:
349+  C199 3E 00            ld a,0
350+  C19B 32 79 C5         ld (player+2),a        ; set direction to up
351+  C19E C1               pop bc
352+  C19F C9               ret
353+  C1A0              ;
354+  C1A0              ; Moves the player down
355+  C1A0              ;
356+  C1A0              control_pl_movedown:
357+  C1A0 C5               push bc
358+  C1A1 ED 4B 77 C5      ld bc,(player)          ; get the current coords, b horiz, c vert
359+  C1A5 79               ld a,c                  ; load c into the acc
360+  C1A6 FE E0            cp 224
361+  C1A8 CA C5 C1         jp z,control_pl_movedown0 ; are we at the edge of the screen
362+  C1AB FE 80            cp 128
363+  C1AD CC 43 C2         call z, control_scroll_down
364+  C1B0 CD CE C3         call movement_checkcanmove_down ; check we can move down, e will be 1 if we can
365+  C1B3 F5               push af
366+  C1B4 7B               ld a,e                  ; put e in a
367+  C1B5 FE 00            cp 0
368+  C1B7 CA C4 C1         jp z,control_pl_movedown1 ; don't move if we can't
369+  C1BA F1               pop af
370+  C1BB 3C               inc a                   ; add 1
371+  C1BC                  ;inc a                   ; add 1
372+  C1BC 4F               ld c,a                  ; load back to c
373+  C1BD ED 43 77 C5      ld (player),bc          ; load back to player
374+  C1C1 C3 C5 C1         jp control_pl_movedown0
375+  C1C4              control_pl_movedown1:
376+  C1C4 F1               pop af                  ; restore af if needed
377+  C1C5              control_pl_movedown0:
378+  C1C5 3E 03            ld a,3
379+  C1C7 32 79 C5         ld (player+2),a        ; set direction to down
380+  C1CA C1               pop bc
381+  C1CB C9               ret
382+  C1CC              ;
383+  C1CC              ; Moves the player left
384+  C1CC              ;
385+  C1CC              control_pl_moveleft:
386+  C1CC C5               push bc
387+  C1CD ED 4B 77 C5      ld bc,(player)          ; get the current coords, b horiz, c vert
388+  C1D1 78               ld a,b                  ; load b into the acc
389+  C1D2 FE 10            cp 16
390+  C1D4 CA F5 C1         jp z,control_pl_moveleft0 ; are we at the edge of the screen
391+  C1D7 CD 59 C4         call movement_checkcanmove_left ; check we can move down, e will be 1 if we can
392+  C1DA F5               push af
393+  C1DB 7B               ld a,e                  ; put e in a
394+  C1DC FE 00            cp 0
395+  C1DE CA F4 C1         jp z,control_pl_moveleft1 ; don't move if we can't
396+  C1E1 21 7C C5         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
397+  C1E4 3E 03            ld a,3
398+  C1E6 77               ld (hl),a
399+  C1E7 F1               pop af
400+  C1E8 D6 01            sub 1                    ; subtract 2
401+  C1EA D6 01            sub 1
402+  C1EC 47               ld b,a                  ; load back to c
403+  C1ED ED 43 77 C5      ld (player),bc          ; load back to player
404+  C1F1 C3 F5 C1         jp control_pl_moveleft0
405+  C1F4              control_pl_moveleft1:
406+  C1F4 F1               pop af
407+  C1F5              control_pl_moveleft0:
408+  C1F5 3E 01            ld a,1
409+  C1F7 32 79 C5         ld (player+2),a        ; set direction to left
410+  C1FA C1               pop bc
411+  C1FB C9               ret
412+  C1FC              ;
413+  C1FC              ; Moves the player right
414+  C1FC              ;
415+  C1FC              control_pl_moveright:
416+  C1FC C5               push bc
417+  C1FD ED 4B 77 C5      ld bc,(player)          ; get the current coords, b horiz, c vert
418+  C201 78               ld a,b                  ; load b into the acc
419+  C202 FE F0            cp 240
420+  C204 CA 23 C2         jp z,control_pl_moveright0 ; are we at the edge of the screen
421+  C207 CD 2D C4         call movement_checkcanmove_right ; check we can move down, e will be 1 if we can
422+  C20A F5               push af
423+  C20B 7B               ld a,e                  ; put e in a
424+  C20C FE 00            cp 0
425+  C20E CA 22 C2         jp z,control_pl_moveright1 ; don't move if we can't
426+  C211 21 7C C5         ld hl,player+5          ; need to store the amount of pixels still left to move in the player status
427+  C214 3E 03            ld a,3
428+  C216 77               ld (hl),a
429+  C217 F1               pop af
430+  C218 3C               inc a                   ; add 2
431+  C219 3C               inc a
432+  C21A 47               ld b,a                  ; load back to b
433+  C21B ED 43 77 C5      ld (player),bc          ; load back to player
434+  C21F C3 23 C2         jp control_pl_moveright0
435+  C222              control_pl_moveright1:
436+  C222 F1               pop af                  ; restore af if needed
437+  C223              control_pl_moveright0:
438+  C223 3E 02            ld a,2
439+  C225 32 79 C5         ld (player+2),a        ; set direction to right
440+  C228 C1               pop bc
441+  C229 C9               ret
442+  C22A
443+  C22A              ;
444+  C22A              ; Player fires
445+  C22A              ;
446+  C22A              control_pl_fire:
447+  C22A 3A 79 C5         ld a,(player+2)         ; get player direction
448+  C22D FE 00            cp 0
449+  C22F C8               ret z
450+  C230 FE 03            cp 3
451+  C232 C8               ret z                   ; if up or down, don't fire
452+  C233 3A 29 D6         ld a,(bullet_state+3)       ; get the state
453+  C236 FE 01            cp 1
454+  C238 C8               ret z                   ; if currently firing, don't fire
455+  C239 CD 2A D6         call bullet_init        ; initialise the bullet
456+  C23C CD 3F D6         call bullet_shoot       ; shoot the bullet
457+  C23F CD 7B B1         call sound_laser
458+  C242 C9               ret
459+  C243
460+  C243              ;
461+  C243              ; Scrolls the screen down
462+  C243              ;
463+  C243              control_scroll_down:
464+  C243 F5               push af
465+  C244 3E 08            ld a,8
466+  C246 32 DA A8         ld (screen_offset),a
467+  C249 F1               pop af
468+  C24A 21 27 A7         ld hl,buffer_updateall
469+  C24D 36 01            ld (hl),1         ; flag as screen needing update
470+  C24F C9               ret
471+  C250
472+  C250              ;
473+  C250              ; Scrolls the screen up
474+  C250              ;
475+  C250              control_scroll_up:
476+  C250 F5               push af
477+  C251 3E 00            ld a,0
478+  C253 32 DA A8         ld (screen_offset),a
479+  C256 F1               pop af
480+  C257 21 27 A7         ld hl,buffer_updateall
481+  C25A 36 01            ld (hl),1         ; flag as screen needing update
482+  C25C C9               ret
483+  C25D
484+  C25D
485+  C25D
486+  C25D
# file closed: game/control.asm
154   C25D                  include "game\movement.asm"
# file opened: game/movement.asm
  1+  C25D              ;
  2+  C25D              ; The number of frames to dig for
  3+  C25D              ;
  4+  C25D              movement_numberdigframes:
  5+  C25D 0A               defb 10
  6+  C25E
  7+  C25E              ;
  8+  C25E              ; Checks the contents of a cell are empty - ie, all pixel rows are zero
  9+  C25E              ; Inputs:
 10+  C25E              ; hl - memory location of top pixel row
 11+  C25E              ; bc - screen coords, b horiz, c vert
 12+  C25E              ; Outputs:
 13+  C25E              ; e - 0 if not empty, 1 if empty
 14+  C25E              ;
 15+  C25E              movement_spaceisempty:
 16+  C25E C5               push bc
 17+  C25F E5               push hl
 18+  C260 CD 88 C2         call movement_spaceisgem        ; check if space is a gem
 19+  C263 E1               pop hl
 20+  C264 C1               pop bc
 21+  C265 7B               ld a,e
 22+  C266 FE 01            cp 1
 23+  C268 C8               ret z                           ; if e is 1, space is a gem so can move here, return
 24+  C269 3E 08            ld a,8                          ; 8 rows to check
 25+  C26B              movement_spaceisempty0:
 26+  C26B 08               ex af,af'                       ; store the loop counter
 27+  C26C 7E               ld a,(hl)                       ; get current pixel row
 28+  C26D FE 00            cp 0
 29+  C26F C2 83 C2         jp nz, movement_spaceisempty1    ; row is not empty, can't move here
 30+  C272 79               ld a,c                          ; load the vertical coord
 31+  C273 3C               inc a                           ; next row down
 32+  C274 11 20 00         ld de,32
 33+  C277 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
 34+  C278 4F               ld c,a                          ; copy vert coord back to c
 35+  C279 08               ex af,af'                       ; get loop counter back
 36+  C27A 3D               dec a                           ; decrease loop counter
 37+  C27B C2 6B C2         jp nz, movement_spaceisempty0
 38+  C27E 16 00            ld d,0
 39+  C280 1E 01            ld e,1                          ; got to end, so space is empty
 40+  C282 C9               ret
 41+  C283              movement_spaceisempty1:
 42+  C283 16 00            ld d,0
 43+  C285 1E 00            ld e,0                          ; returning false, ie space not empty
 44+  C287 C9               ret
 45+  C288
 46+  C288              ;
 47+  C288              ; Check if a space contains a gem
 48+  C288              ; Inputs:
 49+  C288              ; bc - screen coords
 50+  C288              ; Outputs:
 51+  C288              ; e = 1 if gem
 52+  C288              movement_spaceisgem:
 53+  C288 CD 3A AA         call screen_getcharcoordsfromscreencoords   ; get the char coords we're checking into bc
 54+  C28B 21 54 B8         ld hl,level_diamonds           ; check diamonds first
 55+  C28E              movement_spaceisgem0:
 56+  C28E 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 57+  C292 7B               ld a,e                          ; check for end of data
 58+  C293 FE FF            cp 255
 59+  C295 CA B0 C2         jp z,movement_spaceisgem1       ; if yes, done with diamonds
 60+  C298 23               inc hl
 61+  C299 23               inc hl                          ; move to state
 62+  C29A 7E               ld a,(hl)
 63+  C29B 23               inc hl
 64+  C29C 23               inc hl
 65+  C29D 23               inc hl                          ; get to next
 66+  C29E FE 01            cp 1                            ; check if collected
 67+  C2A0 CA 8E C2         jp z,movement_spaceisgem0       ; if yes, move to next diamond
 68+  C2A3 7B               ld a,e                          ; load e again
 69+  C2A4 B9               cp c                            ; otherwise, compare c with e
 70+  C2A5 C2 8E C2         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 71+  C2A8 7A               ld a,d                          ; get d coord
 72+  C2A9 B8               cp b                            ; compare b with d
 73+  C2AA C2 8E C2         jp nz,movement_spaceisgem0      ; if different, move to next diamond
 74+  C2AD 1E 01            ld e,1                          ; otherwise, exit with e = 1
 75+  C2AF C9               ret
 76+  C2B0              movement_spaceisgem1:
 77+  C2B0 21 64 B8         ld hl,level_gems              ; check gems
 78+  C2B3              movement_spaceisgem2:
 79+  C2B3 5E 23 56 2B      ld de,(hl)                      ; get gem coords into de
 80+  C2B7 7B               ld a,e                          ; check for end of data
 81+  C2B8 FE FF            cp 255
 82+  C2BA CA D5 C2         jp z,movement_spaceisgem3       ; if yes, done with gems
 83+  C2BD 23               inc hl
 84+  C2BE 23               inc hl                          ; move to state
 85+  C2BF 7E               ld a,(hl)
 86+  C2C0 23               inc hl
 87+  C2C1 23               inc hl
 88+  C2C2 23               inc hl                          ; get to next
 89+  C2C3 FE 01            cp 1                            ; check if collected
 90+  C2C5 CA B3 C2         jp z,movement_spaceisgem2       ; if yes, move to next diamond
 91+  C2C8 7B               ld a,e                          ; load e again
 92+  C2C9 B9               cp c                            ; otherwise, compare c with e
 93+  C2CA C2 B3 C2         jp nz,movement_spaceisgem2      ; if different, move to next gem
 94+  C2CD 7A               ld a,d                          ; get d coord
 95+  C2CE B8               cp b                            ; compare b with d
 96+  C2CF C2 B3 C2         jp nz,movement_spaceisgem2      ; if different, move to next gem
 97+  C2D2 1E 01            ld e,1                          ; otherwise, exit with e = 1
 98+  C2D4 C9               ret
 99+  C2D5              movement_spaceisgem3:
100+  C2D5 1E 00            ld e,0                          ; nothing found, return e = 0
101+  C2D7 C9               ret
102+  C2D8
103+  C2D8              ;
104+  C2D8              ; Checks the line of a cell below is empty - ie, first pixel rows is zero
105+  C2D8              ; Inputs:
106+  C2D8              ; hl - memory location of top pixel row
107+  C2D8              ; bc - screen coords, b horiz, c vert
108+  C2D8              ; Outputs:
109+  C2D8              ; e - 0 if not empty, 1 if empty
110+  C2D8              ;
111+  C2D8              movement_linebelowisempty:
112+  C2D8 C5               push bc
113+  C2D9 E5               push hl
114+  C2DA CD 88 C2         call movement_spaceisgem        ; check if space is a gem
115+  C2DD E1               pop hl
116+  C2DE C1               pop bc
117+  C2DF 7B               ld a,e
118+  C2E0 FE 01            cp 1
119+  C2E2 C8               ret z                           ; if e is 1, space is a gem so can move here, return
120+  C2E3 7E               ld a,(hl)                       ; get current pixel row
121+  C2E4 FE 00            cp 0
122+  C2E6 C2 EE C2         jp nz, movement_linebelowisempty1    ; row is not empty, can't move here
123+  C2E9 16 00            ld d,0
124+  C2EB 1E 01            ld e,1                          ; got to end, so space is empty
125+  C2ED C9               ret
126+  C2EE              movement_linebelowisempty1:
127+  C2EE 16 00            ld d,0
128+  C2F0 1E 00            ld e,0                          ; returning false, ie space not empty
129+  C2F2 C9               ret
130+  C2F3
131+  C2F3              ;
132+  C2F3              ; Checks the line of a cell above is empty - ie, last pixel rows are zero
133+  C2F3              ; Inputs:
134+  C2F3              ; hl - memory location of top pixel row
135+  C2F3              ; bc - screen coords, b horiz, c vert
136+  C2F3              ; Outputs:
137+  C2F3              ; e - 0 if not empty, 1 if empty
138+  C2F3              ;
139+  C2F3              movement_lineaboveisempty:
140+  C2F3 C5               push bc
141+  C2F4 E5               push hl
142+  C2F5 CD 88 C2         call movement_spaceisgem        ; check if space is a gem
143+  C2F8 E1               pop hl
144+  C2F9 C1               pop bc
145+  C2FA 7B               ld a,e
146+  C2FB FE 01            cp 1
147+  C2FD C8               ret z
148+  C2FE 7E               ld a,(hl)                       ; get current pixel row
149+  C2FF FE 00            cp 0
150+  C301 C2 09 C3         jp nz, movement_lineaboveisempty1    ; row is not empty, can't move here
151+  C304 16 00            ld d,0
152+  C306 1E 01            ld e,1                          ; got to end, so space is empty
153+  C308 C9               ret
154+  C309              movement_lineaboveisempty1:
155+  C309 16 00            ld d,0
156+  C30B 1E 00            ld e,0                          ; returning false, ie space not empty
157+  C30D C9               ret
158+  C30E
159+  C30E              ;
160+  C30E              ; Checks the contents of a cell are diggable - ie, all pixel rows are dirt or empty
161+  C30E              ; Inputs:
162+  C30E              ; hl - memory location of top pixel row
163+  C30E              ; bc - screen coords, b horiz, c vert
164+  C30E              ; Outputs:
165+  C30E              ; none - puts player into digging mode
166+  C30E              ;
167+  C30E              movement_spaceisdiggable:
168+  C30E 3E 08            ld a,8                          ; 8 rows to check
169+  C310              movement_spaceisdiggable0:
170+  C310 08               ex af,af'                       ; store the loop counter
171+  C311 7E               ld a,(hl)                       ; get current pixel row
172+  C312 FE 00            cp 0
173+  C314 CA 24 C3         jp z, movement_spaceisdiggable2  ; row is empty, can dig here
174+  C317 FE 55            cp 85
175+  C319 CA 24 C3         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
176+  C31C FE AA            cp 170
177+  C31E CA 24 C3         jp z, movement_spaceisdiggable2  ; row is dirt, can dig here
178+  C321 C3 41 C3         jp movement_spaceisdiggable1     ; otherwise, stop checking
179+  C324              movement_spaceisdiggable2:
180+  C324 79               ld a,c                          ; load the vertical coord
181+  C325 3C               inc a                           ; next row down
182+  C326 11 20 00         ld de,32
183+  C329 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
184+  C32A 4F               ld c,a                          ; copy vert coord back to c
185+  C32B 08               ex af,af'                       ; get loop counter back
186+  C32C 3D               dec a                           ; decrease loop counter
187+  C32D C2 10 C3         jp nz, movement_spaceisdiggable0
188+  C330 21 7D C5         ld hl,player+6
189+  C333 36 01            ld (hl),1                       ; set the player into digging mode
190+  C335 23               inc hl
191+  C336 3A 5D C2         ld a,(movement_numberdigframes)
192+  C339 77               ld (hl),a                       ; set the number of frame to dig for
193+  C33A 23               inc hl
194+  C33B 36 08            ld (hl),8                       ; set the number of pixels to dig
195+  C33D CD 21 B1         call sound_dig
196+  C340 C9               ret
197+  C341              movement_spaceisdiggable1:
198+  C341 21 7D C5         ld hl,player+6
199+  C344 36 00            ld (hl),0                       ; set the player out of digging mode
200+  C346 C9               ret
201+  C347
202+  C347              ;
203+  C347              ; Checks the contents of a cell below are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
204+  C347              ; Inputs:
205+  C347              ; hl - memory location of top pixel row
206+  C347              ; bc - screen coords, b horiz, c vert
207+  C347              ; Outputs:
208+  C347              ; none - puts player into digging mode
209+  C347              ;
210+  C347              movement_spacebelowisdiggable:
211+  C347 7E               ld a,(hl)                       ; get first pixel row
212+  C348 FE 55            cp 85
213+  C34A CA 55 C3         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
214+  C34D FE AA            cp 170
215+  C34F CA 55 C3         jp z, movement_spacebelowisdiggable3  ; row is dirt, can dig here
216+  C352 C3 41 C3         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
217+  C355              movement_spacebelowisdiggable3:
218+  C355 3E 08            ld a,8                          ; rows to check
219+  C357 1E 00            ld e,0                          ; count of rows to dig
220+  C359              movement_spacebelowisdiggable0:
221+  C359 08               ex af,af'                       ; store the loop counter
222+  C35A 7E               ld a,(hl)                       ; get current pixel row
223+  C35B FE 55            cp 85
224+  C35D CA 68 C3         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
225+  C360 FE AA            cp 170
226+  C362 CA 68 C3         jp z, movement_spacebelowisdiggable4  ; row is dirt, can dig here
227+  C365 C3 77 C3         jp movement_spacebelowisdiggable5     ; don't count this row and stop counting
228+  C368              movement_spacebelowisdiggable4:
229+  C368 1C               inc e                           ; inc count of rows to dig
230+  C369              movement_spacebelowisdiggable2:
231+  C369 79               ld a,c                          ; load the vertical coord
232+  C36A 3C               inc a                           ; next row down
233+  C36B D5               push de                         ; need e for later
234+  C36C 11 20 00         ld de,32
235+  C36F 19               add hl,de                       ; otherwise, just go one down for hl, which means add 32, because of course
236+  C370 4F               ld c,a                          ; copy vert coord back to c
237+  C371 D1               pop de                          ; get e back
238+  C372 08               ex af,af'                       ; get loop counter back
239+  C373 3D               dec a                           ; incease loop counter
240+  C374 C2 59 C3         jp nz, movement_spacebelowisdiggable0
241+  C377              movement_spacebelowisdiggable5:
242+  C377 21 7D C5         ld hl,player+6
243+  C37A 36 01            ld (hl),1                       ; set the player into digging mode
244+  C37C 23               inc hl
245+  C37D 3A 5D C2         ld a,(movement_numberdigframes)
246+  C380 77               ld (hl),a                       ; set the number of frame to dig for
247+  C381 23               inc hl
248+  C382 73               ld (hl),e                       ; set the number of pixels to dig
249+  C383 C9               ret
250+  C384              movement_spacebelowisdiggable1:
251+  C384 21 7D C5         ld hl,player+6
252+  C387 36 00            ld (hl),0                       ; set the player out of digging mode
253+  C389 C9               ret
254+  C38A
255+  C38A              ;
256+  C38A              ; Checks the contents of a cell above are diggable - ie, at least one pixel row has dirt. If the first one isn't dirt, stop
257+  C38A              ; Inputs:
258+  C38A              ; hl - memory location of top pixel row
259+  C38A              ; bc - screen coords, b horiz, c vert
260+  C38A              ; Outputs:
261+  C38A              ; none - puts player into digging mode
262+  C38A              ;
263+  C38A              movement_spaceaboveisdiggable:
264+  C38A 7E               ld a,(hl)                       ; get first pixel row
265+  C38B FE 55            cp 85
266+  C38D CA 98 C3         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
267+  C390 FE AA            cp 170
268+  C392 CA 98 C3         jp z, movement_spaceaboveisdiggable3  ; row is dirt, can dig here
269+  C395 C3 41 C3         jp movement_spaceisdiggable1    ; the first row is not dirt, so don't bother checking the rest, can't dig
270+  C398              movement_spaceaboveisdiggable3:
271+  C398 3E 08            ld a,8                          ; rows to check
272+  C39A 1E 00            ld e,0                          ; count of rows to dig
273+  C39C              movement_spaceaboveisdiggable0:
274+  C39C 08               ex af,af'                       ; store the loop counter
275+  C39D 7E               ld a,(hl)                       ; get current pixel row
276+  C39E FE 55            cp 85
277+  C3A0 CA AB C3         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
278+  C3A3 FE AA            cp 170
279+  C3A5 CA AB C3         jp z, movement_spaceaboveisdiggable4  ; row is dirt, can dig here
280+  C3A8 C3 BB C3         jp movement_spaceaboveisdiggable5     ; don't count this row and stop counting
281+  C3AB              movement_spaceaboveisdiggable4:
282+  C3AB 1C               inc e                           ; inc count of rows to dig
283+  C3AC              movement_spaceaboveisdiggable2:
284+  C3AC 79               ld a,c                          ; load the vertical coord
285+  C3AD 3D               dec a                           ; next row up
286+  C3AE D5               push de                         ; need e for later
287+  C3AF 11 20 00         ld de,32
288+  C3B2 ED 52            sbc hl,de                       ; otherwise, just go one up for hl, which means sub 32, because of course
289+  C3B4 4F               ld c,a                          ; copy vert coord back to c
290+  C3B5 D1               pop de                          ; get e back
291+  C3B6 08               ex af,af'                       ; get loop counter back
292+  C3B7 3D               dec a                           ; incease loop counter
293+  C3B8 C2 9C C3         jp nz, movement_spaceaboveisdiggable0
294+  C3BB              movement_spaceaboveisdiggable5:
295+  C3BB 21 7D C5         ld hl,player+6
296+  C3BE 36 01            ld (hl),1                       ; set the player into digging mode
297+  C3C0 23               inc hl
298+  C3C1 3A 5D C2         ld a,(movement_numberdigframes)
299+  C3C4 77               ld (hl),a                       ; set the number of frame to dig for
300+  C3C5 23               inc hl
301+  C3C6 73               ld (hl),e                       ; set the number of pixels to dig
302+  C3C7 C9               ret
303+  C3C8              movement_spaceaboveisdiggable1:
304+  C3C8 21 7D C5         ld hl,player+6
305+  C3CB 36 00            ld (hl),0                       ; set the player out of digging mode
306+  C3CD C9               ret
307+  C3CE
308+  C3CE              ;
309+  C3CE              ; Checks if the player can move down
310+  C3CE              ; Inputs:
311+  C3CE              ; bc - player coords, b horiz, c vert
312+  C3CE              ; Outputs:
313+  C3CE              ; de - 1 can move
314+  C3CE              movement_checkcanmove_down:
315+  C3CE F5               push af
316+  C3CF C5               push bc
317+  C3D0 CD 01 AC         call sprites_scadd              ; get the memory location of cell into de
318+  C3D3 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
319+  C3D5 24               inc h                       ; memory location of cell beneath now in hl
320+  C3D6 3E 08            ld a,8                       ; look below
321+  C3D8 81               add c
322+  C3D9 4F               ld c,a
323+  C3DA CD D8 C2         call movement_linebelowisempty       ; check space is empty
324+  C3DD 7B               ld a,e                          ; check space empty flag
325+  C3DE FE 00            cp 0
326+  C3E0 CA E9 C3         jp z, movement_checkcanmove_down1 ; can't move
327+  C3E3 CD 82 C7         call player_justmoved
328+  C3E6 C1               pop bc
329+  C3E7 F1               pop af
330+  C3E8 C9               ret
331+  C3E9              movement_checkcanmove_down1:
332+  C3E9 C1               pop bc
333+  C3EA CD 01 AC         call sprites_scadd              ; get the memory location of cell into de
334+  C3ED 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
335+  C3EF 24               inc h
336+  C3F0 C5               push bc
337+  C3F1 CD 47 C3         call movement_spacebelowisdiggable    ; can't move here, but can we dig
338+  C3F4 11 00 00         ld de,0
339+  C3F7 C1               pop bc
340+  C3F8 F1               pop af
341+  C3F9 C9               ret
342+  C3FA
343+  C3FA              ;
344+  C3FA              ; Checks if the player can move up
345+  C3FA              ; Inputs:
346+  C3FA              ; bc - player coords, b horiz, c vert
347+  C3FA              ; Outputs:
348+  C3FA              ; de - 1 can move
349+  C3FA              movement_checkcanmove_up:
350+  C3FA F5               push af
351+  C3FB C5               push bc
352+  C3FC CD 01 AC         call sprites_scadd              ; get the memory location of cell into de
353+  C3FF 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
354+  C401 11 20 00         ld de,32
355+  C404 ED 52            sbc hl,de                       ; memory location of line above now in hl
356+  C406 0D               dec c                           ; look above
357+  C407 CD F3 C2         call movement_lineaboveisempty       ; check space is empty
358+  C40A 7B               ld a,e                          ; check space empty flag
359+  C40B FE 00            cp 0
360+  C40D CA 18 C4         jp z, movement_checkcanmove_up1 ; can't move
361+  C410 1E 01            ld e,1
362+  C412 CD 82 C7         call player_justmoved
363+  C415 C1               pop bc
364+  C416 F1               pop af
365+  C417 C9               ret
366+  C418              movement_checkcanmove_up1:
367+  C418 C1               pop bc
368+  C419 CD 01 AC         call sprites_scadd              ; get the memory location of cell into de
369+  C41C 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
370+  C41E 11 20 00         ld de,32
371+  C421 ED 52            sbc hl,de                       ; memory location of line above now in hl
372+  C423 C5               push bc
373+  C424 CD 8A C3         call movement_spaceaboveisdiggable    ; can't move here, but can we dig
374+  C427 11 00 00         ld de,0
375+  C42A C1               pop bc
376+  C42B F1               pop af
377+  C42C C9               ret
378+  C42D
379+  C42D              ;
380+  C42D              ; Checks if the player can move right
381+  C42D              ; Inputs:
382+  C42D              ; bc - player coords, b horiz, c vert
383+  C42D              ; Outputs:
384+  C42D              ; de - 1 can move
385+  C42D              movement_checkcanmove_right:
386+  C42D F5               push af
387+  C42E C5               push bc
388+  C42F CD 01 AC         call sprites_scadd              ; get the memory location of cell into de
389+  C432 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
390+  C434 3E 08            ld a,8
391+  C436 80               add b                           ; move one cell right
392+  C437 47               ld b,a
393+  C438 23               inc hl                          ; memory location of cell to the right now in hl
394+  C439 CD 5E C2         call movement_spaceisempty       ; check space is empty
395+  C43C 7B               ld a,e                          ; check space empty flag
396+  C43D FE 00            cp 0
397+  C43F CA 48 C4         jp z, movement_checkcanmove_right1 ; can't move
398+  C442 CD 82 C7         call player_justmoved
399+  C445 C1               pop bc
400+  C446 F1               pop af
401+  C447 C9               ret
402+  C448              movement_checkcanmove_right1:
403+  C448 C1               pop bc
404+  C449 CD 01 AC         call sprites_scadd              ; get the memory location of cell into de
405+  C44C 62 6B            ld hl,de
406+  C44E 23               inc hl                          ; memory location of cell to the right now in hl
407+  C44F C5               push bc
408+  C450 CD 0E C3         call movement_spaceisdiggable    ; can't move here, but can we dig
409+  C453 11 00 00         ld de,0
410+  C456 C1               pop bc
411+  C457 F1               pop af
412+  C458 C9               ret
413+  C459
414+  C459              ;
415+  C459              ; Checks if the player can move left
416+  C459              ; Inputs:
417+  C459              ; bc - player coords, b horiz, c vert
418+  C459              ; Outputs:
419+  C459              ; de - 1 can move
420+  C459              movement_checkcanmove_left:
421+  C459 F5               push af
422+  C45A C5               push bc
423+  C45B CD 01 AC         call sprites_scadd              ; get the memory location of cell into de
424+  C45E 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
425+  C460 78               ld a,b
426+  C461 06 08            ld b,8
427+  C463 90               sub b                           ; move one cell left
428+  C464 47               ld b,a
429+  C465 2B               dec hl                          ; memory location of cell to the right now in hl
430+  C466 CD 5E C2         call movement_spaceisempty       ; check space is empty
431+  C469 7B               ld a,e                          ; check space empty flag
432+  C46A FE 00            cp 0
433+  C46C CA 75 C4         jp z, movement_checkcanmove_left1 ; can't move
434+  C46F CD 82 C7         call player_justmoved
435+  C472 C1               pop bc
436+  C473 F1               pop af
437+  C474 C9               ret
438+  C475              movement_checkcanmove_left1:
439+  C475 C1               pop bc
440+  C476 CD 01 AC         call sprites_scadd              ; get the memory location of cell into de
441+  C479 62 6B            ld hl,de
442+  C47B 2B               dec hl                          ; memory location of cell to the right now in hl
443+  C47C C5               push bc
444+  C47D CD 0E C3         call movement_spaceisdiggable    ; can't move here, but can we dig
445+  C480 11 00 00         ld de,0
446+  C483 C1               pop bc
447+  C484 F1               pop af
448+  C485 C9               ret
# file closed: game/movement.asm
155   C486                  include "game\game.asm"
# file opened: game/game.asm
  1+  C486              ;
  2+  C486              ; The current frame count, incremented each frame
  3+  C486              ;
  4+  C486              game_framenumber:
  5+  C486 00               defb    0
  6+  C487
  7+  C487              ;
  8+  C487              ; The number of players
  9+  C487              ;
 10+  C487              game_numberplayers:
 11+  C487 01               defb 1
 12+  C488
 13+  C488              ;
 14+  C488              ; The current player
 15+  C488              ;
 16+  C488              game_currentplayer:
 17+  C488 01               defb 1
 18+  C489
 19+  C489              ;
 20+  C489              ; The default number of lives
 21+  C489              ;
 22+  C489              game_numberlives:
 23+  C489 04               defb 4
 24+  C48A
 25+  C48A              ;
 26+  C48A              ; The current difficulty
 27+  C48A              ;
 28+  C48A              game_difficulty:
 29+  C48A 01               defb 1
 30+  C48B
 31+  C48B              ;
 32+  C48B              ; Control method: 0 for keyboard, 1 for kempston
 33+  C48B              ;
 34+  C48B              game_control:
 35+  C48B 00               defb 0
 36+  C48C
 37+  C48C              ;
 38+  C48C              ; The current rocks used
 39+  C48C              ;
 40+  C48C              game_current_rocks:
 41+  C48C 00 00            defb 0,0
 42+  C48E
 43+  C48E
 44+  C48E              game_tankdifficulty:
 45+  C48E 46 41 3C 37      defb 70,65,60,55,50,45,40,35,30,25,20,12
 45+  C492 32 2D 28 23
 45+  C496 1E 19 14 0C
 46+  C49A              game_pitdifficulty:
 47+  C49A 07 05 05 04      defb 7,5,5,4,4,4,2,2,2,2,2,2
 47+  C49E 04 04 02 02
 47+  C4A2 02 02 02 02
 48+  C4A6              game_robotdifficulty:
 49+  C4A6 06 04 04 04      defb 6,4,4,4,3,3,3,2,0,0,0,0
 49+  C4AA 03 03 03 02
 49+  C4AE 00 00 00 00
 50+  C4B2              game_digdifficulty:
 51+  C4B2 14 0E 0A 0A      defb 20,14,10,10,8,8,8,8,6,6,6,4
 51+  C4B6 08 08 08 08
 51+  C4BA 06 06 06 04
 52+  C4BE              game_rockdifficulty:
 53+  C4BE 28 1C 14 14      defb 40,28,20,20,16,16,16,16,16,16,16,16
 53+  C4C2 10 10 10 10
 53+  C4C6 10 10 10 10
 54+  C4CA              game_missiledifficulty:
 55+  C4CA 46 32 2D 2D      defb 70,50,45,45,40,35,35,30,30,25,25,20
 55+  C4CE 28 23 23 1E
 55+  C4D2 1E 19 19 14
 56+  C4D6              ;
 57+  C4D6              ; Moves to the next player
 58+  C4D6              ;
 59+  C4D6              game_changeplayer:
 60+  C4D6 3A 87 C4         ld a,(game_numberplayers)
 61+  C4D9 FE 01            cp 1
 62+  C4DB C8               ret z                       ; if just one player, no need to change
 63+  C4DC 3A 88 C4         ld a,(game_currentplayer)   ; get current player
 64+  C4DF 3D               dec a                       ; otherwise decrease by one
 65+  C4E0 EE 01            xor 1                       ; xor with one to flip
 66+  C4E2 3C               inc a                       ; increment
 67+  C4E3 21 88 C4         ld hl,game_currentplayer
 68+  C4E6 77               ld (hl),a                   ; store
 69+  C4E7 C9               ret
 70+  C4E8
 71+  C4E8              ;
 72+  C4E8              ; Sets the number of players at the start of the game
 73+  C4E8              ; Inputs:
 74+  C4E8              ; a - number of players
 75+  C4E8              game_setnumberofplayers:
 76+  C4E8 21 87 C4         ld hl,game_numberplayers
 77+  C4EB 77               ld (hl),a
 78+  C4EC
 79+  C4EC              ;
 80+  C4EC              ; Starts a game
 81+  C4EC              ;
 82+  C4EC              game_init:
 83+  C4EC 3E 01            ld a,1
 84+  C4EE 32 88 C4         ld (game_currentplayer),a
 85+  C4F1 C9               ret
 86+  C4F2
 87+  C4F2              ;
 88+  C4F2              ; Sets the current rock layout. Odd gets 1, even gets 2
 89+  C4F2              ;
 90+  C4F2              game_setcurrentrocks:
 91+  C4F2 3A 8A C4         ld a,(game_difficulty)
 92+  C4F5 E6 01            and 1
 93+  C4F7 FE 00            cp 0
 94+  C4F9 CA 07 C5         jp z,game_setcurrentrocks0
 95+  C4FC 11 F4 B5         ld de,level_rocks
 96+  C4FF 21 8C C4         ld hl,game_current_rocks
 97+  C502 73 23 72 2B      ld (hl),de
 98+  C506 C9               ret
 99+  C507              game_setcurrentrocks0:
100+  C507 11 F4 B6         ld de,level_rocks_alt
101+  C50A 21 8C C4         ld hl,game_current_rocks
102+  C50D 73 23 72 2B      ld (hl),de
103+  C511 C9               ret
104+  C512
105+  C512              ;
106+  C512              ; Increment frame number by 1
107+  C512              ;
108+  C512              game_incrementframe:
109+  C512 3A 86 C4         ld a,(game_framenumber)
110+  C515 FE FF            cp 255
111+  C517 C2 1C C5         jp nz,game_incrementframe0
112+  C51A 3E 00            ld a,0
113+  C51C              game_incrementframe0:
114+  C51C 3C               inc a
115+  C51D 32 86 C4         ld (game_framenumber),a
116+  C520 C9               ret
117+  C521
118+  C521              ;
119+  C521              ; Returns current frame
120+  C521              ; Outputs:
121+  C521              ; a - current frame
122+  C521              ;
123+  C521              game_getcurrentframe:
124+  C521 3A 86 C4         ld a,(game_framenumber)
125+  C524 C9               ret
126+  C525
127+  C525              ;
128+  C525              ; Resets current frame
129+  C525              ;
130+  C525              game_resetcurrentframe:
131+  C525 21 86 C4         ld hl,game_framenumber
132+  C528 36 00            ld (hl),0
133+  C52A C9               ret
134+  C52B
135+  C52B              ;
136+  C52B              ; Increases the current difficulty
137+  C52B              ;
138+  C52B              game_increasedifficulty:
139+  C52B 3A 8A C4         ld a,(game_difficulty)
140+  C52E 3C               inc a
141+  C52F 32 8A C4         ld (game_difficulty),a
142+  C532
143+  C532              ;
144+  C532              ; Sets the various difficulties
145+  C532              ;
146+  C532              game_setdifficulty:
147+  C532 3A 8A C4         ld a,(game_difficulty)
148+  C535 FE 0D            cp 13
149+  C537 C2 3C C5         jp nz,game_setdifficulty0
150+  C53A 3E 0C            ld a,12                         ; limit difficulty to twelve
151+  C53C              game_setdifficulty0:
152+  C53C 11 00 00         ld de,0
153+  C53F 5F               ld e,a                          ; keep the difficulty in de
154+  C540                  ; Set the tank difficulty
155+  C540 21 8E C4         ld hl,game_tankdifficulty
156+  C543 2B               dec hl
157+  C544 19               add hl,de                       ; add the difficulty
158+  C545 7E               ld a,(hl)                       ; get the value
159+  C546 32 02 C9         ld (tank_speed),a               ; set the tank speed
160+  C549                  ; Set the pit difficulty
161+  C549 21 9A C4         ld hl,game_pitdifficulty
162+  C54C 2B               dec hl
163+  C54D 19               add hl,de                       ; add the difficulty
164+  C54E 7E               ld a,(hl)                       ; get the value
165+  C54F 32 BA D0         ld (thepit_speed),a               ; set the pit speed
166+  C552                  ; Set the robot difficulty
167+  C552 21 A6 C4         ld hl,game_robotdifficulty
168+  C555 2B               dec hl
169+  C556 19               add hl,de                       ; add the difficulty
170+  C557 7E               ld a,(hl)                       ; get the value
171+  C558 32 98 D2         ld (robots_robotspeed),a        ; set the robot speed
172+  C55B                  ; Set the dig difficulty
173+  C55B 21 B2 C4         ld hl,game_digdifficulty
174+  C55E 2B               dec hl
175+  C55F 19               add hl,de                       ; add the difficulty
176+  C560 7E               ld a,(hl)                       ; get the value
177+  C561 32 5D C2         ld (movement_numberdigframes),a ; set the dig frames
178+  C564                  ; Set the rock difficulty
179+  C564 21 BE C4         ld hl,game_rockdifficulty
180+  C567 2B               dec hl
181+  C568 19               add hl,de                       ; add the difficulty
182+  C569 7E               ld a,(hl)                       ; get the value
183+  C56A 32 07 CB         ld (rocks_numberofframestowobble),a ; set the wobble frames
184+  C56D                  ; Set the missile difficulty
185+  C56D 21 CA C4         ld hl,game_missiledifficulty
186+  C570 2B               dec hl
187+  C571 19               add hl,de                       ; add the difficulty
188+  C572 7E               ld a,(hl)                       ; get the value
189+  C573 32 F6 CE         ld (missiles_speed),a           ; set the missile difficulty
190+  C576 C9               ret
# file closed: game/game.asm
156   C577                  include "game\player.asm"
# file opened: game/player.asm
  1+  C577              ;
  2+  C577              ;   Data for current player
  3+  C577              ;
  4+  C577              player:
  5+  C577 00 00            defb    0,0                 ; horiz,vert (+0,+1)
  6+  C579 02 00 01         defb    2,0,1               ; dir (0 up, 1 left, 2 right, 3 down), frame, frame transition count (+2,+3,+4)
  7+  C57C 00               defb    0                   ; auto move remaining (+5)
  8+  C57D 00 00 00         defb    0,0,0               ; is digging (0 no), digging count, pixels to di (+6,+7,+8)
  9+  C580 00               defb    0                   ; lives remaining (+9)
 10+  C581 00               defb    0                   ; died this life (+10)
 11+  C582 00 00            defb    0,0                 ; dying (+11), frames (+12)
 12+  C584 00               defb    0                   ; can finish level, whether can finish level or not (+13)
 13+  C585 00               defb    0                   ; difficulty (+14)
 14+  C586
 15+  C586              player_location:
 16+  C586 00               defb 0                      ; 0 normal, 1 diamond cavern, 2 the pit
 17+  C587
 18+  C587              ;
 19+  C587              ; Works out which part of the screen the player is in
 20+  C587              ; Pit is between 3,9 and 8,9
 21+  C587              ; Diamond cavern is between 11,22 and 22,28
 22+  C587              ;
 23+  C587              player_getlocation:
 24+  C587 ED 4B 77 C5      ld bc,(player)              ; get screen coords
 25+  C58B CD 3A AA         call screen_getcharcoordsfromscreencoords ; get char coords, c horiz
 26+  C58E 78               ld a,b                      ; check for pit first
 27+  C58F FE 09            cp 9                        ; if not on this row, not in the pit
 28+  C591 C2 A0 C5         jp nz,player_getlocation0
 29+  C594 79               ld a,c                      ; check horizontal
 30+  C595 FE 09            cp 9
 31+  C597 D2 A0 C5         jp nc, player_getlocation0  ; if more than 9, not in the pit
 32+  C59A 21 86 C5         ld hl,player_location
 33+  C59D 36 02            ld (hl),2                   ; load location with 2, the pit
 34+  C59F C9               ret                         ; done
 35+  C5A0              player_getlocation0:            ; check for diamond cavern
 36+  C5A0 78               ld a,b                      ; first check vertical
 37+  C5A1 FE 16            cp 22                       ; if above row 22, then not in cavern
 38+  C5A3 DA B7 C5         jp c,player_getlocation1
 39+  C5A6 79               ld a,c                      ; get the horizontal next
 40+  C5A7 FE 0B            cp 11
 41+  C5A9 DA B7 C5         jp c,player_getlocation1    ; if less than 11 not in diamond cave
 42+  C5AC FE 16            cp 22
 43+  C5AE D2 B7 C5         jp nc,player_getlocation1    ; if less than 11 not in diamond cave
 44+  C5B1 21 86 C5         ld hl,player_location
 45+  C5B4 36 01            ld (hl),1                   ; load location with 1, the cavern
 46+  C5B6 C9               ret
 47+  C5B7              player_getlocation1:
 48+  C5B7 21 86 C5         ld hl,player_location
 49+  C5BA 36 00            ld (hl),0                   ; load location with 2, the pit
 50+  C5BC C9               ret                         ; done
 51+  C5BD
 52+  C5BD
 53+  C5BD              ;
 54+  C5BD              ; Initializes a player at start of game
 55+  C5BD              ; Copy initial coords, copy lives, copy score
 56+  C5BD              ;
 57+  C5BD              player_init_gamestart:
 58+  C5BD 3A 89 C4         ld a,(game_numberlives)
 59+  C5C0 32 7E C6         ld (player1_lives),a
 60+  C5C3 32 7F C6         ld (player2_lives),a                        ; set the initial number of lives at game start
 61+  C5C6
 62+  C5C6 21 82 C6         ld hl,player1_score+2
 63+  C5C9 06 06            ld b,6
 64+  C5CB              player_init_gamestart0:
 65+  C5CB 36 30            ld (hl),48
 66+  C5CD 23               inc hl
 67+  C5CE 10 FB            djnz player_init_gamestart0                 ; zero out player 1 score
 68+  C5D0 21 8B C6         ld hl,player2_score+2
 69+  C5D3 06 06            ld b,6
 70+  C5D5              player_init_gamestart1:
 71+  C5D5 36 30            ld (hl),48
 72+  C5D7 23               inc hl
 73+  C5D8 10 FB            djnz player_init_gamestart1                 ; zero out player 2 score
 74+  C5DA 3E 01            ld a,1
 75+  C5DC 32 92 C6         ld (player1_difficulty),a
 76+  C5DF 32 93 C6         ld (player2_difficulty),a                   ; set player difficulties to zero
 77+  C5E2 C9               ret
 78+  C5E3
 79+  C5E3              ;
 80+  C5E3              ; Initializes a player at start of a life
 81+  C5E3              ; Copy initial coords, copy lives, copy score
 82+  C5E3              ;
 83+  C5E3              player_init_lifestart:
 84+  C5E3 21 7C C5         ld hl,player+5
 85+  C5E6 06 09            ld b,9                      ; initialise 9 properties
 86+  C5E8              player_init_lifestart2:
 87+  C5E8 36 00            ld (hl),0
 88+  C5EA 23               inc hl
 89+  C5EB 10 FB            djnz player_init_lifestart2
 90+  C5ED
 91+  C5ED 21 79 C5         ld hl,player+2              ; initialise some properties
 92+  C5F0 36 02            ld (hl),2
 93+  C5F2 23               inc hl
 94+  C5F3 36 00            ld (hl),0
 95+  C5F5 23               inc hl
 96+  C5F6 36 01            ld (hl),1
 97+  C5F8
 98+  C5F8 ED 4B E8 80      ld bc,(init_coord)
 99+  C5FC ED 43 77 C5      ld (player),bc
100+  C600
101+  C600 3A 88 C4         ld a,(game_currentplayer)
102+  C603 FE 01            cp 1
103+  C605 C2 12 C6         jp nz,player_init_lifestart4
104+  C608 01 80 C5         ld bc,player+9
105+  C60B 3A 7E C6         ld a,(player1_lives)
106+  C60E 02               ld (bc),a
107+  C60F C3 19 C6         jp player_init_lifestart3
108+  C612              player_init_lifestart4:
109+  C612 01 80 C5         ld bc,player+9
110+  C615 3A 7F C6         ld a,(player2_lives)
111+  C618 02               ld (bc),a
112+  C619              player_init_lifestart3:
113+  C619 CD BE CE         call diamonds_init      ; initialise gems
114+  C61C 01 06 00         ld bc,6
115+  C61F 11 6A CC         ld de,scores_current+2
116+  C622 3A 88 C4         ld a,(game_currentplayer)
117+  C625 FE 01            cp 1
118+  C627 C2 36 C6         jp nz,player_init_lifestart0
119+  C62A 3A 92 C6         ld a,(player1_difficulty)       ; initialise player 1 difficulty
120+  C62D 32 8A C4         ld (game_difficulty),a
121+  C630 21 82 C6         ld hl,player1_score+2           ; itialise player 1 scores
122+  C633 C3 3F C6         jp player_init_lifestart1
123+  C636              player_init_lifestart0:
124+  C636 3A 93 C6         ld a,(player2_difficulty)       ; initialise player 2 difficulty
125+  C639 32 8A C4         ld (game_difficulty),a
126+  C63C 21 8B C6         ld hl,player2_score+2           ; initialise player 2 scores
127+  C63F              player_init_lifestart1:
128+  C63F ED B0            ldir
129+  C641 C9               ret
130+  C642
131+  C642
132+  C642              ;
133+  C642              ; Copies the current score and difficulty in the current player
134+  C642              ;
135+  C642              player_recordcurrentstate:
136+  C642 01 06 00         ld bc,6                  ; copy current score back to correct player
137+  C645 21 6A CC         ld hl,scores_current+2
138+  C648 3A 88 C4         ld a,(game_currentplayer)
139+  C64B FE 01            cp 1
140+  C64D C2 62 C6         jp nz,player_recordcurrentstate0
141+  C650 3A 8A C4         ld a,(game_difficulty)
142+  C653 32 92 C6         ld (player1_difficulty),a       ; store difficulty
143+  C656 11 82 C6         ld de,player1_score+2
144+  C659 3A 80 C5         ld a,(player+9)
145+  C65C 32 7E C6         ld (player1_lives),a              ; record lives
146+  C65F C3 71 C6         jp player_recordcurrentstate1
147+  C662              player_recordcurrentstate0:         ; do player 2
148+  C662 3A 8A C4         ld a,(game_difficulty)
149+  C665 32 93 C6         ld (player2_difficulty),a       ; store difficulty
150+  C668 3A 80 C5         ld a,(player+9)
151+  C66B 32 7F C6         ld (player2_lives),a              ; record lives
152+  C66E 11 8B C6         ld de,player2_score+2
153+  C671              player_recordcurrentstate1:
154+  C671 ED B0            ldir
155+  C673 C9               ret
156+  C674
157+  C674              ;
158+  C674              ; Player just died, subtract a life
159+  C674              ;
160+  C674              player_died:
161+  C674 01 80 C5         ld bc,player+9
162+  C677 0A               ld a,(bc)
163+  C678 3D               dec a
164+  C679 02               ld (bc),a
165+  C67A CD 42 C6         call player_recordcurrentstate
166+  C67D C9               ret
167+  C67E
168+  C67E              ;
169+  C67E              ; Player lives
170+  C67E              ;
171+  C67E              player1_lives:
172+  C67E 03               defb 3
173+  C67F              player2_lives:
174+  C67F 03               defb 3
175+  C680
176+  C680              ;
177+  C680              ; Player scores
178+  C680              ;
179+  C680              player1_score:
180+  C680 04 01 30 30      defb 4,1,'000000',255
180+  C684 30 30 30 30
180+  C688 FF
181+  C689              player2_score:
182+  C689 16 01 30 30      defb 22,1,'000000',255
182+  C68D 30 30 30 30
182+  C691 FF
183+  C692
184+  C692              ;
185+  C692              ; Player difficulties
186+  C692              ;
187+  C692              player1_difficulty:
188+  C692 00               defb 0
189+  C693              player2_difficulty:
190+  C693 00               defb 0
191+  C694
192+  C694              ;
193+  C694              ; Kills a player this life
194+  C694              ;
195+  C694              player_killplayer:
196+  C694 21 81 C5         ld hl,player+10
197+  C697 36 01            ld (hl),1
198+  C699 C9               ret
199+  C69A
200+  C69A              ;
201+  C69A              ; Crush a player this life
202+  C69A              ;
203+  C69A              player_crushplayer:
204+  C69A 21 82 C5         ld hl,player+11             ; mark as crushed
205+  C69D 36 01            ld (hl),1
206+  C69F C9               ret
207+  C6A0
208+  C6A0              player_tankkillplayer
209+  C6A0 21 82 C5         ld hl,player+11             ; mark as tanked
210+  C6A3 36 02            ld (hl),2
211+  C6A5 C9               ret
212+  C6A6
213+  C6A6              player_zonkplayer
214+  C6A6 21 82 C5         ld hl,player+11             ; mark as zonked (missile)
215+  C6A9 36 03            ld (hl),3
216+  C6AB C9               ret
217+  C6AC
218+  C6AC              player_pitkillplayer
219+  C6AC 21 82 C5         ld hl,player+11             ; mark as pit killed
220+  C6AF 36 04            ld (hl),4
221+  C6B1 C9               ret
222+  C6B2
223+  C6B2              player_robotkillplayer
224+  C6B2 21 82 C5         ld hl,player+11             ; mark as robot killed
225+  C6B5 36 05            ld (hl),5
226+  C6B7 C9               ret
227+  C6B8
228+  C6B8              ;
229+  C6B8              ; Draws the player at the current position or deletes them
230+  C6B8              ;
231+  C6B8              player_drawplayer:
232+  C6B8 3A 79 C5         ld a,(player+2)             ; get the current direction
233+  C6BB FE 03            cp 3
234+  C6BD C2 C2 C6         jp nz,player_drawplayer0
235+  C6C0 3E 00            ld a,0                      ; if 3, then down, so set the direction to 0 since the sprite is the same as up
236+  C6C2              player_drawplayer0:             ; DYING CHECKS
237+  C6C2 5F               ld e,a                      ; store in e
238+  C6C3 3A 82 C5         ld a,(player+11)             ; get the dying flag
239+  C6C6 FE 01            cp 1
240+  C6C8 CA 02 C7         jp z,player_drawplayer3     ; if it's one, we're being crushed
241+  C6CB FE 04            cp 4
242+  C6CD CA 4A C7         jp z,player_drawplayer9     ; player is falling into the pit
243+  C6D0 FE 05            cp 5
244+  C6D2 CA 66 C7         jp z,player_drawplayer12    ; player has been killed by a robot
245+  C6D5              player_drawplayer4:             ; CHECK FOR DIGGING
246+  C6D5 3A 7D C5         ld a,(player+6)             ; get the dig flag
247+  C6D8 FE 01            cp 1
248+  C6DA CA EB C6         jp z,player_drawplayer1    ; get dig frame
249+  C6DD 3A 7A C5         ld a,(player+3)             ; this is normal movement so get the current frame
250+  C6E0 83               add a,e
251+  C6E1 C3 F0 C6         jp player_drawplayer2
252+  C6E4              player_drawplayer6:             ; GETTING THE DIG FRAM
253+  C6E4 E6 01            and 1                       ; check for odd
254+  C6E6 C6 0A            add 10                      ; add 10, to get either 10 or 11
255+  C6E8 C3 F0 C6         jp player_drawplayer2
256+  C6EB              player_drawplayer1:             ; GET THE NORMAL FRAME
257+  C6EB 3A 79 C5         ld a,(player+2)             ; digging, get the current direction again, because want all four
258+  C6EE C6 06            add a,6                     ; add direction to 6 to get frame
259+  C6F0              player_drawplayer2:             ; WORK OUT THE FRAME
260+  C6F0 07               rlca
261+  C6F1 07               rlca
262+  C6F2 07               rlca                        ; multiply by eight
263+  C6F3 6F               ld l,a
264+  C6F4 26 00            ld h,0
265+  C6F6 11 D5 BD         ld de,player_sprite
266+  C6F9 19               add hl,de                   ; load hl with the location of the player sprite data
267+  C6FA              player_drawplayer7:             ; DRAW THE PlAYER
268+  C6FA ED 4B 77 C5      ld bc,(player)              ; load bc with the start coords
269+  C6FE CD 0C AB         call sprites_drawsprite     ; call the routine to draw the sprite
270+  C701                  ;call player_storeupdatedlines ; log updated rows
271+  C701 C9               ret
272+  C702              ;
273+  C702              ; CRUSHING
274+  C702              ;
275+  C702              player_drawplayer3:
276+  C702 21 83 C5         ld hl,player+12
277+  C705 7E               ld a,(hl)                  ; crushing, so get the current anim flag
278+  C706 FE 00            cp 0
279+  C708 C2 11 C7         jp nz,player_drawplayer5    ; if this isn't zero, then this isn't the first time round, so do the crush anim
280+  C70B 3E 64            ld a,100
281+  C70D 77               ld (hl),a                   ; otherwise, load up the anim frames
282+  C70E C3 D5 C6         jp player_drawplayer4       ; and return to the main loop to remove the current frame
283+  C711              player_drawplayer5:
284+  C711 3D               dec a
285+  C712 77               ld (hl),a
286+  C713 FE 00            cp 0
287+  C715 CC 94 C6         call z,player_killplayer     ; final animation, so kill the player
288+  C718 FE 0A            cp 10                         ; play the sound
289+  C71A CC B8 B1         call z, sound_rockfell
290+  C71D FE 14            cp 20                        ; check if we should move the rock
291+  C71F C2 33 C7         jp nz,player_drawplayer8
292+  C722 D9               exx
293+  C723 F5               push af
294+  C724 ED 4B 08 CB      ld bc,(rocks_killerrock)    ; get the coords of the rock that killed us
295+  C728 21 21 BD         ld hl,sprites+72
296+  C72B CD 0C AB         call sprites_drawsprite     ; draw a rock over current
297+  C72E F1               pop af
298+  C72F D9               exx
299+  C730 C3 E4 C6         jp player_drawplayer6       ; continue drawing player
300+  C733              player_drawplayer8:
301+  C733 FE 14            cp 20
302+  C735 D2 E4 C6         jp nc,player_drawplayer6    ; if not in last 10 frames, draw as normal
303+  C738 ED 4B 77 C5      ld bc,(player)
304+  C73C CD 3A AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
305+  C73F 3E 42            ld a,66             ; load red
306+  C741 CD 92 AA         call screen_setattr
307+  C744 21 21 BD         ld hl,sprites+72            ; otherwise, player is rock
308+  C747 C3 FA C6         jp player_drawplayer7
309+  C74A              ;
310+  C74A              ; FALLING
311+  C74A              ;
312+  C74A              player_drawplayer9:             ; player is falling into the pit
313+  C74A 21 83 C5         ld hl,player+12
314+  C74D 7E               ld a,(hl)                   ; get the frames
315+  C74E FE 00            cp 0
316+  C750 C2 59 C7         jp nz,player_drawplayer10    ; if this isn't zero, then this isn't the first time round, so do the crush anim
317+  C753 3E 50            ld a,80
318+  C755 77               ld (hl),a                   ; otherwise, load up the anim frames
319+  C756 C3 D5 C6         jp player_drawplayer4       ; and return to the main loop to remove the current frame
320+  C759              player_drawplayer10:
321+  C759 3D               dec a
322+  C75A 77               ld (hl),a
323+  C75B FE 00            cp 0
324+  C75D CC 94 C6         call z,player_killplayer     ; final frame, so kill the player
325+  C760 3A 7A C5         ld a,(player+3)
326+  C763 C3 F0 C6         jp player_drawplayer2
327+  C766              ;
328+  C766              ; ROBOT KILLED
329+  C766              ;
330+  C766              player_drawplayer12:
331+  C766 21 83 C5         ld hl,player+12
332+  C769 7E               ld a,(hl)                   ; get the frames
333+  C76A FE 00            cp 0
334+  C76C C2 75 C7         jp nz,player_drawplayer13    ; if this isn't zero, then this isn't the first time round, so do the crush anim
335+  C76F 3E C8            ld a,200
336+  C771 77               ld (hl),a                   ; otherwise, load up the anim frames
337+  C772 C3 D5 C6         jp player_drawplayer4       ; and return to the main loop to remove the current frame
338+  C775              player_drawplayer13:
339+  C775 3D               dec a
340+  C776 77               ld (hl),a
341+  C777 FE 00            cp 0
342+  C779 CC 94 C6         call z,player_killplayer     ; final frame, so kill the player
343+  C77C 3A 7A C5         ld a,(player+3)
344+  C77F C3 F0 C6         jp player_drawplayer2
345+  C782
346+  C782              ;
347+  C782              ; Runs after the player just moved. Changes animation frame if required
348+  C782              ;
349+  C782              player_justmoved:
350+  C782 D9               exx
351+  C783 3A 7B C5         ld a,(player+4)             ; get the transition count
352+  C786 FE 00            cp 0
353+  C788 CA 8E C7         jp z, player_justmoved2     ; if zero reset and change the frame
354+  C78B C3 A8 C7         jp player_justmoved1       ; otherwise decrease and continue
355+  C78E              player_justmoved2:
356+  C78E                  ; reset and change frame in here
357+  C78E 3E 01            ld a,1
358+  C790 32 7B C5         ld (player+4),a            ; reset back to whatever
359+  C793 3A 7A C5         ld a,(player+3)             ; load the frame
360+  C796 FE 03            cp 3                       ; flip between 3 and 0
361+  C798 C2 A0 C7         jp nz, player_justmoved4
362+  C79B 3E 00            ld a,0
363+  C79D C3 A2 C7         jp player_justmoved5
364+  C7A0              player_justmoved4:
365+  C7A0 3E 03            ld a,3
366+  C7A2              player_justmoved5:
367+  C7A2 32 7A C5         ld (player+3),a           ; save back
368+  C7A5 C3 AC C7         jp player_justmoved3
369+  C7A8              player_justmoved1:
370+  C7A8                  ; decrease count
371+  C7A8 3D               dec a
372+  C7A9 32 7B C5         ld (player+4),a
373+  C7AC              player_justmoved3:
374+  C7AC D9               exx;
375+  C7AD C9               ret
376+  C7AE
377+  C7AE              ;
378+  C7AE              ; Called if the player has collected a diamond. Checks the current coord. If it is the start coord, then return complete
379+  C7AE              ; Outputs:
380+  C7AE              ; a - 1 for completed level
381+  C7AE              player_checkforexit:
382+  C7AE ED 4B 77 C5      ld bc,(player)                 ; get player coords
383+  C7B2 ED 5B E8 80      ld de,(init_coord)             ; get start coords
384+  C7B6 78               ld a,b
385+  C7B7 BA               cp d                         ; compare horiz
386+  C7B8 C2 C3 C7         jp nz,player_checkforexit1
387+  C7BB 79               ld a,c
388+  C7BC BB               cp e                        ; compare vert
389+  C7BD C2 C3 C7         jp nz,player_checkforexit1
390+  C7C0              player_checkforexit0:
391+  C7C0 3E 01            ld a,1                       ; hasn't completed
392+  C7C2 C9               ret
393+  C7C3              player_checkforexit1:
394+  C7C3 3E 00            ld a,0                       ; has completed
395+  C7C5 C9               ret
# file closed: game/player.asm
157   C7C6                  include "game\ship.asm"
# file opened: game/ship.asm
  1+  C7C6              ;
  2+  C7C6              ; Ship initial position: vert,horiz
  3+  C7C6              ;
  4+  C7C6              ship_initpos:
  5+  C7C6 00 24            defb 0,36
  6+  C7C8              ship_initpos2:
  7+  C7C8 00 00            defb 0,0
  8+  C7CA              ship_frame:
  9+  C7CA 00               defb 0
 10+  C7CB              ;
 11+  C7CB              ; The current memory location
 12+  C7CB              ;
 13+  C7CB              ship_current_sprite:
 14+  C7CB 00 00            defb 0,0
 15+  C7CD
 16+  C7CD              ship_current_coords:
 17+  C7CD 00 00            defb 0,0
 18+  C7CF
 19+  C7CF              ship_process:
 20+  C7CF 3A 82 C5         ld a,(player+11)
 21+  C7D2 FE 02            cp 2                        ; has the player been killed by tank?
 22+  C7D4 C0               ret nz                      ; do nothing if not
 23+  C7D5 CD 50 C2         call control_scroll_up           ; make sure the screen is on the top screen
 24+  C7D8 CD 52 C8         call ship_takeoff           ; bye bye
 25+  C7DB CD 94 C6         call player_killplayer      ; killed
 26+  C7DE 06 32            ld b,50
 27+  C7E0 CD 61 81         call utilities_pauseforframes
 28+  C7E3 C9               ret
 29+  C7E4
 30+  C7E4              ;
 31+  C7E4              ;   Draw and land the ship - first move the ship down, then across, drawing the player in the middle
 32+  C7E4              ;
 33+  C7E4              ship_land:
 34+  C7E4 ED 4B C6 C7      ld bc,(ship_initpos)
 35+  C7E8 ED 43 C8 C7      ld (ship_initpos2),bc        ; save the initial position for later use
 36+  C7EC 1E 00            ld e,0                      ; store a flag to track first time round
 37+  C7EE 06 09            ld b,9                      ; move down 8 pixels
 38+  C7F0              ship_land0:
 39+  C7F0 C5               push bc
 40+  C7F1 7B               ld a,e
 41+  C7F2 D5               push de                     ; store de for next time round
 42+  C7F3 FE 01            cp 1                        ; check first time flag
 43+  C7F5 C2 0A C8         jp nz,ship_land1             ; don't draw over previous one if first time
 44+  C7F8 CD 9A C8         call ship_draw_full         ; delete old one
 45+  C7FB CD 7E C8         call ship_change_frame      ; increment the frame
 46+  C7FE ED 4B C8 C7      ld bc,(ship_initpos2)       ; get the current coords
 47+  C802 81 C6 01         add c,1                     ; move down one pixels
 48+  C805 4F               ld c,a
 49+  C806 ED 43 C8 C7      ld (ship_initpos2),bc
 50+  C80A              ship_land1:
 51+  C80A CD 9A C8         call ship_draw_full         ; draw the ship
 52+  C80D D1               pop de
 53+  C80E 7B               ld a,e
 54+  C80F FE 00            cp 0
 55+  C811 C2 17 C8         jp nz,ship_land4
 56+  C814 CD A5 B1         call sound_pitchbend        ; play sound if first frame
 57+  C817              ship_land4:
 58+  C817 D5               push de
 59+  C818 CD 93 C8         call ship_draw_screen
 60+  C81B D1               pop de
 61+  C81C 1E 01            ld e,1
 62+  C81E C1               pop bc
 63+  C81F 10 CF            djnz ship_land0             ; repeat for downward movement
 64+  C821                  ; done moving down
 65+  C821                  ; now move across
 66+  C821 CD B8 C6         call player_drawplayer      ; draw player
 67+  C824 CD 9A C8         call ship_draw_full         ; delete old one
 68+  C827 1E 00            ld e,0                      ; store a flag to track first time round
 69+  C829 06 14            ld b,20                      ; move back 20 pixels pixels
 70+  C82B              ship_land3:
 71+  C82B C5               push bc
 72+  C82C 7B               ld a,e
 73+  C82D D5               push de                     ; store de for next time round
 74+  C82E FE 01            cp 1                        ; check first time flag
 75+  C830 C2 45 C8         jp nz,ship_land2             ; don't draw over previous one if first time
 76+  C833 CD 9A C8         call ship_draw_full         ; delete old one
 77+  C836 CD 7E C8         call ship_change_frame      ; increment the frame
 78+  C839 ED 4B C8 C7      ld bc,(ship_initpos2)       ; get the current coords
 79+  C83D 78               ld a,b
 80+  C83E D6 01            sub 1                       ; move back one pixels
 81+  C840 47               ld b,a
 82+  C841 ED 43 C8 C7      ld (ship_initpos2),bc
 83+  C845              ship_land2:
 84+  C845 CD 9A C8         call ship_draw_full         ; draw the ship
 85+  C848 CD 93 C8         call ship_draw_screen       ; draw the frame to screen by clearing the buffer
 86+  C84B D1               pop de
 87+  C84C 1E 01            ld e,1                      ; set e to 1 to indicate >1 time
 88+  C84E C1               pop bc
 89+  C84F 10 DA            djnz ship_land3             ; repeat for vertical movement
 90+  C851 C9               ret
 91+  C852
 92+  C852              ;
 93+  C852              ;   Take off the ship
 94+  C852              ;
 95+  C852              ship_takeoff:
 96+  C852 1E 01            ld e,1                      ; store a flag to track first time round
 97+  C854 06 08            ld b,8                      ; move up 8 pixels
 98+  C856              ship_takeoff0:
 99+  C856 C5               push bc
100+  C857 7B               ld a,e
101+  C858 D5               push de                     ; store de for next time round
102+  C859 FE 01            cp 1                        ; check first time flag
103+  C85B C2 71 C8         jp nz,ship_takeoff1             ; don't draw over previous one if first time
104+  C85E ED 4B C8 C7      ld bc,(ship_initpos2)       ; get the current coords
105+  C862 CD 9A C8         call ship_draw_full         ; delete old one
106+  C865 CD 7E C8         call ship_change_frame      ; increment the frame
107+  C868 ED 4B C8 C7      ld bc,(ship_initpos2)       ; get the current coords
108+  C86C 0D               dec c                       ; move up one pixels
109+  C86D ED 43 C8 C7      ld (ship_initpos2),bc
110+  C871              ship_takeoff1:
111+  C871 CD 9A C8         call ship_draw_full         ; draw the ship
112+  C874 CD 93 C8         call ship_draw_screen
113+  C877 D1               pop de
114+  C878 1E 01            ld e,1
115+  C87A C1               pop bc
116+  C87B 10 D9            djnz ship_takeoff0             ; repeat for upward movement
117+  C87D                  ; done moving up
118+  C87D C9               ret
119+  C87E
120+  C87E              ;
121+  C87E              ; Swap the animation frame between 0 and 32. This will be added to the memory location later
122+  C87E              ;
123+  C87E              ship_change_frame:
124+  C87E F5               push af
125+  C87F 3A CA C7         ld a,(ship_frame)
126+  C882 FE 00            cp 0
127+  C884 CA 8C C8         jp z,ship_change_frame0
128+  C887 3E 00            ld a,0                      ; flip to 0
129+  C889 C3 8E C8         jp ship_change_frame1
130+  C88C              ship_change_frame0:
131+  C88C 3E 20            ld a,32                      ; flip to 32
132+  C88E              ship_change_frame1:
133+  C88E 32 CA C7         ld (ship_frame),a            ; save the frame
134+  C891 F1               pop af
135+  C892 C9               ret
136+  C893
137+  C893              ship_draw_screen:
138+  C893 76               halt
139+  C894 F3               di
140+  C895 CD 03 A8         call buffer_buffertoscreen  ; copy buffer to screen
141+  C898 FB               ei                          ; enable interupts
142+  C899 C9               ret
143+  C89A
144+  C89A              ship_draw_full:
145+  C89A 21 45 BE         ld hl,ship_sprite
146+  C89D ED 4B C8 C7      ld bc,(ship_initpos2)         ; load bc with the start coords
147+  C8A1 22 CB C7         ld (ship_current_sprite),hl  ; put into memory
148+  C8A4 ED 43 CD C7      ld (ship_current_coords),bc  ; put into memory
149+  C8A8 CD C7 C8         call ship_draw
150+  C8AB 08               ex af,af'
151+  C8AC 3A CA C7         ld a,(ship_frame)            ; get the animation frame
152+  C8AF 16 00            ld d,0
153+  C8B1 5F               ld e,a
154+  C8B2 19               add hl,de
155+  C8B3 22 CB C7         ld (ship_current_sprite),hl  ; put into memory
156+  C8B6 08               ex af,af'
157+  C8B7 ED 4B C8 C7      ld bc,(ship_initpos2)         ; load bc with the start coords
158+  C8BB 81 C6 08         add c,8                      ; move one line down
159+  C8BE 4F               ld c,a
160+  C8BF ED 43 CD C7      ld (ship_current_coords),bc  ; put into memory
161+  C8C3 CD C7 C8         call ship_draw
162+  C8C6 C9               ret
163+  C8C7
164+  C8C7              ;
165+  C8C7              ; Draw the ship
166+  C8C7              ; Inputs:
167+  C8C7              ; None, all in memory
168+  C8C7              ;
169+  C8C7              ship_draw:
170+  C8C7 3E 04            ld a,4                              ; 4 pieces per half
171+  C8C9              ship_draw0:
172+  C8C9 F5               push af
173+  C8CA 2A CB C7         ld hl,(ship_current_sprite)
174+  C8CD ED 4B CD C7      ld bc,(ship_current_coords)         ; load bc with the start coords
175+  C8D1 CD 0C AB         call sprites_drawsprite
176+  C8D4 2A CB C7         ld hl,(ship_current_sprite)
177+  C8D7 ED 4B CD C7      ld bc,(ship_current_coords)         ; load bc with the start coords
178+  C8DB 11 08 00         ld de,8
179+  C8DE 19               add hl,de
180+  C8DF 80 C6 08         add b,8
181+  C8E2 47               ld b,a
182+  C8E3 22 CB C7         ld (ship_current_sprite),hl         ; put into memory
183+  C8E6 ED 43 CD C7      ld (ship_current_coords),bc         ; put into memory
184+  C8EA F1               pop af
185+  C8EB 3D               dec a
186+  C8EC FE 00            cp 0
187+  C8EE C2 C9 C8         jp nz,ship_draw0
188+  C8F1
189+  C8F1 C9               ret
190+  C8F2
# file closed: game/ship.asm
158   C8F2                  include "game\tank.asm"
# file opened: game/tank.asm
  1+  C8F2              ;
  2+  C8F2              ; tank initial position: vert,horiz
  3+  C8F2              ;
  4+  C8F2              tank_initpos:
  5+  C8F2 10 D0            defb 16,208
  6+  C8F4              tank_initpos2:
  7+  C8F4 00 00            defb 0,0
  8+  C8F6              tank_frame:
  9+  C8F6 00               defb 0
 10+  C8F7              tank_anim:
 11+  C8F7 11               defb 17
 12+  C8F8
 13+  C8F8              ;
 14+  C8F8              ; The damage countdown
 15+  C8F8              ;
 16+  C8F8              tank_currentdamage:
 17+  C8F8 F0               defb 240
 18+  C8F9
 19+  C8F9              ;
 20+  C8F9              ; The damage coordinate
 21+  C8F9              ;
 22+  C8F9              tank_currentdamagecoord:
 23+  C8F9 16 02            defb 22,2
 24+  C8FB
 25+  C8FB              ;
 26+  C8FB              ; Controls when the tank shoots
 27+  C8FB              ;
 28+  C8FB              tank_count:
 29+  C8FB 00               defb 0
 30+  C8FC
 31+  C8FC              ;
 32+  C8FC              ; Holds the block number of the current damage sprite
 33+  C8FC              ;
 34+  C8FC              tank_damageframe:
 35+  C8FC 00               defb 0
 36+  C8FD
 37+  C8FD              ;
 38+  C8FD              ; The current memory location
 39+  C8FD              ;
 40+  C8FD              tank_current_sprite:
 41+  C8FD 00 00            defb 0,0
 42+  C8FF
 43+  C8FF              tank_current_coords:
 44+  C8FF 00 00            defb 0,0
 45+  C901
 46+  C901              ;
 47+  C901              ; Is the missile displayed - will be 19 if so, 0 if not
 48+  C901              ;
 49+  C901              tank_missile_displayed:
 50+  C901 00               defb 0
 51+  C902
 52+  C902              ;
 53+  C902              ; Speed that the tank fires
 54+  C902              ;
 55+  C902              tank_speed:
 56+  C902 00               defb 0
 57+  C903
 58+  C903              ;
 59+  C903              ; Initialise the tank
 60+  C903              ;
 61+  C903              tank_init:
 62+  C903 ED 4B F2 C8      ld bc,(tank_initpos)
 63+  C907 ED 43 F4 C8      ld (tank_initpos2),bc       ; save the initial position for later use
 64+  C90B 21 F6 C8         ld hl,tank_frame
 65+  C90E 36 00            ld (hl),0
 66+  C910 21 F7 C8         ld hl,tank_anim
 67+  C913 36 11            ld (hl),17
 68+  C915 21 FC C8         ld hl,tank_damageframe              ; reset tank
 69+  C918 36 00            ld (hl),0
 70+  C91A 21 FB C8         ld hl,tank_count
 71+  C91D 36 00            ld (hl),0
 72+  C91F 21 F8 C8         ld hl,tank_currentdamage
 73+  C922 36 F0            ld (hl),240
 74+  C924 21 F9 C8         ld hl,tank_currentdamagecoord
 75+  C927 36 16            ld (hl),22
 76+  C929 23               inc hl
 77+  C92A 36 02            ld (hl),2
 78+  C92C 21 01 C9         ld hl,tank_missile_displayed
 79+  C92F 36 00            ld (hl),0
 80+  C931
 81+  C931 C9               ret
 82+  C932
 83+  C932              ;
 84+  C932              ;   Draw and move the tank
 85+  C932              ;   Start processing at frame 200
 86+  C932              ;   Don't move if anim is zero
 87+  C932              ;   Decrement frame if moved
 88+  C932              ;
 89+  C932              tank_process:
 90+  C932 3A F7 C8         ld a,(tank_anim)
 91+  C935 FE 00            cp 0
 92+  C937 C2 3E C9         jp nz,tank_process0         ; fire the tank if we've already moved, or jump to movement
 93+  C93A CD 4F C9         call tank_fire
 94+  C93D C9               ret
 95+  C93E              tank_process0:
 96+  C93E CD 21 C5         call game_getcurrentframe   ; get the current frame number into a
 97+  C941 FE 4B            cp 75
 98+  C943 D8               ret c                       ; return if the frame number is below 100
 99+  C944 CD 7B CA         call tank_move              ; move tank if not
100+  C947 3A F7 C8         ld a,(tank_anim)
101+  C94A 3D               dec a
102+  C94B 32 F7 C8         ld (tank_anim),a            ; decrease the anim count
103+  C94E C9               ret
104+  C94F
105+  C94F              ;
106+  C94F              ; Fires the tank
107+  C94F              ;
108+  C94F              tank_fire:
109+  C94F 3A FB C8         ld a,(tank_count)            ; if not, don't do anything
110+  C952 3C               inc a                        ; increment
111+  C953 ED 5B 02 C9      ld de,(tank_speed)
112+  C957 BB               cp e                        ; have we reached the speed
113+  C958 C2 5D C9         jp nz,tank_fire0
114+  C95B 3E 00            ld a,0                       ; reset if reached fifty
115+  C95D              tank_fire0:                      ; DEALING WITH A NEW BLOCK
116+  C95D 32 FB C8         ld (tank_count),a            ; store tank count
117+  C960 FE 00            cp 0
118+  C962 CA 83 C9         jp z,tank_fire7              ; If this is zero, fire
119+  C965 3A 01 C9         ld a,(tank_missile_displayed) ; is the missile displaying?
120+  C968 FE 00            cp 0
121+  C96A C8               ret z                       ; don't do anything if not
122+  C96B CD 35 CA         call tank_missilegraphic     ; if not, overwrite the previous tank missile
123+  C96E 3E 00            ld a,0                       ; reset the flag
124+  C970 32 01 C9         ld (tank_missile_displayed),a
125+  C973 3E 02            ld a,2
126+  C975 ED 4B F9 C8      ld bc,(tank_currentdamagecoord)
127+  C979 0C               inc c
128+  C97A 0C               inc c
129+  C97B ED 43 23 AC      ld (origcoords),bc
130+  C97F CD 28 A7         call buffer_marklineforupdate
131+  C982 C9               ret                        ; only shoot if we're on 0
132+  C983              tank_fire7:
133+  C983 3A F8 C8         ld a,(tank_currentdamage)    ; get the damage countdown
134+  C986 E6 07            and 7                       ; check if multiple of 8 - house keeping when moving onto a new block
135+  C988 C2 BE C9         jp nz,tank_fire1            ; not, so just do a normal frame
136+  C98B ED 4B F9 C8      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
137+  C98F 79               ld a,c
138+  C990 FE 0A            cp 10
139+  C992 C2 99 C9         jp nz, tank_fire6
140+  C995 CD 6D CA         call tank_killedbytank      ; we're through, so the player has died. Kill them.
141+  C998 C9               ret                         ; return if we're through the mountain
142+  C999              tank_fire6:
143+  C999 3E 0F            ld a,15
144+  C99B 32 FC C8         ld (tank_damageframe),a     ; reset the damage frame
145+  C99E 21 D9 BC         ld hl,sprites               ; location of the empty block
146+  C9A1 CD 64 AA         call screen_showchar        ; show this character here
147+  C9A4 ED 4B F9 C8      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
148+  C9A8 05               dec b                       ; look one above
149+  C9A9 CD C8 AA         call screen_ischarempty     ; check if it is empty
150+  C9AC ED 4B F9 C8      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc again
151+  C9B0 FE 01            cp 1
152+  C9B2 C2 F5 C9         jp nz,tank_fire2             ; block above isn't empty, so can't move on, copy down above blocks
153+  C9B5 ED 4B F9 C8      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
154+  C9B9 0D               dec c
155+  C9BA ED 43 F9 C8      ld (tank_currentdamagecoord),bc ; store the coord
156+  C9BE              tank_fire1:                         ; DEALING WITH NORMAL DAMAGE
157+  C9BE ED 4B F9 C8      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
158+  C9C2 3A F8 C8         ld a,(tank_currentdamage)    ; get the damage countdown
159+  C9C5 E6 07            and 7                       ; is it a multiple of 8? only want to do the first line check then
160+  C9C7 C2 D2 C9         jp nz, tank_fire5
161+  C9CA CD F8 AA         call screen_getcharfirstbyte    ; get the first byte to check if this is a slope
162+  C9CD FE FF            cp 255                      ; if it's a full line, it will be 255 and not a slope
163+  C9CF C2 13 CA         jp nz,tank_fire3            ; if it's a slope, handle this differently
164+  C9D2              tank_fire5:
165+  C9D2 3A FC C8         ld a,(tank_damageframe)
166+  C9D5 CD 87 AA         call screen_getblock        ; get the block data into hl
167+  C9D8 CD 64 AA         call screen_showchar        ; show this character here
168+  C9DB 3A FC C8         ld a,(tank_damageframe)
169+  C9DE 3C               inc a
170+  C9DF 32 FC C8         ld (tank_damageframe),a     ; increment the damage block and store
171+  C9E2 3A F8 C8         ld a,(tank_currentdamage)    ; get the damage countdown
172+  C9E5 3D               dec a
173+  C9E6 3D               dec a
174+  C9E7 32 F8 C8         ld (tank_currentdamage),a     ; decrease current damage by 2 and store
175+  C9EA 3A 01 C9         ld a,(tank_missile_displayed) ; is the missile displaying?
176+  C9ED FE 00            cp 0
177+  C9EF CC 35 CA         call z, tank_missilegraphic
178+  C9F2 C3 1C CA         jp tank_fire4
179+  C9F5              tank_fire2:                     ; DEALING WITH COPYING BLOCKS FROM ABOVE
180+  C9F5 05               dec b
181+  C9F6 C5               push bc
182+  C9F7 CD E1 AA         call screen_copyblockdown       ; copy the block down
183+  C9FA ED 4B F9 C8      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
184+  C9FE C1               pop bc                      ; get the coord we just checked back
185+  C9FF 78               ld a,b
186+  CA00 FE 00            cp 0
187+  CA02 CA BE C9         jp z,tank_fire1             ; if we're at the top of the screen, don't check any more
188+  CA05 C5               push bc
189+  CA06 05               dec b
190+  CA07 CD C8 AA         call screen_ischarempty     ; check if it is empty
191+  CA0A C1               pop bc
192+  CA0B FE 01            cp 1                        ; if empty
193+  CA0D C2 F5 C9         jp nz, tank_fire2            ; copy another one down
194+  CA10 C3 BE C9         jp tank_fire1               ; otherwise, return to main thread
195+  CA13              tank_fire3:                      ; dealing with slopes
196+  CA13 3A F8 C8         ld a,(tank_currentdamage)    ; get the damage countdown
197+  CA16 06 08            ld b,8
198+  CA18 90               sub b                        ; special case for slopes
199+  CA19 32 F8 C8         ld (tank_currentdamage),a    ; decrease the damage countdown by 8, so that next time, we get rid of this block without eroding it
200+  CA1C              tank_fire4:                     ; TIDY UP
201+  CA1C ED 4B F9 C8      ld bc,(tank_currentdamagecoord)
202+  CA20 ED 43 23 AC      ld (origcoords),bc
203+  CA24 CD 28 A7         call buffer_marklineforupdate
204+  CA27 3E 01            ld a,1
205+  CA29 CD 28 A7         call buffer_marklineforupdate
206+  CA2C 3E 02            ld a,2
207+  CA2E CD 28 A7         call buffer_marklineforupdate
208+  CA31 CD E9 B1         call sound_tankshoot
209+  CA34 C9               ret
210+  CA35
211+  CA35              ;
212+  CA35              ; Displays or hides the missile graphic, and changes the gun
213+  CA35              ;
214+  CA35              tank_missilegraphic:
215+  CA35 3A 01 C9         ld a,(tank_missile_displayed)
216+  CA38 FE 00            cp 0
217+  CA3A C2 42 CA         jp nz,tank_missilegraphic0
218+  CA3D 3E 13            ld a,19
219+  CA3F C3 44 CA         jp tank_missilegraphic1
220+  CA42              tank_missilegraphic0:
221+  CA42 3E 00            ld a,0
222+  CA44              tank_missilegraphic1:
223+  CA44 32 01 C9         ld (tank_missile_displayed),a ; store the flipped graphic
224+  CA47 ED 4B F9 C8      ld bc,(tank_currentdamagecoord)
225+  CA4B 0C               inc c
226+  CA4C 0C               inc c                   ; print the graphic 2 spaces right
227+  CA4D CD 87 AA         call screen_getblock        ; get the block data into hl
228+  CA50 CD 64 AA         call screen_showchar        ; show this character here
229+  CA53 06 02            ld b,2
230+  CA55 0E 18            ld c,24                     ; set gunbarrel coords
231+  CA57 11 00 00         ld de,0
232+  CA5A 21 A5 BE         ld hl,tank_sprite           ; set hl to gunbarrel gfx, shooting is +64
233+  CA5D 3A 01 C9         ld a,(tank_missile_displayed)
234+  CA60 FE 00            cp 0
235+  CA62 CA 68 CA         jp z,tank_missilegraphic2
236+  CA65 11 40 00         ld de,64
237+  CA68              tank_missilegraphic2:
238+  CA68 19               add hl,de                   ; work out missile graphic
239+  CA69 CD 64 AA         call screen_showchar        ; show this character here
240+  CA6C C9               ret
241+  CA6D
242+  CA6D              ;
243+  CA6D              ; Deal with the player being killed by the tank
244+  CA6D              ;
245+  CA6D              tank_killedbytank:
246+  CA6D ED 4B F9 C8      ld bc,(tank_currentdamagecoord) ; get the current damage coord into bc
247+  CA71 21 D9 BC         ld hl,sprites                   ; empty sprite
248+  CA74 CD 64 AA         call screen_showchar            ; hide the last piece of dirt
249+  CA77 CD A0 C6         call player_tankkillplayer
250+  CA7A C9               ret
251+  CA7B
252+  CA7B              tank_move:
253+  CA7B ED 4B F4 C8      ld bc,(tank_initpos2)
254+  CA7F C5               push bc
255+  CA80 3A F7 C8         ld a,(tank_anim)
256+  CA83 FE 11            cp 17                       ; check first time flag
257+  CA85 CA 97 CA         jp z,tank_move1             ; don't draw over previous one if first time
258+  CA88 CD 9C CA         call tank_draw_full         ; delete old one
259+  CA8B ED 4B F4 C8      ld bc,(tank_initpos2)       ; get the current coords
260+  CA8F 78               ld a,b
261+  CA90 D6 01            sub 1                       ; move back one pixels
262+  CA92 47               ld b,a
263+  CA93 ED 43 F4 C8      ld (tank_initpos2),bc
264+  CA97              tank_move1:
265+  CA97 CD 9C CA         call tank_draw_full         ; draw the tank
266+  CA9A C1               pop bc
267+  CA9B C9               ret
268+  CA9C
269+  CA9C              tank_draw_full:
270+  CA9C 21 A5 BE         ld hl,tank_sprite
271+  CA9F ED 4B F4 C8      ld bc,(tank_initpos2)         ; load bc with the start coords
272+  CAA3 22 FD C8         ld (tank_current_sprite),hl  ; put into memory
273+  CAA6 ED 43 FF C8      ld (tank_current_coords),bc  ; put into memory
274+  CAAA CD C9 CA         call tank_draw
275+  CAAD 08               ex af,af'
276+  CAAE 3A F6 C8         ld a,(tank_frame)            ; get the animation frame
277+  CAB1 16 00            ld d,0
278+  CAB3 5F               ld e,a
279+  CAB4 19               add hl,de
280+  CAB5 22 FD C8         ld (tank_current_sprite),hl  ; put into memory
281+  CAB8 08               ex af,af'
282+  CAB9 ED 4B F4 C8      ld bc,(tank_initpos2)         ; load bc with the start coords
283+  CABD 81 C6 08         add c,8                      ; move one line down
284+  CAC0 4F               ld c,a
285+  CAC1 ED 43 FF C8      ld (tank_current_coords),bc  ; put into memory
286+  CAC5 CD C9 CA         call tank_draw
287+  CAC8 C9               ret
288+  CAC9
289+  CAC9              ;
290+  CAC9              ; Draw the tank
291+  CAC9              ; Inputs:
292+  CAC9              ; None, all in memory
293+  CAC9              ;
294+  CAC9              tank_draw:
295+  CAC9 3E 04            ld a,4                              ; 4 pieces per half
296+  CACB              tank_draw0:
297+  CACB F5               push af
298+  CACC 2A FD C8         ld hl,(tank_current_sprite)
299+  CACF ED 4B FF C8      ld bc,(tank_current_coords)         ; load bc with the start coords
300+  CAD3 CD 0C AB         call sprites_drawsprite
301+  CAD6 2A FD C8         ld hl,(tank_current_sprite)
302+  CAD9 ED 4B FF C8      ld bc,(tank_current_coords)         ; load bc with the start coords
303+  CADD 11 08 00         ld de,8
304+  CAE0 19               add hl,de
305+  CAE1 80 C6 08         add b,8
306+  CAE4 47               ld b,a
307+  CAE5 22 FD C8         ld (tank_current_sprite),hl         ; put into memory
308+  CAE8 ED 43 FF C8      ld (tank_current_coords),bc         ; put into memory
309+  CAEC F1               pop af
310+  CAED 3D               dec a
311+  CAEE FE 00            cp 0
312+  CAF0 C2 CB CA         jp nz,tank_draw0
313+  CAF3
314+  CAF3 C9               ret
315+  CAF4
# file closed: game/tank.asm
159   CAF4                  include "game\rocks.asm"
# file opened: game/rocks.asm
  1+  CAF4              ;
  2+  CAF4              ; A structure of falling rocks
  3+  CAF4              ; Assume we'll never have more than 4 falling at any one time
  4+  CAF4              ; (1,2 - 16 bit memory location for rock graphic),state (0 fell, 1 falling, 2 wobbling), countdown
  5+  CAF4              ;
  6+  CAF4              rocks_falling:
  7+  CAF4 00 00 00 00      defb 0,0,0,0
  8+  CAF8 00 00 00 00      defb 0,0,0,0
  9+  CAFC 00 00 00 00      defb 0,0,0,0
 10+  CB00 00 00 00 00      defb 0,0,0,0
 11+  CB04
 12+  CB04              rocks_tmp:
 13+  CB04 00               defb 0
 14+  CB05
 15+  CB05              rocks_tmp2:
 16+  CB05 00 00            defb 0,0
 17+  CB07
 18+  CB07              ;
 19+  CB07              ; The number of frames to wobble for
 20+  CB07              ; Must always be 10 more than the number of frames a player digs
 21+  CB07              ;
 22+  CB07              rocks_numberofframestowobble:
 23+  CB07 14               defb 20
 24+  CB08
 25+  CB08              ;
 26+  CB08              ; Coords of the rock that killed us
 27+  CB08              ;
 28+  CB08              rocks_killerrock:
 29+  CB08 00 00            defb 0,0
 30+  CB0A
 31+  CB0A              ;
 32+  CB0A              ; Checks for a rock that needs to start falling. Takes a memory location of the first line at the bottom of the space.
 33+  CB0A              ; Checks to see if the pixel row in that location is a rock bottom. If it is, mark this rock as ready to fall.
 34+  CB0A              ; If the pixel row is not the rock bottom, stop checking.
 35+  CB0A              ; Inputs:
 36+  CB0A              ; hl- memory location
 37+  CB0A              ;
 38+  CB0A              rocks_checkforfalling:
 39+  CB0A 7E               ld a,(hl)           ; get the pixel row in this memory location
 40+  CB0B FE 7E            cp 126              ; check against the bottom pixel row of the rock graphic
 41+  CB0D C2 13 CB         jp nz,rocks_checkforfalling2 ; not a rock, stop
 42+  CB10 CD 14 CB         call rocks_addrocktofalling ; mark the rock as falling
 43+  CB13              rocks_checkforfalling2:
 44+  CB13 C9               ret
 45+  CB14
 46+  CB14              ;
 47+  CB14              ; Adds the rock to the structure that tracks falling rocks
 48+  CB14              ; Inputs:
 49+  CB14              ; hl - memory location of falling rock graphic
 50+  CB14              ; bc - coords of rock, c vert
 51+  CB14              rocks_addrocktofalling:
 52+  CB14 C5               push bc             ; store the coords
 53+  CB15 11 F4 CA         ld de,rocks_falling
 54+  CB18 06 04            ld b,4              ; number of possible falling rocks
 55+  CB1A              rocks_addrocktofalling0:
 56+  CB1A 13               inc de
 57+  CB1B                  ;inc de
 58+  CB1B 13               inc de              ; move three along to get the state
 59+  CB1C 1A               ld a,(de)           ; load the state
 60+  CB1D FE 00            cp 0                ; check if this is not falling
 61+  CB1F C2 36 CB         jp nz,rocks_addrocktofalling1 ; continue the loop if not 0
 62+  CB22 13               inc de              ; move to frame
 63+  CB23 3A 07 CB         ld a,(rocks_numberofframestowobble) ; load the number of frames to wobble
 64+  CB26 12               ld (de),a
 65+  CB27 1B               dec de              ; move de back to state
 66+  CB28 3E 02            ld a,2
 67+  CB2A 12               ld (de),a           ; set the state to wobbling
 68+  CB2B 1B               dec de              ; move back coords
 69+  CB2C C1               pop bc              ; get back coords
 70+  CB2D 78               ld a,b
 71+  CB2E 12               ld (de),a           ; store the vertical
 72+  CB2F 1B               dec de
 73+  CB30 79               ld a,c
 74+  CB31 12               ld (de),a           ; store the horizontal
 75+  CB32 C5               push bc
 76+  CB33 C3 3A CB         jp rocks_addrocktofalling2 ; done
 77+  CB36              rocks_addrocktofalling1:
 78+  CB36 13               inc de
 79+  CB37 13               inc de              ; move memory along to next rock
 80+  CB38 10 E0            djnz rocks_addrocktofalling0 ; try the next rock
 81+  CB3A              rocks_addrocktofalling2: ; done, return
 82+  CB3A C1               pop bc              ; to tidy up
 83+  CB3B C9               ret
 84+  CB3C
 85+  CB3C              ;
 86+  CB3C              ; Processes any falling rocks
 87+  CB3C              ;
 88+  CB3C              rocks_processrocks:
 89+  CB3C DD 21 F4 CA      ld ix,rocks_falling
 90+  CB40 06 04            ld b,4              ; the number of rocks to check
 91+  CB42              rocks_processrocks0:
 92+  CB42 C5               push bc             ; store loop count
 93+  CB43 DD 4E 00 DD      ld bc,(ix)          ; load the coords for this rock into bc
 93+  CB47 46 01
 94+  CB49 DD 23            inc ix
 95+  CB4B DD 23            inc ix              ; move to the state
 96+  CB4D DD 7E 00         ld a,(ix)           ; load the state into a
 97+  CB50 FE 00            cp 0
 98+  CB52 CA 73 CB         jp z,rocks_processrocks3 ; if not falling, check next
 99+  CB55 FE 02            cp 2
100+  CB57 C2 67 CB         jp nz, rocks_processrocks2
101+  CB5A                  ; we're wobbling
102+  CB5A DD 23            inc ix              ; get frame number for wobble
103+  CB5C DD 7E 00         ld a,(ix)           ; get wobble frame into a
104+  CB5F CD 36 CC         call rocks_wobble
105+  CB62 DD 23            inc ix              ; increment for next
106+  CB64 C3 77 CB         jp rocks_processrocks1  ; do next rock
107+  CB67              rocks_processrocks2:
108+  CB67                  ; we're falling
109+  CB67 C5               push bc
110+  CB68 CD 7B CB         call rocks_fall
111+  CB6B C1               pop bc
112+  CB6C DD 23            inc ix
113+  CB6E DD 23            inc ix              ; inc ix to get to next
114+  CB70 C3 77 CB         jp rocks_processrocks1
115+  CB73              rocks_processrocks3:
116+  CB73 DD 23            inc ix
117+  CB75 DD 23            inc ix
118+  CB77              rocks_processrocks1:
119+  CB77 C1               pop bc              ; get loop count back
120+  CB78 10 C8            djnz rocks_processrocks0
121+  CB7A C9               ret
122+  CB7B
123+  CB7B              ;
124+  CB7B              ; Falls a rock one pixel, checks the next square down to see if it is empty, if not, stop falling
125+  CB7B              ; bc - coord of current rock graphic on screen
126+  CB7B              ; ix - memory location of current rock in rock list, currently at the 3rd position (rock state)
127+  CB7B              ;
128+  CB7B              rocks_fall:
129+  CB7B DD 2B            dec ix
130+  CB7D DD 2B            dec ix              ; decrease ix back to coords
131+  CB7F ED 43 05 CB      ld (rocks_tmp2),bc  ; store original coords
132+  CB83 3E 03            ld a,3              ; move this number of pixels
133+  CB85              rocks_fall1:
134+  CB85 32 04 CB         ld (rocks_tmp),a    ; store loop counter
135+  CB88 DD 4E 00 DD      ld bc,(ix)          ; get current coords
135+  CB8C 46 01
136+  CB8E CD 01 AC         call sprites_scadd  ; get the memory of the coords into de
137+  CB91 14               inc d               ; add 256 to get next row
138+  CB92 1A               ld a,(de)           ; get the contents of the next row
139+  CB93 FE 00            cp 0
140+  CB95 C2 F5 CB         jp nz,rocks_fall3    ; move the rock if the row is empty
141+  CB98 0C               inc c               ; increment the vertical
142+  CB99 DD 71 00 DD      ld (ix),bc          ; store the new coords
142+  CB9D 70 01
143+  CB9F 79               ld a,c              ; get the vertical coord into a
144+  CBA0 E6 07            and 7               ; divisible by 8?
145+  CBA2 FE 00            cp 0
146+  CBA4 C2 C1 CB         jp nz,rocks_fall4   ; if not, carry on
147+  CBA7 CD 3A AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
148+  CBAA 3E 42            ld a,66             ; load red
149+  CBAC CD 92 AA         call screen_setattr
150+  CBAF DD 4E 00 DD      ld bc,(ix)
150+  CBB3 46 01
151+  CBB5 79               ld a,c              ; get vertical
152+  CBB6 D6 08            sub 8               ; look up one square
153+  CBB8 4F               ld c,a              ; put a back in c
154+  CBB9 CD 3A AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
155+  CBBC 3E 46            ld a,70             ; load yellow
156+  CBBE CD 92 AA         call screen_setattr
157+  CBC1              rocks_fall4:
158+  CBC1 3A 04 CB         ld a,(rocks_tmp)    ; get the loop counter
159+  CBC4 3D               dec a
160+  CBC5 FE 00            cp 0
161+  CBC7 C2 85 CB         jp nz,rocks_fall1   ; do another pixel if needed
162+  CBCA              rocks_fall2:
163+  CBCA 3E 09            ld a,9              ; rock graphic
164+  CBCC ED 4B 05 CB      ld bc,(rocks_tmp2)  ; get the original coords
165+  CBD0 CD 87 AA         call screen_getblock     ; get the memory into hl
166+  CBD3 CD 0C AB         call sprites_drawsprite  ; draw the sprite - over the top of the current one
167+  CBD6 3E 09            ld a,9
168+  CBD8 DD 4E 00 DD      ld bc,(ix)          ; get the new coords
168+  CBDC 46 01
169+  CBDE CD 87 AA         call screen_getblock     ; get the memory into hl
170+  CBE1 CD 0C AB         call sprites_drawsprite  ; draw the sprite - over the top of the current one
171+  CBE4 DD 4E 00 DD      ld bc,(ix)          ; get the coords again
171+  CBE8 46 01
172+  CBEA CD 1B CC         call rocks_checkforplayer ; check to see if we hit a player
173+  CBED DD 23            inc ix
174+  CBEF DD 23            inc ix                  ; get ix back to state
175+  CBF1 CD 0B CC         call rocks_makesound
176+  CBF4 C9               ret
177+  CBF5              rocks_fall3:
178+  CBF5 3E 00            ld a,0              ; set the state to fell
179+  CBF7 DD 77 02         ld (ix+2),a           ; store the falling state
180+  CBFA DD 4E 00 DD      ld bc,(ix)          ; get the coords
180+  CBFE 46 01
181+  CC00 CD 3A AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
182+  CC03 3E 42            ld a,66             ; load magenta
183+  CC05 CD 92 AA         call screen_setattr
184+  CC08 C3 CA CB         jp rocks_fall2      ; rejoin main loop
185+  CC0B
186+  CC0B              ;
187+  CC0B              ; Makes the rock sound if we're no longer falling, and if we didn't hit a player
188+  CC0B              ;
189+  CC0B              rocks_makesound:
190+  CC0B DD 7E 00         ld a,(ix)           ; get the state
191+  CC0E FE 00            cp 0
192+  CC10 C0               ret nz              ; if we haven't fallen, don't do anything
193+  CC11 21 82 C5         ld hl,player+11
194+  CC14 7E               ld a,(hl)
195+  CC15 FE 01            cp 1
196+  CC17 C4 B8 B1         call nz, sound_rockfell ; only make sound if didn't kill player
197+  CC1A C9               ret
198+  CC1B
199+  CC1B              ;
200+  CC1B              ; Checks to see if the rock is hitting a player
201+  CC1B              ; Inputs:
202+  CC1B              ; bc - coords of rock we're checking
203+  CC1B              rocks_checkforplayer:
204+  CC1B ED 5B 77 C5      ld de,(player)       ; get the player coords
205+  CC1F 7B               ld a,e               ; get the vert coord first
206+  CC20 91               sub c                ; subtract the rock vertical coord from players
207+  CC21 FE 08            cp 8                 ; the rock will only hit a player if the player is directly underneath, so this must be 8
208+  CC23 C0               ret nz               ; if not, hasn't hit
209+  CC24 7A               ld a,d               ; get the player horiz coord
210+  CC25 90               sub b                ; subtract rock coord
211+  CC26 C6 07            add 7                ; add max distance
212+  CC28 FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
213+  CC2A DA 2E CC         jp c,rocks_checkforplayer0
214+  CC2D C9               ret
215+  CC2E              rocks_checkforplayer0:
216+  CC2E ED 43 08 CB      ld (rocks_killerrock),bc; store the coords of the killer rock
217+  CC32 CD 9A C6         call player_crushplayer ; if so, jump out
218+  CC35 C9               ret
219+  CC36
220+  CC36              ;
221+  CC36              ; Wobbles a rocks
222+  CC36              ; Inputs:
223+  CC36              ; bc - coord of current rock graphic on screen
224+  CC36              ; ix - memory location of current rock in rock list, currently at the 4th position (wobble count)
225+  CC36              ; a - wobble frame
226+  CC36              rocks_wobble:
227+  CC36 DD 7E 00         ld a,(ix)           ; get the wobble count, which we'll use as frame toggle
228+  CC39 E6 01            and 1               ; is it odd or even, gets 1 or 0
229+  CC3B 1E 09            ld e,9              ; this is the rock frame
230+  CC3D 83               add a,e             ; add the frame toggle
231+  CC3E C5               push bc
232+  CC3F CD 87 AA         call screen_getblock     ; get the memory into hl
233+  CC42 CD 0C AB         call sprites_drawsprite  ; draw the sprite - over the top of the current one
234+  CC45 DD 7E 00         ld a,(ix)           ; get the frame toggle again
235+  CC48 3D               dec a               ; decrease
236+  CC49 DD 77 00         ld (ix),a           ; store
237+  CC4C E6 01            and 1
238+  CC4E 1E 09            ld e,9              ; this is the rock frame
239+  CC50 83               add a,e             ; add the frame toggle
240+  CC51 CD 87 AA         call screen_getblock     ; get the memory into hl
241+  CC54 C1               pop bc
242+  CC55 CD 0C AB         call sprites_drawsprite  ; draw the sprite again with the new frame - next time it will do the opposite
243+  CC58 DD 7E 00         ld a,(ix)           ; get the wobble count back
244+  CC5B FE 00            cp 0
245+  CC5D C0               ret nz              ; if we're not at zero, return
246+  CC5E DD 2B            dec ix              ; otherwise look to state location
247+  CC60 3E 01            ld a,1              ; set the state to falling
248+  CC62 DD 77 00         ld (ix),a           ; store the falling state
249+  CC65 DD 23            inc ix              ; set ix back to location of wobble count, and we're done
250+  CC67 C9               ret
251+  CC68
# file closed: game/rocks.asm
160   CC68                  include "game\scores.asm"
# file opened: game/scores.asm
  1+  CC68              ;
  2+  CC68              ; The score of the current player
  3+  CC68              ;
  4+  CC68              scores_current:
  5+  CC68 04 01 30 30      defb 4,1,'000000',255       ;+2
  5+  CC6C 30 30 30 30
  5+  CC70 FF
  6+  CC71
  7+  CC71              scores_defaultname:
  8+  CC71 2D 2D 2D         defb '---'
  9+  CC74
 10+  CC74              ;
 11+  CC74              ; The current high score table
 12+  CC74              ;
 13+  CC74              scores_table:
 14+  CC74 03 17 47 41      defb 03,23,'GAM000000',255         ;+0, +2, +5
 14+  CC78 4D 30 30 30
 14+  CC7C 30 30 30 FF
 15+  CC80 0C 17 47 41      defb 12,23,'GAM000000',255        ;+12, +14, +17
 15+  CC84 4D 30 30 30
 15+  CC88 30 30 30 FF
 16+  CC8C 15 17 47 41      defb 21,23,'GAM000000',255        ;+24, +26, +29
 16+  CC90 4D 30 30 30
 16+  CC94 30 30 30 FF
 17+  CC98
 18+  CC98              ;
 19+  CC98              ; Add thousands to the score
 20+  CC98              ; Inputs:
 21+  CC98              ; b - number to add
 22+  CC98              ;
 23+  CC98              scores_addthousands:
 24+  CC98 21 6C CC         ld hl,scores_current+4
 25+  CC9B CD FC CC         call scores_update
 26+  CC9E C9               ret
 27+  CC9F
 28+  CC9F              ;
 29+  CC9F              ; Add hundreds to the score
 30+  CC9F              ; Inputs:
 31+  CC9F              ; b - number to add
 32+  CC9F              ;
 33+  CC9F              scores_addhundreds:
 34+  CC9F 21 6D CC         ld hl,scores_current+5
 35+  CCA2 CD FC CC         call scores_update
 36+  CCA5 C9               ret
 37+  CCA6
 38+  CCA6              ;
 39+  CCA6              ; Temporary area for printing scores
 40+  CCA6              ;
 41+  CCA6              scores_printscore_tmp:
 42+  CCA6 00 00 00 00      defb 0,0,0,0,0,0,0,0,255
 42+  CCAA 00 00 00 00
 42+  CCAE FF
 43+  CCAF
 44+  CCAF              ;
 45+  CCAF              ; Prints the score to screen
 46+  CCAF              ;
 47+  CCAF              scores_printscore:
 48+  CCAF 3A 88 C4         ld a,(game_currentplayer)   ; get current player
 49+  CCB2 21 68 CC         ld hl,scores_current
 50+  CCB5 FE 01            cp 1
 51+  CCB7 C2 BF CC         jp nz, score_printscore0    ; if not player 1
 52+  CCBA 36 04            ld (hl),4       ; set position for player 1
 53+  CCBC C3 C1 CC         jp score_printscore1
 54+  CCBF              score_printscore0:
 55+  CCBF 36 16            ld (hl),22       ; set position for player 2
 56+  CCC1              score_printscore1:
 57+  CCC1 CD C5 CC         call score_printscoreformatted
 58+  CCC4 C9               ret
 59+  CCC5
 60+  CCC5              ;
 61+  CCC5              ; Formats a score and prints to the top screen
 62+  CCC5              ; Inputs:
 63+  CCC5              ; hl - where is the score
 64+  CCC5              score_printscoreformatted:
 65+  CCC5 01 08 00         ld bc,8
 66+  CCC8 11 A6 CC         ld de,scores_printscore_tmp
 67+  CCCB ED B0            ldir                        ; copy to temp
 68+  CCCD 21 A6 CC         ld hl,scores_printscore_tmp
 69+  CCD0 E5 DD E1         ld ix,hl
 70+  CCD3 DD 7E 02         ld a,(ix+2)
 71+  CCD6 FE 30            cp 48                   ; is it a leading zero?
 72+  CCD8 C2 EB CC         jp nz,score_printscore2
 73+  CCDB DD 36 02 20      ld (ix+2),32              ; load it with a space
 74+  CCDF DD 7E 03         ld a,(ix+3)
 75+  CCE2 FE 30            cp 48                   ; is it a leading zero?
 76+  CCE4 C2 EB CC         jp nz,score_printscore2
 77+  CCE7 DD 36 03 20      ld (ix+3),32              ; load it with a space
 78+  CCEB              score_printscore2:
 79+  CCEB CD 28 86         call string_print
 80+  CCEE C9               ret
 81+  CCEF
 82+  CCEF              ;
 83+  CCEF              ; Prints both scores to screen
 84+  CCEF              ;
 85+  CCEF              scores_printscores:
 86+  CCEF 21 80 C6         ld hl,player1_score
 87+  CCF2 CD C5 CC         call score_printscoreformatted
 88+  CCF5 21 89 C6         ld hl,player2_score
 89+  CCF8 CD C5 CC         call score_printscoreformatted
 90+  CCFB C9               ret
 91+  CCFC
 92+  CCFC              ;
 93+  CCFC              ; Updates the current score.
 94+  CCFC              ; Inputs:
 95+  CCFC              ; hl - memory location of the score column
 96+  CCFC              ; b - number to add
 97+  CCFC              ;
 98+  CCFC              scores_update:
 99+  CCFC 7E               ld a,(hl)           ; current value of digit.
100+  CCFD 80               add a,b             ; add points to this digit.
101+  CCFE 77               ld (hl),a           ; place new digit back in string.
102+  CCFF FE 3A            cp 58               ; more than ASCII value '9'?
103+  CD01 D8               ret c               ; no - relax.
104+  CD02 D6 0A            sub 10              ; subtract 10.
105+  CD04 77               ld (hl),a           ; put new character back in string.
106+  CD05              scores_update0:
107+  CD05 2B               dec hl              ; previous character in string.
108+  CD06 34               inc (hl)            ; up this by one.
109+  CD07 7E               ld a,(hl)           ; what's the new value?
110+  CD08 FE 3A            cp 58               ; gone past ASCII nine?
111+  CD0A D8               ret c               ; no, scoring done.
112+  CD0B D6 0A            sub 10              ; down by ten.
113+  CD0D 77               ld (hl),a           ; put it back
114+  CD0E C3 05 CD         jp scores_update0   ; go round again.
115+  CD11
116+  CD11
117+  CD11              ;
118+  CD11              ; Temporary area to store score
119+  CD11              ;
120+  CD11              scores_showtable_tmp:
121+  CD11 00 00 00 00      defb 0,0,0,0,0,0,0,0,0,0,0,255
121+  CD15 00 00 00 00
121+  CD19 00 00 00 FF
122+  CD1D
123+  CD1D              ;
124+  CD1D              ; Processes a score
125+  CD1D              ; Inputs:
126+  CD1D              ; hl - location on table
127+  CD1D              ;
128+  CD1D              scores_showtable_process:
129+  CD1D 01 0B 00         ld bc,11                     ; copy this many
130+  CD20 11 11 CD         ld de,scores_showtable_tmp
131+  CD23 ED B0            ldir
132+  CD25 DD 21 11 CD      ld ix,scores_showtable_tmp   ; decide whether to show five or six numbers
133+  CD29 DD 7E 05         ld a,(ix+5)
134+  CD2C FE 30            cp 48                        ; is this a zero?
135+  CD2E C2 44 CD         jp nz,scores_showtable_process0 ; if not, show the whole thing
136+  CD31 01 05 00         ld bc,5                      ; copy this many
137+  CD34 DD E5 E1         ld hl,ix
138+  CD37 11 06 00         ld de,6
139+  CD3A 19               add hl,de                    ; move to second digit
140+  CD3B 54 5D            ld de,hl
141+  CD3D 1B               dec de
142+  CD3E ED B0            ldir
143+  CD40 DD 36 0A 20      ld (ix+10),32                ; stick a space at the end
144+  CD44              scores_showtable_process0:
145+  CD44 21 11 CD         ld hl,scores_showtable_tmp
146+  CD47 CD 28 86         call string_print
147+  CD4A C9               ret
148+  CD4B
149+  CD4B              ;
150+  CD4B              ; Displays the high score table at the bottom of the screen
151+  CD4B              ;
152+  CD4B              scores_showtable:
153+  CD4B 21 74 CC         ld hl, scores_table
154+  CD4E CD 1D CD         call scores_showtable_process
155+  CD51 21 80 CC         ld hl, scores_table+12
156+  CD54 CD 1D CD         call scores_showtable_process
157+  CD57 21 8C CC         ld hl, scores_table+24
158+  CD5A CD 1D CD         call scores_showtable_process
159+  CD5D C9               ret
160+  CD5E
161+  CD5E              ;
162+  CD5E              ; Place to store the current position we're checking
163+  CD5E              ;
164+  CD5E              scores_highscoretmp:
165+  CD5E 00               defb 0
166+  CD5F
167+  CD5F              ;
168+  CD5F              ; Place to store the equal indicator
169+  CD5F              ;
170+  CD5F              scores_highscoretmp2:
171+  CD5F 00               defb 0
172+  CD60
173+  CD60              ;
174+  CD60              ; Updates the highscore table. Start at bottom score. Work way from left. Compare each digit. If current is higher than one we're checking,
175+  CD60              ; copy checking one down (or erase) then copy current over that one. Then move up one and do the same
176+  CD60              ;
177+  CD60              scores_processhighscores:
178+  CD60 21 5E CD         ld hl,scores_highscoretmp
179+  CD63 36 00            ld (hl),0  ; load up the tracking byte with 0 (ie, not on the table)
180+  CD65 3E 1D            ld a,29
181+  CD67              scores_processhighscores3:
182+  CD67 21 74 CC         ld hl,scores_table          ; position of first score column
183+  CD6A 5F               ld e,a
184+  CD6B 16 00            ld d,0
185+  CD6D 19               add hl,de
186+  CD6E 08               ex af,af'                   ; store a for later
187+  CD6F 11 6A CC         ld de,scores_current+2      ; position of current score column
188+  CD72 3E 01            ld a,1
189+  CD74 32 5F CD         ld (scores_highscoretmp2),a ; set the equal indicator to 1 - this will be set to zero if a different number is found
190+  CD77 06 06            ld b,6                      ; times to loop
191+  CD79              scores_processhighscores0:
192+  CD79 7E               ld a,(hl)
193+  CD7A 4F               ld c,a                      ; get first score column
194+  CD7B 1A               ld a,(de)                   ; get first current column
195+  CD7C B9               cp c                        ; compare current with first
196+  CD7D DA 9F CD         jp c,scores_processhighscores4  ; if c is bigger, then this is not a higher score, so end
197+  CD80 CA 88 CD         jp z,scores_processhighscores5  ; if c is equal, then this is not a higher score, so end
198+  CD83 3E 00            ld a,0
199+  CD85 32 5F CD         ld (scores_highscoretmp2),a ; zero the equality indicator
200+  CD88              scores_processhighscores5:
201+  CD88 23               inc hl
202+  CD89 13               inc de                      ; move to next column
203+  CD8A 10 ED            djnz scores_processhighscores0 ; loop
204+  CD8C 3A 5F CD         ld a,(scores_highscoretmp2)   ; get the equality indicator
205+  CD8F FE 01            cp 1
206+  CD91 CA 9F CD         jp z,scores_processhighscores4 ; if it is equal, not a highscore
207+  CD94 B7               or a                            ; clear the carry flag
208+  CD95 08               ex af,af'                     ; still here, so must be bigger
209+  CD96 32 5E CD         ld (scores_highscoretmp),a  ; store the position indicator in the tracking byte
210+  CD99 0E 0C            ld c,12
211+  CD9B 91               sub c
212+  CD9C D2 67 CD         jp nc,scores_processhighscores3 ; if the place we're looking is less than zero, we've gone to far, so continue, otherwise go again
213+  CD9F              scores_processhighscores4
214+  CD9F CD A3 CD         call scores_updatehighscores
215+  CDA2 C9               ret
216+  CDA3
217+  CDA3              ;
218+  CDA3              ; Update score table
219+  CDA3              ;
220+  CDA3              scores_updatehighscores:
221+  CDA3 3A 5E CD         ld a,(scores_highscoretmp)  ; get the place we want to overwrite
222+  CDA6 FE 00            cp 0
223+  CDA8 C8               ret z                       ; if this is 0, didn't get a high score
224+  CDA9 FE 1D            cp 29                       ; check against 29... if it's equal, we don't want to copy the current score down one
225+  CDAB CA DE CD         jp z, scores_updatehighscores3
226+  CDAE                                              ; copy old score over one below, if not first
227+  CDAE 21 74 CC         ld hl,scores_table
228+  CDB1 11 11 00         ld de,17                    ; start at second score, because this is the first one we'd ever need to copy...
229+  CDB4 19               add hl,de                   ; position of first column
230+  CDB5 2B               dec hl
231+  CDB6 2B               dec hl
232+  CDB7 2B               dec hl
233+  CDB8 E5               push hl
234+  CDB9 11 0C 00         ld de,12
235+  CDBC 19               add hl,de                   ; get position of next score
236+  CDBD 54 5D            ld de,hl
237+  CDBF E1               pop hl                      ; get hl back
238+  CDC0 01 09 00         ld bc,9
239+  CDC3 ED B0            ldir
240+  CDC5 FE 11            cp 17                       ; see if we're copying into the second place slot (17 memory offset). If so, stop copying back the scores
241+  CDC7 CA DE CD         jp z,scores_updatehighscores3
242+  CDCA 21 74 CC         ld hl,scores_table
243+  CDCD 11 02 00         ld de,2                    ; ... otherwise, copy back the first score
244+  CDD0 19               add hl,de                   ; position of first column
245+  CDD1 E5               push hl
246+  CDD2 11 0C 00         ld de,12
247+  CDD5 19               add hl,de                   ; get position of next score
248+  CDD6 54 5D            ld de,hl
249+  CDD8 E1               pop hl                      ; get hl back
250+  CDD9 01 09 00         ld bc,9
251+  CDDC ED B0            ldir
252+  CDDE              scores_updatehighscores3:
253+  CDDE 06 06            ld b,6                      ; now overwrite
254+  CDE0 21 74 CC         ld hl,scores_table
255+  CDE3 16 00            ld d,0
256+  CDE5 5F               ld e,a
257+  CDE6 19               add hl,de                   ; position of first column
258+  CDE7 08               ex af,af'
259+  CDE8 11 6A CC         ld de,scores_current+2      ; position of current score column
260+  CDEB              scores_updatehighscores2:
261+  CDEB 1A               ld a,(de)
262+  CDEC 77               ld (hl),a
263+  CDED 23               inc hl
264+  CDEE 13               inc de
265+  CDEF 10 FA            djnz scores_updatehighscores2
266+  CDF1 11 09 00         ld de,9
267+  CDF4 ED 52            sbc hl,de
268+  CDF6 54 5D            ld de,hl                    ; get back to start of entry
269+  CDF8 21 71 CC         ld hl,scores_defaultname    ; still need to overwrite the name
270+  CDFB 01 03 00         ld bc,3                      ; 3 chars to copy
271+  CDFE ED B0            ldir
272+  CE00 C9               ret
# file closed: game/scores.asm
161   CE01                  include "game\diamonds.asm"
# file opened: game/diamonds.asm
  1+  CE01              diamonds_tmp:
  2+  CE01 00               defb 0
  3+  CE02
  4+  CE02              diamonds_tmp2:
  5+  CE02 00               defb 0
  6+  CE03
  7+  CE03              ;
  8+  CE03              ; Holds the number of thousands for the current gem type
  9+  CE03              ;
 10+  CE03              diamonds_score:
 11+  CE03 00               defb 0
 12+  CE04
 13+  CE04              ;
 14+  CE04              ; Changes the attribute of gem and diamond cells based on the frame count
 15+  CE04              ; Inputs:
 16+  CE04              ; hl - memory location of gem type
 17+  CE04              diamonds_twinkle_type:
 18+  CE04 CD 21 C5         call game_getcurrentframe       ; get current frame number
 19+  CE07 E6 07            and 7                           ; want a number from 0-7
 20+  CE09 C6 40            add 64                          ; add to 60 to get attr colour
 21+  CE0B 32 02 CE         ld (diamonds_tmp2),a             ; store the colour
 22+  CE0E              diamonds_twinkle_type0:
 23+  CE0E 4E 23 46 2B      ld bc,(hl)                      ; get coords into bc
 24+  CE12 79               ld a,c                          ; load c into a
 25+  CE13 FE FF            cp 255                          ; is this the end?
 26+  CE15 CA 3D CE         jp z,diamonds_twinkle_type1           ; step out if so
 27+  CE18 23               inc hl
 28+  CE19 23               inc hl
 29+  CE1A 7E               ld a,(hl)                       ; check the state, don't process if collected
 30+  CE1B FE 01            cp 1
 31+  CE1D CA 3E CE         jp z,diamonds_twinkle_type2           ; step out if so
 32+  CE20 CD 7E CE         call diamonds_checkforplayer    ; check to see if we've collided with player
 33+  CE23 DC 45 CE         call c,diamonds_collect     ; we collided
 34+  CE26 23               inc hl
 35+  CE27 E5               push hl
 36+  CE28 E5 DD E1         ld ix,hl
 37+  CE2B DD 4E FD DD      ld bc,(ix-3)                    ; get coords again
 37+  CE2F 46 FE
 38+  CE31 3A 02 CE         ld a,(diamonds_tmp2)
 39+  CE34 CD 92 AA         call screen_setattr
 40+  CE37 E1               pop hl
 41+  CE38 23               inc hl
 42+  CE39 23               inc hl                          ; move to next diamond
 43+  CE3A C3 0E CE         jp diamonds_twinkle_type0
 44+  CE3D              diamonds_twinkle_type1:
 45+  CE3D C9               ret
 46+  CE3E              diamonds_twinkle_type2:
 47+  CE3E 23               inc hl                          ; do stuff the we would have done anyway to get to next gem
 48+  CE3F 23               inc hl
 49+  CE40 23               inc hl
 50+  CE41 08               ex af,af'
 51+  CE42 C3 0E CE         jp diamonds_twinkle_type0       ; rejoin main loop
 52+  CE45
 53+  CE45              ;
 54+  CE45              ; Collect the diamond we collided with
 55+  CE45              ; Inputs:
 56+  CE45              ; hl - memory location of current diamond, currently on state
 57+  CE45              ; Output:
 58+  CE45              ; a - 70 - for yellow on black
 59+  CE45              diamonds_collect:
 60+  CE45 36 01            ld (hl),1                       ; collected
 61+  CE47 E5               push hl
 62+  CE48 2B               dec hl
 63+  CE49 2B               dec hl
 64+  CE4A 4E 23 46 2B      ld bc,(hl)                      ; get the coords
 65+  CE4E CD 4A AA         call screen_getscreencoordsfromcharcoords ; get the screen coords into bc
 66+  CE51 ED 5B 01 CE      ld de,(diamonds_tmp)            ; tmp stores the offset for this type of gem
 67+  CE55 16 00            ld d,0
 68+  CE57 21 D9 BC         ld hl,sprites
 69+  CE5A 19               add hl,de
 70+  CE5B CD 0C AB         call sprites_drawsprite     ; call the routine to draw the sprite
 71+  CE5E E1               pop hl
 72+  CE5F 3E 46            ld a,70                     ; pass this back to overwrite the attr
 73+  CE61 32 02 CE         ld (diamonds_tmp2),a
 74+  CE64 D9               exx
 75+  CE65 3A 03 CE         ld a,(diamonds_score)
 76+  CE68 47               ld b,a
 77+  CE69 CD 98 CC         call scores_addthousands
 78+  CE6C 3A 01 CE         ld a,(diamonds_tmp)
 79+  CE6F FE 40            cp 64                       ; check the gem type offset, if its 64 this is a diamond, so mark the level as completable
 80+  CE71 C2 79 CE         jp nz,diamonds_collect0
 81+  CE74 21 84 C5         ld hl,player+13
 82+  CE77 36 01            ld (hl),1                   ; mark the player as able to complete the level
 83+  CE79              diamonds_collect0:
 84+  CE79 CD 90 B1         call sound_gemcollected
 85+  CE7C D9               exx
 86+  CE7D C9               ret
 87+  CE7E
 88+  CE7E              ;
 89+  CE7E              ; Checks to see if the gem is hitting a player
 90+  CE7E              ; Inputs:
 91+  CE7E              ; bc - coords of diamond we're checking
 92+  CE7E              diamonds_checkforplayer:
 93+  CE7E 78               ld a,b               ; multiply b by 8
 94+  CE7F 07               rlca
 95+  CE80 07               rlca
 96+  CE81 07               rlca
 97+  CE82 47               ld b,a
 98+  CE83 ED 5B 77 C5      ld de,(player)       ; get the player coords
 99+  CE87 7B               ld a,e               ; get the vert coord first
100+  CE88 90               sub b                ; subtract the diamond vertical coord from players
101+  CE89 C6 04            add 4                ; add the max distance
102+  CE8B FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
103+  CE8D D0               ret nc               ; if not, hasn't hit
104+  CE8E 79               ld a,c               ; multiply c by 8
105+  CE8F 07               rlca
106+  CE90 07               rlca
107+  CE91 07               rlca
108+  CE92 4F               ld c,a
109+  CE93 7A               ld a,d               ; get the player horiz coord
110+  CE94 91               sub c                ; subtract rock coord
111+  CE95 C6 04            add 4                ; add max distance
112+  CE97 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
113+  CE99 D0               ret nc
114+  CE9A 3E 00            ld a,0
115+  CE9C C9               ret
116+  CE9D
117+  CE9D
118+  CE9D              ;
119+  CE9D              ; Initialise diamonds and gems
120+  CE9D              ;
121+  CE9D              diamonds_twinkle
122+  CE9D 21 03 CE         ld hl,diamonds_score
123+  CEA0 36 02            ld (hl),2         ; store the score we'll add
124+  CEA2 21 01 CE         ld hl,diamonds_tmp
125+  CEA5 36 40            ld (hl),64         ; store the location the diamond sprite
126+  CEA7 21 54 B8         ld hl, level_diamonds
127+  CEAA CD 04 CE         call diamonds_twinkle_type
128+  CEAD 21 03 CE         ld hl,diamonds_score
129+  CEB0 36 01            ld (hl),1         ; store the score we'll add
130+  CEB2 21 01 CE         ld hl,diamonds_tmp
131+  CEB5 36 70            ld (hl),112         ; store the location the gem sprite
132+  CEB7 21 64 B8         ld hl, level_gems
133+  CEBA CD 04 CE         call diamonds_twinkle_type
134+  CEBD C9               ret
135+  CEBE
136+  CEBE              ;
137+  CEBE              ; Initialise diamonds and gems
138+  CEBE              ;
139+  CEBE              diamonds_init:
140+  CEBE 21 54 B8         ld hl, level_diamonds
141+  CEC1 CD CB CE         call diamonds_init_type
142+  CEC4 21 64 B8         ld hl, level_gems
143+  CEC7 CD CB CE         call diamonds_init_type
144+  CECA C9               ret
145+  CECB
146+  CECB              ;
147+  CECB              ; Initialise diamonds or gems, get memory addresses
148+  CECB              ; Inputs:
149+  CECB              ; hl - memory location
150+  CECB              diamonds_init_type:
151+  CECB 4E               ld c,(hl)                      ; get coords into c
152+  CECC 79               ld a,c                          ; load c into add
153+  CECD FE FF            cp 255                          ; is this the end?
154+  CECF CA E6 CE         jp z,diamonds_init_type1             ; step out if so
155+  CED2 23               inc hl
156+  CED3 46               ld b,(hl)                       ; get coords into b
157+  CED4 E5               push hl
158+  CED5 CD FB A9         call screen_getcellattroffset ; get memory of attr for this diamond into de
159+  CED8 E1               pop hl
160+  CED9 23               inc hl                          ; move to state
161+  CEDA 36 00            ld (hl),0
162+  CEDC 23               inc hl                          ; move to memory
163+  CEDD 73 23 72 2B      ld (hl),de                      ; store the memory location
164+  CEE1 23               inc hl                          ; move to next diamond
165+  CEE2 23               inc hl
166+  CEE3 C3 CB CE         jp diamonds_init_type
167+  CEE6              diamonds_init_type1:
168+  CEE6 C9               ret
# file closed: game/diamonds.asm
162   CEE7                  include "game\missiles.asm"
# file opened: game/missiles.asm
  1+  CEE7              ;
  2+  CEE7              ; Controls when missiles fall
  3+  CEE7              ;
  4+  CEE7              missiles_count:
  5+  CEE7 00               defb 0
  6+  CEE8
  7+  CEE8              ;
  8+  CEE8              ; A structure of falling missiles
  9+  CEE8              ; Assume we'll never have more than 4 falling at any one time
 10+  CEE8              ; (1,2 - 16 bit memory location for missile graphic),state (0 fell, 1 falling)
 11+  CEE8              ;
 12+  CEE8              missiles_falling:
 13+  CEE8 00 00 00         defb 0,0,0
 14+  CEEB 00 00 00         defb 0,0,0
 15+  CEEE 00 00 00         defb 0,0,0
 16+  CEF1 00 00 00         defb 0,0,0
 17+  CEF4
 18+  CEF4              ;
 19+  CEF4              ; The coords of the missile that killed us
 20+  CEF4              ;
 21+  CEF4              missiles_killermissile:
 22+  CEF4 00 00            defb 0,0
 23+  CEF6
 24+  CEF6              ;
 25+  CEF6              ; The speed of the missiles
 26+  CEF6              ;
 27+  CEF6              missiles_speed:
 28+  CEF6 00               defb 0
 29+  CEF7
 30+  CEF7              ;
 31+  CEF7              ; Zeroes the state of each missile
 32+  CEF7              ;
 33+  CEF7              missiles_init:
 34+  CEF7 06 0C            ld b,12
 35+  CEF9 DD 21 DB B7      ld ix,level_missiles
 36+  CEFD              missiles_init0:
 37+  CEFD DD 36 02 00      ld (ix+2),0               ; set the state to zero
 38+  CF01 11 05 00         ld de,5
 39+  CF04 DD 19            add ix,de
 40+  CF06 DD 36 02 00      ld (ix+2),0
 41+  CF0A DD 19            add ix,de
 42+  CF0C 10 EF            djnz missiles_init0
 43+  CF0E 06 04            ld b,4                  ; reset four falling missiles
 44+  CF10 21 E8 CE         ld hl,missiles_falling
 45+  CF13              missiles_init1:
 46+  CF13 36 00            ld (hl),0
 47+  CF15 23               inc hl
 48+  CF16 36 00            ld (hl),0
 49+  CF18 23               inc hl
 50+  CF19 36 00            ld (hl),0
 51+  CF1B 23               inc hl
 52+  CF1C 10 F5            djnz missiles_init1
 53+  CF1E C9               ret
 54+  CF1F
 55+  CF1F              ;
 56+  CF1F              ; Runs each frame and checks if a missile can fall, then selects one at random and adds to the falling missiles
 57+  CF1F              ; Processes any already falling missiles
 58+  CF1F              ;
 59+  CF1F              missiles_process:
 60+  CF1F 3A 82 C5         ld a,(player+11)                        ; check if the player was hit by a missile previously
 61+  CF22 FE 03            cp 3
 62+  CF24 C2 2B CF         jp nz,missiles_process3                 ; if not, continue
 63+  CF27 CD 6B D0         call missiles_zonkplayer
 64+  CF2A C9               ret
 65+  CF2B              missiles_process3:
 66+  CF2B 3A 86 C5         ld a,(player_location)
 67+  CF2E FE 01            cp 1
 68+  CF30 C2 A1 CF         jp nz, missiles_process0                ; if not 1 we're not in the cavern so no need to make any more fall
 69+  CF33 21 84 C5         ld hl,player+13
 70+  CF36 7E               ld a,(hl)                               ; check if player has collected a diamond
 71+  CF37 FE 01            cp 1
 72+  CF39 C2 A1 CF         jp nz, missiles_process0                ; don't activate if not
 73+  CF3C 21 E7 CE         ld hl,missiles_count
 74+  CF3F 7E               ld a,(hl)                   ; get the missiles count
 75+  CF40 3C               inc a
 76+  CF41 ED 5B F6 CE      ld de,(missiles_speed)
 77+  CF45 BB               cp e                                   ; have we reached the count yet
 78+  CF46 CA 4D CF         jp z,missiles_process2                 ; if not, don't activate a new one
 79+  CF49 77               ld (hl),a                               ; store the updated count, and continue without activating
 80+  CF4A C3 A1 CF         jp missiles_process0
 81+  CF4D              missiles_process2:
 82+  CF4D 36 00            ld (hl),0                               ; zero the counter
 83+  CF4F 1E 0C            ld e,12
 84+  CF51 CD B5 81         call utilities_randomupper              ; get random number from 0 to 11
 85+  CF54 11 0A 00         ld de,10
 86+  CF57 CD 00 81         call utilities_multiply                 ; multiple random number by 10
 87+  CF5A 54 5D            ld de,hl                                ; this is the offset for the random missile
 88+  CF5C DD 21 DB B7      ld ix,level_missiles                   ; load the location of the missile definitions
 89+  CF60 DD 19            add ix,de                               ; get to location of missile
 90+  CF62 DD 7E 02         ld a,(ix+2)
 91+  CF65 FE 00            cp 0
 92+  CF67 CA 77 CF         jp z,missiles_process1                  ; if this missile isn't active, activate it
 93+  CF6A 11 05 00         ld de,5                                 ; otherwise, check the missile above
 94+  CF6D DD 19            add ix,de
 95+  CF6F DD 7E 02         ld a,(ix+2)
 96+  CF72 FE 00            cp 0
 97+  CF74 C2 A1 CF         jp nz,missiles_process0                 ; if this is active as well, the player got lucky
 98+  CF77              missiles_process1:                          ; activate a missile
 99+  CF77 DD 36 02 01      ld (ix+2),1                               ; mark this missile as active
100+  CF7B DD 4E 00 DD      ld bc,(ix)                              ; get char coords from the missile
100+  CF7F 46 01
101+  CF81 78               ld a,b
102+  CF82 ED 5B DA A8      ld de,(screen_offset)          ; load the screen offset, this is in rows
103+  CF86 93               sub e
104+  CF87 CD 4A AA         call screen_getscreencoordsfromcharcoords ; get screen coords into bc
105+  CF8A C5               push bc
106+  CF8B 3E 0C            ld a,12                                 ; inactive missile sprite
107+  CF8D CD 87 AA         call screen_getblock
108+  CF90 CD 0C AB         call sprites_drawsprite                 ; draw the sprite over the old one
109+  CF93 C1               pop bc
110+  CF94 C5               push bc
111+  CF95 3E 14            ld a,20                                 ; active missile sprite
112+  CF97 CD 87 AA         call screen_getblock
113+  CF9A CD 0C AB         call sprites_drawsprite                 ; draw the sprite over the old one
114+  CF9D C1               pop bc
115+  CF9E CD 2F D0         call missiles_addmissiletofalling
116+  CFA1              missiles_process0:
117+  CFA1 CD A5 CF         call missiles_fall
118+  CFA4 C9               ret
119+  CFA5
120+  CFA5              ;
121+  CFA5              ; Processes falling missiles
122+  CFA5              ;
123+  CFA5              missiles_fall:
124+  CFA5 06 04            ld b,4              ; number of possible falling missiles
125+  CFA7 DD 21 E8 CE      ld ix,missiles_falling
126+  CFAB              missiles_fall0:
127+  CFAB C5               push bc
128+  CFAC DD 7E 02         ld a,(ix+2)
129+  CFAF FE 00            cp 0
130+  CFB1 CA 0E D0         jp z,missiles_fall1 ; not falling move to next
131+  CFB4 FE 01            cp 1                ; is this ready to fall
132+  CFB6 CA BC CF         jp z, missiles_fall3
133+  CFB9 C3 28 D0         jp missiles_fall4   ; if not, decrease the countdown
134+  CFBC              missiles_fall3:
135+  CFBC DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
135+  CFC0 46 01
136+  CFC2 CD 01 AC         call sprites_scadd  ; get the memory of the coords into de
137+  CFC5 14               inc d               ; add 256 to get next row
138+  CFC6 1A               ld a,(de)           ; get the contents of the next row
139+  CFC7 FE 00            cp 0
140+  CFC9 C2 21 D0         jp nz,missiles_fall2 ; if this is not empty, stop this missile falling
141+  CFCC 3E 14            ld a,20                                 ; active missile sprite
142+  CFCE CD 87 AA         call screen_getblock
143+  CFD1 CD 0C AB         call sprites_drawsprite                 ; draw the sprite over the old one
144+  CFD4 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
144+  CFD8 46 01
145+  CFDA 0C               inc c               ; move down one pixel
146+  CFDB DD 71 00 DD      ld (ix),bc          ; store the new coords
146+  CFDF 70 01
147+  CFE1 3E 14            ld a,20                                 ; active missile sprite
148+  CFE3 CD 87 AA         call screen_getblock
149+  CFE6 CD 0C AB         call sprites_drawsprite                 ; draw the sprite
150+  CFE9 DD 4E 00 DD      ld bc,(ix)          ; load coords into bc
150+  CFED 46 01
151+  CFEF 79               ld a,c              ; get the vertical coord into a
152+  CFF0 E6 07            and 7               ; divisible by 8?
153+  CFF2 FE 00            cp 0
154+  CFF4 C2 0E D0         jp nz,missiles_fall1   ; if not, carry on
155+  CFF7 CD 3A AA         call screen_getcharcoordsfromscreencoords ; get the char coords into bc
156+  CFFA 3E 43            ld a,67             ; load magenta
157+  CFFC CD 92 AA         call screen_setattr
158+  CFFF DD 4E 00 DD      ld bc,(ix)
158+  D003 46 01
159+  D005 CD 3A AA         call screen_getcharcoordsfromscreencoords ; get the attr address into de
160+  D008 05               dec b               ; look one square above
161+  D009 3E 46            ld a,70             ; load yellow
162+  D00B CD 92 AA         call screen_setattr
163+  D00E              missiles_fall1:         ; hl at state
164+  D00E DD 4E 00 DD      ld bc,(ix)          ; get coords back
164+  D012 46 01
165+  D014 CD 50 D0         call missiles_checkforplayer ; check for player
166+  D017 DD 23            inc ix
167+  D019 DD 23            inc ix
168+  D01B DD 23            inc ix              ; get to next missile
169+  D01D C1               pop bc
170+  D01E 10 8B            djnz missiles_fall0
171+  D020 C9               ret
172+  D021              missiles_fall2:
173+  D021 DD 36 02 00      ld (ix+2),0
174+  D025 C3 0E D0         jp missiles_fall1   ; rejoin the loop
175+  D028              missiles_fall4:
176+  D028 3D               dec a               ; decrease the countdown
177+  D029 DD 77 02         ld (ix+2),a         ; store back
178+  D02C C3 0E D0         jp missiles_fall1   ; do next missile
179+  D02F
180+  D02F              ;
181+  D02F              ; Adds the missile to the structure that tracks falling missile
182+  D02F              ; Inputs:
183+  D02F              ; bc - coords of missile, c vert
184+  D02F              missiles_addmissiletofalling:
185+  D02F C5               push bc             ; store the coords
186+  D030 11 E8 CE         ld de,missiles_falling
187+  D033 06 04            ld b,4              ; number of possible falling missiles
188+  D035              missiles_addmissiletofalling0:
189+  D035 13               inc de
190+  D036 13               inc de              ; move three along to get the state
191+  D037 1A               ld a,(de)           ; load the state
192+  D038 FE 00            cp 0                ; check if this is not falling
193+  D03A C2 4B D0         jp nz,missiles_addmissiletofalling1 ; continue the loop if not 0
194+  D03D 3E 19            ld a,25
195+  D03F 12               ld (de),a           ; set the state to pre-falling
196+  D040 1B               dec de              ; move back coords
197+  D041 C1               pop bc              ; get back coords
198+  D042 78               ld a,b
199+  D043 12               ld (de),a           ; store the vertical
200+  D044 1B               dec de
201+  D045 79               ld a,c
202+  D046 12               ld (de),a           ; store the horizontal
203+  D047 C5               push bc
204+  D048 C3 4E D0         jp missiles_addmissiletofalling2 ; done
205+  D04B              missiles_addmissiletofalling1:
206+  D04B 13               inc de              ; move memory along to next rock
207+  D04C 10 E7            djnz missiles_addmissiletofalling0 ; try the next missile
208+  D04E              missiles_addmissiletofalling2: ; done, return
209+  D04E C1               pop bc              ; to tidy up
210+  D04F C9               ret
211+  D050
212+  D050              ;
213+  D050              ; Checks to see if the missile is hitting a player
214+  D050              ; Inputs:
215+  D050              ; bc - coords of missile we're checking
216+  D050              missiles_checkforplayer:
217+  D050 ED 5B 77 C5      ld de,(player)       ; get the player coords
218+  D054 7B               ld a,e               ; get the vert coord first
219+  D055 91               sub c                ; subtract the missile vertical coord from players
220+  D056 FE 08            cp 8                 ; the missile will only hit a player if the player is directly underneath, so this must be 8
221+  D058 C0               ret nz               ; if not, hasn't hit
222+  D059 7A               ld a,d               ; get the player horiz coord
223+  D05A 90               sub b                ; subtract missile coord
224+  D05B C6 07            add 7                ; add max distance
225+  D05D FE 0D            cp 13                ; compare to 13? if carry flag set, they've hit
226+  D05F DA 63 D0         jp c,missiles_checkforplayer0
227+  D062 C9               ret
228+  D063              missiles_checkforplayer0:
229+  D063 ED 43 F4 CE      ld (missiles_killermissile),bc; store the coords of the killer missile
230+  D067 CD A6 C6         call player_zonkplayer ; if so, jump out
231+  D06A C9               ret
232+  D06B
233+  D06B              ;
234+  D06B              ; Player has been hit, so draw text over them and mark as dead
235+  D06B              ;
236+  D06B              missiles_zonkplayer:
237+  D06B CD 94 C6         call player_killplayer      ; mark as dead
238+  D06E ED 4B 77 C5      ld bc,(player)              ; get player coords
239+  D072 CD 3A AA         call screen_getcharcoordsfromscreencoords
240+  D075 0D               dec c
241+  D076 0D               dec c
242+  D077 04               inc b
243+  D078 C5               push bc
244+  D079 3E 42            ld a,66
245+  D07B CD 92 AA         call screen_setattr
246+  D07E 0C               inc c
247+  D07F CD 92 AA         call screen_setattr
248+  D082 0C               inc c
249+  D083 CD 92 AA         call screen_setattr
250+  D086 0C               inc c
251+  D087 CD 92 AA         call screen_setattr
252+  D08A 0C               inc c
253+  D08B CD 92 AA         call screen_setattr
254+  D08E 0C               inc c
255+  D08F CD 92 AA         call screen_setattr
256+  D092 C1               pop bc
257+  D093 ED 5B DA A8      ld de,(screen_offset)
258+  D097 78               ld a,b
259+  D098 93               sub e
260+  D099 47               ld b,a                      ; subtract the offset
261+  D09A 04               inc b
262+  D09B 04               inc b                       ; add two for the score rows
263+  D09C ED 43 A0 85      ld (string_zonk),bc         ; set coords of string
264+  D0A0 21 A0 85         ld hl,string_zonk
265+  D0A3 CD 28 86         call string_print
266+  D0A6 06 14            ld b,20
267+  D0A8 CD 61 81         call utilities_pauseforframes ; pause
268+  D0AB C9               ret
269+  D0AC
# file closed: game/missiles.asm
163   D0AC                  include "game\thepit.asm"
# file opened: game/thepit.asm
  1+  D0AC              ;
  2+  D0AC              ; Timer for deciding how fast the trap withdraws
  3+  D0AC              ;
  4+  D0AC              thepit_timer:
  5+  D0AC 00               defb 0
  6+  D0AD
  7+  D0AD              ;
  8+  D0AD              ; Ticks for the trap state. Will count to 3 then reset
  9+  D0AD              ;
 10+  D0AD              thepit_trapcount:
 11+  D0AD 00               defb 0
 12+  D0AE
 13+  D0AE              ;
 14+  D0AE              ; The horizontal coordinate of the current pit trap
 15+  D0AE              ;
 16+  D0AE              thepit_trapcoord:
 17+  D0AE 08               defb 8
 18+  D0AF
 19+  D0AF              ;
 20+  D0AF              ; Initialises the pit
 21+  D0AF              ;
 22+  D0AF              thepit_init:
 23+  D0AF 21 AE D0         ld hl,thepit_trapcoord
 24+  D0B2 36 08            ld (hl),8
 25+  D0B4 21 AD D0         ld hl,thepit_trapcount
 26+  D0B7 36 00            ld (hl),0
 27+  D0B9 C9               ret
 28+  D0BA              ;
 29+  D0BA              ; The speed the pit will withdraw
 30+  D0BA              ;
 31+  D0BA              thepit_speed:
 32+  D0BA 00               defb 0
 33+  D0BB
 34+  D0BB              ;
 35+  D0BB              ; Performs per frame processing on the pit room
 36+  D0BB              ;
 37+  D0BB              thepit_process:
 38+  D0BB 3A 86 C5         ld a,(player_location)
 39+  D0BE FE 02            cp 2                            ; if two, the player is in the pit, so process the trap
 40+  D0C0 C2 2A D1         jp nz,thepit_process0
 41+  D0C3 ED 4B 77 C5      ld bc,(player)                  ; get the player's coords to check if about to fall
 42+  D0C7 3E 08            ld a,8
 43+  D0C9 81               add a,c
 44+  D0CA 4F               ld c,a                          ; look at the square underneath
 45+  D0CB CD 3A AA         call screen_getcharcoordsfromscreencoords ; get the cell coords
 46+  D0CE CD C8 AA         call screen_ischarempty
 47+  D0D1 FE 01            cp 1                            ; check if this is 1=empty
 48+  D0D3 CA 2B D1         jp z,thepit_process2
 49+  D0D6 3A AC D0         ld a,(thepit_timer)             ; get the timer
 50+  D0D9 3C               inc a
 51+  D0DA 32 AC D0         ld (thepit_timer),a             ; store
 52+  D0DD ED 5B BA D0      ld de,(thepit_speed)            ; get the speed
 53+  D0E1 BB               cp e                           ; have we reached the trigger?
 54+  D0E2 C2 2A D1         jp nz, thepit_process0          ; no need to do anything
 55+  D0E5 3E 00            ld a,0
 56+  D0E7 32 AC D0         ld (thepit_timer),a             ; zero the timer and process
 57+  D0EA 3A AD D0         ld a,(thepit_trapcount)         ; get the current count
 58+  D0ED 3C               inc a
 59+  D0EE 32 AD D0         ld (thepit_trapcount),a         ; reset the trap count
 60+  D0F1 FE 04            cp 4                            ; do we need to begin another character?
 61+  D0F3 C2 12 D1         jp nz,thepit_process1           ; if not, draw as normal
 62+  D0F6 3E 00            ld a,0
 63+  D0F8 32 AD D0         ld (thepit_trapcount),a         ; reset the trap count
 64+  D0FB 3A AE D0         ld a,(thepit_trapcoord)         ; get the trap horiz coord
 65+  D0FE FE 02            cp 2
 66+  D100 CA 2A D1         jp z,thepit_process0
 67+  D103 4F               ld c,a
 68+  D104 06 0A            ld b,10
 69+  D106 3E 46            ld a,70
 70+  D108 CD 92 AA         call screen_setattr             ; set the attr of the empty square to yellow on black
 71+  D10B 3A AE D0         ld a,(thepit_trapcoord)         ; get the trap horiz coord
 72+  D10E 3D               dec a
 73+  D10F 32 AE D0         ld (thepit_trapcoord),a         ; store the reduced coord
 74+  D112
 75+  D112              thepit_process1:                    ; draw the trapdoor in current position
 76+  D112 3A AE D0         ld a,(thepit_trapcoord)
 77+  D115 FE 02            cp 2
 78+  D117 CA 2A D1         jp z, thepit_process0           ; don't process outside of the pit
 79+  D11A 4F               ld c,a
 80+  D11B 06 0A            ld b,10                         ; vertical coord will always be the same
 81+  D11D 3A AD D0         ld a,(thepit_trapcount)         ; get the trap count
 82+  D120 5F               ld e,a                          ; store in e
 83+  D121 3E 16            ld a,22                         ; 21 is full trapdoor
 84+  D123 83               add a,e
 85+  D124 CD 87 AA         call screen_getblock
 86+  D127 CD 64 AA         call screen_showchar            ; show the char
 87+  D12A
 88+  D12A              thepit_process0:
 89+  D12A C9               ret
 90+  D12B              thepit_process2:
 91+  D12B CD AC C6         call player_pitkillplayer
 92+  D12E C9               ret
 93+  D12F
# file closed: game/thepit.asm
164   D12F                  include "game\monster.asm"
# file opened: game/monster.asm
  1+  D12F
  2+  D12F              ;
  3+  D12F              ; Where the monster currently is
  4+  D12F              ;
  5+  D12F              monster_currentcoords:
  6+  D12F 00 00            defb 0,0
  7+  D131
  8+  D131              ;
  9+  D131              ; The start coords of the monster
 10+  D131              ;
 11+  D131              monster_initcoords:
 12+  D131 70 1B            defb 112,27
 13+  D133
 14+  D133              ;
 15+  D133              ; Store the memory location of the current jump position
 16+  D133              ;
 17+  D133              monster_jumppos:
 18+  D133 00 00            defb 0,0
 19+  D135
 20+  D135              ;
 21+  D135              ; The jump table for the monster.
 22+  D135              ;
 23+  D135              monster_jumptable:
 24+  D135 FF 03 02 02      defb 255,3,2,2,2,2,2,2,2,2,1,1,1,1,1,1,255
 24+  D139 02 02 02 02
 24+  D13D 02 02 01 01
 24+  D141 01 01 01 01
 24+  D145 FF
 25+  D146
 26+  D146              ;
 27+  D146              ; The vertical direction: 0 up, 1 down
 28+  D146              ;
 29+  D146              monster_jumpdirectionvert:
 30+  D146 00               defb 0
 31+  D147
 32+  D147              ;
 33+  D147              ; The horiz direction: 0 right, 1 left
 34+  D147              ;
 35+  D147              monster_jumpdirectionhoriz:
 36+  D147 00               defb 0
 37+  D148
 38+  D148              ;
 39+  D148              ; Frame offset, 0 or 32
 40+  D148              ;
 41+  D148              monster_frameoffset:
 42+  D148 00               defb 0
 43+  D149
 44+  D149              ;
 45+  D149              ; Monster tick
 46+  D149              ;
 47+  D149              monster_tick:
 48+  D149 00               defb 0
 49+  D14A
 50+  D14A              ;
 51+  D14A              ; The colour of the monster
 52+  D14A              ;
 53+  D14A              monster_colour:
 54+  D14A 06               defb 6
 55+  D14B
 56+  D14B              ;
 57+  D14B              ; Initialises the pit monster
 58+  D14B              ;
 59+  D14B              monster_init:
 60+  D14B ED 4B 31 D1      ld bc,(monster_initcoords)              ; load the initial coords
 61+  D14F ED 43 2F D1      ld (monster_currentcoords),bc           ; save in current coords
 62+  D153 21 36 D1         ld hl,monster_jumptable+1
 63+  D156 22 33 D1         ld (monster_jumppos),hl                 ; store the initial position in the jump table
 64+  D159 3E 00            ld a,0
 65+  D15B 32 46 D1         ld (monster_jumpdirectionvert),a        ; going up
 66+  D15E 32 48 D1         ld (monster_frameoffset),a
 67+  D161 32 49 D1         ld (monster_tick),a
 68+  D164 CD EE D1         call monster_draw                       ; the monster
 69+  D167 C9               ret
 70+  D168
 71+  D168              ;
 72+  D168              ; Animate the monster
 73+  D168              ;
 74+  D168              monster_process:
 75+  D168 3A 49 D1         ld a,(monster_tick)                     ; check if we should draw this frame
 76+  D16B FE 01            cp 1
 77+  D16D CA 75 D1         jp z,monster_process6
 78+  D170 3C               inc a
 79+  D171 32 49 D1         ld (monster_tick),a                     ; increase the tick and continue
 80+  D174 C9               ret
 81+  D175              monster_process6:
 82+  D175 3E 00            ld a,0
 83+  D177 32 49 D1         ld (monster_tick),a                     ; zero the tick
 84+  D17A CD EE D1         call monster_draw                       ; overwrite the old sprite
 85+  D17D 3A 48 D1         ld a,(monster_frameoffset)              ; get the anim frame offset
 86+  D180 EE 20            xor 32                                  ; flip between 0 and 32
 87+  D182 32 48 D1         ld (monster_frameoffset),a              ; store
 88+  D185 ED 4B 2F D1      ld bc,(monster_currentcoords)           ; get the current coords
 89+  D189 2A 33 D1         ld hl,(monster_jumppos)                 ; get the position in the jump table
 90+  D18C 56               ld d,(hl)                               ; get the jump modifier
 91+  D18D 3A 46 D1         ld a,(monster_jumpdirectionvert)        ; get the vertical direction
 92+  D190 FE 00            cp 0                                    ; if 0, going up, so dec vert
 93+  D192 C2 9B D1         jp nz,monster_process0
 94+  D195 79               ld a,c
 95+  D196 92               sub d
 96+  D197 23               inc hl                                  ; move forward a jump pos
 97+  D198 C3 9E D1         jp monster_process1
 98+  D19B              monster_process0:
 99+  D19B 79               ld a,c                                   ; going down so inc c
100+  D19C 82               add a,d
101+  D19D 2B               dec hl                                  ; move back a jump pos
102+  D19E              monster_process1:
103+  D19E 4F               ld c,a                                  ; get the vertical coord back
104+  D19F 7E               ld a,(hl)                               ; check the next jump pos
105+  D1A0 FE FF            cp 255                                  ; if 255 reverse
106+  D1A2 CA AB D1         jp z,monster_process3
107+  D1A5 22 33 D1         ld (monster_jumppos),hl                 ; store the new pos
108+  D1A8 C3 BD D1         jp monster_process2                     ; keep going
109+  D1AB              monster_process3:
110+  D1AB 3A 46 D1         ld a,(monster_jumpdirectionvert)        ; get the direction
111+  D1AE EE 01            xor 1                                   ; flip it
112+  D1B0 32 46 D1         ld (monster_jumpdirectionvert),a        ; store it
113+  D1B3 FE 01            cp 1
114+  D1B5 CA BD D1         jp z,monster_process2
115+  D1B8 D9               exx
116+  D1B9 CD 01 D2         call monster_colourchange
117+  D1BC D9               exx
118+  D1BD              monster_process2:
119+  D1BD 3A 47 D1         ld a,(monster_jumpdirectionhoriz)       ; get the horiz direction
120+  D1C0 FE 00            cp 0                                    ; is it right?
121+  D1C2 C2 D7 D1         jp nz,monster_process4
122+  D1C5 04               inc b                                   ; 1 pixel right
123+  D1C6 78               ld a,b
124+  D1C7 FE 38            cp 56                                   ; reached the edge of the pit?
125+  D1C9 C2 E6 D1         jp nz,monster_process5
126+  D1CC 3A 47 D1         ld a,(monster_jumpdirectionhoriz)
127+  D1CF EE 01            xor 1
128+  D1D1 32 47 D1         ld (monster_jumpdirectionhoriz),a       ; flip direction
129+  D1D4 C3 E6 D1         jp monster_process5
130+  D1D7              monster_process4:
131+  D1D7 05               dec b                                   ; 1 pixel left
132+  D1D8 78               ld a,b
133+  D1D9 FE 18            cp 24                                   ; reached the edge of the pit?
134+  D1DB C2 E6 D1         jp nz,monster_process5
135+  D1DE 3A 47 D1         ld a,(monster_jumpdirectionhoriz)
136+  D1E1 EE 01            xor 1
137+  D1E3 32 47 D1         ld (monster_jumpdirectionhoriz),a       ; flip direction
138+  D1E6              monster_process5:
139+  D1E6 ED 43 2F D1      ld (monster_currentcoords),bc           ; store the new vertical coords
140+  D1EA CD EE D1         call monster_draw                       ; finally, draw the monster
141+  D1ED C9               ret
142+  D1EE
143+  D1EE              ;
144+  D1EE              ; Draw the monster at the current location
145+  D1EE              ;
146+  D1EE              monster_draw:
147+  D1EE ED 4B 2F D1      ld bc,(monster_currentcoords)
148+  D1F2 3A 48 D1         ld a,(monster_frameoffset)
149+  D1F5 11 00 00         ld de,0
150+  D1F8 5F               ld e,a
151+  D1F9 21 ED BE         ld hl,monster_sprite                    ; load the first frame
152+  D1FC 19               add hl,de
153+  D1FD CD 6A AB         call sprites_draw2by2sprite
154+  D200 C9               ret
155+  D201
156+  D201              ;
157+  D201              ; Changes the monster colour whenever it reaches the bottom of its jump
158+  D201              ;
159+  D201              monster_colourchange:
160+  D201 3A 4A D1         ld a,(monster_colour)
161+  D204 3C               inc a
162+  D205 FE 07            cp 7
163+  D207 C2 0C D2         jp nz, monster_colourchange0
164+  D20A 3E 01            ld a,1
165+  D20C              monster_colourchange0:
166+  D20C 32 4A D1         ld (monster_colour),a                   ; save the monster colour
167+  D20F 3A DA A8         ld a,(screen_offset)
168+  D212 FE 00            cp 0
169+  D214 CA 41 D2         jp z,monster_colourchange1
170+  D217 3A 4A D1         ld a,(monster_colour)                   ; get the monster colour
171+  D21A 06 06            ld b,6
172+  D21C 0E 40            ld c,64
173+  D21E 81               add c                                   ; want this with black background, so add 64
174+  D21F 11 A3 58         ld de,22528+163                         ; attrs here
175+  D222 CD 9D A9         call screen_setcolours
176+  D225 3A 4A D1         ld a,(monster_colour)                   ; get the monster colour
177+  D228 06 06            ld b,6
178+  D22A 0E 40            ld c,64
179+  D22C 81               add c                                   ; want this with black background, so add 64
180+  D22D 11 C3 58         ld de,22528+195                         ; attrs here
181+  D230 CD 9D A9         call screen_setcolours
182+  D233 3A 4A D1         ld a,(monster_colour)                   ; get the monster colour
183+  D236 F6 60            or 96
184+  D238 06 06            ld b,6
185+  D23A 11 E3 58         ld de,22528+227                         ; attrs here
186+  D23D CD 9D A9         call screen_setcolours
187+  D240 C9               ret
188+  D241              monster_colourchange1:
189+  D241 3A 4A D1         ld a,(monster_colour)                   ; get the monster colour
190+  D244 06 06            ld b,6
191+  D246 0E 40            ld c,64
192+  D248 81               add c                                   ; want this with black background, so add 64
193+  D249 11 A3 59         ld de,22528+419                         ; attrs here
194+  D24C CD 9D A9         call screen_setcolours
195+  D24F 3A 4A D1         ld a,(monster_colour)                   ; get the monster colour
196+  D252 06 06            ld b,6
197+  D254 0E 40            ld c,64
198+  D256 81               add c                                   ; want this with black background, so add 64
199+  D257 11 C3 59         ld de,22528+451                         ; attrs here
200+  D25A CD 9D A9         call screen_setcolours
201+  D25D 3A 4A D1         ld a,(monster_colour)                   ; get the monster colour
202+  D260 F6 60            or 96
203+  D262 06 06            ld b,6
204+  D264 11 E3 59         ld de,22528+483                         ; attrs here
205+  D267 CD 9D A9         call screen_setcolours
206+  D26A C9               ret
# file closed: game/monster.asm
165   D26B                  include "game\robots.asm"
# file opened: game/robots.asm
  1+  D26B
  2+  D26B              ;
  3+  D26B              ; Array of robot states
  4+  D26B              ; x,y,state (0 inactive, 1 active), direction (0 left, 1 right), anim offset, automove frames remaining, move direction (0 left, 1 right, 3 up, 4 down)
  5+  D26B              robots_robots:
  6+  D26B 00 00 00 00      defb 0,0,0,0,0,0,0
  6+  D26F 00 00 00
  7+  D272 00 00 00 00      defb 0,0,0,0,0,0,0
  7+  D276 00 00 00
  8+  D279 00 00 00 00      defb 0,0,0,0,0,0,0
  8+  D27D 00 00 00
  9+  D280 00 00 00 00      defb 0,0,0,0,0,0,0
  9+  D284 00 00 00
 10+  D287 00 00 00 00      defb 0,0,0,0,0,0,0
 10+  D28B 00 00 00
 11+  D28E
 12+  D28E              robots_initcoords:
 13+  D28E 18 E8            defb 24,232
 14+  D290
 15+  D290              ;
 16+  D290              ; When this reaches zero, spawn a new robot
 17+  D290              ;
 18+  D290              robots_spawntimer:
 19+  D290 FA               defb 250
 20+  D291
 21+  D291              ;
 22+  D291              ; When this reaches max, change the anim frame
 23+  D291              ;
 24+  D291              robots_animtimer:
 25+  D291 00               defb 0
 26+  D292
 27+  D292              ;
 28+  D292              ; When this reaches max, change move the robot
 29+  D292              ;
 30+  D292              robots_movetimer:
 31+  D292 00               defb 0
 32+  D293
 33+  D293
 34+  D293              ;
 35+  D293              ; The number of robots active
 36+  D293              ;
 37+  D293              robots_numberactive:
 38+  D293 00               defb 0
 39+  D294
 40+  D294              ;
 41+  D294              ; Tracks which directions a robot can move
 42+  D294              ; up,down,left,right
 43+  D294              robots_canmovedirections:
 44+  D294 00 00 00 00      defb 0,0,0,0
 45+  D298
 46+  D298              ;
 47+  D298              ; The current robot speed
 48+  D298              ;
 49+  D298              robots_robotspeed:
 50+  D298 02               defb 2
 51+  D299
 52+  D299              ;
 53+  D299              ; The current max robots
 54+  D299              ;
 55+  D299              robots_robotsmax:
 56+  D299 03               defb 3
 57+  D29A
 58+  D29A              ;
 59+  D29A              ; Initialises the robots
 60+  D29A              ;
 61+  D29A              robots_init:
 62+  D29A 06 23            ld b,35
 63+  D29C DD 21 6B D2      ld ix,robots_robots
 64+  D2A0              robots_init0:
 65+  D2A0 DD 36 00 00      ld (ix),0                       ; reset robot states back to zero
 66+  D2A4 DD 23            inc ix
 67+  D2A6 10 F8            djnz robots_init0
 68+  D2A8 3E 00            ld a,0
 69+  D2AA 32 93 D2         ld (robots_numberactive),a
 70+  D2AD 3E FA            ld a,250
 71+  D2AF 32 90 D2         ld (robots_spawntimer),a
 72+  D2B2                  ; Self writing code
 73+  D2B2                  ; Robot speed
 74+  D2B2 3A 98 D2         ld a,(robots_robotspeed)
 75+  D2B5 32 4F D3         ld (robots_process7+1),a
 76+  D2B8 3C               inc a
 77+  D2B9 32 7F D3         ld (robots_process6+1),a
 78+  D2BC                  ; Robots max
 79+  D2BC 3A 99 D2         ld a,(robots_robotsmax)
 80+  D2BF 32 CA D2         ld (robots_spawn+1),a
 81+  D2C2 32 21 D3         ld (robots_process8+1),a
 82+  D2C5 32 3D D3         ld (robots_process0+1),a
 83+  D2C8 C9               ret
 84+  D2C9
 85+  D2C9              ;
 86+  D2C9              ; Spawns a new robot
 87+  D2C9              ; Inputs:
 88+  D2C9              ; ix - pointer to start of robot array entry
 89+  D2C9              ;
 90+  D2C9              robots_spawn:
 91+  D2C9 06 03            ld b,3                      ;(SELF WRITING CODE)
 92+  D2CB DD 21 6B D2      ld ix,robots_robots
 93+  D2CF              robots_spawn0:
 94+  D2CF DD 7E 02         ld a,(ix+2)                 ; get the state
 95+  D2D2 FE 00            cp 0
 96+  D2D4 C2 00 D3         jp nz,robots_spawn1         ; if already active, move on
 97+  D2D7 ED 4B 8E D2      ld bc,(robots_initcoords)
 98+  D2DB DD 71 00 DD      ld (ix),bc
 98+  D2DF 70 01
 99+  D2E1 DD 36 02 01      ld (ix+2),1
100+  D2E5 DD 36 03 00      ld (ix+3),0
101+  D2E9 DD 36 04 00      ld (ix+4),0
102+  D2ED DD 36 05 00      ld (ix+5),0
103+  D2F1 DD 36 06 00      ld (ix+6),0
104+  D2F5 3A 93 D2         ld a,(robots_numberactive)
105+  D2F8 3C               inc a
106+  D2F9 32 93 D2         ld (robots_numberactive),a  ; increase the number active
107+  D2FC CD B7 D5         call robots_draw            ; draw initial frame
108+  D2FF C9               ret
109+  D300              robots_spawn1:
110+  D300 11 07 00         ld de,7
111+  D303 DD 19            add ix,de
112+  D305 10 C8            djnz robots_spawn0
113+  D307 C9               ret
114+  D308              ;
115+  D308              ; Kills robot
116+  D308              ; Inputs:
117+  D308              ; ix - pointer to start of robot array entry
118+  D308              ;
119+  D308              robots_kill:
120+  D308 3A 93 D2         ld a,(robots_numberactive)
121+  D30B 3D               dec a
122+  D30C 32 93 D2         ld (robots_numberactive),a
123+  D30F DD 36 02 00      ld (ix+2),0                     ; set to inactive
124+  D313 C5               push bc
125+  D314 E5               push hl
126+  D315 06 01            ld b,1
127+  D317 CD 9F CC         call scores_addhundreds
128+  D31A E1               pop hl
129+  D31B C1               pop bc
130+  D31C C9               ret
131+  D31D
132+  D31D              ;
133+  D31D              ; Processes the robots
134+  D31D              ;
135+  D31D              robots_process:
136+  D31D 3A 93 D2         ld a,(robots_numberactive)              ; first, check if we need to spawn a new robot
137+  D320              robots_process8:
138+  D320 FE 03            cp 3                                    ; 3 is the maximum
139+  D322 CA 3C D3         jp z,robots_process0                    ; if already three, nothing to do
140+  D325 3A 90 D2         ld a,(robots_spawntimer)                ; now check the spawn timer
141+  D328 FE 00            cp 0
142+  D32A C2 38 D3         jp nz,robots_process1                   ; if it hasn't reached zero yet, just decrease
143+  D32D 3E FA            ld a,250
144+  D32F 32 90 D2         ld (robots_spawntimer),a                ; reset the spawn timer
145+  D332 CD C9 D2         call robots_spawn                       ; spawn a robot
146+  D335 C3 3C D3         jp robots_process0                      ; carry on
147+  D338              robots_process1:
148+  D338 3D               dec a
149+  D339 32 90 D2         ld (robots_spawntimer),a                ; decrease the spawn timer and store
150+  D33C              robots_process0:
151+  D33C 06 03            ld b,3                                  ; max number of robots (SELF WRITING CODE)
152+  D33E DD 21 6B D2      ld ix, robots_robots                    ; point ix at the robot array
153+  D342              robots_process2:
154+  D342 C5               push bc
155+  D343 DD 7E 02         ld a,(ix+2)                             ; check the state
156+  D346 FE 00            cp 0
157+  D348 CA 64 D3         jp z,robots_process3                    ; if not active, move on
158+  D34B 3A 92 D2         ld a,(robots_movetimer)
159+  D34E              robots_process7:                            ; self writing code - the number in the comparison will be ovewritten
160+  D34E FE 04            cp 4
161+  D350 C2 64 D3         jp nz,robots_process3                   ; can we move this frame
162+  D353 CD B7 D5         call robots_draw                        ; draw over existing
163+  D356 CD 89 D3         call robots_move                        ; move the
164+  D359 DD 7E 02         ld a,(ix+2)                             ; get the state again
165+  D35C FE 00            cp 0
166+  D35E CA 64 D3         jp z,robots_process3                    ; move to next if this robot has become inactive
167+  D361 CD B7 D5         call robots_draw                        ; draw the new robot
168+  D364              robots_process3:
169+  D364 C1               pop bc
170+  D365 11 07 00         ld de,7
171+  D368 DD 19            add ix,de
172+  D36A 10 D6            djnz robots_process2
173+  D36C 3A 91 D2         ld a,(robots_animtimer)
174+  D36F 3C               inc a
175+  D370 FE 08            cp 8
176+  D372 C2 77 D3         jp nz,robots_process4
177+  D375 3E 00            ld a,0                                  ; reset if we reached max
178+  D377              robots_process4:
179+  D377 32 91 D2         ld (robots_animtimer),a
180+  D37A 3A 92 D2         ld a,(robots_movetimer)                 ; increment the robot move timer
181+  D37D 3C               inc a
182+  D37E              robots_process6:                            ; self writing code - the number in the comparison will be ovewritten
183+  D37E FE 05            cp 5                                    ; there is another reference to this number above
184+  D380 C2 85 D3         jp nz,robots_process5
185+  D383 3E 00            ld a,0
186+  D385              robots_process5:
187+  D385 32 92 D2         ld (robots_movetimer),a
188+  D388
189+  D388 C9               ret
190+  D389
191+  D389
192+  D389              ;
193+  D389              ; Moves a robot
194+  D389              ; Inputs:
195+  D389              ; ix - points to first byte of robot in array
196+  D389              robots_move:
197+  D389 DD 7E 02         ld a,(ix+2)                             ; get the state
198+  D38C FE 02            cp 2
199+  D38E CA BF D3         jp z,robots_move4                       ; don't move if shot, just change the anim
200+  D391 3A 91 D2         ld a,(robots_animtimer)                 ; get the anim timer
201+  D394 FE 07            cp 7                                    ; compare with 8
202+  D396 C2 A9 D3         jp nz,robots_move1                       ; if even, don't increment frame
203+  D399 DD 7E 04         ld a,(ix+4)                             ; get the anim frame
204+  D39C 06 08            ld b,8
205+  D39E 80               add a,b                                 ; add to anim frame
206+  D39F FE 20            cp 32
207+  D3A1 C2 A6 D3         jp nz,robots_move0                      ; if not 32, then just store
208+  D3A4 3E 00            ld a,0                                  ; otherwise, reset
209+  D3A6              robots_move0:
210+  D3A6 DD 77 04         ld (ix+4),a                             ; store
211+  D3A9              robots_move1:
212+  D3A9 DD 7E 05         ld a,(ix+5)
213+  D3AC FE 00            cp 0                                    ; are we automoving
214+  D3AE CA B7 D3         jp z,robots_move2                       ; if not, keep directions
215+  D3B1 CD D3 D3         call robots_automove
216+  D3B4 C3 BB D3         jp robots_move3
217+  D3B7              robots_move2:
218+  D3B7 CD 08 D4         call robots_checkdirectionsandmove
219+  D3BA C9               ret
220+  D3BB              robots_move3:
221+  D3BB CD 00 D6         call robots_checkforplayer              ; check to see if we collided with a player
222+  D3BE C9               ret
223+  D3BF              robots_move4:
224+  D3BF DD 7E 04         ld a,(ix+4)
225+  D3C2 FE 48            cp 72
226+  D3C4 C2 CD D3         jp nz,robots_move5
227+  D3C7 3E 40            ld a,64
228+  D3C9 DD 77 04         ld (ix+4),a
229+  D3CC C9               ret
230+  D3CD              robots_move5:
231+  D3CD 3E 48            ld a,72
232+  D3CF DD 77 04         ld (ix+4),a
233+  D3D2 C9               ret
234+  D3D3
235+  D3D3
236+  D3D3              ;
237+  D3D3              ; Processes automove
238+  D3D3              ; Inputs:
239+  D3D3              ; ix - points to the current robot
240+  D3D3              ; a - number of frames left to move
241+  D3D3              robots_automove:
242+  D3D3 3D               dec a
243+  D3D4 DD 77 05         ld (ix+5),a                         ; store the decreased frames
244+  D3D7 DD 4E 00 DD      ld bc,(ix)                          ; get coords
244+  D3DB 46 01
245+  D3DD DD 7E 06         ld a,(ix+6)                         ; get the direction
246+  D3E0 FE 00            cp 0                                ; left
247+  D3E2 CA F3 D3         jp z,robots_automove1
248+  D3E5 FE 02            cp 2                                ; up
249+  D3E7 CA F7 D3         jp z,robots_automove3
250+  D3EA FE 03            cp 3                                ; down
251+  D3EC CA FC D3         jp z,robots_automove4
252+  D3EF 04               inc b                               ; right
253+  D3F0 C3 01 D4         jp robots_automove2
254+  D3F3              robots_automove1:
255+  D3F3 05               dec b
256+  D3F4 C3 01 D4         jp robots_automove2
257+  D3F7              robots_automove3:
258+  D3F7 0D               dec c
259+  D3F8 0D               dec c
260+  D3F9 C3 01 D4         jp robots_automove2
261+  D3FC              robots_automove4:
262+  D3FC 0C               inc c
263+  D3FD 0C               inc c
264+  D3FE C3 01 D4         jp robots_automove2
265+  D401              robots_automove2:
266+  D401 DD 71 00 DD      ld (ix),bc
266+  D405 70 01
267+  D407 C9               ret
268+  D408
269+  D408              ;
270+  D408              ; Checks if a robot can move in all directions, then picks one and moves there.
271+  D408              ; This looks complicated, but really what it does is:
272+  D408              ; 1) Look at the current direction
273+  D408              ; 2) Randomly determine which orthoganal direction check first
274+  D408              ; 3) If orthogonal can't be moved, keep going in direction we're going
275+  D408              ; 4) Otherwise, back the way we came
276+  D408              ; Inputs:
277+  D408              ; ix - points to the current robot
278+  D408              ;
279+  D408              robots_checkdirectionsandmove:
280+  D408 DD 7E 06         ld a,(ix+6)                 ; get the direction
281+  D40B FE 00            cp 0                        ; left
282+  D40D C2 34 D4         jp nz,robots_checkdirectionsandmove0
283+  D410                  ; random check
284+  D410 CD 21 C5         call game_getcurrentframe
285+  D413 E6 01            and 1                       ; odd or even
286+  D415 CA 21 D4         jp z,robots_checkdirectionsandmove3
287+  D418 CD BA D4         call robots_checkupthendown ; prefer up over down
288+  D41B FE 01            cp 1
289+  D41D C8               ret z
290+  D41E C3 27 D4         jp robots_checkdirectionsandmove4
291+  D421              robots_checkdirectionsandmove3:
292+  D421 CD B0 D4         call robots_checkdownthenup ; prefer down over up
293+  D424 FE 01            cp 1
294+  D426 C8               ret z
295+  D427              robots_checkdirectionsandmove4:
296+  D427                  ; check left
297+  D427 CD 40 D5         call robots_checkleftandmove
298+  D42A FE 01            cp 1
299+  D42C C8               ret z                       ; if we moved, don't check again
300+  D42D                  ; check right
301+  D42D CD 79 D5         call robots_checkrightandmove
302+  D430 FE 01            cp 1
303+  D432 C8               ret z                       ; if we moved, don't check again
304+  D433                  ; if we're here and haven't moved...
305+  D433 C9               ret
306+  D434              robots_checkdirectionsandmove0
307+  D434 FE 01            cp 1                        ; right
308+  D436 C2 5D D4         jp nz,robots_checkdirectionsandmove1
309+  D439                  ; ALREADY MOVING RIGHT
310+  D439                  ; random check
311+  D439 CD 21 C5         call game_getcurrentframe
312+  D43C E6 01            and 1                       ; odd or even
313+  D43E CA 4A D4         jp z,robots_checkdirectionsandmove5
314+  D441 CD B0 D4         call robots_checkdownthenup ; prefer down over up
315+  D444 FE 01            cp 1
316+  D446 C8               ret z
317+  D447 C3 50 D4         jp robots_checkdirectionsandmove6
318+  D44A              robots_checkdirectionsandmove5:
319+  D44A CD BA D4         call robots_checkupthendown ; prefer down over up
320+  D44D FE 01            cp 1
321+  D44F C8               ret z
322+  D450              robots_checkdirectionsandmove6:
323+  D450                  ; check right
324+  D450 CD 79 D5         call robots_checkrightandmove
325+  D453 FE 01            cp 1
326+  D455 C8               ret z                       ; if we moved, don't check again
327+  D456                  ; check left
328+  D456 CD 40 D5         call robots_checkleftandmove
329+  D459 FE 01            cp 1
330+  D45B C8               ret z                       ; if we moved, don't check again
331+  D45C                  ; if we're here and haven't moved...
332+  D45C C9               ret
333+  D45D              robots_checkdirectionsandmove1
334+  D45D FE 02            cp 2                        ; up
335+  D45F C2 86 D4         jp nz,robots_checkdirectionsandmove2
336+  D462                  ; ALREADY MOVING UP
337+  D462                  ; random check
338+  D462 CD 21 C5         call game_getcurrentframe
339+  D465 E6 01            and 1                       ; odd or even
340+  D467 CA 73 D4         jp z,robots_checkdirectionsandmove7
341+  D46A CD D0 D4         call robots_checkleftthenright ; prefer left over right
342+  D46D FE 01            cp 1
343+  D46F C8               ret z
344+  D470 C3 79 D4         jp robots_checkdirectionsandmove8
345+  D473              robots_checkdirectionsandmove7:
346+  D473 CD C6 D4         call robots_checkrightthenleft ; prefer right over left
347+  D476 FE 01            cp 1
348+  D478 C8               ret z
349+  D479              robots_checkdirectionsandmove8:
350+  D479                  ; check up
351+  D479 CD DC D4         call robots_checkupandmove
352+  D47C FE 01            cp 1
353+  D47E C8               ret z                       ; if we moved, don't check again
354+  D47F                  ; check down
355+  D47F CD 12 D5         call robots_checkdownandmove
356+  D482 FE 01            cp 1
357+  D484 C8               ret z                       ; if we moved, don't check again
358+  D485                  ; if we're here and haven't moved...
359+  D485 C9               ret
360+  D486              robots_checkdirectionsandmove2
361+  D486                  ; ALREADY MOVING DOWN
362+  D486                  ; random check
363+  D486 CD 21 C5         call game_getcurrentframe
364+  D489 E6 01            and 1                       ; odd or even
365+  D48B CA 97 D4         jp z,robots_checkdirectionsandmove9
366+  D48E CD C6 D4         call robots_checkrightthenleft ; prefer right over left
367+  D491 FE 01            cp 1
368+  D493 C8               ret z
369+  D494 C3 9D D4         jp robots_checkdirectionsandmove10
370+  D497              robots_checkdirectionsandmove9:
371+  D497 CD D0 D4         call robots_checkleftthenright ; prefer left over right
372+  D49A FE 01            cp 1
373+  D49C C8               ret z
374+  D49D              robots_checkdirectionsandmove10:
375+  D49D                  ; check down
376+  D49D CD 12 D5         call robots_checkdownandmove
377+  D4A0 FE 01            cp 1
378+  D4A2 C8               ret z                       ; if we moved, don't check again
379+  D4A3                  ; check right first
380+  D4A3 CD 79 D5         call robots_checkrightandmove
381+  D4A6 FE 01            cp 1
382+  D4A8 C8               ret z                       ; if we moved, don't check again
383+  D4A9                  ; check up
384+  D4A9 CD DC D4         call robots_checkupandmove
385+  D4AC FE 01            cp 1
386+  D4AE C8               ret z                       ; if we moved, don't check again
387+  D4AF                  ; if we're here and haven't moved...
388+  D4AF C9               ret
389+  D4B0
390+  D4B0              ;
391+  D4B0              ; Different orders of checking directions, for pseudo random motion
392+  D4B0              ;
393+  D4B0              robots_checkdownthenup:
394+  D4B0                  ; check down
395+  D4B0 CD 12 D5         call robots_checkdownandmove
396+  D4B3 FE 01            cp 1
397+  D4B5 C8               ret z                       ; if we moved, don't check again
398+  D4B6                  ; check up
399+  D4B6 CD DC D4         call robots_checkupandmove
400+  D4B9 C9               ret
401+  D4BA
402+  D4BA              robots_checkupthendown:
403+  D4BA                  ; check up
404+  D4BA CD DC D4         call robots_checkupandmove
405+  D4BD FE 01            cp 1
406+  D4BF C8               ret z
407+  D4C0                  ; check down
408+  D4C0 CD 12 D5         call robots_checkdownandmove
409+  D4C3 FE 01            cp 1
410+  D4C5 C9               ret
411+  D4C6              robots_checkrightthenleft:
412+  D4C6                  ; check right
413+  D4C6 CD 79 D5         call robots_checkrightandmove
414+  D4C9 FE 01            cp 1
415+  D4CB C8               ret z                       ; if we moved, don't check again
416+  D4CC                  ; check left
417+  D4CC CD 40 D5         call robots_checkleftandmove
418+  D4CF C9               ret
419+  D4D0
420+  D4D0              robots_checkleftthenright:
421+  D4D0                  ; check left
422+  D4D0 CD 40 D5         call robots_checkleftandmove
423+  D4D3 FE 01            cp 1
424+  D4D5 C8               ret z
425+  D4D6                  ; check right
426+  D4D6 CD 79 D5         call robots_checkrightandmove
427+  D4D9 FE 01            cp 1
428+  D4DB C9               ret
429+  D4DC
430+  D4DC              ;
431+  D4DC              ; Checks up for movement
432+  D4DC              ; Outputs:
433+  D4DC              ; a - 1 if have moved
434+  D4DC              robots_checkupandmove:
435+  D4DC                  ; check above
436+  D4DC DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
436+  D4E0 46 01
437+  D4E2 79               ld a,c
438+  D4E3 FE 28            cp 40
439+  D4E5 D8               ret c
440+  D4E6 CD 01 AC         call sprites_scadd              ; get the memory location of cell into de
441+  D4E9 62 6B            ld hl,de                        ; look at cell directly above (subtract 32)
442+  D4EB 11 20 00         ld de,32
443+  D4EE ED 52            sbc hl,de                       ; memory location of line above now in hl
444+  D4F0 7E               ld a,(hl)                       ; get the contents of the line
445+  D4F1 FE 00            cp 0
446+  D4F3 C2 0F D5         jp nz,robots_checkupandmove0    ; can't move here so return
447+  D4F6 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
447+  D4FA 46 01
448+  D4FC 0D               dec c                       ; move up
449+  D4FD 0D               dec c
450+  D4FE DD 71 00 DD      ld (ix),bc
450+  D502 70 01
451+  D504 DD 36 06 02      ld (ix+6),2
452+  D508 DD 36 05 03      ld (ix+5),3                 ; set the auto move frames
453+  D50C 3E 01            ld a,1
454+  D50E C9               ret
455+  D50F              robots_checkupandmove0:
456+  D50F 3E 00            ld a,0
457+  D511 C9               ret
458+  D512
459+  D512              ;
460+  D512              ; Checks down for movement
461+  D512              ; Outputs:
462+  D512              ; a - 1 if have moved
463+  D512              robots_checkdownandmove:
464+  D512                  ; check below
465+  D512 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
465+  D516 46 01
466+  D518 CD 01 AC         call sprites_scadd              ; get the memory location of cell into de
467+  D51B 62 6B            ld hl,de                        ; look at cell directly underneath (add 256)
468+  D51D 24               inc h                       ; memory location of cell beneath now in hl
469+  D51E 7E               ld a,(hl)                       ; get the contents of the line
470+  D51F FE 00            cp 0
471+  D521 C2 3D D5         jp nz,robots_checkdownandmove0    ; can't move here so return
472+  D524 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
472+  D528 46 01
473+  D52A 0C               inc c                       ; move up
474+  D52B 0C               inc c
475+  D52C DD 71 00 DD      ld (ix),bc
475+  D530 70 01
476+  D532 DD 36 06 03      ld (ix+6),3
477+  D536 DD 36 05 03      ld (ix+5),3                 ; set the auto move frames
478+  D53A 3E 01            ld a,1
479+  D53C C9               ret
480+  D53D              robots_checkdownandmove0:
481+  D53D 3E 00            ld a,0
482+  D53F C9               ret
483+  D540
484+  D540              ;
485+  D540              ; Checks left for movement
486+  D540              ; Outputs:
487+  D540              ; a - 1 if have moved
488+  D540              robots_checkleftandmove:
489+  D540                  ; check below
490+  D540 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
490+  D544 46 01
491+  D546 CD 01 AC         call sprites_scadd              ; get the memory location of cell into de
492+  D549 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
493+  D54B 78               ld a,b
494+  D54C 06 08            ld b,8
495+  D54E 90               sub b                           ; move one cell left
496+  D54F 47               ld b,a
497+  D550 2B               dec hl                          ; memory location of cell to the right now in hl
498+  D551 CD 5E C2         call movement_spaceisempty       ; check space is empty
499+  D554 7B               ld a,e                          ; check space empty flag
500+  D555 FE 00            cp 0
501+  D557 CA 76 D5         jp z,robots_checkleftandmove0    ; if zero can't move
502+  D55A DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
502+  D55E 46 01
503+  D560 05               dec b
504+  D561 DD 71 00 DD      ld (ix),bc
504+  D565 70 01
505+  D567 DD 36 06 00      ld (ix+6),0
506+  D56B DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
507+  D56F DD 36 03 00      ld (ix+3),0                 ; set to right
508+  D573 3E 01            ld a,1
509+  D575 C9               ret
510+  D576              robots_checkleftandmove0:
511+  D576 3E 00            ld a,0
512+  D578 C9               ret
513+  D579
514+  D579              ;
515+  D579              ; Checks right for movement
516+  D579              ; Outputs:
517+  D579              ; a - 1 if have moved
518+  D579              robots_checkrightandmove:
519+  D579                  ; check below
520+  D579 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
520+  D57D 46 01
521+  D57F 78               ld a,b
522+  D580 FE E8            cp 232
523+  D582 CA B4 D5         jp z,robots_checkrightandmove0  ; can't move if at edge
524+  D585 CD 01 AC         call sprites_scadd              ; get the memory location of cell into de
525+  D588 62 6B            ld hl,de                        ; look at cell directly to the right (add 1)
526+  D58A 3E 08            ld a,8
527+  D58C 80               add b                           ; move one cell right
528+  D58D 47               ld b,a
529+  D58E 23               inc hl                          ; memory location of cell to the right now in hl
530+  D58F CD 5E C2         call movement_spaceisempty       ; check space is empty
531+  D592 7B               ld a,e                          ; check space empty flag
532+  D593 FE 00            cp 0
533+  D595 CA B4 D5         jp z,robots_checkrightandmove0    ; if zero can't move
534+  D598 DD 4E 00 DD      ld bc,(ix)                  ; load current coords into bc
534+  D59C 46 01
535+  D59E 04               inc b
536+  D59F DD 71 00 DD      ld (ix),bc
536+  D5A3 70 01
537+  D5A5 DD 36 06 01      ld (ix+6),1
538+  D5A9 DD 36 05 07      ld (ix+5),7                 ; set the auto move frames
539+  D5AD DD 36 03 01      ld (ix+3),1                 ; set to right
540+  D5B1 3E 01            ld a,1
541+  D5B3 C9               ret
542+  D5B4              robots_checkrightandmove0:
543+  D5B4 3E 00            ld a,0
544+  D5B6 C9               ret
545+  D5B7
546+  D5B7              ;
547+  D5B7              ; Draws a robot
548+  D5B7              ; Inputs:
549+  D5B7              ; ix - points to first byte of robot in array
550+  D5B7              robots_draw:
551+  D5B7 DD 4E 00 DD      ld bc,(ix)
551+  D5BB 46 01
552+  D5BD 21 2D BF         ld hl,robot_sprite                      ; set to the robot sprite
553+  D5C0 DD 7E 02         ld a,(ix+2)                             ; get the state
554+  D5C3 FE 02            cp 2                                    ; is this dying
555+  D5C5 CA E0 D5         jp z,robots_draw1
556+  D5C8              robots_draw3:
557+  D5C8 DD 7E 03         ld a,(ix+3)                             ; get the direction
558+  D5CB FE 00            cp 0
559+  D5CD CA D4 D5         jp z,robots_draw0                       ; if left, nothing to do
560+  D5D0 11 20 00         ld de,32
561+  D5D3 19               add hl,de                               ; add four frames to sprite
562+  D5D4              robots_draw0:
563+  D5D4 DD 7E 04         ld a,(ix+4)                             ; get the anim frame
564+  D5D7 11 00 00         ld de,0
565+  D5DA 5F               ld e,a
566+  D5DB 19               add hl,de                               ; add to base
567+  D5DC CD 0C AB         call sprites_drawsprite
568+  D5DF C9               ret
569+  D5E0              ;
570+  D5E0              ; Dying
571+  D5E0              ;
572+  D5E0              robots_draw1:
573+  D5E0 DD 7E 05         ld a,(ix+5)                             ; get anim frames
574+  D5E3 FE 00            cp 0                                    ; if zero this is the first time around
575+  D5E5 C2 F0 D5         jp nz,robots_draw2
576+  D5E8 3E 18            ld a,24
577+  D5EA DD 77 05         ld (ix+5),a                             ; load up the anim frames
578+  D5ED C3 C8 D5         jp robots_draw3                         ; return to main loop to draw as normal
579+  D5F0              robots_draw2:
580+  D5F0 3D               dec a
581+  D5F1 DD 77 05         ld (ix+5),a
582+  D5F4 FE 00            cp 0                                    ; have we reached the end yet
583+  D5F6 C2 FC D5         jp nz, robots_draw4
584+  D5F9 CD 08 D3         call robots_kill
585+  D5FC              robots_draw4:
586+  D5FC C3 D4 D5         jp robots_draw0
587+  D5FF C9               ret
588+  D600
589+  D600              ;
590+  D600              ; Checks to see if the robot is hitting a player
591+  D600              ; Inputs:
592+  D600              ; ix - memory location of robot we're checking
593+  D600              robots_checkforplayer:
594+  D600 3A 82 C5         ld a,(player+11)     ; get player state
595+  D603 FE 00            cp 0
596+  D605 C0               ret nz               ; if already dying, don't kill again
597+  D606 DD 4E 00 DD      ld bc,(ix)           ; get coords
597+  D60A 46 01
598+  D60C ED 5B 77 C5      ld de,(player)       ; get the player coords
599+  D610 7B               ld a,e               ; get the vert coord first
600+  D611 91               sub c                ; subtract the diamond vertical coord from players
601+  D612 C6 08            add 8                ; add the max distance
602+  D614 FE 11            cp 17                ; compare to max*2+1? if carry flag set, they've hit
603+  D616 D0               ret nc               ; if not, hasn't hit
604+  D617 7A               ld a,d               ; get the player horiz coord
605+  D618 90               sub b                ; subtract rock coord
606+  D619 C6 08            add 8                ; add max distance
607+  D61B FE 11            cp 17                ; compare to max*2+1? if carry flag set, they've hit
608+  D61D D0               ret nc
609+  D61E DD 36 02 00      ld (ix+2),0          ; mark as inactive
610+  D622 CD B2 C6         call player_robotkillplayer ; mark the player as killed
611+  D625 C9               ret
# file closed: game/robots.asm
166   D626                  include "game\bullet.asm"
# file opened: game/bullet.asm
  1+  D626              ;
  2+  D626              ; Current state: x & y coords (screen), direction (0 left, 1 right), state
  3+  D626              ;
  4+  D626              bullet_state:
  5+  D626 00 00 00 00      defb 0,0,0,0
  6+  D62A
  7+  D62A              ;
  8+  D62A              ; Initialise a the bullet
  9+  D62A              ;
 10+  D62A              bullet_init:
 11+  D62A DD 21 26 D6      ld ix,bullet_state
 12+  D62E DD 36 00 00      ld (ix),0
 13+  D632 DD 36 01 00      ld (ix+1),0
 14+  D636 DD 36 02 00      ld (ix+2),0
 15+  D63A DD 36 03 00      ld (ix+3),0
 16+  D63E C9               ret
 17+  D63F
 18+  D63F              ;
 19+  D63F              ; Shoots the bullet
 20+  D63F              ;
 21+  D63F              bullet_shoot:
 22+  D63F DD 21 26 D6      ld ix,bullet_state
 23+  D643 ED 4B 77 C5      ld bc,(player)              ; get the player coords
 24+  D647 3A 79 C5         ld a,(player+2)             ; get the player direction
 25+  D64A FE 01            cp 1                        ; going left?
 26+  D64C CA 5A D6         jp z,bullet_shoot0
 27+  D64F 3E 08            ld a,8
 28+  D651 80               add a,b                     ; going right so add eight to start coords
 29+  D652 47               ld b,a
 30+  D653 DD 36 02 01      ld (ix+2),1                 ; set right
 31+  D657 C3 63 D6         jp bullet_shoot1
 32+  D65A              bullet_shoot0:
 33+  D65A 78               ld a,b
 34+  D65B 06 08            ld b,8
 35+  D65D 90               sub b
 36+  D65E 47               ld b,a                      ; going left so subtract eight to start coords
 37+  D65F DD 36 02 00      ld (ix+2),0                 ; set right
 38+  D663              bullet_shoot1:
 39+  D663 DD 71 00 DD      ld (ix),bc        ; store coords
 39+  D667 70 01
 40+  D669 DD 36 03 01      ld (ix+3),1       ; set state to 1
 41+  D66D CD C3 D6         call bullet_draw ; draw the initial frame
 42+  D670 C9               ret
 43+  D671
 44+  D671              ;
 45+  D671              ; Performs bullet processing
 46+  D671              ;
 47+  D671              bullet_process:
 48+  D671 3A 29 D6         ld a,(bullet_state+3)       ; get the state
 49+  D674 FE 00            cp 0
 50+  D676 C8               ret z                       ; don't draw if this has become inactive
 51+  D677 CD C3 D6         call bullet_draw            ; delete current frame
 52+  D67A CD 87 D6         call bullet_move            ; move the bullet
 53+  D67D 3A 29 D6         ld a,(bullet_state+3)       ; get the state
 54+  D680 FE 00            cp 0
 55+  D682 C8               ret z                       ; don't draw if this has become inactive
 56+  D683 CD C3 D6         call bullet_draw            ; draw new frame
 57+  D686 C9               ret
 58+  D687
 59+  D687              ;
 60+  D687              ; Moves the bullet, checking for collisions
 61+  D687              ;
 62+  D687              bullet_move:
 63+  D687 DD 21 26 D6      ld ix,bullet_state
 64+  D68B DD 4E 00 DD      ld bc,(ix)
 64+  D68F 46 01
 65+  D691 DD 7E 02         ld a,(ix+2)                 ; get the direction
 66+  D694 FE 00            cp 0                        ; going left?
 67+  D696 CA A0 D6         jp z,bullet_move0
 68+  D699 3E 08            ld a,8
 69+  D69B 80               add b
 70+  D69C 47               ld b,a                      ; add 8 since going right
 71+  D69D C3 A5 D6         jp bullet_move1
 72+  D6A0              bullet_move0:
 73+  D6A0 78               ld a,b
 74+  D6A1 06 08            ld b,8
 75+  D6A3 90               sub b
 76+  D6A4 47               ld b,a                      ; subtract 8 since going left
 77+  D6A5              bullet_move1:
 78+  D6A5 DD 71 00 DD      ld (ix),bc                  ; store new coords
 78+  D6A9 70 01
 79+  D6AB C5               push bc
 80+  D6AC CD D0 D6         call bullets_checkforrobot
 81+  D6AF C1               pop bc
 82+  D6B0 FE 01            cp 1                        ; if we hit a robot, keep moving
 83+  D6B2 C8               ret z
 84+  D6B3 CD 01 AC         call sprites_scadd          ; get memory loc of this block into de
 85+  D6B6 21 60 00         ld hl,96
 86+  D6B9 19               add hl,de
 87+  D6BA 7E               ld a,(hl)                   ; get the content
 88+  D6BB FE 00            cp 0
 89+  D6BD C8               ret z                       ; if empty, continue
 90+  D6BE DD 36 03 00      ld (ix+3),0                 ; otherwise, mark bullet as inactive
 91+  D6C2 C9               ret
 92+  D6C3
 93+  D6C3              ;
 94+  D6C3              ; Draw the bullet
 95+  D6C3              ;
 96+  D6C3              bullet_draw:
 97+  D6C3 ED 4B 26 D6      ld bc,(bullet_state)        ; get coords
 98+  D6C7 3E 1B            ld a,27
 99+  D6C9 CD 87 AA         call screen_getblock        ; get the block address
100+  D6CC CD 0C AB         call sprites_drawsprite     ; draw the sprite
101+  D6CF C9               ret
102+  D6D0
103+  D6D0              ;
104+  D6D0              ; Checks to see if the robot is hitting a bullet
105+  D6D0              ; Outputs:
106+  D6D0              ; a = 0 if not robot hit
107+  D6D0              ; a = 1 if robot not hit
108+  D6D0              bullets_checkforrobot:
109+  D6D0 3E 00            ld a,0
110+  D6D2 32 26 D7         ld (bullets_tmp),a
111+  D6D5 3A 99 D2         ld a,(robots_robotsmax) ; robots to check
112+  D6D8 47               ld b,a
113+  D6D9 FD 21 6B D2      ld iy,robots_robots   ; start of robot array
114+  D6DD              bullets_checkforrobot0:
115+  D6DD C5               push bc
116+  D6DE FD 7E 02         ld a,(iy+2)             ; get the state
117+  D6E1 FE 01            cp 1
118+  D6E3 C2 1A D7         jp nz,bullets_checkforrobot1 ; if not active, don't check
119+  D6E6 FD 5E 00 FD      ld de,(iy)              ; get robot coords
119+  D6EA 56 01
120+  D6EC 7A               ld a,d
121+  D6ED E6 F8            and 248                 ; get nearest multiple of 8
122+  D6EF 57               ld d,a
123+  D6F0 ED 4B 26 D6      ld bc,(bullet_state)    ; get bullet coords
124+  D6F4 7A               ld a,d               ; get the player horiz coord
125+  D6F5 90               sub b                ; subtract robot coord
126+  D6F6 FE 00            cp 0                ; should be the same
127+  D6F8 C2 04 D7         jp nz,bullets_checkforrobot2 ; if not, might have hit, so check the next char along... if matched, check vert
128+  D6FB 3E 08            ld a,8
129+  D6FD 82               add a,d
130+  D6FE 90               sub b                ; check again for the next char along
131+  D6FF FE 00            cp 0
132+  D701 C2 1A D7         jp nz,bullets_checkforrobot1 ; if not, haven't hit
133+  D704              bullets_checkforrobot2:
134+  D704 7B               ld a,e               ; get the vert coord
135+  D705 91               sub c                ; subtract the bullet vertical coord from robots
136+  D706 C6 04            add 4                ; add the max distance
137+  D708 FE 09            cp 9                ; compare to max*2+1? if carry flag set, they've hit
138+  D70A D2 1A D7         jp nc,bullets_checkforrobot1   ; if not, hasn't hit
139+  D70D FD 36 02 02      ld (iy+2),2             ; mark the robot as killed
140+  D711 FD 36 05 00      ld (iy+5),0             ; mark the anim frames as zero
141+  D715 3E 01            ld a,1
142+  D717 32 26 D7         ld (bullets_tmp),a      ; hit the flag to say we killed a robot
143+  D71A              bullets_checkforrobot1:
144+  D71A 11 07 00         ld de,7
145+  D71D FD 19            add iy,de              ; move to next robot
146+  D71F C1               pop bc
147+  D720 10 BB            djnz bullets_checkforrobot0
148+  D722 3A 26 D7         ld a,(bullets_tmp)
149+  D725 C9               ret
150+  D726
151+  D726              bullets_tmp:
152+  D726 00               defb 0
153+  D727
# file closed: game/bullet.asm
167   D727
168   D727              ;===========================================================================
169   D727              ; Stack.
170   D727              ;===========================================================================
171   D727
172   D727              ; Stack: this area is reserved for the stack
173   D727              STACK_SIZE: equ 100    ; in words
174   D727
175   D727              ; Reserve stack space
176   D727 00 00            defw 0  ; WPMEM, 2
177   D729              stack_bottom:
178   D729 00 00 00...      defs    STACK_SIZE*2, 0
179   D7F1              stack_top:
180   D7F1 00 00            defw 0  ; WPMEM, 2
181   D7F3
182   D7F3                     SAVESNA "./dist/ThePit.sna", main
183   D7F3                     ;SAVETAP "./dist/ThePit.tap", main
# file closed: main.asm
